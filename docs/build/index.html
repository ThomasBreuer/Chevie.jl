<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gapjm Documentation · Gapjm.jl documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Gapjm.jl documentation</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Gapjm Documentation</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Permutations"><span>Permutations</span></a></li><li class="toplevel"><a class="tocitem" href="#Groups"><span>Groups</span></a></li><li class="toplevel"><a class="tocitem" href="#Permutation-groups"><span>Permutation groups</span></a></li><li class="toplevel"><a class="tocitem" href="#Extensions-to-Laurent-and-Puiseux-polynomials"><span>Extensions to Laurent and Puiseux polynomials</span></a></li><li class="toplevel"><a class="tocitem" href="#Cyclotomic-polynomials"><span>Cyclotomic polynomials</span></a></li><li class="toplevel"><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li class="toplevel"><a class="tocitem" href="#Combinatorics"><span>Combinatorics</span></a></li><li class="toplevel"><a class="tocitem" href="#Posets"><span>Posets</span></a></li><li class="toplevel"><a class="tocitem" href="#Signed-permutations"><span>Signed permutations</span></a></li><li class="toplevel"><a class="tocitem" href="#Linear-algebra-on-any-field/ring"><span>Linear algebra on any field/ring</span></a></li><li class="toplevel"><a class="tocitem" href="#Integral-matrices-and-lattices"><span>Integral matrices and lattices</span></a></li><li class="toplevel"><a class="tocitem" href="#Finite-fields"><span>Finite fields</span></a></li><li class="toplevel"><a class="tocitem" href="#Presentations"><span>Presentations</span></a></li><li class="toplevel"><a class="tocitem" href="#Coxeter-groups"><span>Coxeter groups</span></a></li><li class="toplevel"><a class="tocitem" href="#Finite-Coxeter-groups-and-Weyl-groups"><span>Finite Coxeter groups and Weyl groups</span></a></li><li class="toplevel"><a class="tocitem" href="#Finite-reflection-groups"><span>Finite reflection groups</span></a></li><li class="toplevel"><a class="tocitem" href="#Hecke-algebras"><span>Hecke algebras</span></a></li><li class="toplevel"><a class="tocitem" href="#Kazhdan-Lusztig-polynomials-and-bases"><span>Kazhdan-Lusztig polynomials and bases</span></a></li><li class="toplevel"><a class="tocitem" href="#Garside-monoids-and-groups,-braids."><span>Garside monoids and groups, braids.</span></a></li><li class="toplevel"><a class="tocitem" href="#Classes/characters-of-reflection-groups"><span>Classes/characters of reflection groups</span></a></li><li class="toplevel"><a class="tocitem" href="#Reductive-groups,-semisimple-elements"><span>Reductive groups, semisimple elements</span></a></li><li class="toplevel"><a class="tocitem" href="#Reflection-cosets"><span>Reflection cosets</span></a></li><li class="toplevel"><a class="tocitem" href="#Non-connected-reductive-groups"><span>Non-connected reductive groups</span></a></li><li class="toplevel"><a class="tocitem" href="#Unipotent-characters"><span>Unipotent characters</span></a></li><li class="toplevel"><a class="tocitem" href="#d-Harish-Chandra-series"><span>d-Harish-Chandra series</span></a></li><li class="toplevel"><a class="tocitem" href="#Unipotent-classes-of-reductive-groups"><span>Unipotent classes of reductive groups</span></a></li><li class="toplevel"><a class="tocitem" href="#Symbols"><span>Symbols</span></a></li><li class="toplevel"><a class="tocitem" href="#Eigenspaces"><span>Eigenspaces</span></a></li><li class="toplevel"><a class="tocitem" href="#Classtypes"><span>Classtypes</span></a></li><li class="toplevel"><a class="tocitem" href="#Unipotent-Elements"><span>Unipotent Elements</span></a></li><li class="toplevel"><a class="tocitem" href="#Decomposition-Matrices"><span>Decomposition Matrices</span></a></li><li class="toplevel"><a class="tocitem" href="#Dictionary-from-GAP3/Chevie"><span>Dictionary from GAP3/Chevie</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Gapjm Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gapjm Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmichel7/Gapjm.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Gapjm-Documentation"><a class="docs-heading-anchor" href="#Gapjm-Documentation">Gapjm Documentation</a><a id="Gapjm-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Gapjm-Documentation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm" href="#Gapjm"><code>Gapjm</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This  is  my  effort  porting  GAP  code  to Julia, specifically the Chevie package  of  GAP3  plus  the  GAP  functionality needed for Chevie to work: Cyclotomics,   Permutations,   Laurent   and   Puiseux  polynomials,  basic permutation group operations, etc….</p><p>I am rather new to Julia, git and github so I am not even sure this package is  properly constituted; I did not try yet to register it. If you are more competent  that me and see anything to  be improved in this package, please write me or make a pull request.</p><p><strong>Installing</strong></p><p>To install this package, at the Julia command line:</p><ul><li>enter package mode with ]</li><li>do the command</li></ul><pre><code class="nohighlight hljs">(@v1.6) pkg&gt; add &quot;https://github.com/jmichel7/Gapjm.jl&quot;</code></pre><ul><li>exit package mode with backspace and then do</li></ul><pre><code class="nohighlight hljs">julia&gt; using Gapjm</code></pre><p>and you are set up.</p><p>To update later to the latest version, do</p><pre><code class="nohighlight hljs">(@v1.6) pkg&gt; update Gapjm</code></pre><p>This  package  requires julia  1.6  or  later.  It  currently  contains  as infrastructure:</p><ul><li>permutations</li><li>cyclotomic numbers</li><li>combinatorics</li><li>linear algebra on any field/ring</li><li>posets</li><li>cyclotomic polynomials</li><li>signed permutations</li><li>finite fields</li><li>groups</li><li>permutation groups</li></ul><p>for  permutation groups I have  often replaced the sophisticated algorithms of  GAP by naive but  easy to write methods  only suitable for small groups (sufficient  for the  rest of  the package  but maybe  not for your needs). Otherwise  the  code  for  infrastructure  is  often  competitive with GAP, despite  being much shorter (often 100 lines of Julia replace 1000 lines of C); I am sure there are more optimisations possible. Any comments about the code and the design are welcome.</p><p>This  package contains about 90% of Chevie functionality, ported from Gap3. The  function <code>gap</code> can help you discover the equivalent functionality to a Gap3  function:  it  takes  a  string  and  gives you Julia translations of functions in Gap3 which match this string.</p><pre><code class="language-julia-rep1 hljs">julia&gt; gap(&quot;words&quot;)
CoxeterWords(W[,l])      =&gt;  word.(Ref(W),elements(W[,l])
GarsideWords             =&gt;  elements
CharRepresentationWords  =&gt;  traces_words_mats</code></pre><p>Then you can call on-line help on the discovered functions.</p><p>The data library of Chevie has been automatically ported by a transpiler so its code is &quot;strange&quot;. Otherwise the code in this package is often 10 times faster  than the  equivalent GAP3  Chevie code  (after the maddeningly long compilation time on first execution).</p><p>I  tried that  as many  submodules as  possible in  my package  can be used independently  of the rest, thus could be independent packages. This is the case for the modules <code>Combinat</code>, <code>Groups</code>, <code>Perms</code> and <code>Util</code>, which can be used  stand-alone. In addition modules <code>MatInt</code>, <code>Posets</code>, <code>FFields</code> can be used  stand-alone except they each use one  or two functions from <code>Util</code>. I already  registered  as  independent  packages  <code>UsingMerge</code>, <code>ModuleElts</code>, <code>LaurentPolynomials</code>,  <code>PuiseuxPolynomials</code>, <code>CyclotomicNumbers</code>  which are used here –- you should look at their documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Gapjm.jl#L1-L80">source</a></section></article><ul><li><a href="#Gapjm-Documentation">Gapjm Documentation</a></li><li><a href="#Permutations">Permutations</a></li><li><a href="#Groups">Groups</a></li><li><a href="#Permutation-groups">Permutation groups</a></li><li><a href="#Extensions-to-Laurent-and-Puiseux-polynomials">Extensions to Laurent and Puiseux polynomials</a></li><li><a href="#Cyclotomic-polynomials">Cyclotomic polynomials</a></li><li><a href="#Utilities">Utilities</a></li><li><a href="#Combinatorics">Combinatorics</a></li><li><a href="#Posets">Posets</a></li><li><a href="#Signed-permutations">Signed permutations</a></li><li><a href="#Linear-algebra-on-any-field/ring">Linear algebra on any field/ring</a></li><li><a href="#Integral-matrices-and-lattices">Integral matrices and lattices</a></li><li><a href="#Finite-fields">Finite fields</a></li><li><a href="#Presentations">Presentations</a></li><li><a href="#Coxeter-groups">Coxeter groups</a></li><li><a href="#Finite-Coxeter-groups-and-Weyl-groups">Finite Coxeter groups and Weyl groups</a></li><li><a href="#Finite-reflection-groups">Finite reflection groups</a></li><li><a href="#Hecke-algebras">Hecke algebras</a></li><li><a href="#Kazhdan-Lusztig-polynomials-and-bases">Kazhdan-Lusztig polynomials and bases</a></li><li><a href="#Garside-monoids-and-groups,-braids.">Garside monoids and groups, braids.</a></li><li><a href="#Classes/characters-of-reflection-groups">Classes/characters of reflection groups</a></li><li><a href="#Reductive-groups,-semisimple-elements">Reductive groups, semisimple elements</a></li><li><a href="#Reflection-cosets">Reflection cosets</a></li><li><a href="#Non-connected-reductive-groups">Non-connected reductive groups</a></li><li><a href="#Unipotent-characters">Unipotent characters</a></li><li><a href="#d-Harish-Chandra-series">d-Harish-Chandra series</a></li><li><a href="#Unipotent-classes-of-reductive-groups">Unipotent classes of reductive groups</a></li><li><a href="#Symbols">Symbols</a></li><li><a href="#Eigenspaces">Eigenspaces</a></li><li><a href="#Classtypes">Classtypes</a></li><li><a href="#Unipotent-Elements">Unipotent Elements</a></li><li><a href="#Decomposition-Matrices">Decomposition Matrices</a></li><li><a href="#Dictionary-from-GAP3/Chevie">Dictionary from GAP3/Chevie</a></li></ul><h1 id="Permutations"><a class="docs-heading-anchor" href="#Permutations">Permutations</a><a id="Permutations-1"></a><a class="docs-heading-anchor-permalink" href="#Permutations" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms" href="#Gapjm.Perms"><code>Gapjm.Perms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This  module implements permutations with the  same semantics as in the GAP language.</p><p><code>Perm</code>s  are permutations  of the  set <code>1:n</code>,  represented internally  as a vector  of <code>n</code>  integers holding  the images  of <code>1:n</code>.  The integer <code>n</code> is called  the degree  of the  permutation; two  permutations are equal if and only  if they move the same points in  the same way, so two permutations of different  degree can be equal; the degree is thus an implementation detail so  usually  it  should  not  be  used.  One should rather use the function <code>largest_moved_point</code>.</p><p>This follows the GAP design: it is possible to multiply, or to store in the same  group,  permutations  of  different  degrees;  this is implemented by promoting both to the higher degree. Slightly different is the MAGMA design where any permutation has to belong to a group and the degree is determined by  that group; then multiplication of permutations within a given group is (very  slightly) faster, but it is  more difficult to multiply permutations coming  from different groups, like  a group and one  of its subgroups.</p><p>The default constructor for a permutation uses the list of images of <code>1:n</code>, like  <code>Perm([2,3,1,5,4])</code>.  Often  it  is  more  convenient  to  use  cycle decompositions:    the   above   permutation    has   cycle   decomposition <code>(1,2,3)(4,5)</code>    thus   can   be    written   <code>Perm(1,2,3)*Perm(4,5)</code>   or <code>perm&quot;(1,2,3)(4,5)&quot;</code> (this last form can parse a GAP permutation). The list of  images of <code>1:n</code> can  be recovered from the  permutation by the function <code>vec</code>;  note  that  equal  permutations  with  different  degrees will have different <code>vec</code>.</p><p>The  complete type of a permutation  is <code>Perm{T}</code> where <code>T&lt;:Integer</code>, where <code>Vector{T}</code>  is the type of the vector which holds the image of <code>1:n</code>. This can  be used to save space or  time. For instance <code>Perm{UInt8}</code> can be used for  Weyl groups of rank≤8 since they permute  at most 240 roots. If <code>T</code> is not  specified we  take it  to be  <code>Int16</code> since  this is a good compromise between   speed,  compactness  and  possible  size  of  <code>n</code>.  One  can  mix permutations of different integer types; they are promoted to the wider one when multiplying.</p><p><strong>Examples of operations with permutations</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a=Perm(1,2,3)
(1,2,3)

julia&gt; vec(a)
3-element Vector{Int16}:
 2
 3
 1

julia&gt; a==Perm(vec(a))
true

julia&gt; b=Perm(1,2,3,4)
(1,2,3,4)

julia&gt; a*b     # product
(1,3,2,4)

julia&gt; inv(a)  # inverse
(1,3,2)

julia&gt; a/b     # quotient  a*inv(b)
(3,4)

julia&gt; a\b     # left quotient inv(a)*b
(1,4)

julia&gt; a^b     # conjugation inv(b)*a*b
(2,3,4)

julia&gt; b^2     # square
(1,3)(2,4)

julia&gt; 1^a     # image by a of point 1
2

julia&gt; one(a)  # trivial permutation
()

julia&gt; sign(a) # signature of permutation
1

julia&gt; order(a) # order (least trivial power) of permutation
3

julia&gt; largest_moved_point(a)
3

julia&gt; smallest_moved_point(a)
1

julia&gt; Perm{Int8}(a) # convert a to Perm{Int8}
Perm{Int8}: (1,2,3)

julia&gt; Matrix(b)  # permutation matrix of b
4×4 Matrix{Bool}:
 0  1  0  0
 0  0  1  0
 0  0  0  1
 1  0  0  0</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; rand(Perm,10)
(1,8,4,2,9,7,5,10,3,6)</code></pre><p><code>Perm</code>s have methods <code>copy</code>, <code>hash</code>, <code>==</code>, so they can be keys in hashes or elements  of sets; two permutations are equal  if they move the same points to  the same images. They have methods <code>cmp</code>, <code>isless</code> (lexicographic order on   moved  points)  so  they  can  be  sorted.  <code>Perm</code>s  are  scalars  for broadcasting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L1-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.Perm" href="#Gapjm.Perms.Perm"><code>Gapjm.Perms.Perm</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct Perm{T&lt;:Integer}</code></p><p>A  Perm represents a permutation  of the set <code>1:n</code>  and is implemented by a <code>struct</code> with one field, a <code>Vector{T}</code> holding the images of <code>1:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L124-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.Perm-Tuple{Vararg{Integer}}" href="#Gapjm.Perms.Perm-Tuple{Vararg{Integer}}"><code>Gapjm.Perms.Perm</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Perm{T}(x::Integer...)where T&lt;:Integer</code></p><p>returns  a cycle.  For example  <code>Perm{Int8}(1,2,3)</code> constructs the cycle    <code>(1,2,3)</code> as a <code>Perm{Int8}</code>. If omitted <code>{T}</code> is taken to be <code>Int16</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L139-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.Perm-Tuple{AbstractVector, AbstractVector}" href="#Gapjm.Perms.Perm-Tuple{AbstractVector, AbstractVector}"><code>Gapjm.Perms.Perm</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Perm{T}(l::AbstractVector,l1::AbstractVector)</code></p><p>returns <code>p</code>, a <code>Perm{T}</code>, such that <code>l1^p==l</code> if such a <code>p</code> exists; returns <code>nothing</code> otherwise. If not given <code>{T}</code> is taken to be <code>{Int16}</code>. Needs the elements of <code>l</code> and <code>l1</code> to be sortable.</p><pre><code class="language-julia-repl hljs">julia&gt; Perm([0,2,4],[4,0,2])
(1,3,2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L197-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.@perm_str" href="#Gapjm.Perms.@perm_str"><code>Gapjm.Perms.@perm_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@perm&quot;...&quot;</p><p>make a <code>Perm</code> from a string; allows GAP-style <code>perm&quot;(1,2)(5,6,7)(4,9)&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L167-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.largest_moved_point-Tuple{Perm}" href="#Gapjm.Perms.largest_moved_point-Tuple{Perm}"><code>Gapjm.Perms.largest_moved_point</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>largest_moved_point(a::Perm)</code> is the largest integer moved by a</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.smallest_moved_point" href="#Gapjm.Perms.smallest_moved_point"><code>Gapjm.Perms.smallest_moved_point</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>smallest_moved_point(a::Perm)</code> is the smallest integer moved by a</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:^-Tuple{AbstractVector, Perm}" href="#Base.:^-Tuple{AbstractVector, Perm}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Base.:^(l::AbstractVector,p::Perm)</code> </p><p>returns <code>l</code> permuted by <code>p</code>, a vector <code>r</code> such that <code>r[i^p]==l[i]</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; [5,4,6,1,7,5]^Perm(1,3,5,6,4)
6-element Vector{Int64}:
 1
 4
 5
 5
 6
 7</code></pre><p>note that we follow here the convention for the GAP function <code>Permuted</code>, but this has the consequence that <code>sort(a)==a^inv(Perm(sortperm(a)))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L369-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.sortPerm" href="#Gapjm.Perms.sortPerm"><code>Gapjm.Perms.sortPerm</code></a> — <span class="docstring-category">Function</span></header><section><div><p>for convenience: <code>sortPerm(a)=Perm(sortperm(a))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.orbit" href="#Gapjm.Perms.orbit"><code>Gapjm.Perms.orbit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>orbit(a::Perm,i::Integer) returns the orbit of a on i</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L440-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.orbits" href="#Gapjm.Perms.orbits"><code>Gapjm.Perms.orbits</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>orbits(a::Perm,d::Vector=1:length(a.d))</code> </p><p>returns the orbits of <code>a</code> on domain <code>d</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; orbits(Perm(1,2)*Perm(4,5),1:5)
3-element Vector{Vector{Int16}}:
 [1, 2]
 [3]
 [4, 5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L454-L467">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.order" href="#Gapjm.Perms.order"><code>Gapjm.Perms.order</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>order(a::Perm)</code> is the order of the permutation a</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L511-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.cycles" href="#Gapjm.Perms.cycles"><code>Gapjm.Perms.cycles</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>cycles(a::Perm)</code> returns the non-trivial cycles of <code>a</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cycles(Perm(1,2)*Perm(4,5))
2-element Vector{Vector{Int16}}:
 [1, 2]
 [4, 5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L483-L492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.cycletype" href="#Gapjm.Perms.cycletype"><code>Gapjm.Perms.cycletype</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>cycletype(a::Perm,domain=1:length(a.d))</code></p><p>describes the partition of <code>length(a.d)</code> associated to the conjugacy class of <code>a</code> in the symmetric group of <code>domain</code>, with ones removed (thus it does not depend on <code>length(a.d)</code> but just on the moved points). It is represented as a sorted list of pairs <code>cyclesize=&gt;multiplicity</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cycletype(Perm(1,2)*Perm(3,4))
1-element Vector{Pair{Int64, Int64}}:
 2 =&gt; 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L516-L530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.support" href="#Gapjm.Perms.support"><code>Gapjm.Perms.support</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>support(a::Perm)</code> is the set of all points moved by <code>a</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sign" href="#Base.sign"><code>Base.sign</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>sign(a::Perm)</code> is the signature of  the permutation <code>a</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L573">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Matrix-Tuple{Perm, Any}" href="#Base.Matrix-Tuple{Perm, Any}"><code>Base.Matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Matrix(a::Perm,n=length(a.d))</code>  the  permutation matrix  for <code>a</code>  operating on  <code>n</code> points (by default, the degree of <code>a</code>). If given, <code>n</code> should be larger than <code>largest_moved_point(a)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; Matrix(Perm(2,3,4),5)
5×5 Matrix{Bool}:
 1  0  0  0  0
 0  0  1  0  0
 0  0  0  1  0
 0  1  0  0  0
 0  0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L289-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:^-Tuple{AbstractMatrix, Perm}" href="#Base.:^-Tuple{AbstractMatrix, Perm}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Base.:^(m::AbstractMatrix,p::Perm;dims=1)</p><p>Applies the permutation <code>p</code> on the lines, columns or both of the matrix <code>m</code> depending on the value of <code>dims</code></p><pre><code class="language-julia-repl hljs">julia&gt; m=[3*i+j for i in 0:2,j in 1:3]
3×3 Matrix{Int64}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; p=Perm(1,2,3)
(1,2,3)

julia&gt; m^p
3×3 Matrix{Int64}:
 7  8  9
 1  2  3
 4  5  6

julia&gt; ^(m,p;dims=2)
3×3 Matrix{Int64}:
 3  1  2
 6  4  5
 9  7  8

julia&gt; ^(m,p;dims=(1,2))
3×3 Matrix{Int64}:
 9  7  8
 3  1  2
 6  4  5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L395-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.restricted-Tuple{Perm, AbstractVector{&lt;:Integer}}" href="#Gapjm.Perms.restricted-Tuple{Perm, AbstractVector{&lt;:Integer}}"><code>Gapjm.Perms.restricted</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>restricted(a::Perm,l::AbstractVector{&lt;:Integer})</code></p><p><code>l</code> should be a union of cycles of <code>p</code>; returns <code>p</code> restricted to <code>l</code></p><pre><code class="language-julia-repl hljs">julia&gt; restricted(Perm(1,2)*Perm(3,4),3:4)
(3,4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L576-L585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.reflength-Tuple{Perm}" href="#Gapjm.Perms.reflength-Tuple{Perm}"><code>Gapjm.Perms.reflength</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflength(a::Perm)</code></p><p>is   the  &quot;reflection   length&quot;  of   <code>a</code>,  that   is,  minimum  number  of transpositions of which <code>a</code> is the product</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L551-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.mappingPerm" href="#Gapjm.Perms.mappingPerm"><code>Gapjm.Perms.mappingPerm</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>mappingPerm(a,b)</code></p><p>given two lists of positive integers without repetition <code>a</code> and <code>b</code>, this function finds a permutation <code>p</code> such that <code>a.^p==b</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; mappingPerm([1,2,5,3],[2,3,4,6])
(1,2,3,6,5,4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L591-L601">source</a></section></article><h1 id="Groups"><a class="docs-heading-anchor" href="#Groups">Groups</a><a id="Groups-1"></a><a class="docs-heading-anchor-permalink" href="#Groups" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups" href="#Gapjm.Groups"><code>Gapjm.Groups</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This module gives some basic functionality on groups.</p><p><code>Group</code>  is  an  abstract  type,  but  the  following is assumed of all its concrete implementations:</p><ul><li>The function <code>gens(G)</code> returns the list of generators of the group <code>G</code>. </li><li>The function <code>one(G)</code> returns the identity element of <code>G</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G=Group([Perm(1,2),Perm(1,2,3)])
Group([(1,2),(1,2,3)])

julia&gt; gens(G)
2-element Vector{Perm{Int16}}:
 (1,2)  
 (1,2,3)

julia&gt; ngens(G)
2

julia&gt; minimal_words(G)
Dict{Perm{Int16}, Vector{Int64}} with 6 entries:
  ()      =&gt; []
  (1,2)   =&gt; [1]
  (1,3)   =&gt; [1, 2]
  (1,2,3) =&gt; [2]
  (2,3)   =&gt; [2, 1]
  (1,3,2) =&gt; [2, 2]
  

julia&gt; G.prop
Dict{Symbol, Any} with 1 entry:
  :minwords =&gt; Dict(()=&gt;[], (1,2)=&gt;[1], (1,3)=&gt;[1, 2], (1,2,3)=&gt;[2], (2,3)=&gt;[2,…
  </code></pre><p>for  further information,  look at  the docstrings  of centralizer, centre, classreps, comm, conjugacy<em>class, conjugacy</em>classes, Coset, fusion<em>conjugacy</em>classes,    gens,   Hom,   isabelian,   iscyclic,   words, minimal<em>words,   nconjugacy</em>classes,  ngens,   normalizer,  orbit,  orbits, position<em>class, stabilizer, transporting</em>elt, transversal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L1-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.Group" href="#Gapjm.Groups.Group"><code>Gapjm.Groups.Group</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>(G::Group)(i...)</code></p><p>A Group used as a function takes integer arguments in <code>eachindex(gens(W))</code>. This  constructs  the  element  of  <code>G</code>  product of the generators with the specified  indices. An argument  can also be  negative, then the inverse of the corresponding generator is used.</p><pre><code class="language-julia-repl hljs">julia&gt; G=Group([Perm(1,2),Perm(1,2,3)])
Group([(1,2),(1,2,3)])

julia&gt; G(2,1,-2) # returns gens(G)[2]*gens(G)[1]/gens(G)[2]
(1,3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L70-L85">source</a></section><section><div><p><code>Group(l::AbstractVector{T}[,one]) where T</code></p><p>A  group may be constructed  from a list of  <code>l</code> elements of the same type. These  elements must respond to  the functions <code>*</code> and  <code>inv</code>. If it is not possible  to compute  <code>one</code> from  <code>l</code> (because  `<code>l[1]</code> does not respond to <code>one</code>,  or  <code>l</code>  is  empty  and  <code>T</code>  does  not respond to <code>one</code>), then the identity element of the group must be given as a second argument.</p><pre><code class="language-julia-repl hljs">julia&gt; G=Group([[-1 -1;1 0]])
Gapjm.Groups.Groupof{Matrix{Int64}}([[-1 -1; 1 0]], [1 0; 0 1], Dict{Symbol, Any}())

julia&gt; elements(G)
3-element Vector{Matrix{Int64}}:
 [0 1; -1 -1]
 [1 0; 0 1]
 [-1 -1; 1 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L589-L608">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.gens" href="#Gapjm.Groups.gens"><code>Gapjm.Groups.gens</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>gens(G::Group)</code> returns the <code>Vector</code> of generators of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.ngens" href="#Gapjm.Groups.ngens"><code>Gapjm.Groups.ngens</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>ngens(G::Group)</code> returns the number of generators of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.orbit-Tuple{Vector, Any}" href="#Gapjm.Groups.orbit-Tuple{Vector, Any}"><code>Gapjm.Groups.orbit</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>orbit(gens::AbstractVector,p;action::Function=^)</code></p><p><code>orbit(G::Group,p;action::Function=^)</code></p><p>the  orbit of point  <code>p</code> under repeated  action of generators <code>gens</code>. Point <code>p</code>  should be hashable. The default action  of a group element is <code>^</code>. For example  if <code>g</code> is a permutation and <code>p</code>  an integer, <code>p^g</code> is the image of <code>p</code>  by <code>g</code>; if <code>h</code> and <code>g</code> are group elements, then <code>h^g</code> is the conjugate <code>inv(g)*h*g</code>.  If a group  is given instead  of generators, the orbit under <code>gens(G)</code> is returned.</p><pre><code class="language-julia-repl hljs">julia&gt; orbit([Perm(1,2),Perm(2,3)],1) 
3-element Vector{Int64}:
 1
 2
 3

julia&gt; orbit([Perm(1,2),Perm(2,3)],[1,3];action=(v,g)-&gt;v.^g) # Gap &quot;OnTuples&quot;
6-element Vector{Vector{Int64}}:
 [1, 3]
 [2, 3]
 [1, 2]
 [3, 2]
 [2, 1]
 [3, 1]

julia&gt; orbit([Perm(1,2),Perm(2,3)],[1,3];action=(v,g)-&gt;sort(v.^g)) # &quot;OnSets&quot;
3-element Vector{Vector{Int64}}:
 [1, 3]
 [2, 3]
 [1, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L95-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.orbits-Tuple{Group, AbstractVector}" href="#Gapjm.Groups.orbits-Tuple{Group, AbstractVector}"><code>Gapjm.Groups.orbits</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>orbits(gens::Vector,v;action=^,trivial=true)</code></p><p><code>orbits(G,v;action=^,trivial=true)</code></p><p>the  orbits on <code>v</code>  of the repeated  action of <code>gens</code>;  the elements of <code>v</code> should  be hashable. If a  group is given instead  of generators, the orbit under  <code>gens(G)</code> is returned. If <code>trivial=false</code> the one-element orbits are not returned.</p><pre><code class="language-julia-repl hljs">julia&gt; G=Group([Perm(1,2),Perm(2,3)]);
julia&gt; orbits(G,1:4)
2-element Vector{Vector{Int64}}:
 [1, 2, 3]
 [4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L196-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.elements-Tuple{Group}" href="#Gapjm.Groups.elements-Tuple{Group}"><code>Gapjm.Groups.elements</code></a> — <span class="docstring-category">Method</span></header><section><div><p>elements(G::Group): the list of elements of G</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.transversal" href="#Gapjm.Groups.transversal"><code>Gapjm.Groups.transversal</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>transversal(G::Group,p;action::Function=^)</code></p><p>returns a <code>Dict</code> with entries <code>x=&gt;g</code> where <code>x</code> runs over <code>orbit(G,p;action)</code> and where <code>g∈ G</code> is such that <code>x=action(p,g)</code></p><pre><code class="language-julia-repl hljs">julia&gt; G=Group([Perm(1,2),Perm(2,3)]);
julia&gt; transversal(G,1)
Dict{Int64, Perm{Int16}} with 3 entries:
  2 =&gt; (1,2)
  3 =&gt; (1,3,2)
  1 =&gt; ()</code></pre><p>orbit functions can take any action of <code>G</code> as keyword argument</p><pre><code class="language-julia-repl hljs">julia&gt; transversal(G,[1,2],action=(x,y)-&gt;x.^y)
Dict{Vector{Int64}, Perm{Int16}} with 6 entries:
  [2, 3] =&gt; (1,2,3)
  [2, 1] =&gt; (1,2)
  [1, 3] =&gt; (2,3)
  [3, 1] =&gt; (1,3,2)
  [1, 2] =&gt; ()
  [3, 2] =&gt; (1,3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L145-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.centralizer" href="#Gapjm.Groups.centralizer"><code>Gapjm.Groups.centralizer</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>centralizer(WF::Spets,t::SemisimpleElement{Root1})</code>  </p><p><code>WF</code>  should be  a Coxeter  coset representing  an algebraic coset <code>𝐆 ⋅σ</code>, where <code>𝐆</code> is a connected reductive group (represented by &#39;W:=Group(WF)&#39;), and  <code>σ</code>  is  a  quasi-central  automorphism  of <code>𝐆</code> defined by <code>WF</code>. The element  <code>t</code> should be a semisimple  element of <code>𝐆</code>. The function returns an  extended reflection  group describing  <code>C_𝐆 (tσ)</code>, with the reflection group  part representing  <code>C_𝐆 ⁰(tσ)</code>, and  the diagram  automorphism part being those induced by <code>C_𝐆 (tσ)/C_𝐆 (tσ)⁰</code> on <code>C_𝐆 (tσ)⁰</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(:u,6)
u₆

julia&gt; s=SS(Group(WF),[1//4,0,0,0,0,3//4])
SemisimpleElement{Root1}: &lt;ζ₄,1,1,1,1,ζ₄³&gt;

julia&gt; centralizer(WF,s)
B₂Φ₁

julia&gt; centralizer(WF,one(s))
Extended(C₃₍₃₂₁₎)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Sscoset.jl#L143-L167">source</a></section><section><div><p><code>Centralizer(W,s)</code></p><p><code>W</code>  should  be  a  Weyl  group  or  an extended reflection group and <code>s</code> a semisimple  element of the  algebraic group <code>G</code>  corresponding to <code>W</code>. This function  returns the  Weyl group  of <span>$C_G(s)$</span>,  which describes  it. The stabilizer  is an extended reflection group, with the reflection group part equal to the Weyl group of <span>$C_{G⁰}(s)$</span>, and the diagram automorphism part being those induced by <span>$C_G(s)$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; G=coxgroup(:A,3)
A₃
julia&gt; s=SS(G,[0,1//2,0])
SemisimpleElement{Root1}: &lt;1,-1,1&gt;
julia&gt; centralizer(G,s)
A₃₍₁₃₎=(A₁A₁)Φ₂</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Semisimple.jl#L681-L699">source</a></section><section><div><p><code>centralizer(G::Group,p;action=^)</code></p><p>computes  the centralizer of <code>p</code> in <code>G</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; G=Group([Perm(1,2),Perm(1,2,3)]);
julia&gt; centralizer(G,1)
Group([(2,3)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L216-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.centre" href="#Gapjm.Groups.centre"><code>Gapjm.Groups.centre</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>center(G::Group)</code> the centre of <code>G</code></p><pre><code class="language-julia_repl hljs">julia&gt; G=Group([Perm(1,2),Perm(3,4),Perm(1,3)*Perm(2,4)])
Group([(1,2),(3,4),(1,3)(2,4)])

julia&gt; centre(G)
Group([(1,2)(3,4)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L256-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.stabilizer" href="#Gapjm.Groups.stabilizer"><code>Gapjm.Groups.stabilizer</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>stabilizer(G::Group,s)</code></p><p>Assume that <code>s</code> is a set, represented as a sorted list without repetitions. The  action  of  <code>g∈  G</code>  on  sets  is  given  by  <code>(g,p)-&gt;sort(p.^g)</code>. The <em>stabilizer</em> of <code>s</code> in <code>G</code> is the centralizer of <code>s</code> for that action.</p><pre><code class="language-julia-repl hljs">julia&gt; G=Group([Perm(1,2),Perm(1,2,3,4)])
Group([(1,2),(1,2,3,4)])

julia&gt; centralizer(G,[1,2];action=(s,g)-&gt;sort(s.^g))
Group([(3,4),(1,2),(1,2)(3,4)])

julia&gt; stabilizer(G,[1,2])
Group([(3,4),(1,2),(1,2)(3,4)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L236-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.normalizer" href="#Gapjm.Groups.normalizer"><code>Gapjm.Groups.normalizer</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>normalizer(G::Group,H::Group)</code> the normalizer of <code>H</code> in <code>G</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.word-Tuple{Group, Any}" href="#Gapjm.Groups.word-Tuple{Group, Any}"><code>Gapjm.Groups.word</code></a> — <span class="docstring-category">Method</span></header><section><div><p>word(G::Group,w): a minimal word in  gens(G) representing element w of G</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.comm" href="#Gapjm.Groups.comm"><code>Gapjm.Groups.comm</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>comm(a,b)</code> the commutator <code>a^-1*b^-1*a*b</code> of <code>a</code> and <code>b</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{Group}" href="#Base.length-Tuple{Group}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p>length(G::Group): the number of elements of G</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.classreps-Tuple{Group}" href="#Gapjm.Groups.classreps-Tuple{Group}"><code>Gapjm.Groups.classreps</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>classreps(G::Group)</code> </p><p>representatives of conjugacy classes of <code>G</code>. Fills <code>G.classreps</code>. If this field is filled it is used by  <code>conjugacy_classes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L431-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.conjugacy_classes" href="#Gapjm.Groups.conjugacy_classes"><code>Gapjm.Groups.conjugacy_classes</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>conjugacy_classes(G::Group)</code> conjugacy classes of <code>G</code> (as a <code>Vector{Vector}</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.nconjugacy_classes" href="#Gapjm.Groups.nconjugacy_classes"><code>Gapjm.Groups.nconjugacy_classes</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>nconjugacy_classes(G::Group)</code> the number of conjugacy classes of <code>G</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.position_class" href="#Gapjm.Groups.position_class"><code>Gapjm.Groups.position_class</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>position_class(G::Group,g)</code> index of conjugacy class to which <code>g</code> belongs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.fusion_conjugacy_classes" href="#Gapjm.Groups.fusion_conjugacy_classes"><code>Gapjm.Groups.fusion_conjugacy_classes</code></a> — <span class="docstring-category">Function</span></header><section><div><p>&#39;fusion<em>conjugacy</em>classes(H::Group,G::Group)`</p><p>A <code>Vector{Int}</code> telling for each conjugacy class of subgroup <code>H</code> of which class of <code>G</code> is is a subset</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L421-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.minimal_words" href="#Gapjm.Groups.minimal_words"><code>Gapjm.Groups.minimal_words</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>minimal_words(G::Group)</code></p><p>returns  a <code>Dict</code> giving for each element of <code>G</code> a minimal positive word in the generators representing it.</p><pre><code class="language-julia-repl hljs">julia&gt; G=Group([Perm(1,2),Perm(1,2,3)]);
julia&gt; minimal_words(G)
Dict{Perm{Int16}, Vector{Int64}} with 6 entries:
  ()      =&gt; []
  (1,2)   =&gt; [1]
  (1,3)   =&gt; [1, 2]
  (1,2,3) =&gt; [2]
  (2,3)   =&gt; [2, 1]
  (1,3,2) =&gt; [2, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L273-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.words-Tuple{Group}" href="#Gapjm.Groups.words-Tuple{Group}"><code>Gapjm.Groups.words</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>words(G::Group)</code></p><p>returns  a <code>Dict</code>  giving for  each element  of <code>G</code>  a positive word in the generators representing it. It is faster than <code>minimal_words</code> but the words are not guaranteed minimal.</p><pre><code class="language-julia-repl hljs">julia&gt; G=Group([Perm(1,2),Perm(1,2,3)]);
julia&gt; words(G)
Dict{Perm{Int16}, Vector{Int64}} with 6 entries:
  ()      =&gt; []
  (1,2)   =&gt; [1]
  (1,3)   =&gt; [1, 2]
  (1,2,3) =&gt; [2]
  (2,3)   =&gt; [2, 1]
  (1,3,2) =&gt; [1, 2, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L308-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.transporting_elt" href="#Gapjm.Groups.transporting_elt"><code>Gapjm.Groups.transporting_elt</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>transporting_elt(G,p,q;action=^,dist=nothing)</code>   </p><p>returns  an  element  <code>g∈  G</code>  such  that  <code>p^g==q</code> (or <code>action(p,g)==q</code> if <code>action</code> is given), if such a <code>g</code> exists, and nothing otherwise. The set of possible <code>g</code> forms a right coset of the centralizer of p in G.</p><pre><code class="language-julia-repl hljs">julia&gt; g=Group(perm&quot;(1,2,3)(6,7)&quot;,perm&quot;(3,4,5)(7,8)&quot;)
Group([(1,2,3)(6,7),(3,4,5)(7,8)])

julia&gt; transporting_elt(g,1,5)
(1,5,4,3,2)

julia&gt; transporting_elt(g,1,6)

julia&gt; transporting_elt(g,[1,2,3,4],[2,3,4,5];action=(s,g)-&gt;sort(s.^g))
(1,2,3,4,5)(6,7,8)

julia&gt; transporting_elt(g,[1,2,3,4],[3,4,5,2];action=(s,g)-&gt;s.^g)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L505-L526">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.isabelian" href="#Gapjm.Groups.isabelian"><code>Gapjm.Groups.isabelian</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>isabelian(G::Group)</code> whether <code>G</code> is abelian</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.iscyclic" href="#Gapjm.Groups.iscyclic"><code>Gapjm.Groups.iscyclic</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>iscyclic(G::Group)</code> whether <code>G</code> is cyclic</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Tools.abelian_gens" href="#Gapjm.Tools.abelian_gens"><code>Gapjm.Tools.abelian_gens</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>abelian_gens(A)</code></p><p><code>A</code>  should be an abelian group or the list of its generators. Such a group has  a unique decomposition  up to isomorphism  of the form <code>C₁×…×Cₙ</code> where the  order of <code>Cᵢ</code> divides the order of <code>Cᵢ₊₁</code>. The function returns a list of generators for each of the <code>Cᵢ</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; abelian_gens([Perm(1,2),Perm(3,4,5),Perm(6,7)])
2-element Vector{Perm{Int16}}:
 (1,2)(6,7)
 (3,5,4)(6,7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Tools.jl#L96-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.Hom" href="#Gapjm.Groups.Hom"><code>Gapjm.Groups.Hom</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Hom(S::Group,T::Group,images)</code></p><p>builds an object representing the homomorphism from <code>S</code> to <code>T</code> which maps <code>gens(S)</code> to <code>images</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; S=Group([Perm(1,2),Perm(2,3)])
Group([(1,2),(2,3)])

julia&gt; T=Group([Perm(1,2)])
Group([(1,2)])

julia&gt; h=Hom(S,T,[T(1),T(1)])
Hom(Group([(1,2),(2,3)])→ Group([(1,2)]);[(1,2), (2,3)]↦ [(1,2), (1,2)]

julia&gt; h(S(1,2)) # the image by h
()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L448-L467">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.kernel" href="#Gapjm.Groups.kernel"><code>Gapjm.Groups.kernel</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>kernel(h::Hom)</code> the kernel of the homomorphism <code>h</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.blocks-Tuple{Any, Any}" href="#Gapjm.Combinat.blocks-Tuple{Any, Any}"><code>Gapjm.Combinat.blocks</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>blocks(G::Group,p::Integer)</code></p><p>Let  <code>p</code> be a prime. This function returns the partition of the irreducible characters  of <code>G</code>  in <code>p</code>-blocks,  represented by  the list  of indices of irreducibles characters in each block.</p><pre><code class="language-julia-repl hljs">julia&gt; W=CoxSym(5)
𝔖 ₅

julia&gt; blocks(W,2)
2-element Vector{Vector{Int64}}:
 [1, 3, 4, 5, 7]
 [2, 6]

julia&gt; blocks(W,3)
3-element Vector{Vector{Int64}}:
 [1, 5, 6]
 [2, 3, 7]
 [4]

julia&gt; blocks(W,7)
7-element Vector{Vector{Int64}}:
 [1]
 [2]
 [3]
 [4]
 [5]
 [6]
 [7]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Tools2.jl#L15-L47">source</a></section></article><h1 id="Permutation-groups"><a class="docs-heading-anchor" href="#Permutation-groups">Permutation groups</a><a id="Permutation-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Permutation-groups" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups" href="#Gapjm.PermGroups"><code>Gapjm.PermGroups</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This module is a port of some GAP functionality on permutation groups.</p><p>The code refers to the <a href="biblio.htm#H05">Handbook of computational group theory, chapter 4</a> for basic algorithms.</p><p>A  PermGroup is  a group  where gens  are Perms,  which allows  for all the algorithms like base, centralizer chain, etc...</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G=Group([Perm(i,i+1) for i in 1:2])
Group([(1,2),(2,3)])

# PermGroups are iterators over their elements
julia&gt; collect(G)  
6-element Vector{Perm{Int16}}:
 (1,2)
 (1,3,2)
 ()
 (1,2,3)
 (1,3)
 (2,3)

# maximum moved point of an element of G
julia&gt; largest_moved_point(G)  
3

julia&gt; Perm(1,2) in G
true

julia&gt; Perm(1,2,4) in G
false

# Elements,  appartenance test and  other function are  computed on G using
# Schreier-Sims theory, that is computing the following

# a list of points that no element of G fixes
julia&gt; base(G) 
2-element Vector{Int16}:
 1
 2

# the i-th element is the centralizer of base[1:i-1]
julia&gt; centralizers(G) 
2-element Vector{PermGroup{Int16}}:
 Group([(1,2),(2,3)])
 Group([(2,3)])

# i-th element is transversal of centralizer[i] on base[i]
julia&gt; transversals(G)
2-element Vector{Dict{Int16, Perm{Int16}}}:
 Dict(2 =&gt; (1,2), 3 =&gt; (1,3,2), 1 =&gt; ())
 Dict(2 =&gt; (), 3 =&gt; (2,3))</code></pre><p>finally, benchmarks on julia 1.7</p><pre><code class="language-benchmark hljs">julia&gt; @btime collect(symmetric_group(8));
  3.720 ms (271800 allocations: 7.94 MiB)

julia&gt; @btime words(symmetric_group(8));
  8.730 ms (202029 allocations: 12.86 MiB)
  
julia&gt; @btime elements(symmetric_group(8));
  1.616 ms (52681 allocations: 3.77 MiB)</code></pre><p>Compare to GAP3 Elements(SymmetricGroup(8)); takes 8 ms (GAP4 9 ms)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermGroups.jl#L1-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.largest_moved_point-Tuple{PermGroup}" href="#Gapjm.Perms.largest_moved_point-Tuple{PermGroup}"><code>Gapjm.Perms.largest_moved_point</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&#39;largest<em>moved</em>point(G::PermGroup)&#39; the largest moved point by any <code>g∈ G</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermGroups.jl#L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups.base" href="#Gapjm.PermGroups.base"><code>Gapjm.PermGroups.base</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>base(G::PermGroup)</code> A <code>Vector</code> of points stabilized by no element of <code>G</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermGroups.jl#L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups.centralizers" href="#Gapjm.PermGroups.centralizers"><code>Gapjm.PermGroups.centralizers</code></a> — <span class="docstring-category">Function</span></header><section><div><p>centralizers: the i-th element is the centralizer of base[1:i-1]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermGroups.jl#L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups.transversals" href="#Gapjm.PermGroups.transversals"><code>Gapjm.PermGroups.transversals</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>transversals(G::PermGroup)</code></p><p>returns a list whose <code>i</code>-th element is the transversal of <code>G.centralizers[i]</code> on <code>G.base[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermGroups.jl#L206-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in-Tuple{Perm, PermGroup}" href="#Base.in-Tuple{Perm, PermGroup}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>g in G</code> Tells whether permutation <code>g</code> is an element of <code>G</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermGroups.jl#L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups.on_classes" href="#Gapjm.PermGroups.on_classes"><code>Gapjm.PermGroups.on_classes</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>on_classes(G, aut)</code></p><p><code>aut</code>  is an automorphism of  the group <code>G</code> (for  a permutation group, this could  be  given  as  a  permutation  normalizing  <code>G</code>).  The result is the permutation of <code>1:nconjugacy_classes(G)</code> induced ny <code>aut</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(&quot;3D4&quot;)
³D₄

julia&gt; on_classes(Group(WF),WF.phi)
Perm{Int64}: (2,8,7)(5,13,12)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermGroups.jl#L345-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups.symmetric_group" href="#Gapjm.PermGroups.symmetric_group"><code>Gapjm.PermGroups.symmetric_group</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The symmetric group of degree n </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermGroups.jl#L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups.onmats" href="#Gapjm.PermGroups.onmats"><code>Gapjm.PermGroups.onmats</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>onmats(m::AbstractMatrix,g::Perm)&#39; simultaneous action of</code>g` on cols and rows</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermGroups.jl#L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups.stab_onmats" href="#Gapjm.PermGroups.stab_onmats"><code>Gapjm.PermGroups.stab_onmats</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>stab_onmats([G,]M[,l])</code></p><p>If  <code>onmats(m,p)=^(M,p;dims=(1,2))</code>, and  the argument  <code>G</code> is given (which should   be  a  <code>PermGroup</code>)   this  is  just   a  fast  implementation  of <code>centralizer(G,M;action=onmats)</code>.  If  <code>G</code>  is  omitted  it  is taken to be <code>symmetric_group(size(M,1))</code>.  The  program  uses sophisticated algorithms, and can handle matrices up to 80×80.</p><pre><code class="language-julia-repl hljs">julia&gt; uc=UnipotentCharacters(ComplexReflectionGroup(34));

julia&gt; stab_onmats(fourier(uc.families[20]))
Group([(7,38),(39,44)(40,43)(41,42)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermGroups.jl#L422-L437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups.Perm_onmats" href="#Gapjm.PermGroups.Perm_onmats"><code>Gapjm.PermGroups.Perm_onmats</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>Perm_onmats(M, N[, m ,n])</code> </p><p>If  <code>onmats(M,p)=^(M,p;dims=(1,2))</code>, return <code>p</code>  such that <code>onmats(M,p)=N</code>; so is just an efficient version of <code>transporting_elt(symmetric_group(size(M,1)),M,N;action=onmats)</code>    If   in addition the vectors <code>m</code> and <code>n</code> are given, <code>p</code> should satisfy <code>m^p=n</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; m=cartan(:D,12);

julia&gt; n=^(m,Perm(1,5,2,8,12,4,7)*Perm(3,9,11,6);dims=(1,2));

julia&gt; Perm_onmats(m,n)
(1,5,2,8,12,4,7)(3,9,11,6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermGroups.jl#L457-L473">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups.Perm_rowcolmat" href="#Gapjm.PermGroups.Perm_rowcolmat"><code>Gapjm.PermGroups.Perm_rowcolmat</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>Perm_rowcolmat(m1,m2)</code></p><p>whether matrix <code>m1</code> is conjugate to matrix <code>m2</code> by row/col permutations</p><p><code>m1</code>  and <code>m2</code> should  be rectangular matrices  of the same dimensions. The function returns a pair of permutations <code>(p1,p2)</code> such that <code>^(m1^p1,p2;dims=2)==m2</code> if such permutations exist, <code>nothing</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermGroups.jl#L537-L545">source</a></section></article><h1 id="Extensions-to-Laurent-and-Puiseux-polynomials"><a class="docs-heading-anchor" href="#Extensions-to-Laurent-and-Puiseux-polynomials">Extensions to Laurent and Puiseux polynomials</a><a id="Extensions-to-Laurent-and-Puiseux-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Extensions-to-Laurent-and-Puiseux-polynomials" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.FFfac.factor-Tuple{Pol{FFE{p}} where p, Any}" href="#Gapjm.FFfac.factor-Tuple{Pol{FFE{p}} where p, Any}"><code>Gapjm.FFfac.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>factor(f::Pol{FFE{p}}[, F])</code></p><p>Given  <code>f</code> a polynomial  over a finite  field of characteristic <code>p</code>, factor <code>f</code>,  by default over the  field of its coefficients,  or if specified over the field <code>F</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; @Pol q
Pol{Int64}: q

julia&gt; f=(q^4-1)*Z(3)^0
Pol{FFE{3}}: q⁴-1

julia&gt; factor(f)
3-element Vector{Pol{FFE{3}}}:
 q²+1
 q+1
 q-1

julia&gt; factor(f,GF(9))
4-element Vector{Pol{FFE{3}}}:
 q+1
 q-1
 q+Z₉²
 q+Z₉⁶</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/FFfac.jl#L77-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.factor-Tuple{Pol{&lt;:Union{Integer, Rational}}}" href="#Gapjm.Util.factor-Tuple{Pol{&lt;:Union{Integer, Rational}}}"><code>Gapjm.Util.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>factor(f::Pol{&lt;:Union{Integer,Rational}})</code></p><p>Factor over the integers a polynomial with integral coefficients, or do the same over the rationals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Fact.jl#L208-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.factor-Union{Tuple{Mvp{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#Gapjm.Util.factor-Union{Tuple{Mvp{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>Gapjm.Util.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>factor(p::Mvp)</code></p><p><code>p</code>  should be of degree &lt;=2 thus represents a quadratic form. The function returns  a list  of two  linear forms  of which  <code>p</code> is the product if such exist, otherwise it returns [p].</p><pre><code class="language-julia-repl hljs">julia&gt; @Mvp x,y

julia&gt; factor(x^2-y^2+x+3y-2)
2-element Vector{Mvp{Int64, Int64}}:
 x-y+2
 x+y-1

julia&gt; factor(x^2+x+1)
2-element Vector{Mvp{Cyc{Int64}, Int64}}:
 x-ζ₃
 x-ζ₃²

julia&gt; factor(x*y-1)
1-element Vector{Mvp{Int64, Int64}}:
 xy-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Tools2.jl#L56-L80">source</a></section></article><h1 id="Cyclotomic-polynomials"><a class="docs-heading-anchor" href="#Cyclotomic-polynomials">Cyclotomic polynomials</a><a id="Cyclotomic-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Cyclotomic-polynomials" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CycPols.cyclotomic_polynomial" href="#Gapjm.CycPols.cyclotomic_polynomial"><code>Gapjm.CycPols.cyclotomic_polynomial</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>cyclotomic_polynomial(n)</code></p><p>returns the <code>n</code>-th cyclotomic polynomial.</p><pre><code class="language-julia-repl hljs">julia&gt; cyclotomic_polynomial(5)
Pol{Int64}: q⁴+q³+q²+q+1

julia&gt; cyclotomic_polynomial(24)
Pol{Int64}: q⁸-q⁴+1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CycPols.jl#L155-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CycPols" href="#Gapjm.CycPols"><code>Gapjm.CycPols</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This package depends only on the packages <code>Primes</code>, <code>ModuleElts</code>, <code>CyclotomicNumbers</code> and <code>LaurentPolynomials</code>. </p><p>Cyclotomic  numbers, and cyclotomic polynomials  over the rationals or some cyclotomic  field,  are  important  in  reductive  groups  or  Spetses.  In particular  Schur  elements  of  cyclotomic  Hecke algebras are products of cyclotomic polynomials.</p><p>The  type <code>CycPol</code>  represents the  product of  a <code>coeff</code>  (a constant or a polynomial)  with a  rational fraction  in one  variable with  all poles or zeroes  equal to  0 or  roots of  unity. The  advantages of representing as <code>CycPol</code>  such objects are:  nice display (factorized),  less storage, fast multiplication,  division and evaluation. The drawback is that addition and subtraction are not implemented!</p><pre><code class="language-julia-repl hljs">julia&gt; @Pol q
Pol{Int64}: q

julia&gt; p=CycPol(q^25-q^24-2q^23-q^2+q+2) # a `Pol` coefficient remains
(q-2)Φ₁Φ₂Φ₂₃

julia&gt; p(q) # a CycPol is a callable object, this call evaluates p at q
Pol{Int64}: q²⁵-q²⁴-2q²³-q²+q+2

julia&gt; p*inv(CycPol(q^2+q+1))
(q-2)Φ₁Φ₂Φ₃⁻¹Φ₂₃

julia&gt; -p
(-q+2)Φ₁Φ₂Φ₂₃

julia&gt; valuation(p)
0

julia&gt; degree(p)
25

julia&gt; lcm(p,CycPol(q^3-1))
(q-2)Φ₁Φ₂Φ₃Φ₂₃

julia&gt; subs(p,Pol()^-1) # evaluate as a CycPol at Pol()^n
(2-q⁻¹)q⁻²⁴Φ₁Φ₂Φ₂₃

julia&gt; subs(p,Pol([E(2)],1)) # or at Pol([Root1],1)
(q+2)Φ₁Φ₂Φ₄₆
</code></pre><p>The  variable name used when  printing a <code>CycPol</code> is  the same as for <code>LaurentPolynomials</code>.</p><p><code>CycPol</code>s are internally a <code>struct</code> with fields:</p><p><code>.coeff</code>:  a coefficient, usually a <code>Cyc</code> or a <code>Pol</code>. The <code>Pol</code> case allows    to represent as <code>CycPol</code>s arbitrary <code>Pol</code>s which is useful sometimes.</p><p><code>.valuation</code>: an <code>Int</code>.</p><p><code>.v</code>: a list of pairs <code>ζ=&gt;m</code> of a <code>Root1</code> <code>ζ</code> and a multiplicity <code>m</code>.</p><p>So <code>CycPol(c,val,v)</code> represents <code>c*q^val*prod((q-ζ)^m for (r,m) in v)</code>.</p><p>When showing a <code>CycPol</code>, some factors of the cyclotomic polynomial <code>Φₙ</code> are given a special name. If <code>n</code> has a primitive root <code>ξ</code>, <code>ϕ′ₙ</code> is the product of  the <code>(q-ζ)</code> where <code>ζ</code> runs over the odd powers of <code>ξ</code>, and <code>ϕ″ₙ</code> is the product  for the even powers. Some further factors are recognized for small <code>n</code>.  The  function  <code>show_factors</code>  gives  the complete list of recognized factors:</p><pre><code class="language-julia-rep1 hljs">julia&gt; CycPols.show_factors(24)
Φ₂₄=q⁸-q⁴+1
Φ′₂₄=q⁴+ζ₃²
Φ″₂₄=q⁴+ζ₃
Φ‴₂₄=q⁴-√2q³+q²-√2q+1
Φ⁗₂₄=q⁴+√2q³+q²+√2q+1
Φ⁽⁵⁾₂₄=q⁴-√6q³+3q²-√6q+1
Φ⁽⁶⁾₂₄=q⁴+√6q³+3q²+√6q+1
Φ⁽⁷⁾₂₄=q⁴+√-2q³-q²-√-2q+1
Φ⁽⁸⁾₂₄=q⁴-√-2q³-q²+√-2q+1
Φ⁽⁹⁾₂₄=q²+ζ₃²√-2q-ζ₃
Φ⁽¹⁰⁾₂₄=q²-ζ₃²√-2q-ζ₃
Φ⁽¹¹⁾₂₄=q²+ζ₃√-2q-ζ₃²
Φ⁽¹²⁾₂₄=q²-ζ₃√-2q-ζ₃²
Φ⁽¹³⁾₂₄=q⁴-ζ₄q²-1
Φ⁽¹⁴⁾₂₄=q⁴+ζ₄q²-1</code></pre><p>A factor can be obtained directly as:</p><pre><code class="language-julia-repl hljs">julia&gt; CycPol(;conductor=24,no=8)
Φ⁽⁷⁾₂₄

julia&gt; CycPol(;conductor=24,no=8)(q)
Pol{Cyc{Int64}}: q⁴+√-2q³-q²-√-2q+1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CycPols.jl#L1-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CycPols.CycPol" href="#Gapjm.CycPols.CycPol"><code>Gapjm.CycPols.CycPol</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>CycPol(p::Pol)</code></p><p>Converts a <code>Pol</code> to <code>CycPol</code></p><pre><code class="language-julia-repl hljs">julia&gt; @Pol q;CycPol(3*q^3-3q)
3qΦ₁Φ₂</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CycPols.jl#L405-L414">source</a></section><section><div><p><code>CycPol(v::AbstractVector)</code></p><p>This  form is an  compact way unsed  in the Chevie  library of specifying a <code>CycPol</code>  with only  positive multiplicities:  <code>v</code> should  be a vector. The first  element is taken as the <code>.coeff</code>  of the <code>CycPol</code>, the second as the <code>.valuation</code>.   Subsequent  elements  are   rationals  <code>i//d</code>  representing <code>(q-E(d)^i)</code> or are integers <code>d</code> representing <code>Φ_d(q)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; CycPol([3,-5,6,3//7])
3q⁻⁵Φ₆(q-ζ₇³)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/cheviesupport.jl#L152-L165">source</a></section><section><div><p><code>CycPol(x::Mvp)</code> converts univariate <code>Mvp</code> <code>x</code> to a <code>CycPol</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Tools2.jl#L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Tools2.eigmat" href="#Gapjm.Tools2.eigmat"><code>Gapjm.Tools2.eigmat</code></a> — <span class="docstring-category">Function</span></header><section><div><p>eigenvalues as Cycs of a matrix of finite order</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Tools2.jl#L115">source</a></section></article><h1 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util" href="#Gapjm.Util"><code>Gapjm.Util</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This  module contains  various utility  functions used  in the  rest of the code.  Maybe some  of them  exist in  some Julia  module I am not aware of; please tell me.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Util.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.@forward" href="#Gapjm.Util.@forward"><code>Gapjm.Util.@forward</code></a> — <span class="docstring-category">Macro</span></header><section><div><p><code>@forward T.f f1,f2,...</code></p><p>is a macro which delegates definitions. The above generates </p><pre><code class="nohighlight hljs">f1(a::T,args...)=f1(a.f,args...)
f2(a::T,args...)=f2(a.f,args...)
...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Util.jl#L25-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.@GapObj" href="#Gapjm.Util.@GapObj"><code>Gapjm.Util.@GapObj</code></a> — <span class="docstring-category">Macro</span></header><section><div><p><code>@GapObj struct...</code></p><p>A <code>GapObj</code> is a kind of object where properties are computed on demand when asked for. So it has fixed fields but can dynamically have new ones.</p><pre><code class="language-julia_repl hljs">julia&gt; @GapObj struct Foo
       a::Int
       end

julia&gt; s=Foo(1,Dict{Symbol,Any}())
Foo(1, Dict{Symbol, Any}())

julia&gt; s.a
1

julia&gt; haskey(s,:b)
false

julia&gt; s.b=&quot;hello&quot;
&quot;hello&quot;

julia&gt; s.b
&quot;hello&quot;

julia&gt; haskey(s,:b)
true</code></pre><p>The  properties when computed are stored in the field <code>.prop</code> of <code>G</code>, which is  of type <code>Dict{Symbol, Any}()</code>. This  explains the extra argument needed in the constructor. The name is because it mimics a GAP record, but perhaps there could be a better name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Util.jl#L54-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.showtable" href="#Gapjm.Util.showtable"><code>Gapjm.Util.showtable</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>showtable(io, table::AbstractMatrix; options )</code></p><p>General  routine to format a table. The  following options can be passed as properties of the <code>io</code> or as keywords.</p><ul><li><code>row_labels</code>         labels for rows (default <code>axes(table,1)</code>)</li><li><code>rows_label</code>         label for first column (column of row labels)</li><li><code>col_labels</code>         labels for other columns</li><li><code>rowseps</code>            line numbers after which to put a separator</li><li><code>rows</code>               show only these rows</li><li><code>cols</code>               show only these columns</li><li><code>TeX</code>                give LaTeX output (useful in Jupyter or Pluto)</li><li><code>column_repartition</code> display in vertical pieces of sizes indicated (default if not <code>TeX</code>: take in account <code>displaysize(io,2)</code>)</li></ul><pre><code class="language-julia-rep1 hljs">julia&gt; m=[1 2 3 4;5 6 7 8;9 1 2 3;4 5 6 7];

julia&gt; showtable(stdout,m)
1│1 2 3 4
2│5 6 7 8
3│9 1 2 3
4│4 5 6 7

julia&gt; labels=[&quot;x&quot;,&quot;y&quot;,&quot;z&quot;,&quot;t&quot;];

julia&gt; showtable(stdout,m;cols=2:4,col_labels=labels,rowseps=[0,2,4])
 │y z t
─┼──────
1│2 3 4
2│6 7 8
─┼──────
3│1 2 3
4│5 6 7
─┴──────</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Util.jl#L264-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.cut" href="#Gapjm.Util.cut"><code>Gapjm.Util.cut</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>cut(io::IO=stdout,string;width=displaysize(io)[2]-2,after=&quot;,&quot;,before=&quot;&quot;)</code></p><p>This  function prints to <code>io</code> the  string argument cut across several lines for improved display. It can take the following keyword arguments:</p><ul><li>width   the cutting width</li><li>after   cut after these chars</li><li>before  cut before these chars</li></ul><pre><code class="language-julia-rep1 hljs">julia&gt; cut(string(collect(1:50)))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Util.jl#L394-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.prime_residues" href="#Gapjm.Util.prime_residues"><code>Gapjm.Util.prime_residues</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>prime_residues(n)</code> the numbers less than <code>n</code> and prime to <code>n</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Util.jl#L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.primitiveroot" href="#Gapjm.Util.primitiveroot"><code>Gapjm.Util.primitiveroot</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>primitiveroot(m::Integer)</code> a primitive root <code>mod. m</code>,   that is generating multiplicatively <code>prime_residues(m)</code>.   It exists if <code>m</code> is of the form <code>4</code>, <code>2p^a</code> or <code>p^a</code> for <code>p</code> prime&gt;2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Util.jl#L486-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.divisors" href="#Gapjm.Util.divisors"><code>Gapjm.Util.divisors</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>divisors(n)</code> the increasing list of divisors of <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Util.jl#L480">source</a></section></article><h1 id="Combinatorics"><a class="docs-heading-anchor" href="#Combinatorics">Combinatorics</a><a id="Combinatorics-1"></a><a class="docs-heading-anchor-permalink" href="#Combinatorics" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat" href="#Gapjm.Combinat"><code>Gapjm.Combinat</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This self-contained module (it has no dependencies) is a Julia port of some GAP combinatorics. The list of functions it exports are:</p><p>Classical enumerations:</p><p><code>combinations, arrangements, partitions, partition_tuples,  restrictedpartitions, partitions_set, compositions, submultisets</code></p><p>functions to count them without computing them:</p><p><code>ncombinations, narrangements, npartitions, npartition_tuples,  nrestrictedpartitions, npartitions_set</code></p><p>some functions on partitions:</p><p><code>lcm_partitions, gcd_partitions, conjugate_partition, dominates</code></p><p>counting functions:</p><p><code>bell, stirling2, catalan, bernoulli</code></p><p>some structural manipulations not yet in Julia:</p><p><code>groupby, tally, collectby, unique_sorted!</code></p><p>matrix blocks:</p><p><code>blocks, diagblocks</code></p><p>Have  a  look  at  the  individual  docstrings  and  enjoy (any feedback is welcome).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.combinations" href="#Gapjm.Combinat.combinations"><code>Gapjm.Combinat.combinations</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>combinations(mset[,k])</code></p><p><code>ncombinations(mset[,k])</code></p><p><code>combinations</code>  returns  all  combinations  of  the  multiset <code>mset</code> (a not necessarily  sorted  collection  with  possible  repetitions).  If a second argument  <code>k</code>  is  given,  it  returns  the combinations with <code>k</code> elements. <code>ncombinations</code> returns the number of combinations.</p><p>A  <em>combination</em> is an unordered subsequence and is represented by a sorted <code>Vector</code>  (the  elements  of  <code>mset</code>  must  be  sortable). If <code>mset</code> has no repetitions, the list of all combinations is just the <em>powerset</em> of <code>mset</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; ncombinations([1,2,2,3])
12

julia&gt; combinations([1,2,2,3])
12-element Vector{Vector{Int64}}:
 []
 [1]
 [2]
 [3]
 [1, 2]
 [1, 3]
 [2, 2]
 [2, 3]
 [1, 2, 2]
 [1, 2, 3]
 [2, 2, 3]
 [1, 2, 2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L202-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.arrangements" href="#Gapjm.Combinat.arrangements"><code>Gapjm.Combinat.arrangements</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>arrangements(mset[,k])</code></p><p><code>narrangements(mset[,k])</code></p><p><code>arrangements</code>  returns  the  arrangements  of  the  multiset <code>mset</code> (a not necessarily  sorted  collection  with  possible  repetitions).  If a second argument   <code>k</code>  is  given,  it  returns  arrangements  with  <code>k</code>  elements. <code>narrangements</code> returns the number of arrangements.</p><p>An  <em>arrangement</em>  of  <code>mset</code>  is  a  subsequence taken in arbitrary order, representated as a <code>Vector</code>.</p><p>As  an example of arrangements  of a multiset, think  of the game Scrabble. Suppose  you have the six  characters of the word  &#39;settle&#39; and you have to make a four letter word. Then the possibilities are given by</p><pre><code class="language-julia-repl hljs">julia&gt; narrangements(collect(&quot;settle&quot;),4)
102</code></pre><p>while all possible words (including the empty one) are:</p><pre><code class="language-julia-repl hljs">julia&gt; narrangements(collect(&quot;settle&quot;))
523</code></pre><p>The  result returned  by &#39;arrangements&#39;  is sorted  (the elements of <code>mset</code> must  be sortable), which means in  this example that the possibilities are listed  in the same  order as they  appear in the  dictionary. Here are the two-letter words:</p><pre><code class="language-julia-repl hljs">julia&gt; String.(arrangements(collect(&quot;settle&quot;),2))
14-element Vector{String}:
 &quot;ee&quot;
 &quot;el&quot;
 &quot;es&quot;
 &quot;et&quot;
 &quot;le&quot;
 &quot;ls&quot;
 &quot;lt&quot;
 &quot;se&quot;
 &quot;sl&quot;
 &quot;st&quot;
 &quot;te&quot;
 &quot;tl&quot;
 &quot;ts&quot;
 &quot;tt&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L279-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.partitions" href="#Gapjm.Combinat.partitions"><code>Gapjm.Combinat.partitions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>partitions(n[,k])</code></p><p><code>npartitions(n[,k])</code></p><p><code>partitions</code> returns the set of all partitions of the positive integer <code>n</code> (the partitions with <code>k</code> parts if <code>k</code> is given). <code>npartitions</code> returns (faster) the number of partitions.</p><p>There are approximately <code>exp(π√(2n/3))/(4√3 n)</code> partitions of <code>n</code>.</p><p>A  <em>partition</em>  is  a  decomposition  <code>n=p₁+p₂+…+pₖ</code>  in integers such that <code>p₁≥p₂≥…≥pₖ&gt;0</code>, and is represented by the vector <code>p=[p₁,p₂,…,pₖ]</code>. We write <code>p⊢n</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; npartitions(7)
15

julia&gt; partitions(7)
15-element Vector{Vector{Int64}}:
 [1, 1, 1, 1, 1, 1, 1]
 [2, 1, 1, 1, 1, 1]
 [2, 2, 1, 1, 1]
 [2, 2, 2, 1]
 [3, 1, 1, 1, 1]
 [3, 2, 1, 1]
 [3, 2, 2]
 [3, 3, 1]
 [4, 1, 1, 1]
 [4, 2, 1]
 [4, 3]
 [5, 1, 1]
 [5, 2]
 [6, 1]
 [7]

julia&gt; npartitions(7,3)
4

julia&gt; partitions(7,3)
4-element Vector{Vector{Int64}}:
 [3, 2, 2]
 [3, 3, 1]
 [4, 2, 1]
 [5, 1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L417-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.partition_tuples" href="#Gapjm.Combinat.partition_tuples"><code>Gapjm.Combinat.partition_tuples</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>partition_tuples(n,r)</code></p><p><code>npartition_tuples(n,r)</code></p><p>the <code>r</code>-tuples of partitions that together partition <code>n</code>. <code>npartition_tuples</code> is the number of partition tuples.</p><pre><code class="language-julia-repl hljs">julia&gt; npartition_tuples(3,2)
10

julia&gt; partition_tuples(3,2)
10-element Vector{Vector{Vector{Int64}}}:
 [[1, 1, 1], []]
 [[1, 1], [1]]
 [[1], [1, 1]]
 [[], [1, 1, 1]]
 [[2, 1], []]
 [[1], [2]]
 [[2], [1]]
 [[], [2, 1]]
 [[3], []]
 [[], [3]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L708-L733">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.partitions_set" href="#Gapjm.Combinat.partitions_set"><code>Gapjm.Combinat.partitions_set</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>partitions_set(set[,k])</code></p><p><code>npartitions_set(set[,k])</code></p><p>the  set of all unordered partitions of the set <code>set</code> (a collection without repetitions);  if  <code>k</code>  is  given  the  unordered  partitions  in <code>k</code> sets. <code>npartitions_set</code> returns the number of unordered partitions.</p><p>An <em>unordered partition</em> of <code>set</code> is  a set of pairwise disjoint nonempty sets with union <code>set</code>  and is represented by  a sorted Vector of Vectors.</p><pre><code class="language-julia-repl hljs">julia&gt; npartitions_set(1:3)
5

julia&gt; partitions_set(1:3)
5-element Vector{Vector{Vector{Int64}}}:
 [[1], [2], [3]]
 [[1], [2, 3]]
 [[1, 2], [3]]
 [[1, 2, 3]]
 [[1, 3], [2]]

julia&gt; npartitions_set(1:4,2)
7

julia&gt; partitions_set(1:4,2)
7-element Vector{Vector{Vector{Int64}}}:
 [[1], [2, 3, 4]]
 [[1, 2], [3, 4]]
 [[1, 2, 3], [4]]
 [[1, 2, 4], [3]]
 [[1, 3], [2, 4]]
 [[1, 3, 4], [2]]
 [[1, 4], [2, 3]]</code></pre><p>Note  that <code>partitions_set</code> does not currently support multisets and that there is currently no ordered counterpart.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L875-L915">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.restrictedpartitions" href="#Gapjm.Combinat.restrictedpartitions"><code>Gapjm.Combinat.restrictedpartitions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>restrictedpartitions(n,set[,k])</code>   </p><p><code>restrictedpartitions</code>  returns the list of partitions of <code>n</code> restricted to have  parts  in  <code>set</code>  (the  partitions  with  <code>k</code> parts if <code>k</code> is given). <code>nrestrictedpartitions</code>  with the same arguments  gives (faster) the number of restricted partitions.</p><p>The next example shows how many ways there are to pay 17 cents using coins of 2,5 and 10 cents.</p><pre><code class="language-julia-repl hljs">julia&gt; nrestrictedpartitions(17,[10,5,2])
3

julia&gt; restrictedpartitions(17,[10,5,2])
3-element Vector{Vector{Int64}}:
 [5, 2, 2, 2, 2, 2, 2]
 [5, 5, 5, 2]
 [10, 5, 2]

julia&gt; restrictedpartitions(17,[10,5,2],3)
1-element Vector{Vector{Int64}}:
 [10, 5, 2]

julia&gt; nrestrictedpartitions(17,[10,5,2],3)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L521-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.compositions" href="#Gapjm.Combinat.compositions"><code>Gapjm.Combinat.compositions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>compositions(n[,k];start=1)</code></p><p>This  function returns the compositions of  <code>n</code> (the compositions of length <code>k</code>  if a second argument <code>k</code> is given), where a composition of the integer <code>n</code> is a decomposition <code>n=p₁+…+pₖ</code> in integers <code>≥start</code>, represented as the vector  <code>[p₁,…,pₖ]</code>. Unless <code>k</code>  is given, <code>start</code>  must be <code>&gt;0</code>. There are <span>$2^{n-1}$</span>  compositions of <code>n</code> in  integers <code>≥1</code>, and <code>binomial(n-1,k-1)</code> compositions  of <code>n</code> in  <code>k</code> parts <code>≥1</code>.  Compositions are sometimes called ordered partitions.</p><pre><code class="language-julia-repl hljs">julia&gt; compositions(4)
8-element Vector{Vector{Int64}}:
 [1, 1, 1, 1]
 [2, 1, 1]
 [1, 2, 1]
 [3, 1]
 [1, 1, 2]
 [2, 2]
 [1, 3]
 [4]

julia&gt; compositions(4,2)
3-element Vector{Vector{Int64}}:
 [3, 1]
 [2, 2]
 [1, 3]

julia&gt; compositions(4,2;start=0)
5-element Vector{Vector{Int64}}:
 [4, 0]
 [3, 1]
 [2, 2]
 [1, 3]
 [0, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L779-L816">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.submultisets" href="#Gapjm.Combinat.submultisets"><code>Gapjm.Combinat.submultisets</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>submultisets(set,k)</code></p><p><code>nsubmultisets(set,k)</code></p><p><code>submultisets</code>  returns  the  set  of  all  multisets of length <code>k</code> made of elements   of   the   set   <code>set</code>   (a   collection  without  repetitions). <code>nsubmultisets</code> returns the number of multisets.</p><p>An  <em>multiset</em> of length <code>k</code> is  an unordered selection with repetitions of length  <code>k</code> from <code>set</code> and is represented  by a sorted vector of length <code>k</code> made  of  elements  from  <code>set</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; submultisets(1:4,3)
20-element Vector{Vector{Int64}}:
 [1, 1, 1]
 [1, 1, 2]
 [1, 1, 3]
 [1, 1, 4]
 [1, 2, 2]
 [1, 2, 3]
 [1, 2, 4]
 [1, 3, 3]
 [1, 3, 4]
 [1, 4, 4]
 [2, 2, 2]
 [2, 2, 3]
 [2, 2, 4]
 [2, 3, 3]
 [2, 3, 4]
 [2, 4, 4]
 [3, 3, 3]
 [3, 3, 4]
 [3, 4, 4]
 [4, 4, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L828-L865">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.lcm_partitions" href="#Gapjm.Combinat.lcm_partitions"><code>Gapjm.Combinat.lcm_partitions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>lcm_partitions(p1,…,pn)</code></p><p>each  argument is  a partition  of the  same set  <code>S</code>, given  as a  list of disjoint  vectors whose  union is  <code>S</code>. Equivalently  each argument  can be interpreted as an equivalence relation on <code>S</code>.</p><p>The result is the finest partition of <code>S</code> such that each argument partition refines it. It represents the &#39;or&#39; of the equivalence relations represented by the arguments.</p><pre><code class="language-julia-repl hljs">julia&gt; lcm_partitions([[1,2],[3,4],[5,6]],[[1],[2,5],[3],[4],[6]])
2-element Vector{Vector{Int64}}:
 [1, 2, 5, 6]
 [3, 4]      </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L1025-L1042">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.gcd_partitions" href="#Gapjm.Combinat.gcd_partitions"><code>Gapjm.Combinat.gcd_partitions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>gcd_partitions(p1,…,pn)</code></p><p>Each  argument is  a partition  of the  same set  <code>S</code>, given  as a  list of disjoint  vectors whose  union is  <code>S</code>. Equivalently  each argument  can be interpreted as an equivalence relation on <code>S</code>.</p><p>The result is the coarsest partition which refines all argument partitions. It  represents the  &#39;and&#39; of  the equivalence  relations represented by the arguments.</p><pre><code class="language-julia-repl hljs">julia&gt; gcd_partitions([[1,2],[3,4],[5,6]],[[1],[2,5],[3],[4],[6]])
6-element Vector{Vector{Int64}}:
 [1]
 [2]
 [3]
 [4]
 [5]
 [6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L1058-L1079">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.conjugate_partition" href="#Gapjm.Combinat.conjugate_partition"><code>Gapjm.Combinat.conjugate_partition</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>conjugate_partition(λ)</code></p><p>returns  the  conjugate  partition  of  the  partition  <code>λ</code>,  that  is, the partition having the transposed of the Young diagram of <code>λ</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; conjugate_partition([4,2,1])
4-element Vector{Int64}:
 3
 2
 1
 1

julia&gt; conjugate_partition([6])
6-element Vector{Int64}:
 1
 1
 1
 1
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L634-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.dominates" href="#Gapjm.Combinat.dominates"><code>Gapjm.Combinat.dominates</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>dominates(λ,μ)</code></p><p>The  dominance  order  on  partitions  is  an  important  partial  order in representation theory. <code>λ</code> dominates <code>μ</code> if and only if for all <code>i</code> we have <code>sum(λ[1:i])≥sum(μ[1:i])</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; dominates([5,4],[4,4,1])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L665-L676">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.bell" href="#Gapjm.Combinat.bell"><code>Gapjm.Combinat.bell</code></a> — <span class="docstring-category">Function</span></header><section><div><p>&#39;bell(n)&#39;</p><p>The  Bell numbers are  defined by <code>bell(0)=1</code>  and <span>$bell(n+1)=∑_{k=0}^n {n \choose  k}bell(k)$</span>, or by the fact  that <code>bell(n)/n!</code> is the coefficient of <code>xⁿ</code> in the formal series <code>e^(eˣ-1)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; bell.(0:6)
7-element Vector{Int64}:
   1
   1
   2
   5
  15
  52
 203

julia&gt; bell(14)
190899322

julia&gt; bell(big(30))
846749014511809332450147</code></pre><p>julia-repl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L1087-L1111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.stirling2" href="#Gapjm.Combinat.stirling2"><code>Gapjm.Combinat.stirling2</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>stirling2(n,k)</code></p><p>the   <em>Stirling  number   of  the   second  kind</em>.   They  are  defined  by <code>stirling2(0,0)=1</code>,  <code>stirling2(n,0)=stirling2(0,k)=0</code>  if  <code>n,  k!=0</code>  and <code>stirling2(n,k)=k   stirling2(n-1,k)+stirling2(n-1,k-1)</code>,   and   also   as coefficients of the generating function <span>$x^n=\sum_{k=0}^{n}stirling2(n,k) k!{x\choose k}$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; stirling2.(4,0:4)
5-element Vector{Int64}:  # Knuth calls this the trademark of stirling2
 0
 1
 7
 6
 1

julia&gt; [stirling2(i,j) for i in 0:6, j in 0:6]
7×7 Matrix{Int64}:
 1  0   0   0   0   0  0 # Note the similarity with Pascal&#39;s triangle
 0  1   0   0   0   0  0
 0  1   1   0   0   0  0
 0  1   3   1   0   0  0
 0  1   7   6   1   0  0
 0  1  15  25  10   1  0
 0  1  31  90  65  15  1

julia&gt; stirling2(50,big(10))
26154716515862881292012777396577993781727011</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L1121-L1152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.catalan-Tuple{Integer}" href="#Gapjm.Combinat.catalan-Tuple{Integer}"><code>Gapjm.Combinat.catalan</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Catalan(n)</code> <code>n</code>-th Catalan Number</p><pre><code class="language-julia-repl hljs">julia&gt; catalan(8)
1430

julia&gt; catalan(big(50))
1978261657756160653623774456</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L1210-L1220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.bernoulli" href="#Gapjm.Combinat.bernoulli"><code>Gapjm.Combinat.bernoulli</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>bernoulli(n)</code> the <code>n</code>-th <em>Bernoulli number</em>  <code>Bₙ</code> as a <code>Rational{BigInt}</code></p><p><code>Bₙ</code> is defined by <span>$B₀=1, B_n=-\sum_{k=0}^{n-1}((n+1\choose k)B_k)/(n+1)$</span>. <code>Bₙ/n!</code> is the coefficient of  <code>xⁿ</code> in the power series of  <code>x/(eˣ-1)</code>. Except for <code>B₁=-1/2</code>  the Bernoulli numbers for odd indices are zero.</p><pre><code class="language-julia_repl hljs">julia&gt; Combinat.bernoulli(4)
-1//30

julia&gt; Combinat.bernoulli(10)
5//66

julia&gt; Combinat.bernoulli(12) # there is no simple pattern in Bernoulli numbers
-691//2730

julia&gt; Combinat.bernoulli(50) # and they grow fairly fast
495057205241079648212477525//66</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L1170-L1190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.groupby" href="#Gapjm.Combinat.groupby"><code>Gapjm.Combinat.groupby</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>groupby(v,l)</code></p><p>group  elements of collection <code>l</code> according  to the corresponding values in the collection <code>v</code> (which should have same length as <code>l</code>).</p><pre><code class="language-julia-rep1 hljs">julia&gt; groupby([31,28,31,30,31,30,31,31,30,31,30,31],
  [:Jan,:Feb,:Mar,:Apr,:May,:Jun,:Jul,:Aug,:Sep,:Oct,:Nov,:Dec])
Dict{Int64,Vector{Symbol}} with 3 entries:
  31 =&gt; Symbol[:Jan, :Mar, :May, :Jul, :Aug, :Oct, :Dec]
  28 =&gt; Symbol[:Feb]
  30 =&gt; Symbol[:Apr, :Jun, :Sep, :Nov]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L46-L60">source</a></section><section><div><p><code>groupby(f::Function,l)</code></p><p>group  elements of collection <code>l</code> according to the values taken by function <code>f</code> on them. The values of <code>f</code> must be hashable.</p><pre><code class="language-julia-repl hljs">julia&gt; groupby(iseven,1:10)
Dict{Bool, Vector{Int64}} with 2 entries:
  0 =&gt; [1, 3, 5, 7, 9]
  1 =&gt; [2, 4, 6, 8, 10]</code></pre><p>Note:  keys of the result will  have type <code>Any</code> if <code>l</code>  is empty since I do not know how to access the return type of a function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L67-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.tally" href="#Gapjm.Combinat.tally"><code>Gapjm.Combinat.tally</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>tally(v)</code></p><p>count  how many times  each element of  collection <code>v</code> occurs  and return a sorted  <code>Vector</code> of  <code>elt=&gt;count</code> (a  variation on  StatsBase.countmap; the elements of <code>v</code> must be sortable).</p><pre><code class="language-julia-repl hljs">julia&gt; tally(&quot;a tally test&quot;)
7-element Vector{Pair{Char, Int64}}:
 &#39; &#39; =&gt; 2
 &#39;a&#39; =&gt; 2
 &#39;e&#39; =&gt; 1
 &#39;l&#39; =&gt; 2
 &#39;s&#39; =&gt; 1
 &#39;t&#39; =&gt; 3
 &#39;y&#39; =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L104-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.collectby" href="#Gapjm.Combinat.collectby"><code>Gapjm.Combinat.collectby</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>collectby(f,v)</code></p><p>group  the elements of <code>v</code> in packets  (<code>Vector</code>s) where <code>f</code> takes the same value.  The resulting <code>Vector{Vector}</code> is sorted  by the values of <code>f</code> (the values  of  <code>f</code>  must  be  sortable;  otherwise  you  can  use  the  slower <code>values(groupby(f,v))</code>).  Here <code>f</code> can  be a function  of one variable or a collection of same length as <code>v</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; l=[:Jan,:Feb,:Mar,:Apr,:May,:Jun,:Jul,:Aug,:Sep,:Oct,:Nov,:Dec];

julia&gt; collectby(x-&gt;first(string(x)),l)
8-element Vector{Vector{Symbol}}:
 [:Apr, :Aug]
 [:Dec]
 [:Feb]
 [:Jan, :Jun, :Jul]
 [:Mar, :May]
 [:Nov]
 [:Oct]
 [:Sep]

julia&gt; collectby(&quot;JFMAMJJASOND&quot;,l)
8-element Vector{Vector{Symbol}}:
 [:Apr, :Aug]
 [:Dec]
 [:Feb]
 [:Jan, :Jun, :Jul]
 [:Mar, :May]
 [:Nov]
 [:Oct]
 [:Sep]</code></pre><p>julia-repl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L127-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.cartesian" href="#Gapjm.Util.cartesian"><code>Gapjm.Util.cartesian</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>cartesian(a::AbstractVector...)</code></p><p>A variation on `<code>Iterators.product</code> which gives the same result as GAP&#39;s <code>Cartesian</code>. <code>reverse</code> is done twice to get the same order as GAP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Util.jl#L523-L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.unique_sorted!" href="#Gapjm.Combinat.unique_sorted!"><code>Gapjm.Combinat.unique_sorted!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>faster than unique! for sorted vectors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.diagblocks" href="#Gapjm.Combinat.diagblocks"><code>Gapjm.Combinat.diagblocks</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>diagblocks(M::Matrix)</code></p><p><code>M</code>  should  be  a  square  matrix.  Define  a  graph  <code>G</code>  with vertices <code>1:size(M,1)</code> and with an edge between <code>i</code>  and <code>j</code> if either <code>M[i,j]</code> or <code>M[j,i]</code> is not zero or <code>false</code>. <code>diagblocks</code> returns a vector of vectors <code>I</code>  such that  <code>I[1]</code>,<code>I[2]</code>, etc..  are the  vertices in each connected component  of <code>G</code>.  In other  words, <code>M[I[1],I[1]]</code>,<code>M[I[2],I[2]]</code>,etc... are diagonal blocks of <code>M</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; m=[0 0 0 1;0 0 1 0;0 1 0 0;1 0 0 0]
4×4 Matrix{Int64}:
 0  0  0  1
 0  0  1  0
 0  1  0  0
 1  0  0  0

julia&gt; diagblocks(m)
2-element Vector{Vector{Int64}}:
 [1, 4]
 [2, 3]

julia&gt; m[[1,4],[1,4]]
2×2 Matrix{Int64}:
 0  1
 1  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L1223-L1251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.blocks-Tuple{AbstractMatrix}" href="#Gapjm.Combinat.blocks-Tuple{AbstractMatrix}"><code>Gapjm.Combinat.blocks</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>blocks(M:AbstractMatrix)</code></p><p>Finds  if the  matrix  <code>M</code> admits a block decomposition.</p><p>Define  a bipartite  graph <code>G</code>  with vertices  <code>axes(M,1)</code>, <code>axes(M,2)</code> and with an edge between <code>i</code> and <code>j</code> if <code>M[i,j]</code> is not zero. BlocksMat returns a  list of pairs of  lists <code>I</code> such that  <code>I[i]</code>, etc.. are the vertices in the <code>i</code>-th connected component of <code>G</code>. In other words, <code>M[I[1][1],I[1][2]], M[I[2][1],I[2][2]]</code>,etc... are blocks of <code>M</code>.</p><p>This  function may  also be  applied to  boolean matrices.</p><pre><code class="language-julia-repl hljs">julia&gt; m=[1 0 0 0;0 1 0 0;1 0 1 0;0 0 0 1;0 0 1 0]
5×4 Matrix{Int64}:
 1  0  0  0
 0  1  0  0
 1  0  1  0
 0  0  0  1
 0  0  1  0

julia&gt; blocks(m)
3-element Vector{Tuple{Vector{Int64}, Vector{Int64}}}:
 ([1, 3, 5], [1, 3])
 ([2], [2])
 ([4], [4])

julia&gt; m[[1,3,5,2,4],[1,3,2,4]]
5×4 Matrix{Int64}:
 1  0  0  0
 1  1  0  0
 0  1  0  0
 0  0  1  0
 0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Combinat.jl#L1268-L1304">source</a></section></article><h1 id="Posets"><a class="docs-heading-anchor" href="#Posets">Posets</a><a id="Posets-1"></a><a class="docs-heading-anchor-permalink" href="#Posets" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets" href="#Gapjm.Posets"><code>Gapjm.Posets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Posets are constructed from one of the two following fields:</p><ul><li><p><code>incidence</code>:  a  boolean  matrix  such that <code>incidence[i,j]==true</code> iff <code>i&lt;=j</code> in the poset. This is sometimes called the ζ matrix of <code>P</code>.</p></li><li><p><code>hasse</code>:  a list representing  the Hasse diagram  of the poset: the i-th entry is the list of indices of elements which are immediate successors (covers) of the i-th element, that is the list of j such that <code>i&lt;j</code> and such that there is no k such that i&lt;k&lt;j.</p></li></ul><p>By  default a <code>Poset</code> <code>P</code> is a  poset on <code>1:length(P)</code> where <code>length(P)</code> is the  cardinality of <code>P</code>. To make a  poset with other elements, the elements should  also be given in the  constructor. There are thus two constructors,</p><ul><li><code>Poset(I::Matrix{Bool}[,elements])</code> from  the  incidence  matrix  <code>I</code>. If given one should have <code>length(elements)==size(I,1)==size(I,2)</code>.</li><li><code>Poset(H::Vector{&lt;:Vector{&lt;:Integer}}[,elements])</code> from the Hasse diagram. If given one should have <code>length(elements)==length(H)</code>.</li></ul><p>For convenience there is another constructor</p><ul><li><code>Poset(isless::Function,elements)</code>;  this  begins  by  constructing  the incidence matrix from the <code>isless</code> function which may be expensive. For isless  one can give  either a function  implementing <code>&lt;</code> or a function implementing <code>≤</code> (it is ored with <code>=</code> in any case).</li></ul><pre><code class="language-julia-repl hljs">julia&gt; l=vec(collect(Iterators.product(1:2,1:2)))
4-element Vector{Tuple{Int64, Int64}}:
 (1, 1)
 (2, 1)
 (1, 2)
 (2, 2)

julia&gt; P=Poset((x,y)-&gt;all(map(&lt;=,x,y)),l)
1&lt;2,3&lt;4</code></pre><p><code>Poset</code>s  are printed at  the REPL as  a list of  covering chains. Elements which  are equivalent  for the  <code>Poset</code> are  printed together  separated by commas.</p><p>By default printing shows the index in <code>1:length(P)</code> for the elements. This can be changed by giving the keyword argument <code>show=:elements</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; P=Poset((x,y)-&gt;all(map(&lt;=,x,y)),l;show=:elements)
(1, 1)&lt;(2, 1),(1, 2)&lt;(2, 2)

julia&gt; length(P) # the number of elements of the `Poset`
4

julia&gt; hasse(P)
4-element Vector{Vector{Int64}}:
 [2, 3]
 [4]
 [4]
 []

julia&gt; incidence(P)
4×4 Matrix{Bool}:
 1  1  1  1
 0  1  0  1
 0  0  1  1
 0  0  0  1</code></pre><p>More flexibility on printing is obtained by setting a function <code>show_elements</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; P.show_element=(io,x,n)-&gt;print(io,join(x.elements[n],&quot;.&quot;));

julia&gt; P
1.1&lt;2.1,1.2&lt;2.2</code></pre><p>see the on-line help on <code>linear_extension, hasse, incidence, partition,  covering_chains, transitive_closure, is_join_lattice, is_meet_lattice, moebius, reverse, restricted, minimum, maximum</code> for more information</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Posets.jl#L1-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.Poset" href="#Gapjm.Posets.Poset"><code>Gapjm.Posets.Poset</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Poset(W::CoxeterGroup,w=longest(W))</code></p><p>returns  as a poset the Bruhat interval <code>[1,w]</code>of <code>W</code>. If <code>w</code> is not given, the whole Bruhat Poset of <code>W</code> is returned (<code>W</code> must then be finite).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; Poset(W)
.&lt;1,2&lt;21,12&lt;121</code></pre><p>The above poset is constructed efficiently by constructing the Hasse diagram, but it could be constructed naively as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; Poset(W)
.&lt;1,2&lt;21,12&lt;121

julia&gt; p=Poset((x,y)-&gt;bruhatless(W,x,y),elements(W))
1&lt;2,3&lt;4,5&lt;6</code></pre><p>The element printing is not so nice. This can be remedied by giving a function:</p><pre><code class="language-julia-repl hljs">julia&gt; p.show_element=(io,x,n)-&gt;(e=x.elements[n];isone(e) ? print(io,&quot;.&quot;) : print(io,joindigits(word(W,e))));

julia&gt; p
.&lt;2,1&lt;21,12&lt;121

julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; Poset(W,W(1,3))
.&lt;3,1&lt;13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L531-L567">source</a></section><section><div><p><code>Poset(m::Matrix{Bool})</code></p><p>Creates a poset from an incidence matrix <code>m</code>, that is <code>m[i,j]==true</code> if and only if <code>i≤j</code> in the poset,</p><pre><code class="language-julia-repl hljs">julia&gt; Poset(Bool[1 1 1 1 1;0 1 0 1 1;0 0 1 1 1;0 0 0 1 0;0 0 0 0 1])
1&lt;2,3&lt;4,5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Posets.jl#L128-L138">source</a></section><section><div><p><code>Poset(h::Vector{&lt;:Vector{&lt;:Integer}})</code></p><p>Creates a poset from a Hasse diagram given as a <code>Vector</code> whose <code>i</code>-th entry is  the list of indices of elements which are immediate successors (covers) of the <code>i</code>-th element, that is <code>h[i]</code> is the list of <code>j</code> such that <code>i&lt;j</code> in the poset and such that there is no <code>k</code> such that <code>i&lt;k&lt;j</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; Poset([[2,3],[4,5],[4,5],Int[],Int[]])
1&lt;2,3&lt;4,5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Posets.jl#L146-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.hasse" href="#Gapjm.Posets.hasse"><code>Gapjm.Posets.hasse</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>hasse(P::Poset)</code></p><p>the Hasse diagram of <code>P</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; p=Poset((i,j)-&gt;j%i==0,1:5)
1&lt;3,5
1&lt;2&lt;4

julia&gt; hasse(p)
5-element Vector{Vector{Int64}}:
 [2, 3, 5]
 [4]      
 []       
 []       
 []       </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Posets.jl#L240-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.incidence" href="#Gapjm.Posets.incidence"><code>Gapjm.Posets.incidence</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>incidence(P::Poset)</code></p><p>returns the incidence matrix (also called the ζ matrix) of <code>P</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; p=Poset([i==6 ? Int[] : [i+1] for i in 1:6])
1&lt;2&lt;3&lt;4&lt;5&lt;6

julia&gt; incidence(p)
6×6 Matrix{Bool}:
 1  1  1  1  1  1
 0  1  1  1  1  1
 0  0  1  1  1  1
 0  0  0  1  1  1
 0  0  0  0  1  1
 0  0  0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Posets.jl#L261-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.transitive_closure" href="#Gapjm.Posets.transitive_closure"><code>Gapjm.Posets.transitive_closure</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>transitive_closure(M)</code></p><p><code>M</code>  should be a  square boolean matrix  representing a relation; returns a boolean  matrix representing the  transitive closure of  this relation. The transitive  closure is computed  by the Floyd-Warshall  algorithm, which is quite fast even for large matrices.</p><pre><code class="language-julia-repl hljs">julia&gt; m=[j-i in [0,1] for i in 1:5, j in 1:5]
5×5 Matrix{Bool}:
 1  1  0  0  0
 0  1  1  0  0
 0  0  1  1  0
 0  0  0  1  1
 0  0  0  0  1

julia&gt;transitive_closure(m)
5×5 Matrix{Bool}:
 1  1  1  1  1
 0  1  1  1  1
 0  0  1  1  1
 0  0  0  1  1
 0  0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Posets.jl#L94-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.linear_extension" href="#Gapjm.Posets.linear_extension"><code>Gapjm.Posets.linear_extension</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>linear_extension(P)</code></p><p>returns  a  linear  extension  of  the  poset  <code>P</code>,  that  is  a vector <code>l</code> containing  a permutation of the integers  <code>1:length(P)</code> such that if <code>i&lt;j</code> in <code>P</code>, then <code>findfirst(==(i),l)&lt;findfirst(==(j),l)</code>. This is also called a topological sort of <code>P</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; p=Poset((i,j)-&gt;j%i==0,1:6)
1&lt;5
1&lt;2&lt;4
1&lt;3&lt;6
2&lt;6

julia&gt; linear_extension(p)
6-element Vector{Int64}:
 1
 2
 3
 5
 4
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Posets.jl#L195-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse" href="#Base.reverse"><code>Base.reverse</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reverse(P::Poset)</code></p><p>the opposed poset to <code>P</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; p=Poset((i,j)-&gt;i%4&lt;j%4,1:8)
4,8&lt;1,5&lt;2,6&lt;3,7

julia&gt; reverse(p)
3,7&lt;2,6&lt;1,5&lt;4,8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Posets.jl#L308-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.partition" href="#Gapjm.Posets.partition"><code>Gapjm.Posets.partition</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>partition(P::Poset)</code></p><p>returns  the  partition  of  <code>1:length(P)</code>  determined  by  the equivalence relation  associated to <code>P</code>; that  is, <code>i</code> and <code>j</code>  are in the same part of the  partition if the <code>k</code> such that <code>i&lt;k</code> and <code>j&lt;k</code> are the same as well as the <code>k</code> such that <code>k&lt;i</code> and <code>k&lt;j</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; p=Poset([i==j || i%4&lt;j%4 for i in 1:8, j in 1:8])
4,8&lt;1,5&lt;2,6&lt;3,7

julia&gt; partition(p)
4-element Vector{Vector{Int64}}:
 [4, 8]
 [2, 6]
 [3, 7]
 [1, 5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Posets.jl#L331-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.restricted-Tuple{Poset, AbstractVector{&lt;:Integer}}" href="#Gapjm.Posets.restricted-Tuple{Poset, AbstractVector{&lt;:Integer}}"><code>Gapjm.Posets.restricted</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>restricted(P::Poset,inds::AbstractVector{&lt;:Integer};show=:indices)</code></p><p>returns  the sub-poset of <code>P</code> determined by <code>inds</code>, which must be a sublist of <code>1:length(P)</code>. The indices in this sub-poset will be renumbered to their position in <code>inds</code>, but the elements set to <code>P.elements[inds]</code>. The keyword show is transmitted to the constructed poset.</p><pre><code class="language-julia-repl hljs">julia&gt; p=Poset((i,j)-&gt;i%4&lt;j%4,1:8)
4,8&lt;1,5&lt;2,6&lt;3,7

julia&gt; restricted(p,2:6)
3&lt;4&lt;1,5&lt;2

julia&gt; restricted(p,2:6;show=:elements)
4&lt;5&lt;2,6&lt;3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Posets.jl#L363-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.is_join_lattice" href="#Gapjm.Posets.is_join_lattice"><code>Gapjm.Posets.is_join_lattice</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>is_join_lattice(P::Poset)</code></p><p>returns  <code>true</code> if <code>P</code> is  a join semilattice, that  is any two elements of <code>P</code> have a unique smallest upper bound; returns <code>false</code> otherwise.</p><pre><code class="language-julia-repl hljs">julia&gt; p=Poset((i,j)-&gt;j%i==0,1:8)
1&lt;5,7
1&lt;2&lt;4&lt;8
1&lt;3&lt;6
2&lt;6

julia&gt; is_join_lattice(p)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Posets.jl#L423-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.is_meet_lattice" href="#Gapjm.Posets.is_meet_lattice"><code>Gapjm.Posets.is_meet_lattice</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>is_meet_lattice(P)</code></p><p>returns  <code>true</code> if <code>P</code> is  a meet semilattice, that  is any two elements of <code>P</code> have a unique highest lower bound; returns <code>false</code> otherwise.</p><pre><code class="language-julia-repl hljs">julia&gt; p=Poset((i,j)-&gt;j%i==0,1:8)
1&lt;5,7
1&lt;2&lt;4&lt;8
1&lt;3&lt;6
2&lt;6

julia&gt; is_meet_lattice(p)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Posets.jl#L442-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.moebius" href="#Gapjm.Posets.moebius"><code>Gapjm.Posets.moebius</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>moebius(P,y=maximum(P))</code></p><p>the vector of value <code>μ(x,y)</code> of the Moebius function of <code>P</code> for <code>x</code> varying. Here is an example giving the ususal Moebius function on integers.</p><pre><code class="language-julia_repl hljs">julia&gt; p=Poset((i,j)-&gt;i%j==0,1:8)
5,7&lt;1
6&lt;2&lt;1
6&lt;3&lt;1
8&lt;4&lt;2

julia&gt; moebius(p)
8-element Vector{Int64}:
  1
 -1
 -1
  0
 -1
  1
 -1
  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Posets.jl#L461-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.Poset" href="#Gapjm.Posets.Poset"><code>Gapjm.Posets.Poset</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Poset(W::CoxeterGroup,w=longest(W))</code></p><p>returns  as a poset the Bruhat interval <code>[1,w]</code>of <code>W</code>. If <code>w</code> is not given, the whole Bruhat Poset of <code>W</code> is returned (<code>W</code> must then be finite).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; Poset(W)
.&lt;1,2&lt;21,12&lt;121</code></pre><p>The above poset is constructed efficiently by constructing the Hasse diagram, but it could be constructed naively as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; Poset(W)
.&lt;1,2&lt;21,12&lt;121

julia&gt; p=Poset((x,y)-&gt;bruhatless(W,x,y),elements(W))
1&lt;2,3&lt;4,5&lt;6</code></pre><p>The element printing is not so nice. This can be remedied by giving a function:</p><pre><code class="language-julia-repl hljs">julia&gt; p.show_element=(io,x,n)-&gt;(e=x.elements[n];isone(e) ? print(io,&quot;.&quot;) : print(io,joindigits(word(W,e))));

julia&gt; p
.&lt;2,1&lt;21,12&lt;121

julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; Poset(W,W(1,3))
.&lt;3,1&lt;13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L531-L567">source</a></section></article><h1 id="Signed-permutations"><a class="docs-heading-anchor" href="#Signed-permutations">Signed permutations</a><a id="Signed-permutations-1"></a><a class="docs-heading-anchor-permalink" href="#Signed-permutations" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.SPerms" href="#Gapjm.SPerms"><code>Gapjm.SPerms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A  signed permutation of <code>1:n</code> is  a permutation of the set <code>-n,…,-1,1,…,n</code> which  preserves the  pairs <code>(-i,i)</code>.  It is  represented internally as the images of <code>1:n</code>. It is printed as a product of signed cycles.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SPerm([-2,-1,-3])
SPerm{Int64}: (1,-2)(3,-3)

julia&gt; p=SPerm(-1)
(1,-1)

julia&gt; q=SPerm(1,2)
(1,2)

julia&gt; sort(elements(Group([p,q])))
8-element Vector{SPerm{Int16}}:
 (1,-2)
 (1,-2,-1,2)
 (1,-1)(2,-2)
 (1,-1)
 (2,-2)
 ()
 (1,2,-1,-2)
 (1,2)</code></pre><p>The  complete type of signed permutations is <code>SPerm{T}</code> where <code>T&lt;:Integer</code>, where <code>Vector{T}</code> is the type of the vector which holds the image of <code>1:n</code>. This  can used to save space or time when possible. If <code>T</code> is not specified we  take it to be <code>Int16</code> since this is a good compromise between speed and compactness.</p><p>SPerms  have methods <code>copy, hash, ==, isless</code>  (total order) so they can be keys in hashes or elements of sets; two <code>SPerms</code> are equal if they move the same points to the same images. For instance,</p><pre><code class="language-julia-repl hljs">julia&gt; SPerm([-2,-1,-3])==SPerm([-2,-1,-3,4])
true</code></pre><p>SPerms are considered as scalars for broadcasting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/SPerms.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.SPerms.SPerm" href="#Gapjm.SPerms.SPerm"><code>Gapjm.SPerms.SPerm</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct SPerm</code></p><p>An  <code>SPerm</code> represents a signed permutation of <code>1:n</code>, that is a permutation of  the  set  <code>-n,…,-1,1,…,n</code>  which  preserves  the  pairs <code>(-i,i)</code>. It is implemented  by a <code>struct SPerm</code>  with one field <code>d</code>,  a vector holding the images of <code>1:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/SPerms.jl#L48-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.Perm-Tuple{SPerm}" href="#Gapjm.Perms.Perm-Tuple{SPerm}"><code>Gapjm.Perms.Perm</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Perm(p::SPerm)</code> returns the underlying Perm of an SPerm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/SPerms.jl#L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.SPerms.@sperm_str" href="#Gapjm.SPerms.@sperm_str"><code>Gapjm.SPerms.@sperm_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@sperm&quot;...&quot;</p><p>make a <code>SPerm</code> from a string; allows the style <code>sperm&quot;(1,-2)(5,-6,7)(-4,9)&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/SPerms.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.orbit-Tuple{SPerm, Integer}" href="#Gapjm.Groups.orbit-Tuple{SPerm, Integer}"><code>Gapjm.Groups.orbit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>orbit(a::SPerm,i::Integer) returns the orbit of a on i</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/SPerms.jl#L169-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.order-Tuple{SPerm}" href="#Gapjm.Groups.order-Tuple{SPerm}"><code>Gapjm.Groups.order</code></a> — <span class="docstring-category">Method</span></header><section><div><p>order(a)</p><p>order of the signed permutation a</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/SPerms.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Matrix" href="#Base.Matrix"><code>Base.Matrix</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Matrix(a::Perm,n=length(a.d))</code>  the  permutation matrix  for <code>a</code>  operating on  <code>n</code> points (by default, the degree of <code>a</code>). If given, <code>n</code> should be larger than <code>largest_moved_point(a)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; Matrix(Perm(2,3,4),5)
5×5 Matrix{Bool}:
 1  0  0  0  0
 0  0  1  0  0
 0  0  0  1  0
 0  1  0  0  0
 0  0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Perms.jl#L289-L303">source</a></section><section><div><p><code>Matrix(a::SPerm)</code> is the permutation matrix for a</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Matrix(SPerm([-2,-1,-3]))
3×3 Matrix{Int64}:
  0  -1   0
 -1   0   0
  0   0  -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/SPerms.jl#L328-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.SPerms.CoxHyperoctaedral" href="#Gapjm.SPerms.CoxHyperoctaedral"><code>Gapjm.SPerms.CoxHyperoctaedral</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>CoxHyperoctaedral(n)</code>  The Hyperoctaedral  group on  ±1,…,±n as  a Coxeter group  of type  B, with  generators (1,-1)  and (i,i+1)(-i,-i-1); it is the group of all signed permutations of <code>1:n</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; elements(CoxHyperoctaedral(2))
8-element Vector{SPerm{Int8}}:
 ()
 (1,2)
 (1,-1)
 (1,2,-1,-2)
 (1,-2,-1,2)
 (2,-2)
 (1,-2)
 (1,-1)(2,-2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/SPerms.jl#L380-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection_subgroup-Tuple{CoxHyperoctaedral, AbstractVector{Int64}}" href="#Gapjm.PermRoot.reflection_subgroup-Tuple{CoxHyperoctaedral, AbstractVector{Int64}}"><code>Gapjm.PermRoot.reflection_subgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflection_subgroup(W::CoxHyperoctaedral,I)</code> the only parabolics defined are <code>I=1:m</code> for <code>m≤ngens(W)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/SPerms.jl#L442-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.SPerms.sstab_onmats" href="#Gapjm.SPerms.sstab_onmats"><code>Gapjm.SPerms.sstab_onmats</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>sstab_onmats([G,]M[,l])</code></p><p>If <code>onmats(m,p)=^(M,p;dims=(1,2))</code> (simultaneous signed conjugation of rows and  columns, or conjugating by the  matrix of the signed permutation <code>p</code>), and  the argument <code>G</code>  is given (which  should be an  <code>SPermGroup</code>) this is just  a fast implementation of  <code>centralizer(G,M;action=onmats)</code>. If <code>G</code> is omitted  it is taken to be <code>CoxHyperoctaedral(size(M,1))</code>. The program uses sophisticated  algorithms, and can  handle matrices up  to 80×80. If <code>l</code> is given the return group should also centralize <code>l</code> (for the action ^)</p><pre><code class="language-julia-repl hljs">julia&gt; uc=UnipotentCharacters(ComplexReflectionGroup(6));

julia&gt; g=sstab_onmats(fourier(uc.families[2]))
Group([(1,18)(3,-6)(8,-21)(10,-16)(11,22)(13,15),(1,-15)(2,-19)(3,-11)(6,22)(7,-12)(13,-18),(2,19)(4,-14)(5,20)(7,12),(1,-11)(2,-19)(3,-15)(5,-20)(6,13)(8,10)(16,21)(17,-17)(18,-22),(1,-22)(2,-19)(3,-13)(5,-20)(6,15)(8,-16)(10,-21)(11,-18)(17,-17),(1,6)(2,-19)(3,-18)(4,14)(8,16)(9,-9)(10,21)(11,-13)(15,-22),(1,13)(3,22)(4,14)(5,-20)(6,-11)(8,21)(9,-9)(10,16)(15,18)(17,-17)])
julia&gt; length(g)
32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/SPerms.jl#L488-L507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.SPerms.SPerm_onmats" href="#Gapjm.SPerms.SPerm_onmats"><code>Gapjm.SPerms.SPerm_onmats</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>SPerm_onmats(M,N[,m,n])</code></p><p><code>M</code>  and <code>N</code> should be symmetric  matrices. <code>SPerm_onmats</code> returns a signed permutation <code>p</code> such that <code>onmats(M,p)=N</code> if such a permutation exists, and <code>nothing</code>  otherwise. If  in addition  vectors <code>m</code>  and <code>n</code>  are given, the signed permutation <code>p</code> should also satisfy <code>m^p==n</code>.</p><p>This  routine is  useful to  identify two  objects which are isomorphic but with  different  labelings.  It  is  used  in   Chevie  to identify Lusztig Fourier  transform matrices  with standard  (classified) data.  The program uses  sophisticated  algorithms,  and  can  often  handle  matrices  up  to 80×80.</p><p>Efficient version of <code>transporting_elt(CoxHyperoctaedral(size(M,1)),M,N;action=onmats)</code></p><pre><code class="language-julia-repl hljs">julia&gt; f=SubFamilyij(chevieget(:families,:X)(12),1,3,(3+root(-3))//2);

julia&gt; M=fourier(conj(f));

julia&gt; uc=UnipotentCharacters(ComplexReflectionGroup(6));

julia&gt; N=fourier(uc.families[2]);

julia&gt; p=SPerm_onmats(M,N)
(1,3)(2,19,-2,-19)(4,-14,-4,14)(5,-5)(6,-18)(7,-7)(8,10)(11,15,-11,-15)(12,-12)(13,22)(16,21,-16,-21)

julia&gt; ^(M,p;dims=(1,2))==N
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/SPerms.jl#L529-L561">source</a></section></article><h1 id="Linear-algebra-on-any-field/ring"><a class="docs-heading-anchor" href="#Linear-algebra-on-any-field/ring">Linear algebra on any field/ring</a><a id="Linear-algebra-on-any-field/ring-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-algebra-on-any-field/ring" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra" href="#Gapjm.GLinearAlgebra"><code>Gapjm.GLinearAlgebra</code></a> — <span class="docstring-category">Module</span></header><section><div><p>GLinearAlgebra: linear algebra over arbitrary fields and rings</p><p>The  linear  algebra  package  in  Julia  is  not  suitable  for  a general mathematics  package: it assumes  the field is  the Real or Complex numbers and uses floating point to do approximate computations. Here we are interested in functions which work over any field (or sometimes any ring).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.echelon!" href="#Gapjm.GLinearAlgebra.echelon!"><code>Gapjm.GLinearAlgebra.echelon!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>echelon!(m)</code></p><p>puts <code>m</code> in echelon form and returns: (<code>m</code>, indices of linearly independent rows  of <code>m</code>) The echelon  form transforms the rows  of m into a particular basis  of the rowspace. The  first non-zero element of  each line is 1, and such  an element  is also  the only  non-zero in  its column.  works in any field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L28-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.echelon" href="#Gapjm.GLinearAlgebra.echelon"><code>Gapjm.GLinearAlgebra.echelon</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>echelon(m)</code></p><p>returns: (echelon form of <code>m</code>, indices of linearly independent rows of <code>m</code>).   Works over any field.</p><p>The  echelon form returns a particular basis of the row space of <code>m</code>: the   first non-zero element of each line is 1, and such an element is also the   only non-zero in its column.</p><p>The second element of <code>echelon</code> is the indices of a subset of the rows   which forms a basis of the row space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L61-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.bigcell_decomposition" href="#Gapjm.GLinearAlgebra.bigcell_decomposition"><code>Gapjm.GLinearAlgebra.bigcell_decomposition</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>bigcell_decomposition(M [, b])</code></p><p><code>M</code>  should be a square  matrix, and <code>b</code> specifies  a block structure for a matrix  of  same  size  as  <code>M</code>  (it  is  a  <code>Vector</code>  of  <code>Vector</code>s  whose concatenation  is <code>1:size(M,1)</code>).  If <code>b</code>  is not  given, the trivial block structure <code>[[i] for i in axes(M,1)]</code> is assumed.</p><p>The  function  decomposes  <code>M</code>  as  a  product  <code>P₁ L P</code> where <code>P</code> is upper block-unitriangular   (with  identity  diagonal   blocks),  <code>P₁</code>  is  lower block-unitriangular  and <code>L</code> is block-diagonal for the block structure <code>b</code>. If  <code>M</code> is symmetric then  <code>P₁</code> is the transposed  of <code>P</code> and the result is the  pair  <code>[P,L]</code>;  else  the  result  is  the triple <code>[P₁,L,P]</code>. The only condition  for  this  decomposition  of  <code>M</code>  to  be  possible  is that the principal  minors  according  to  the  block  structure be invertible. This routine  is used  in the  Lusztig-Shoji algorithm  for computing  the Green functions  and the example  below is extracted  from the computation of the Green functions for <code>G₂</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; @Pol q
Pol{Int64}: q

julia&gt; M=[q^6 q^0 q^3 q^3 q^5+q q^4+q^2; q^0 q^6 q^3 q^3 q^5+q q^4+q^2; q^3 q^3 q^6 q^0 q^4+q^2 q^5+q; q^3 q^3 q^0 q^6 q^4+q^2 q^5+q; q^5+q q^5+q q^4+q^2 q^4+q^2 q^6+q^4+q^2+1 q^5+2*q^3+q; q^4+q^2 q^4+q^2 q^5+q q^5+q q^5+2*q^3+q q^6+q^4+q^2+1]
6×6 Matrix{Pol{Int64}}:
 q⁶     1      q³     q³     q⁵+q        q⁴+q²
 1      q⁶     q³     q³     q⁵+q        q⁴+q²
 q³     q³     q⁶     1      q⁴+q²       q⁵+q
 q³     q³     1      q⁶     q⁴+q²       q⁵+q
 q⁵+q   q⁵+q   q⁴+q²  q⁴+q²  q⁶+q⁴+q²+1  q⁵+2q³+q
 q⁴+q²  q⁴+q²  q⁵+q   q⁵+q   q⁵+2q³+q    q⁶+q⁴+q²+1

julia&gt; bb=[[2],[4],[6],[3,5],[1]];

julia&gt; (P,L)=bigcell_decomposition(M,bb);

julia&gt; P
6×6 Matrix{Pol{Int64}}:
 1    0  0    0    0        0
 q⁻⁶  1  q⁻³  q⁻³  q⁻¹+q⁻⁵  q⁻²+q⁻⁴
 0    0  1    0    0        0
 q⁻³  0  0    1    q⁻²      q⁻¹
 q⁻¹  0  0    0    1        0
 q⁻²  0  q⁻¹  0    q⁻¹      1

julia&gt; L
6×6 Matrix{Pol{Int64}}:
 q⁶-q⁴-1+q⁻²  0   0            0     0            0
 0            q⁶  0            0     0            0
 0            0   q⁶-q⁴-1+q⁻²  0     0            0
 0            0   0            q⁶-1  0            0
 0            0   0            0     q⁶-q⁴-1+q⁻²  0
 0            0   0            0     0            q⁶-1

julia&gt; M==transpose(P)*L*P
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L182-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.ratio" href="#Gapjm.GLinearAlgebra.ratio"><code>Gapjm.GLinearAlgebra.ratio</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>ratio(v,w)</code> ratio <code>v/w</code> –- <code>nothing</code> if <code>v</code> is not a multiple of <code>w</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.exterior_power" href="#Gapjm.GLinearAlgebra.exterior_power"><code>Gapjm.GLinearAlgebra.exterior_power</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>exterior_power(mat,n)</code></p><p><code>mat</code>  should be a square matrix.  The function returns the <code>n</code>-th exterior power  of  <code>mat</code>,  in  the  basis naturally indexed by<code>combinations(1:r,n)</code> where<code>r=size(mat,1)</code></p><pre><code class="language-julia-repl hljs">julia&gt; M=[1 2 3 4;2 3 4 1;3 4 1 2;4 1 2 3]
4×4 Matrix{Int64}:
 1  2  3  4
 2  3  4  1
 3  4  1  2
 4  1  2  3

julia&gt; exterior_power(M,2)
6×6 Matrix{Int64}:
  -1   -2   -7   -1  -10  -13
  -2   -8  -10  -10  -12    2
  -7  -10  -13    1    2    1
  -1  -10    1  -13    2    7
 -10  -12    2    2    8   10
 -13    2    1    7   10   -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L279-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.charpoly" href="#Gapjm.GLinearAlgebra.charpoly"><code>Gapjm.GLinearAlgebra.charpoly</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>charpoly(M::Matrix)</code> characteristic polynomial (as <code>Vector</code> of coefficients)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.comatrix" href="#Gapjm.GLinearAlgebra.comatrix"><code>Gapjm.GLinearAlgebra.comatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>comatrix(M::Matrix)</code> is defined by <code>comatrix(M)*M=det(M)*one(M)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.permanent" href="#Gapjm.GLinearAlgebra.permanent"><code>Gapjm.GLinearAlgebra.permanent</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>permanent(m)</code></p><p>returns the <em>permanent</em> of the square matrix <code>m</code>, which is defined by  <span>$\sum_{p\in\frak S_n}\prod_{i=1}^n m[i,p(i)]$</span>.</p><p>Note the similarity of the definition of  the permanent to the definition of the determinant.  In  fact the only  difference is the missing sign of the permutation.  However the  permanent is quite unlike the determinant, for example   it is  not  multilinear or  alternating.  It   has  however important combinatorical properties.</p><pre><code class="language-julia-repl hljs">julia&gt; permanent([0 1 1 1;1 0 1 1;1 1 0 1;1 1 1 0])
9 # inefficient way to compute the number of derangements of 1:4

julia&gt; permanent([1 1 0 1 0 0 0; 0 1 1 0 1 0 0;0 0 1 1 0 1 0; 0 0 0 1 1 0 1;1 0 0 0 1 1 0;0 1 0 0 0 1 1;1 0 1 0 0 0 1])
24 # 24 permutations fit the projective plane of order 2 </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L309-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.symmetric_power" href="#Gapjm.GLinearAlgebra.symmetric_power"><code>Gapjm.GLinearAlgebra.symmetric_power</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>symmetric_power(m,n)</code></p><p>returns the <code>n</code>-th symmetric power of the square matrix <code>m</code>, in the basis  naturally indexed by the <code>submultisets</code> of <code>1:n</code>, where <code>n=size(m,1)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; m=[1 2;3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; Int.(symmetric_power(m,2))
3×3 Matrix{Int64}:
 1   2   4
 6  10  16
 9  12  16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L339-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.schur_functor" href="#Gapjm.GLinearAlgebra.schur_functor"><code>Gapjm.GLinearAlgebra.schur_functor</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>schur_functor(mat,l)</code></p><p><code>mat</code>  should be  a square  matrix and  <code>l</code> a  partition. The result is the Schur  functor  of  the  matrix  <code>mat</code>  corresponding to partition <code>l</code>; for example,   if  <code>l==[n]</code>  it  returns  the   n-th  symmetric  power  and  if <code>l==[1,1,1]</code> it returns the 3rd exterior power. The current algorithm (from Littlewood)  is rather inefficient so it is  quite slow for partitions of n where <code>n&gt;6</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; m=cartan(:A,3)
3×3 Matrix{Int64}:
  2  -1   0
 -1   2  -1
  0  -1   2

julia&gt; schur_functor(m,[2,2])
6×6 Matrix{Rational{Int64}}:
   9//1   -6//1    4//1   3//2   -2//1    1//1
 -12//1   16//1  -16//1  -4//1    8//1   -4//1
   4//1   -8//1   16//1   2//1   -8//1    4//1
  12//1  -16//1   16//1  10//1  -16//1   12//1
  -4//1    8//1  -16//1  -4//1   16//1  -12//1
   1//1   -2//1    4//1   3//2   -6//1    9//1</code></pre><p>julia-repl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L364-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.transporter" href="#Gapjm.GLinearAlgebra.transporter"><code>Gapjm.GLinearAlgebra.transporter</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>transporter(l1, l2 )</code></p><p><code>l1</code>  and <code>l2</code> should be vectors of  the same length of square matrices all of the same size. The result is a basis of the vector space of matrices <code>A</code> such  that for any <code>i</code> we have  <code>A*l1[i]=l2[i]*A</code> –- the basis is returned as  a vector of matrices, empty if the vector space is 0. This is useful to find whether two representations are isomorphic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L410-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.diagconj_elt" href="#Gapjm.GLinearAlgebra.diagconj_elt"><code>Gapjm.GLinearAlgebra.diagconj_elt</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>representative_diagconj(M,N)</code></p><p><code>M</code> and <code>N</code> must be square matrices of the same size. This function returns a  list <code>d</code>  such that  <code>N==inv(Diagonal(d))*M*Diagonal(d)</code> if  such a list exists, and <code>nothing</code> otherwise.</p><pre><code class="language-julia_repl hljs">julia&gt; M=[1 2;2 1];N=[1 4;1 1]
2×2 Matrix{Int64}:
 1  4
 1  1

julia&gt; diagconj_elt(M,N)
2-element Vector{Rational{Int64}}:
 1//1
 2//1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L525-L543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HasType.traces_words_mats" href="#Gapjm.HasType.traces_words_mats"><code>Gapjm.HasType.traces_words_mats</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>traces_words_mats(mats,words)</code></p><p>given  a list <code>mats</code>  of matrices and  a list <code>words</code>  of words returns the list of traces of the corresponding products of the matrices</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:F,4)
F₄

julia&gt; r=classinfo(W)[:classtext];

julia&gt; R=representation(W,17)
4-element Vector{Matrix{Int64}}:
 [-1 -1 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 1]
 [1 0 0 0; -1 -1 -1 0; 0 0 1 0; 0 0 0 1]
 [1 0 0 0; 0 1 0 0; 0 -2 -1 -1; 0 0 0 1]
 [1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 -1 -1]

julia&gt; traces_words_mats(R,r)==CharTable(W).irr[17,:]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/HasType.jl#L47-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.solutionmat" href="#Gapjm.GLinearAlgebra.solutionmat"><code>Gapjm.GLinearAlgebra.solutionmat</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>solutionmat(mat,v)</code></p><p>returns  one solution of the  equation <code>transpose(mat)*x=v</code> or <code>nothing</code> if no  such  solution  exists.  Similar  to  <code>transpose(mat)\v</code> when <code>mat</code> is invertible.</p><pre><code class="language-julia-repl hljs">julia&gt; m=[2 -4 1;0 0 -4;1 -2 -1]
3×3 Matrix{Int64}:
 2  -4   1
 0   0  -4
 1  -2  -1

julia&gt; x=solutionmat(m,[10,-20, -10])
3-element Vector{Rational{Int64}}:
  5//1
 15//4
  0//1

julia&gt; m&#39;*x
3-element Vector{Rational{Int64}}:
  10//1
 -20//1
 -10//1

julia&gt; solutionmat(m,[10, 20, -10])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L445-L473">source</a></section><section><div><p>return matrix x such that x*m==n</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L522">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.sum_rowspace" href="#Gapjm.GLinearAlgebra.sum_rowspace"><code>Gapjm.GLinearAlgebra.sum_rowspace</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>sum_rowspace(m::AbstractMatrix,n::AbstractMatrix)</code> sum of the rowspaces of m and n</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.intersect_rowspace" href="#Gapjm.GLinearAlgebra.intersect_rowspace"><code>Gapjm.GLinearAlgebra.intersect_rowspace</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>intersect_rowspace(m::AbstractMatrix,n::AbstractMatrix)</code> intersection of the rowspaces of m and n</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.lnullspace" href="#Gapjm.GLinearAlgebra.lnullspace"><code>Gapjm.GLinearAlgebra.lnullspace</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>lnullspace(m::AbstractMatrix)</code>: left nullspace of <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/GLinearAlgebra.jl#L114">source</a></section></article><h1 id="Integral-matrices-and-lattices"><a class="docs-heading-anchor" href="#Integral-matrices-and-lattices">Integral matrices and lattices</a><a id="Integral-matrices-and-lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Integral-matrices-and-lattices" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.MatInt.smith" href="#Gapjm.MatInt.smith"><code>Gapjm.MatInt.smith</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>smith(m::AbstractMatrix{&lt;:Integer})</code></p><p>computes  the Smith normal form  <code>S</code> of <code>m</code>, the  unique equivalent (in the sense  that  There  exist  unimodular  integer  matrices  <code>P,  Q</code> such that <code>Q*m*P==S</code>) diagonal matrix such that <code>Sᵢ,ᵢ</code> divides <code>Sⱼ,ⱼ</code> for <code>i≤j</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; m=[1 15 28 7;4 5 6 7;7 8 9 7]
3×4 Matrix{Int64}:
 1  15  28  7
 4   5   6  7
 7   8   9  7

julia&gt; smith(m)
3×4 Matrix{Int64}:
 1  0  0  0
 0  1  0  0
 0  0  3  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/MatInt.jl#L622-L642">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.MatInt.smith_transforms" href="#Gapjm.MatInt.smith_transforms"><code>Gapjm.MatInt.smith_transforms</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>smith_transforms(m::AbstractMatrix{&lt;:Integer})</code></p><p>The  Smith normal form of <code>m</code> is  the unique equivalent diagonal matrix <code>S</code> such  that <code>Sᵢ,ᵢ</code> divides <code>Sⱼ,ⱼ</code> for  <code>i≤j</code>. There exist unimodular integer matrices  <code>P, Q</code> such that <code>Q*m*P==S</code>.  This function returns a named tuple with <code>.normal=S</code>, <code>.rowtrans=Q</code> and <code>.coltrans=P</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; n=smith_transforms(m)
(normal = [1 0 0 0; 0 1 0 0; 0 0 3 0], coltrans = [1 0 -1 -84; 0 1 -1 175; 0 0 1 -91; 0 0 0 1], rowtrans = [-2 62 -35; 1 -30 17; -3 97 -55], rank = 3, signdet = nothing)

julia&gt; n.rowtrans*m*n.coltrans==n.normal
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/MatInt.jl#L645-L660">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.MatInt.hermite" href="#Gapjm.MatInt.hermite"><code>Gapjm.MatInt.hermite</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>hermite(m::AbstractMatrix{&lt;:Integer})</code></p><p>returns  the row Hermite normal  form <code>H</code> of the  integer matrix <code>m</code>, a row equivalent upper triangular form. If a pivot is the first non-zero entry on a row of <code>H</code> (the quadrant below left a pivot is zero), pivots are positive and entries above a pivot are nonnegative and smaller than the pivot. There exists a unique invertible integer matrix <code>Q</code> such that <code>Qm==H</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; m=[1 15 28;4 5 6;7 8 9]
3×3 Matrix{Int64}:
 1  15  28
 4   5   6
 7   8   9

julia&gt; hermite(m)
3×3 Matrix{Int64}:
 1  0  1
 0  1  1
 0  0  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/MatInt.jl#L506-L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.MatInt.hermite_transforms" href="#Gapjm.MatInt.hermite_transforms"><code>Gapjm.MatInt.hermite_transforms</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>hermite_transforms(m::AbstractMatrix{&lt;:Integer})</code></p><p>The  row  Hermite  normal  form  <code>H</code>  of  the  integer  matrix <code>m</code> is a row equivalent upper triangular form. If a pivot is the first non-zero entry on a row of <code>H</code> (the quadrant below left a pivot is zero), pivots are positive and entries above a pivot are nonnegative and smaller than the pivot. There exists  a  unique  invertible  integer  matrix  <code>Q</code>  such that <code>Qm==H</code>. The function returns a tuple with components <code>.normal=H</code> and <code>.rowtrans=Q</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; m=[1 15 28;4 5 6;7 8 9]
3×3 Matrix{Int64}:
 1  15  28
 4   5   6
 7   8   9

julia&gt; n=hermite_transforms(m)
(normal = [1 0 1; 0 1 1; 0 0 3], rowtrans = [-2 62 -35; 1 -30 17; -3 97 -55], rank = 3, signdet = 1)

julia&gt; n.rowtrans*m==n.normal
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/MatInt.jl#L533-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.MatInt.col_hermite" href="#Gapjm.MatInt.col_hermite"><code>Gapjm.MatInt.col_hermite</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>col_hermite(m::AbstractMatrix{&lt;:Integer})</code></p><p>returns  the column Hermite  normal form <code>H</code>  of the integer  matrix <code>m</code>, a column  equivalent lower triangular form. If  a pivot is the first non-zero entry on a column of <code>H</code> (the quadrant above right a pivot is zero), pivots are  positive and entries left of a  pivot are nonnegative and smaller than the  pivot. There exists  a unique invertible  integer matrix <code>Q</code> such that <code>mQ==H</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; m=[1 15 28;4 5 6;7 8 9]
3×3 Matrix{Int64}:
 1  15  28
 4   5   6
 7   8   9

julia&gt; col_hermite(m)
3×3 Matrix{Int64}:
 1  0  0
 0  1  0
 0  1  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/MatInt.jl#L563-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.MatInt.col_hermite_transforms" href="#Gapjm.MatInt.col_hermite_transforms"><code>Gapjm.MatInt.col_hermite_transforms</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>col_hermite_transforms(m::AbstractMatrix{&lt;:Integer})</code></p><p>The  column Hermite normal form  <code>H</code> of the integer  matrix <code>m</code> is a column equivalent lower triangular form. If a pivot is the first non-zero entry on a  column of  <code>H</code> (the  quadrant above  right a  pivot is zero), pivots are positive  and entries left of a pivot  are nonnegative and smaller than the pivot.  There  exists  a  unique  invertible  integer  matrix <code>Q</code> such that <code>mQ==H</code>. The function returns a named tuple with components <code>.normal=H</code> and <code>.rowtrans=Q</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; m=[1 15 28;4 5 6;7 8 9]
3×3 Matrix{Int64}:
 1  15  28
 4   5   6
 7   8   9

julia&gt; n=col_hermite_transforms(m)
(normal = [1 0 0; 0 1 0; 0 1 3], coltrans = [-1 13 -50; 2 -27 106; -1 14 -55], rank = 3, signdet = 1)

julia&gt; m*n.coltrans==n.normal
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/MatInt.jl#L591-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.MatInt.baseInt" href="#Gapjm.MatInt.baseInt"><code>Gapjm.MatInt.baseInt</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>baseInt(m::Matrix{&lt;:Integer})</code></p><p>returns  a list of vectors that forms a  basis of the integral row space of <code>m</code>, i.e. of the set of integral linear combinations of the rows of <code>m</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; m=[1 2 7;4 5 6;10 11 19]
3×3 Matrix{Int64}:
  1   2   7
  4   5   6
 10  11  19

julia&gt; baseInt(m)
3×3 Matrix{Int64}:
 1  2   7
 0  3   7
 0  0  15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/MatInt.jl#L667-L686">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.MatInt.lnullspaceInt" href="#Gapjm.MatInt.lnullspaceInt"><code>Gapjm.MatInt.lnullspaceInt</code></a> — <span class="docstring-category">Function</span></header><section><div><p>`lnullspaceInt(m::Matrix{&lt;:Integer})</p><p>returns  a matrix whose rows form a  basis of the integral lnullspace of <code>m</code>,  that is of elements  of the left nullspace  of <code>m</code> that have integral entries.</p><pre><code class="language-julia-repl hljs">julia&gt; m=[1 2 7;4 5 6;7 8 9;10 11 19;5 7 12]
5×3 Matrix{Int64}:
  1   2   7
  4   5   6
  7   8   9
 10  11  19
  5   7  12

julia&gt; MatInt.lnullspaceInt(m)
2×5 Matrix{Int64}:
 1  18   -9  2  -6
 0  24  -13  3  -7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/MatInt.jl#L765-L786">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.MatInt.complementInt" href="#Gapjm.MatInt.complementInt"><code>Gapjm.MatInt.complementInt</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>complementInt(full::Matrix{&lt;:Integer}, sub::Matrix{&lt;:Integer})</code></p><p>Let  <code>M</code> be the integral row module of  <code>full</code> and let <code>S</code>, a submodule of  <code>M</code>,  be the integral row  module of <code>sub</code>. This  function computes a free  basis for <code>M</code> that extends <code>S</code>, that is, if the dimension of <code>S</code> is <code>n</code> it  determines  a basis  <code>B={b₁,…,bₘ}</code> for  <code>M</code>, as  well as <code>n</code> integers <code>xᵢ</code>  such that the <code>n</code> vectors <code>sᵢ:=xᵢ⋅bᵢ</code> form a basis for <code>S</code>.</p><p>It returns a named tuple with the following components:</p><ul><li><code>complement</code> a matrix whose lines are <code>bₙ₊₁,…,bₘ</code>.</li><li><code>sub</code> a matrix whose lines are the <code>sᵢ</code> (a basis for <code>S</code>).</li><li><code>moduli</code> the factors <code>xᵢ</code>.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; m=one(rand(Int,3,3))
3×3 Matrix{Int64}:
 1  0  0
 0  1  0
 0  0  1

julia&gt; n=[1 2 3;4 5 6]
2×3 Matrix{Int64}:
 1  2  3
 4  5  6

julia&gt; complementInt(m,n)
(complement = [0 0 1], sub = [1 2 3; 0 3 6], moduli = [1, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/MatInt.jl#L721-L750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.MatInt.solutionmatInt" href="#Gapjm.MatInt.solutionmatInt"><code>Gapjm.MatInt.solutionmatInt</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>solutionmatInt(mat::Matrix{&lt;:Integer}, v::Vector{&lt;:Integer})</code></p><p>returns  a  vector  <code>x</code>  with  integer  entries  that  is a solution of the equation <code>mat&#39;*x=vec</code>. It returns <code>false</code> if no such vector exists.</p><pre><code class="language-julia-repl hljs">julia&gt; mat=[1 2 7;4 5 6;7 8 9;10 11 19;5 7 12]
5×3 Matrix{Int64}:
  1   2   7
  4   5   6
  7   8   9
 10  11  19
  5   7  12

julia&gt; solutionmat(mat,[95,115,182])
5-element Vector{Rational{Int64}}:
  47//4
 -17//2
  67//4
   0//1
   0//1

julia&gt; solutionmatInt(mat,[95,115,182])
5-element Vector{Int64}:
  2285
 -5854
  4888
 -1299
     0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/MatInt.jl#L792-L823">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.MatInt.diaconis_graham" href="#Gapjm.MatInt.diaconis_graham"><code>Gapjm.MatInt.diaconis_graham</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>diaconis_graham(m::Matrix{&lt;:Integer}, moduli::Vector{&lt;:Integer})</code></p><p><a href="biblio.htm#dg99">Diaconis-Graham1999</a> defined a normal form for generating sets of abelian groups. Here <code>moduli</code> should be positive integers such that <code>moduli[i+1]</code>  divides <code>moduli[i]</code>  for all  <code>i</code>, representing  the abelian group <code>A=ℤ/moduli[1]×…×ℤ/moduli[n]</code>. The matrix <code>m</code> should have <code>n</code> columns where <code>n=Length(moduli)</code>, and each line (with the <code>i</code>-th element taken <code>mod moduli[i]</code>) represents an element of the group <code>A</code>; the set of lines of <code>m</code> should generate <code>A</code>.</p><p>The  function returns &#39;nothing&#39;  if the lines  of <code>m</code> do  not generate <code>A</code>. Otherwise it returns a named tuple <code>r</code> with fields</p><p><code>.normal</code>:  the Diaconis-Graham normal form, a  matrix of same shape as <code>m</code> where  either the first <code>n</code> lines are the identity matrix and the remaining lines  are <code>0</code>,  or <code>length(m)=n</code>  and <code>.normal</code>  differs from the identity matrix only in the entry <code>.normal[n,n]</code>, which is prime to <code>moduli[n]</code>.</p><p><code>.rowtrans</code>: unimodular matrix such that <code>r.normal==mod.(r.rowtrans*m,moduli&#39;)</code></p><p>Here is an example:</p><pre><code class="language-julia-repl hljs">julia&gt; r=diaconis_graham([3 0;4 1],[10,5])
(rowtrans = [-13 10; 4 -3], normal = [1 0; 0 2])

julia&gt; r.normal==mod.(r.rowtrans*[3 0;4 1],[10,5]&#39;)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/MatInt.jl#L935-L965">source</a></section></article><h1 id="Finite-fields"><a class="docs-heading-anchor" href="#Finite-fields">Finite fields</a><a id="Finite-fields-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-fields" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.FFields" href="#Gapjm.FFields"><code>Gapjm.FFields</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This module introduces modular arithmetic and finite fields.</p><p>The ring of integers mod. <code>n</code> is given by the type <code>Mod{n}</code>.</p><p>Example:</p><pre><code class="language-julia-repl hljs">julia&gt; Mod(5,19)
Mod{UInt64}: 5₁₉

julia&gt; a=Mod(5,19)
Mod{UInt64}: 5₁₉

julia&gt; a^2
Mod{UInt64}: 6₁₉

julia&gt; inv(a)
Mod{UInt64}: 4₁₉

julia&gt; a*inv(a)
Mod{UInt64}: 1₁₉

julia&gt; a+2
Mod{UInt64}: 7₁₉

julia&gt; a*2
Mod{UInt64}: -9₁₉

julia&gt; a+1//2
Mod{UInt64}: -4₁₉

julia&gt; Integer(a) # get back an integer from a
5

julia&gt; order(a) # multiplicative order of a
9</code></pre><p>The Galois field with <code>p^n</code> elements is obtained as <code>GF(p^n)</code>. To work with elements  of  this  field,  (as  in  GAP)  the  function <code>Z(p^n)</code> returns a generator  of  the  multiplicative  group  of  <code>GF(p^n)</code>. Other elements of <code>GF(p^n)</code> are obtained as a power of <code>Z(p^n)</code> or as <code>0*Z(p^n)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; a=Z(64)
FFE{2}: Z₆₄

julia&gt; a^9
FFE{2}: Z₈

julia&gt; a^21
FFE{2}: Z₄

julia&gt; a+1
FFE{2}: Z₆₄⁵⁶</code></pre><p>Elements  of the prime field can be converted back to integers <code>Mod(,p)</code> or to integers:</p><pre><code class="language-julia-repl hljs">julia&gt; a=Z(19)+3
FFE{19}: 5

julia&gt; Mod(a)
Mod{UInt64}: 5₁₉

julia&gt; Int(a)
5

julia&gt; order(a) # order as element of the multiplicative group
9</code></pre><p>The  field, <code>p</code>, <code>n</code> and <code>p^n</code> can be  obtained back as well as which power of <code>Z(p^n)</code> is considered</p><pre><code class="language-julia-repl hljs">julia&gt; a=Z(8)^5
FFE{2}: Z₈⁵

julia&gt; F=field(a)
GF(2^3)

julia&gt; char(F)
2

julia&gt; char(a)
2

julia&gt; degree(F)
3

julia&gt; degree(a)
3

julia&gt; length(F)
8

julia&gt; log(a)
5

julia&gt; elements(F)
8-element Vector{FFE{2}}:
   0
   1
  Z₈
 Z₈²
 Z₈³
 Z₈⁴
 Z₈⁵
 Z₈⁶</code></pre><p>The type of an element of <code>GF(p^n)</code> is <code>FFE{p}</code>. A <code>p</code>-integral number or a <code>Mod(,p)</code> can be converted to the prime field using this type as constructor.</p><pre><code class="language-julia-repl hljs">julia&gt; FFE{19}(2)
FFE{19}: 2

julia&gt; FFE{19}(Mod(2,19))
FFE{19}: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/FFields.jl#L1-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.FFields.FFE" href="#Gapjm.FFields.FFE"><code>Gapjm.FFields.FFE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>FFE{p}</code> is the type of the elements of a finite field of characteristic <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/FFields.jl#L317-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.FFields.FFE-Tuple{Integer}" href="#Gapjm.FFields.FFE-Tuple{Integer}"><code>Gapjm.FFields.FFE</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>FFE{p}(i)</code>  for <code>i</code> an integer or a fraction with denominator prime to <code>p</code> returns the reduction mod <code>p</code> of <code>i</code>, an element of the prime field <code>𝔽ₚ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/FFields.jl#L500-L503">source</a></section><section><div><p><code>FFE{p}(z::Cyc)</code>  where <code>z</code> is  a <code>p</code>-integral cyclotomic  number (that is, <code>z</code>  times some number prime  to <code>p</code> is a  cyclotomic integer), returns the reduction  of <code>z</code> mod.  <code>p</code>, an element  of some extension  <code>𝔽_{pʳ}</code> of the prime field <code>𝔽ₚ</code>.</p><pre><code class="language-julia_repl hljs">julia&gt; FFE{3}(E(7))
Z₇₂₉¹⁰⁴</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Tools.jl#L74-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.FFields.Z-Tuple{Any}" href="#Gapjm.FFields.Z-Tuple{Any}"><code>Gapjm.FFields.Z</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Z(p^d)</code> or <code>Z(p,d)</code></p><p>This  returns a generator  of the multiplicative  group of the finite field <code>𝔽_{pᵈ}</code>,  where   <code>p</code>  must be  prime and  <code>p^d</code> smaller  than <code>2¹⁵</code>. This multiplicative  group is  cyclic thus  <code>Z(p^d)^a</code> runs  over it  for <code>a</code> in <code>0:p^d-1</code>.  The zero of the  field is <code>0*Z(p)</code> (the  same as <code>0*Z(p^d)</code>; we automatically lower an element to the smallest field which contains it).</p><p>The  various generators returned by <code>Z</code> for finite fields of characteristic <code>p</code>  are compatible. That  is, if the  field <code>𝔽_{pⁿ}</code> is  a subfield of the field <code>𝔽_{pᵐ}</code>, that is, <code>n</code> divides <code>m</code>, then <code>Z(p^n)=Z(p^m)^div(p^m-1,p^n-1)</code>.  This is  achieved by  choosing <code>Z(p)</code> as the smallest primitive root modulo <code>p</code> and <code>Z(p^n)</code> as a root of the <code>n</code>-th Conway polynomial of characteristic <code>p</code>. Those polynomials where defined by J.H.~Conway and computed by R.A.~Parker.</p><pre><code class="language-julia-repl hljs">julia&gt; z=Z(16)
FFE{2}: Z₁₆

julia&gt; z^5
FFE{2}: Z₄</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/FFields.jl#L403-L427">source</a></section></article><h1 id="Presentations"><a class="docs-heading-anchor" href="#Presentations">Presentations</a><a id="Presentations-1"></a><a class="docs-heading-anchor-permalink" href="#Presentations" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Presentations" href="#Gapjm.Presentations"><code>Gapjm.Presentations</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This is a port of some GAP3/VkCurve functionality on presentations and finitely presented groups.</p><p><em>finitely  presented groups</em>  are distinguished  from <em>group presentations</em> which  are objects of their own. The  reason is that when a presentation is changed  (e.g. simplified)  by Tietze  transformations, new  generators and relators are introduced; thus all words in a finitely presented group would also have to be changed if such a Tietze transformation were applied to the group. Therefore, it is better to work separately with the presentation and reflect only carefully the changes on the group.</p><p>In order to speed up the algorithms, the relators in a presentation are not represented  by <code>AbsWord</code>s, but by lists  of positive or negative generator numbers which we call <em>Tietze words</em>.</p><p>We  now  describe  the  available  functions;  for more information look at individual  docstrings. The functions <code>Presentation</code> and <code>FpGroup</code> create a presentation from a finitely presented group or, vice versa.</p><p>Since  it could be large, by default a presentation is printed as a summary of  the number of generators, the number  of relators, and the total length of  all  relators.  We  illustrate  below  functions  displaying  more of a presentation.</p><pre><code class="language-julia-repl hljs">julia&gt; @AbsWord a,b

julia&gt; F=FpGroup([a,b])
FreeGroup(a,b)

julia&gt; G=F/[a^2,b^7,comm(a,a^b),comm(a,a^(b^2))*inv(b^a)]
FreeGroup(a,b)/[a²,b⁷,a⁻¹b⁻¹a⁻¹bab⁻¹ab,a⁻¹b⁻²a⁻¹b²ab⁻²ab²a⁻¹b⁻¹a]

julia&gt; P=Presentation(G)
Presentation: 2 generators, 4 relators, total length 30

julia&gt; relators(P)
4-element Vector{AbsWord}:
 a²
 b⁷
 ab⁻¹abab⁻¹ab
 b⁻²ab²ab⁻²ab²ab⁻¹</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; Presentations.PrintGenerators(P)
#I 1. a 10 occurrences involution
#I 2. b 20 occurrences

julia&gt; Presentations.display_balanced(P)
1: a=A
2: bbbbbbb=1
3: aBab=BAbA
4: BBabbaBBabbaB=1</code></pre><p>for more information look at the help strings of  AbsWord, Presentation, FpGroup, Go, GoGo, conjugate,         tryconjugate, simplify, relators, display_balanced</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Presentations.jl#L1-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Presentations.AbsWord" href="#Gapjm.Presentations.AbsWord"><code>Gapjm.Presentations.AbsWord</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An  <code>AbsWord</code> is an abstract word in  some generators, that is a product of some  of  these  generators  raised  to  positive  or  negative powers. The generators are indexed by <code>Symbols</code> in the julia implementation (as a <code>Vector{Pair{Symbol,Int}}</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Presentations.jl#L127-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Presentations.@AbsWord" href="#Gapjm.Presentations.@AbsWord"><code>Gapjm.Presentations.@AbsWord</code></a> — <span class="docstring-category">Macro</span></header><section><div><p><code>@AbsWord x,y,z</code> defines the variables <code>x,y,z</code> to be <code>AbsWord</code>s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Presentations.jl#L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Presentations.FpGroup" href="#Gapjm.Presentations.FpGroup"><code>Gapjm.Presentations.FpGroup</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>FpGroup(P::Presentation)</code></p><p>returns the finitely presented group defined  by the presentation <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Presentations.jl#L579-L583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Presentations.Presentation-Tuple{FpGroup}" href="#Gapjm.Presentations.Presentation-Tuple{FpGroup}"><code>Gapjm.Presentations.Presentation</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Presentation( G::FpGroup[, printlevel])</code></p><p><code>Presentation</code> returns a presentation containing a copy of the presentation of the given finitely presented group <code>G</code> on the same set of generators.</p><p>The  optional <code>printlevel</code> parameter  can be used  to restrict or to extend the  amount of output provided by Tietze transformation functions when being applied  to the created  presentation. The default  value 1 is designed for interactive  use and implies  explicit messages to  be displayed by most of these  functions. A  <code>printlevel</code> value  of 0  will suppress these messages, whereas a <code>printlevel</code> value of 2 will enforce some additional output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Presentations.jl#L645-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Presentations.relators" href="#Gapjm.Presentations.relators"><code>Gapjm.Presentations.relators</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>relators(P::Presentation)</code></p><p>prints the list of relators of <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Presentations.jl#L2308-L2312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Presentations.simplify" href="#Gapjm.Presentations.simplify"><code>Gapjm.Presentations.simplify</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>simplify(G)</code></p><p><code>simplify</code>  applies  Tietze  transformations  to a  copy of  the presentation of the given finitely presented group <code>G</code> in order to reduce it with respect to  the number of generators, the number of relators, and the relator lengths.</p><p><code>simplify</code> returns the resulting finitely presented group (which is isomorphic to <code>G</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; @AbsWord a,b,c,d,e,f

julia&gt; F=FpGroup([a,b,c,d,e,f])
FreeGroup(a,b,c,d,e,f)

julia&gt; G=F/[a^2,b^2,d*f^-1,e^2,f^2,a*b^-1*c,a*e*c^-1,b*d^-1*c,c*d*e^-1,a*f*c^-2,c^4]
FreeGroup(a,b,c,d,e,f)/[a²,b²,df⁻¹,e²,f²,ab⁻¹c,aec⁻¹,bd⁻¹c,cde⁻¹,afc⁻²,c⁴]

julia&gt; simplify(G)
FreeGroup(a,c)/[a²,ac⁻¹ac⁻¹,c⁴]</code></pre><p>In fact, the call</p><pre><code class="language-julia-rep1 hljs">julia&gt; simplify(G)</code></pre><p>is an abbreviation of the call sequence</p><pre><code class="language-julia-rep1 hljs">julia&gt; P=Presentation(G,0);simplify(P);FpGroup(P)</code></pre><p>which applies  a rather simple-minded strategy of  Tietze transformations to the intermediate presentation <code>P</code>. If for  some  concrete group the resulting presentation  is unsatisfying, then  you  should  try  a  more  sophisticated,  interactive  use of  the available Tietze transformation functions  (see &quot;Tietze Transformations&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Presentations.jl#L1111-L1152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Presentations.conjugate" href="#Gapjm.Presentations.conjugate"><code>Gapjm.Presentations.conjugate</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>conjugate(p,conjugation)</code></p><p>This program modifies a presentation by conjugating a generator by another. The  conjugation to  apply is  described by  a length-3  string of the same style  as  the  result  of  <code>display_balanced</code>,  that is <code>&quot;abA&quot;</code> means replace  the second generator by its  conjugate by the first, and  <code>&quot;Aba&quot;</code> means replace it by its conjugate by the inverse of the first.</p><pre><code class="language-julia-rep1 hljs">julia&gt; Presentations.display_balanced(P)
1: dabcd=abcda
2: dabcdb=cabcda
3: bcdabcd=dabcdbc

julia&gt; Presentations.display_balanced(conjugate(P,&quot;Cdc&quot;))
&lt;&lt; presentation with 4 generators, 3 relators of total length 36&gt;&gt;
1: dcabdc=cabdca
2: abdcab=cabdca
3: bdcabd=cabdca</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Presentations.jl#L3315-L3336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Presentations.tryconjugate" href="#Gapjm.Presentations.tryconjugate"><code>Gapjm.Presentations.tryconjugate</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>tryconjugate(p[,goal[,printlevel]])</code></p><p>This program tries to simplify group presentations by applying conjugations to  the  generators.  The  algorithm  depends  on  random  numbers,  and on tree-searching,  so is  not reproducible.  By default  the program stops as soon  as a shorter presentation is found.  Sometimes this does not give the desired  presentation.  One  can  give  a  second argument <code>goal</code>, then the program  will only stop when  a presentation of length  less than <code>goal</code> is found.  Finally, a third  argument can be  given and then all presentations the  programs runs  over which  are of  length less  than or  equal to this argument are displayed. Due to the non-deterministic nature of the program, it  may be useful to  run it several times  on the same input. Upon failure (to improve the presentation), the program returns <code>p</code>.</p><pre><code class="language-julia-rep1 hljs">julia&gt; display_balanced(p)
1: ba=ab
2: dbd=bdb
3: cac=aca
4: bcb=cbc
5: dAca=Acad
6: dcdc=cdcd
7: adad=dada
8: dcDbdc=bdcbdB
9: dcdadc=adcdad
10: adcDad=dcDadc
11: BcccbdcAb=dcbACdddc
julia&gt; p=tryconjugate(p)
Presentation: 4 generators, 11 relators, total length 100
dcD=&gt; Presentation: 4 generators, 10 relators, total length 90
# dcD gives Presentation: 4 generators, 10 relators, total length 90
Presentation: 4 generators, 10 relators, total length 90

julia&gt; p=tryconjugate(p)
Dcd=&gt; Presentation: 4 generators, 10 relators, total length 88
# Dcd gives Presentation: 4 generators, 10 relators, total length 88
Presentation: 4 generators, 10 relators, total length 88

julia&gt; p=tryconjugate(p)
dcD=&gt; Presentation: 4 generators, 10 relators, total length 90
Dbd=&gt; Presentation: 4 generators, 10 relators, total length 96
Aca=&gt; Presentation: 4 generators, 9 relators, total length 84
Presentation: 4 generators, 8 relators, total length 76
# Aca gives Presentation: 4 generators, 8 relators, total length 76
Presentation: 4 generators, 8 relators, total length 76

julia&gt; p=tryconjugate(p)
Bcb=&gt; Presentation: 4 generators, 8 relators, total length 70
# Bcb gives Presentation: 4 generators, 8 relators, total length 70
Presentation: 4 generators, 8 relators, total length 70

julia&gt; p=tryconjugate(p)
Cac=&gt; Presentation: 4 generators, 8 relators, total length 64
# Cac gives Presentation: 4 generators, 8 relators, total length 64
Presentation: 4 generators, 8 relators, total length 64

julia&gt; p=tryconjugate(p)
caC=&gt; Presentation: 4 generators, 8 relators, total length 58
# caC gives Presentation: 4 generators, 8 relators, total length 58
Presentation: 4 generators, 8 relators, total length 58

julia&gt; p=tryconjugate(p)
Cac=&gt; Presentation: 4 generators, 8 relators, total length 64
Cbc=&gt; Presentation: 4 generators, 7 relators, total length 50
# Cbc gives Presentation: 4 generators, 7 relators, total length 50
Presentation: 4 generators, 7 relators, total length 50

julia&gt; p=tryconjugate(p)
cdC=&gt; Presentation: 4 generators, 7 relators, total length 56
Dcd=&gt; Presentation: 4 generators, 7 relators, total length 54
Cac=&gt; Presentation: 4 generators, 7 relators, total length 48
# Cac gives Presentation: 4 generators, 7 relators, total length 48
Presentation: 4 generators, 7 relators, total length 48

julia&gt; p=tryconjugate(p)
caC=&gt; Presentation: 4 generators, 7 relators, total length 50
Cdc=&gt; Presentation: 4 generators, 7 relators, total length 50
Dbd=&gt; Dcd=&gt; Presentation: 4 generators, 7 relators, total length 60
Bab=&gt; Aba=&gt; Aca=&gt; Presentation: 4 generators, 7 relators, total length 46
# Aca gives Presentation: 4 generators, 7 relators, total length 46
Presentation: 4 generators, 7 relators, total length 46

julia&gt; display_balanced(p)
1: db=bd
2: ba=ab
3: cac=aca
4: ada=dad
5: bcb=cbc
6: cdcd=dcdc
7: AdCacd=cAdCac</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Presentations.jl#L3348-L3440">source</a></section></article><h1 id="Coxeter-groups"><a class="docs-heading-anchor" href="#Coxeter-groups">Coxeter groups</a><a id="Coxeter-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Coxeter-groups" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups" href="#Gapjm.CoxGroups"><code>Gapjm.CoxGroups</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A  suitable  reference  for  the  general  theory of Coxeter groups is, for example, Bourbaki &quot;Lie Groups and Lie Algebras&quot; chapter 4.</p><p>A <em>Coxeter group</em> is a group which has the presentation <span>$W=⟨S|(st)^{m(s,t)}=1 for s,t∈  S⟩$</span>  for some symmetric integer matrix <code>m(s,t)</code> called the <em>Coxeter matrix</em>, where <code>m(s,t)&gt;1</code> for <code>s≠t</code> and <code>m(s,s)=1</code>.  It is true (but a non-trivial theorem) that in a Coxeter group the  order of <code>st</code> is exactly <code>m(s,t)</code>, thus a Coxeter group is the same as a  <em>Coxeter system</em>, that is a pair <code>(W,S)</code>  of a group <code>W</code> and a set <code>S⊂W</code> of  involutions, such  that the  group is  presented by  generators <code>S</code> and relations  describing the order  of the product  of two elements  of <code>S</code>. A Coxeter group has a natural representation, its <em>reflection representation</em>, on a real vector space <code>V</code> of dimension <code>length(S)</code> (which is  the  <em>Coxeter  rank</em>  of  W),  where  each  element  of  <code>S</code>  acts as a reflection; the faithfulness of this representation in the main argument to prove  that the order of <code>st</code> is  exactly <code>m(s,t)</code>. Thus Coxeter groups are real  reflection  groups.  The  converse  need  not  be  true if the set of reflecting  hyperplanes has  bad topological  properties, but  it turns out that  finite Coxeter groups are the  same as finite real reflection groups. The   possible  Coxeter  matrices  for  finite  Coxeter  groups  have  been completely  classified,  see  the  <code>Weyl</code>  module; the corresponding finite groups play a deep role in several areas of mathematics.</p><p>Coxeter  groups  have  a  nice  solution  to the word problem. The <em>length</em> <code>l(w)</code>  of an element  <code>w∈ W</code> is  the minimum number  of elements of <code>S</code> of which it is a product (since the elements of <code>S</code> are involutions, we do not need inverses). An expression of <code>w</code> of minimal length is called a <em>reduced word</em>  for <code>w</code>. The main property of  reduced words is the <em>exchange lemma</em> which  states that if <code>s₁…sₖ</code> is a  reduced word for <code>w</code> (thus<code>k=l(w)</code>) and <code>s∈  S</code> is such that <code>l(sw)≤l(w)</code> then one  of the <code>sᵢ</code> in the word for <code>w</code> can be deleted to obtain a reduced word for <code>sw</code>. Thus given <code>s∈ S</code> and <code>w∈ W</code>,  either <code>l(sw)=l(w)+1</code> or  <code>l(sw)=l(w)-1</code> and we  say in this last case that  <code>s</code> belongs to  the <em>left descent  set</em> of <code>w</code>.  The computation of a reduced  word for an element, and other  word problems, are easy if we know how  to multiply elements  and the left  descent sets. In  each case of the Coxeter  groups that we implement, the left  descent set is easy to compute (see  e.g.  &#39;CoxSym&#39;  below),  so  this  suggests  how to deal with Coxeter groups generically:</p><p>The  type  <code>CoxeterGroup</code>  is  an  abstract  type;  an  actual struct which implements it must define a function</p><p><code>isleftdescent(W,w,i)</code> which tells whether the       <code>i</code>-th element of <code>S</code> is in the left descending set of <code>w</code>.</p><p>the other functions needed in an instance of a Coxeter group are</p><ul><li><code>gens(W)</code> which returns the set <code>S</code> (the list of <em>Coxeter generators</em>)</li><li><code>nref(W)</code> which  returns the  number of  reflections of  <code>W</code>, if  <code>W</code> is  finite or <code>nothing</code> if <code>W</code> is infinite</li></ul><p>It  should  be  noted  that  a  Coxeter  group  can  be <em>any</em> kind of group implementing the above functions.</p><p>Because  of the  easy solution  of the  word problem  in Coxeter  groups, a convenient  way  to  represent  their  elements  is as words in the Coxeter generators. They are represented as lists of integers in <code>1:length(S)</code>. The functions  &#39;word&#39; and &#39;W(...)&#39; will do the conversion between Coxeter words and elements of the group.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; W=CoxSym(4)
𝔖 ₄

julia&gt; p=W(1,3,2,1,3)
Perm{UInt8}: (1,4)

julia&gt; word(W,p)
5-element Vector{Int64}:
 1
 2
 3
 2
 1</code></pre><p>We  notice that the word we started with and the one that we ended up with, are not the same, though they represent the same element of <code>W</code>. The reason is  there are  several reduced  words for  an element  of <code>W</code>. The function &#39;word&#39;  computes a lexicographically smallest word  for <code>w</code>. Below are some other possible computations with the same Coxeter group:</p><pre><code class="language-julia-repl hljs">julia&gt; word(W,longest(W))  # the (unique) longest element in W
6-element Vector{Int64}:
 1
 2
 1
 3
 2
 1

julia&gt; w0=longest(W)
Perm{UInt8}: (1,4)(2,3)
julia&gt; length(W,w0)
6
julia&gt; map(i-&gt;word(W,reflection(W,i)),1:nref(W))
6-element Vector{Vector{Int64}}:
 [1]
 [2]
 [3]
 [1, 2, 1]
 [2, 3, 2]
 [1, 2, 3, 2, 1]
julia&gt; [length(elements(W,i)) for i in 0:nref(W)]
7-element Vector{Int64}:
 1
 3
 5
 6
 5
 3
 1</code></pre><p>The above line tells us that there is 1 element of length 0, there are 6 of length 3, …</p><p>For  most basic functions the convention is that the input is an element of the  group, rather than  a Coxeter word.  The reason is  that for a Coxeter group  which  is  a  permutation  group,  using the low level functions for permutations  is usually  much faster  than manipulating lists representing reduced expressions.</p><p>This module contains mostly a port of the basic functions on Coxeter groups in  Chevie. The only Coxeter group  constructor implemented here is CoxSym. The  module <code>Weyl</code> defines <code>coxgroup</code>, a function building a finite Coxeter groups given its type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L1-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.isleftdescent" href="#Gapjm.CoxGroups.isleftdescent"><code>Gapjm.CoxGroups.isleftdescent</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>isleftdescent(W,w,i)</code></p><p>returns  <code>true</code>  if  and  only  if  the <code>i</code>-th generating reflection of the Coxeter  group <code>W</code> is  in the left  descent set of  the element <code>w</code> of <code>W</code>, that is iff <code>length(W,W(i)*w)&lt;length(W,w)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=CoxSym(3)
𝔖 ₃

julia&gt; isleftdescent(W,Perm(1,2),1)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L875-L889">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.firstleftdescent" href="#Gapjm.CoxGroups.firstleftdescent"><code>Gapjm.CoxGroups.firstleftdescent</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>firstleftdescent(W,w)</code></p><p>returns the index in <code>gens(W)</code> of the first element of the left descent set of <code>w</code> –- that is, the first <code>i</code> such that if <code>s=W(i)</code> then `l(sw)&lt;l(w).</p><pre><code class="language-julia-repl hljs">julia&gt; W=CoxSym(3)
𝔖 ₃

julia&gt; firstleftdescent(W,Perm(2,3))
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L142-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.leftdescents" href="#Gapjm.CoxGroups.leftdescents"><code>Gapjm.CoxGroups.leftdescents</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>leftdescents(W,w)</code></p><p>The  left descents of the element <code>w</code> of the Coxeter group <code>W</code>, that is the set of <code>i</code> such that <code>length(W,W(i)*w)&lt;length(W,w)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=CoxSym(3)
𝔖 ₃

julia&gt; leftdescents(W,Perm(1,3))
2-element Vector{Int64}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L160-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups.reduced" href="#Gapjm.PermGroups.reduced"><code>Gapjm.PermGroups.reduced</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reduced(W,w)</code></p><p>The unique element of minimal length in the coset W.w</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; H=reflection_subgroup(W,[2,6])
G₂₍₂₆₎=Ã₁×A₁

julia&gt; word.(Ref(W),unique(reduced.(Ref(H),elements(W))))
3-element Vector{Vector{Int64}}:
 []
 [1]
 [1, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L281-L298">source</a></section><section><div><p><code>reduced(H,W,i=nref(W))</code></p><p>The  elements <code>w∈ W</code> which are <code>H</code>-reduced  (of minimal length in the coset <code>Hw</code>), and of length <code>≤i</code> (by default all of them), grouped by length.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; H=reflection_subgroup(W,[2,6])
G₂₍₂₆₎=Ã₁×A₁

julia&gt; [word(W,w) for S in reduced(H,W) for w in S]
3-element Vector{Vector{Int64}}:
 []
 [1]
 [1, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L307-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.word-Tuple{CoxeterGroup, Any}" href="#Gapjm.Groups.word-Tuple{CoxeterGroup, Any}"><code>Gapjm.Groups.word</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>word(W::CoxeterGroup,w)</code></p><p>returns  a reduced word in the standard generators of the Coxeter group <code>W</code> for  the  element  <code>w</code>  (represented  as  the  vector  of the corresponding generator indices).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; w=perm&quot;(1,11)(3,10)(4,9)(5,7)(6,12)&quot;
(1,11)(3,10)(4,9)(5,7)(6,12)

julia&gt; w in W
true

julia&gt; word(W,w)
5-element Vector{Int64}:
 1
 2
 3
 2
 1</code></pre><p>The  result  of   <code>word</code>  is  the  lexicographically  smallest reduced word for~<code>w</code> (for the ordering of the Coxeter generators given by <code>gens(W)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L182-L209">source</a></section><section><div><p>word(G::Group,w): a minimal word in  gens(G) representing element w of G</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{CoxeterGroup, Any}" href="#Base.length-Tuple{CoxeterGroup, Any}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>length(W::CoxeterGroup ,w)</code></p><p>returns the length of a reduced expression in the Coxeter generators of the element <code>w</code> of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=CoxSym(4)
𝔖 ₄

julia&gt; p=W(1,2,3,1,2,3)
Perm{UInt8}: (1,3)(2,4)

julia&gt; length(W,p)
4

julia&gt; word(W,p)
4-element Vector{Int64}:
 2
 1
 3
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L220-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.elements-Tuple{CoxeterGroup}" href="#Gapjm.Groups.elements-Tuple{CoxeterGroup}"><code>Gapjm.Groups.elements</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>elements(W::CoxeterGroup[,l])</code></p><p>With  one argument this works only if  <code>W</code> is finite; the returned elements are  sorted  by  increasing  Coxeter  length.  If the second argument is an integer  <code>l</code>, the elements  of Coxeter length  <code>l</code> are returned.</p><pre><code class="language-julia_repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; e=elements(W,6)
1-element Vector{Perm{Int16}}:
 (1,7)(2,8)(3,9)(4,10)(5,11)(6,12)

julia&gt; e[1]==longest(W)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L354-L372">source</a></section><section><div><p>elements(G::Group): the list of elements of G</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.words" href="#Gapjm.Groups.words"><code>Gapjm.Groups.words</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>words(W::CoxeterGroup[,l])</code></p><p>With  one argument this works only if <code>W</code> is finite; it returns the reduced Coxeter  words  of  elements  of  <code>W</code>  by  increasing length. If the second argument  is an integer <code>l</code>, only the  elements of length <code>l</code> are returned; this works for infinite Coxeter groups.</p><pre><code class="language-julia_repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; e=elements(W,6)
1-element Vector{Perm{Int16}}:
 (1,7)(2,8)(3,9)(4,10)(5,11)(6,12)

julia&gt; e[1]==longest(W)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L427-L446">source</a></section><section><div><p><code>words(W,w)</code></p><p>returns  the list  of all  reduced expressions  of the  element <code>w</code>  of the Coxeter group <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; words(W,longest(W))
16-element Vector{Vector{Int64}}:
 [1, 2, 1, 3, 2, 1]
 [1, 2, 3, 1, 2, 1]
 [1, 2, 3, 2, 1, 2]
 [1, 3, 2, 1, 3, 2]
 [1, 3, 2, 3, 1, 2]
 [2, 1, 2, 3, 2, 1]
 [2, 1, 3, 2, 1, 3]
 [2, 1, 3, 2, 3, 1]
 [2, 3, 1, 2, 1, 3]
 [2, 3, 1, 2, 3, 1]
 [2, 3, 2, 1, 2, 3]
 [3, 1, 2, 1, 3, 2]
 [3, 1, 2, 3, 1, 2]
 [3, 2, 1, 2, 3, 2]
 [3, 2, 1, 3, 2, 3]
 [3, 2, 3, 1, 2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L603-L632">source</a></section><section><div><p><code>words(G::Group)</code></p><p>returns  a <code>Dict</code>  giving for  each element  of <code>G</code>  a positive word in the generators representing it. It is faster than <code>minimal_words</code> but the words are not guaranteed minimal.</p><pre><code class="language-julia-repl hljs">julia&gt; G=Group([Perm(1,2),Perm(1,2,3)]);
julia&gt; words(G)
Dict{Perm{Int16}, Vector{Int64}} with 6 entries:
  ()      =&gt; []
  (1,2)   =&gt; [1]
  (1,3)   =&gt; [1, 2]
  (1,2,3) =&gt; [2]
  (2,3)   =&gt; [2, 1]
  (1,3,2) =&gt; [1, 2, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L308-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.bruhatless" href="#Gapjm.CoxGroups.bruhatless"><code>Gapjm.CoxGroups.bruhatless</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>bruhatless(W, x, y)</code></p><p>whether <code>x≤y</code> in the Bruhat order, for <code>x,y∈ W</code>. We have <code>x≤y</code> if a reduced expression  for <code>x</code>  can be  extracted from  one for  <code>w</code>). See  <a href="biblio.htm#Hum90">(5.9) and (5.10) Humphreys1990</a> for properties of the Bruhat order.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:H,3)
H₃

julia&gt; w=W(1,2,1,3);

julia&gt; b=filter(x-&gt;bruhatless(W,x,w),elements(W));

julia&gt; word.(Ref(W),b)
12-element Vector{Vector{Int64}}:
 []
 [3]
 [2]
 [1]
 [2, 3]
 [1, 3]
 [2, 1]
 [1, 2]
 [2, 1, 3]
 [1, 2, 3]
 [1, 2, 1]
 [1, 2, 1, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L451-L481">source</a></section><section><div><p><code>bruhatless(W, y)</code></p><p>returns  a vector  whose <code>i</code>-th  element is  the vector  of elements of <code>W</code> smaller for the Bruhat order than <code>w</code> and of Coxeter length <code>i-1</code>. Thus the first  element  of  the  returned  list  contains  only  <code>one(W)</code>  and  the <code>length(W,w)</code>-th element contains only <code>w</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=CoxSym(3)
𝔖 ₃

julia&gt; bruhatless(W,Perm(1,3))
4-element Vector{Vector{Perm{Int16}}}:
 [()]
 [(1,2), (2,3)]
 [(1,2,3), (1,3,2)]
 [(1,3)]</code></pre><p>see also the method <code>Poset</code> for Coxeter groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L498-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.CoxSym" href="#Gapjm.CoxGroups.CoxSym"><code>Gapjm.CoxGroups.CoxSym</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Coxsym(n)</code> The symmetric group on <code>n</code> letters as a Coxeter group</p><pre><code class="language-julia-repl hljs">julia&gt; W=CoxSym(3)
𝔖 ₃

julia&gt; e=elements(W)
6-element Vector{Perm{UInt8}}:
 ()     
 (2,3)  
 (1,2)  
 (1,2,3)
 (1,3,2)
 (1,3)  

julia&gt; length.(Ref(W),e)
6-element Vector{Int64}:
 0
 1
 1
 2
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L819-L843">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection_subgroup-Tuple{CoxSym, AbstractVector{Int64}}" href="#Gapjm.PermRoot.reflection_subgroup-Tuple{CoxSym, AbstractVector{Int64}}"><code>Gapjm.PermRoot.reflection_subgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflection_subgroup(W::CoxSym,I)</code></p><p>The only parabolics defined for <code>CoxSym(n)</code> are for <code>I=1:m</code> for <code>m≤n</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L907-L911">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.longest" href="#Gapjm.CoxGroups.longest"><code>Gapjm.CoxGroups.longest</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>longest(W)</code></p><p>If  <code>W</code> is  finite, returns  the unique  element of  maximal length  of the Coxeter group <code>W</code>. May loop infinitely otherwise.</p><pre><code class="language-julia-repl hljs">julia&gt; longest(CoxSym(4))
Perm{UInt8}: (1,4)(2,3)</code></pre><p><code>longest(W,I)</code></p><p>returns  the longest element of the  parabolic subgroup of <code>W</code> generated by the generating reflections of indices in <code>I</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; longest(CoxSym(4))
Perm{UInt8}: (1,4)(2,3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L248-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.coxmat" href="#Gapjm.CoxGroups.coxmat"><code>Gapjm.CoxGroups.coxmat</code></a> — <span class="docstring-category">Function</span></header><section><div><p>coxmat(m::AbstractMatrix)</p><p>returns  the  Coxeter  matrix  of  the  Coxeter group defined by the cartan matrix <code>m</code></p><pre><code class="language-julia-repl hljs">julia&gt; C=cartan(:H,3)
3×3 Matrix{Cyc{Int64}}:
       2  ζ₅²+ζ₅³   0
 ζ₅²+ζ₅³        2  -1
       0       -1   2

julia&gt; coxmat(C)
3×3 Matrix{Int64}:
 1  5  2
 5  1  3
 2  3  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L703-L722">source</a></section><section><div><p><code>coxmat(W)</code></p><p>returns the Coxeter matrix of the Coxeter group <code>W</code>, that is the matrix <code>m</code> whose  entry <code>m[i,j]</code> contains the order of <code>W(i)*W(j)</code> where <code>W(i)</code> is the <code>i</code>-th  Coxeter generator of  <code>W</code>. An infinite  order is represented by the entry <code>0</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=CoxSym(4)
𝔖 ₄

julia&gt; coxmat(W)
3×3 Matrix{Int64}:
 1  3  2
 3  1  3
 2  3  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L739-L757">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.standard_parabolic_class" href="#Gapjm.CoxGroups.standard_parabolic_class"><code>Gapjm.CoxGroups.standard_parabolic_class</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>standard_parabolic_class(W,I)</code></p><p><code>I</code>  should be a  subset of <code>eachindex(gens(W))</code>.  The function returns the list of such subsets conjugate to the given subset.</p><pre><code class="language-julia-repl hljs">julia&gt; CoxGroups.standard_parabolic_class(coxgroup(:E,8),[7,8])
7-element Vector{Vector{Int64}}:
 [7, 8]
 [6, 7]
 [5, 6]
 [4, 5]
 [2, 4]
 [3, 4]
 [1, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L671-L688">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.GenCox" href="#Gapjm.CoxGroups.GenCox"><code>Gapjm.CoxGroups.GenCox</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>GenCox(m)</code></p><p><code>m</code>  should be a square  matrix of real cyclotomic  numbers. It returns the Coxeter  group  whose  Cartan  matrix  is  <code>m</code>.  This  is  a  matrix  group constructed  as  follows.  Let  <code>V</code>  be  a  real  vector space of dimension <code>size(m,1)</code>,  and  let  <code>⟨,⟩</code>  be  the  bilinear  form defined by <code>⟨eᵢ,eⱼ⟩= m[i,j]</code>  where <code>eᵢ</code> is the  canonical basis of <code>V</code>.  Then the result is the matrix group generated by the reflections <code>sᵢ(x)=x-2⟨x,eᵢ⟩eᵢ</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=GenCox([2 -2;-2 2])
GenCox([2 -2; -2 2])</code></pre><p>Above is a way to construct the affine Weyl group  <code>̃A₁</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L929-L945">source</a></section></article><h1 id="Finite-Coxeter-groups-and-Weyl-groups"><a class="docs-heading-anchor" href="#Finite-Coxeter-groups-and-Weyl-groups">Finite Coxeter groups and Weyl groups</a><a id="Finite-Coxeter-groups-and-Weyl-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Coxeter-groups-and-Weyl-groups" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl" href="#Gapjm.Weyl"><code>Gapjm.Weyl</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Finite Coxeter groups are the finite complex reflection groups which can be defined on a real vector space <code>V</code>.</p><p><em>Weyl  groups</em> are the finite complex which  can be defined over a rational vector space <code>V</code>.</p><p>These  groups  being  complex  reflection  groups,  all methods defined for complex  reflection  groups  are  defined  on  them. They are in particular implemented as groups of permutations of a root system. The particular root systems  for  Weyl  groups  play  an  important role in mathematics as they classify semi-simple Lie algebras and algebraic groups.</p><p>Let  us give precise definitions.  Let <code>V</code> be a  real vector space and <code>V*</code> its  dual. A <em>root system</em> is a finite set of vectors <code>R⊂ V</code> (the <em>roots</em>), together  with  a  map  <code>r↦  rⱽ</code>  from  <code>R</code>  to  a subset <code>Rⱽ</code> of <code>V*</code> (the <em>coroots</em>) such that:</p><ul><li>For any <code>r∈ R</code>,  we have <code>rⱽ(r)=2</code>, so  that the formula <code>x↦ x-rⱽ(x)r</code> defines  a  reflection  <code>sᵣ:V→  V</code>  with  root  <code>r</code>  and coroot <code>rⱽ</code>. </li><li>The reflection <code>sᵣ</code> stabilizes <code>R</code>.</li></ul><p>For  Coxeter groups, we use  <em>reduced</em> root systems, that  is such that the only  elements  of  <code>R</code>  colinear  with  <code>r∈  R</code> are <code>r</code> and <code>-r</code>; for Weyl groups,  we also  ask that  the root  system be <em>crystallographic</em>, that is <code>rⱽ(s)</code>  is an  integer, for  any <code>s∈  R,rⱽ∈ Rⱽ</code>  (in particular the Cartan matrix has integral entries).</p><p>The  subgroup <code>W=W(R)</code>  of <code>GL(V)</code>  generated by  the reflections <code>sᵣ</code> is a finite Coxeter group. All finite-dimensional (complex) representations of a finite  reflection group can be  realized over the same  field as <code>V</code> (thus are rational for the crystallographic root systems).</p><p>If  we identify  <code>V</code> with  <code>Vⱽ</code> by  choosing a  <code>W</code>-invariant bilinear form <code>(.;.)</code>,  then we have <code>rⱽ=2r/(r;r)</code>. A root system <code>R</code> is <em>irreducible</em> if it   is  not  the  union  of   two  orthogonal  subsets  (equivalently  the representation   of  <code>W</code>  on  the  subspace   generated  by  the  roots  is irreducible).  If <code>R</code> is reducible then  the corresponding Coxeter group is the  direct product of  the Coxeter groups  associated with the irreducible components of <code>R</code>.</p><p>Let  us now  describe how  the root  system and  a presentation  of <code>W</code> are encoded  in the Dynkin diagrams.  Let <code>R</code> be a  root system in <code>V</code>. Then we can  choose  a  linear  form  on  <code>V</code>  which vanishes on no element of <code>R</code>. According to the sign of the value of this linear form on a root <code>r ∈ R</code> we call <code>r</code> <em>positive</em> or <em>negative</em>. Then there exists a unique subset <code>Π</code> of the  positive roots, the <em>simple  roots</em>, such that any  positive root is a linear  combination with non-negative coefficients of roots in <code>Π</code>. Any two sets of simple roots (corresponding to different choices of linear forms as above)  can be transformed into  each other by a  unique element of <code>W(R)</code>. Hence, since the pairing between <code>V</code> and <code>Vⱽ</code> is <code>W</code>-invariant, if <code>Π</code> is a set  of simple roots and if we define  the <em>Cartan matrix</em> as being the <code>n</code> times  <code>n</code> matrix  <code>C={rⱽ(s)}ᵣₛ</code>, for  <code>r,s∈Π</code> this  matrix is unique up to simultaneous  permutation of rows and columns.  It is precisely this matrix which is encoded in a <em>Dynkin diagram</em>, as follows.</p><p>The vertices represent the simple roots (giving generating reflections); an edge  is drawn between  <code>s</code> and <code>t</code>  if the order  <code>mₛₜ</code> of <code>st</code> is greater than  <code>2</code>; the  edge is  single if  <code>mₛₜ=3</code>, double  if <code>mₛₜ=4</code>,  triple if <code>mₛₜ=6</code>.  The arrows  indicate the  relative root  lengths (going  from the longer  to the shorter root) which may  be different when <code>W</code> has more than one  orbit  on  <code>R</code>.  The  irreducible  crystallographic  root  systems are classified  by the following list of <em>Dynkin diagrams</em>. The labeling of the nodes  is  the  order  of  the  generators  and  is  shown  by the function <code>Diagram</code>.</p><pre><code class="nohighlight hljs">Aₙ O—O—O—…—O   Bₙ O⇐ O—O—…—O  Cₙ O⇒ O—O—…—O  Dₙ O 2
   1 2 3 … n      1  2 3 … n     1  2 3 … n     ￨
                                              O—O—…—O
                                              1 3 … n

G₂ O⇛ O  F₄ O—O⇒O—O    E₆  O 2    E₇  O 2      E₈  O 2
   1  2     1 2 3 4        ￨          ￨            ￨
                       O—O—O—O—O  O—O—O—O—O—O  O—O—O—O—O—O—O
                       1 3 4 5 6  1 3 4 5 6 7  1 3 4 5 6 7 8</code></pre><p>We get the <em>Coxeter Diagram</em>, which describes the underlying Weyl group, if we  ignore  the  arrows:  we  see  that  the  root  systems <code>B_n</code> and <code>C_n</code> correspond to the same Coxeter group. <code>(W,S)</code> is a Coxeter system where <code>S</code> is  the reflections <code>s</code> corresponding to  the simple roots (called <em>simple</em> reflections  or <em>Coxeter generators</em>) and  the Coxeter matrix is <code>{mₛₜ}ₛₜ</code>. Weyl  groups can  also be  characterized as  the finite Coxeter groups such that all entries of the Coxeter matrix are in <code>{2,3,4,6}</code>.</p><p>Here  are the Coxeter diagrams for the  finite Coxeter groups which are not crystallographic:</p><pre><code class="nohighlight hljs">       e        5         5
I₂(e) O—O   H₃ O—O—O  H₄ O—O—O—O
      1 2      1 2 3     1 2 3 4</code></pre><p>The  Dynkin diagram can be obtained from  the Cartan matrix <code>C</code> as follows: the  indices for the rows of <code>C</code> label the nodes of the diagram. The edges, for  <code>r ≠ s</code>,  are given as  follows. If <code>Cᵣₛ</code>  and <code>Cₛᵣ</code> are integers such that  <code>|Cₛᵣ|≥|Cᵣₛ|=1</code> there is  an edge of  weight <code>|Cₛᵣ|</code> from  <code>r</code> to <code>s</code> with  an arrow pointing  to <code>s</code> if  <code>|Cₛᵣ|&gt;1</code>. For non-integral entries, we put a an edge of weight <code>pᵣₛ≥1</code> where <code>CᵣₛCₛᵣ=cos^2 (π/pₛᵣ)</code>.</p><p>The  Cartan  matrix  corresponding  to  one  of  the above irreducible root systems  (with the specified labeling) is  returned by the command &#39;cartan&#39; which  takes as input  a <code>Symbol</code> giving  the type (that  is &#39;:A&#39;, &#39;:B&#39;, …, &#39;:I&#39;)  and a positive <code>Int</code> giving the  rank (plus an <code>Int</code> giving the bond for  type <code>:I</code>). This function returns a matrix with <code>Int</code> entries for Weyl groups,  and  a  matrix  of  <code>Cyc</code>  for  the  other types. Given two Cartan matrices  <code>c1</code>  and  <code>c2</code>,  their  matrix  direct sum (corresponding to the orthogonal   direct  sum   of  the   root  systems)   can  be  produced  by <code>cat(c1,c2,dims=[1,2])</code>.</p><p>The  whole  root  system  can  be  recovered  from the simple roots and the corresponding  coroots, since each root  is in the orbit  of a simple root. The  restriction of the simple reflections to the span of <code>R</code> is determined by the Cartan matrix, so <code>R</code> is determined by the Cartan matrix and the set of simple roots.</p><p>The  function &#39;rootdatum&#39; takes as input a  list of simple roots and a list of  the  corresponding  coroots  and  produces  a <code>CoxeterGroup</code> containing information  about the root  system <code>R</code> and  about <code>W(R)</code>. If  we label the positive  roots by  &#39;1:N&#39;, and  the negative  roots by  &#39;N+1:2N&#39;, then each simple  reflection is  represented by  the permutation  of &#39;1:2N&#39;  which it induces  on the roots. If only one  argument is given, the Cartan matrix of the  root system, it is taken as the  list of coroots and the list of roots is assumed to be the canonical basis of <code>V</code>.</p><p>If one only wants to work with Cartan matrices with a labeling as specified by  the  above  list,  the  function  call  can  be  simplified. Instead of &#39;rootdatum(cartan(:D,4))&#39; the following is also possible.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; cartan(W)
4×4 Matrix{Int64}:
  2   0  -1   0
  0   2  -1   0
 -1  -1   2  -1
  0   0  -1   2</code></pre><p>Also,  the Weyl group struct associated to a direct sum of irreducible root systems can be obtained as a product</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)*coxgroup(:B,2)
A₂×B₂

julia&gt; cartan(W)
4×4 Matrix{Int64}:
  2  -1   0   0
 -1   2   0   0
  0   0   2  -2
  0   0  -1   2</code></pre><p>The  same object is constructed  by applying  &#39;coxgroup&#39; to  the matrix &#39;cat(cartan(:A,2), cartan(:B,2),dims=[1,2])&#39;.</p><p>The elements of a Weyl group are permutations of the roots:</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; p=W(1,3,2,1,3)
(1,14,13,2)(3,17,8,18)(4,12)(5,20,6,15)(7,10,11,9)(16,24)(19,22,23,21)

julia&gt; word(W,p)
5-element Vector{Int64}:
 1
 3
 1
 2
 3
</code></pre><p>finally, a benchmark on julia 1.0.2</p><pre><code class="language-benchmark hljs">julia&gt; @btime length(elements(coxgroup(:E,7)))
  531.385 ms (5945569 allocations: 1.08 GiB)</code></pre><p>GAP3 for the same computation takes 2.2s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L1-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.cartan-Tuple{Symbol, Integer, Integer}" href="#Gapjm.PermRoot.cartan-Tuple{Symbol, Integer, Integer}"><code>Gapjm.PermRoot.cartan</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>cartan(type, rank [,bond])</code></p><p>return  the Cartan matrix for a finite  Coxeter group described by type and rank.  The recognized types are <code>:A, :B,  :Bsym, :C, :D, :E, :F, :Fsym, :G, :Gsym, :I, :H</code>. For type <code>:I</code> a third argument must be given describing the bond between the two generators. The <code>sym</code> types correspond to root systems where all roots have the same length.</p><pre><code class="language-julia-repl hljs">julia&gt; cartan(:F,4)
4×4 Matrix{Int64}:
  2  -1   0   0
 -1   2  -1   0
  0  -2   2  -1
  0   0  -1   2

julia&gt; cartan(:I,2,5)
2×2 Matrix{Cyc{Int64}}:
       2  ζ₅²+ζ₅³
 ζ₅²+ζ₅³        2

julia&gt; cartan(:Bsym,2)
2×2 Matrix{Cyc{Int64}}:
   2  -√2
 -√2    2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L218-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.cartan-Tuple{AbstractMatrix}" href="#Gapjm.PermRoot.cartan-Tuple{AbstractMatrix}"><code>Gapjm.PermRoot.cartan</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>cartan(M::AbstractMatrix)</code> Cartan matrix from Coxeter matrix</p><p>The  argument should be the Coxeter matrix  <code>M</code> for a Coxeter group <code>W</code> and the   result  is  the  Cartan  Matrix   <code>C</code>  for  the  standard  reflection representation  of <code>W</code>. We have <code>C[s,t]=-2cos(π/M[s,t])</code>, where <code>M[s,s]==1</code> and  by  convention  <code>π/M[s,t]==0</code>  if  <code>M[s,t]==∞</code>,  which we represent by &#39;M[s,t]==0&#39;.  Since  <code>M</code>  is  symmetric,  the  resulting  <code>C</code> is symmetric, meaning  that all roots  in the constructed  reflection representation have same length.</p><pre><code class="language-julia-repl hljs">julia&gt; cartan([1 3;3 1])
2×2 Matrix{Cyc{Int64}}:
  2  -1
 -1   2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L198-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.roots-Tuple{AbstractMatrix}" href="#Gapjm.roots-Tuple{AbstractMatrix}"><code>Gapjm.roots</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>roots(C::AbstractMatrix)</code></p><p>returns the set of positive roots defined by the Cartan matrix <code>C</code>. Works for the Cartan matrix of any finite Coxeter group</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L420-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.two_tree" href="#Gapjm.Weyl.two_tree"><code>Gapjm.Weyl.two_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>two_tree(m)</code></p><p>Given  a square matrix  <code>m</code> with zeroes  (or falses, for  a boolean matrix) symmetric  with respect to the diagonal, let <code>G</code> be the graph with vertices <code>axes(m)[1]</code>  and an edge between <code>i</code> and <code>j</code> iff <code>!iszero(m[i,j])</code>. </p><p>If  <code>G</code> is a line this function returns  it as a <code>Vector{Int}</code>. If <code>G</code> is a tree with one vertex <code>c</code> of valence <code>3</code> the function returns <code>(c,b1,b2,b3)</code> where  <code>b1,b2,b3</code> are  the branches  from this  vertex sorted by increasing length. Otherwise the function returns <code>nothing</code></p><pre><code class="language-julia-repl hljs">julia&gt; Weyl.two_tree(cartan(:A,4))
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; Weyl.two_tree(cartan(:E,8))
(4, [2], [3, 1], [5, 6, 7, 8])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L303-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection_subgroup-Tuple{Gapjm.Weyl.FCG, AbstractVector{&lt;:Integer}}" href="#Gapjm.PermRoot.reflection_subgroup-Tuple{Gapjm.Weyl.FCG, AbstractVector{&lt;:Integer}}"><code>Gapjm.PermRoot.reflection_subgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflection_subgroup(W::FiniteCoxeterGroup,I)</code></p><p>The subgroup of <code>W</code> generated by <code>reflections(W)[I]</code></p><p>A  theorem discovered independently  by <a href="biblio.htm#Deo89">Deodhar1989</a> and <a href="biblio.htm#Dye90">Dyer1990</a>  is that  a subgroup  <code>H</code> of  a Coxeter system <code>(W,S)</code>  generated by reflections  has a canonical  Coxeter generating set, formed  of  the  <code>t  ∈  Ref(H)</code>  such  <code>l(tt&#39;)&gt;l(t)</code>  for  any <code>t&#39;∈ Ref(H)</code> different  from <code>t</code>. This is used by <code>reflection_subgroup</code> to determine the Coxeter system of <code>H</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; Diagram(W)
O⇛ O
1  2

julia&gt; H=reflection_subgroup(W,[2,6])
G₂₍₂₆₎=Ã₁×A₁

julia&gt; Diagram(H)
O
1
O
2</code></pre><p>The  notation <code>G₂₍₂₆₎</code> means  that <code>W.G.roots[2:6]</code> form  a system of simple roots for <code>H</code>.</p><p>A  reflection subgroup has specific properties  the most important of which is  <code>inclusion</code> which gives the positions of  the roots of <code>H</code> in the roots of <code>W</code>. The inverse (partial) map is <code>restriction</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; inclusion(H)
4-element Vector{Int64}:
  2
  6
  8
 12

julia&gt; restriction(H)
12-element Vector{Int64}:
 0
 1
 0
 0
 0
 2
 0
 3
 0
 0
 0
 4</code></pre><p>If  <code>H</code> is a  standard parabolic subgroup  of a Coxeter  group <code>W</code> then the length  function on  <code>H</code> (with  respect to  its set  of generators)  is the restriction  of the length function on <code>W</code>. This need not no longer be true for arbitrary reflection subgroups of <code>W</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; word(W,H(2))
5-element Vector{Int64}:
 1
 2
 1
 2
 1</code></pre><p>In  this package, finite  reflection groups are  represented as permutation groups  on a set of roots. Consequently,  a reflection subgroup <code>H⊆ W</code> is a permutation  subgroup, thus its elements are represented as permutations of the roots of the parent group.</p><pre><code class="language-julia-repl hljs">julia&gt; elH=word.(Ref(H),elements(H))
4-element Vector{Vector{Int64}}:
 []
 [2]
 [1]
 [1, 2]

julia&gt; elW=word.(Ref(W),elements(H))
4-element Vector{Vector{Int64}}:
 []
 [1, 2, 1, 2, 1]
 [2]
 [1, 2, 1, 2, 1, 2]

julia&gt; map(w-&gt;H(w...),elH)==map(w-&gt;W(w...),elW)
true
</code></pre><p>Another  basic result about reflection subgroups  of Coxeter groups is that each  coset of <code>H</code> in <code>W</code> contains  a unique element of minimal length, see <code>reduced</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L885-L988">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.coxgroup" href="#Gapjm.Weyl.coxgroup"><code>Gapjm.Weyl.coxgroup</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>coxgroup(type,rank[,bond])</code></p><p>This is equivalent to &#39;rootdatum(cartan(type,rank[,bond]))`.</p><p>The  resulting object, that we will  call a <em>Coxeter datum</em>, has an  additional entry</p><ul><li><code>W.rootdec</code>:  the root vectors, given  as linear combinations of simple roots.  The first <code>nref(W)</code> roots are  positive, the next <code>nref(W)</code> are the corresponding negative roots. Moreover, the first <code>semisimplerank(W)</code>  roots are the simple roots. The positive roots are ordered by increasing height.</li></ul><p>The  following functions  get various  information on  the root  system and Coxeter group</p><ul><li><p><code>nref(W)</code>:   the number of positive roots</p></li><li><p><code>coroots(W)</code>: The list of coroots. The coroot corresponding  to a given root has same index in the list of coroots as the root in the list of roots.</p></li><li><p><code>rootlengths(W)</code>: the vector  of the (squared)  length of the roots. The  shortest roots in an irreducible subsystem are given the length 1. The  others then have  length 2 (or  3 in type <code>G₂</code>). The matrix of the <code>W</code>-invariant bilinear form is given by <code>map(i-&gt;rootlengths(W)[i]*W.cartan[i,:],1:semisimplerank(W))</code>.</p></li><li><p><code>simple_reps(W,i)</code>: this  gives the  smallest index  of a root in the same <code>W</code>-orbit as the <code>i</code>-th root.</p></li><li><p><code>simple_conjugating(W,i)</code>: returns  an element  <code>w</code> of  <code>W</code> such that `i==simple_reps(W,i)^w&#39;.</p></li><li><p><code>reflrep(W)</code>:  the  reflection  representation  of  <code>W</code>, that is the matrices  (in row convention –- the matrices operate <em>from the right</em>) of the simple reflections generating <code>W</code>.</p></li><li><p><code>gens(W)</code>: the generators, as permutations of the root vectors. They are in the same order as the simple roots.</p></li></ul><pre><code class="language-julia_repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; cartan(W)
3×3 Matrix{Int64}:
  2  -1   0
 -1   2  -1
  0  -1   2

julia&gt; W.rootdec
12-element Vector{Vector{Int64}}:
 [1, 0, 0]
 [0, 1, 0]
 [0, 0, 1]
 [1, 1, 0]
 [0, 1, 1]
 [1, 1, 1]
 [-1, 0, 0]
 [0, -1, 0]
 [0, 0, -1]
 [-1, -1, 0]
 [0, -1, -1]
 [-1, -1, -1]

 julia&gt; reflrep(W)
3-element Vector{Matrix{Int64}}:
 [-1 0 0; 1 1 0; 0 0 1]
 [1 1 0; 0 -1 0; 0 1 1]
 [1 0 0; 0 1 1; 0 0 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L680-L752">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.rootdatum" href="#Gapjm.Weyl.rootdatum"><code>Gapjm.Weyl.rootdatum</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>rootdatum(string or symbol,...)</code> root datum from type </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Cosets.jl#L1138">source</a></section><section><div><p><code>rootdatum(C::AbstractMatrix)</code> adjoint root datum from Cartan matrix <code>C</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L756">source</a></section><section><div><p><code>rootdatum(R::AbstractMatrix,CR::AbstractMatrix)</code></p><p>root  datum from <code>R</code> whose  rows are the simple  roots on a basis of <code>X(T)</code> and <code>CR</code> whose rows are the simple coroots on a basis of <code>Y(T)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L759-L764">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.describe_involution" href="#Gapjm.Weyl.describe_involution"><code>Gapjm.Weyl.describe_involution</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>describe_involution(W,w)</code></p><p>Given  an  involution  <code>w</code>  of  a  Coxeter  group  <code>W</code>,  by  a  theorem  of <a href="biblio.htm#rich82">Richardson1982</a>  there is  a unique  parabolic subgroup <code>P</code> of <code>W</code> such that that <code>w</code> is the longest element of <code>P</code>, and is central in <code>P</code>. The function returns <code>I</code> such that <code>P=reflection_subgroup(W,I)</code>, so that <code>w=longest(reflection_subgroup(W,I))</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; w=longest(W)
(1,5)(2,4)(3,6)

julia&gt; describe_involution(W,w)
1-element Vector{Int64}:
 3

julia&gt; w==longest(reflection_subgroup(W,[3]))
true</code></pre><p>For now does not work for abscox groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L589-L613">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.badprimes" href="#Gapjm.Weyl.badprimes"><code>Gapjm.Weyl.badprimes</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>badprimes(W)</code></p><p>Let  <code>W</code>  be  a  Weyl  group.  A  prime  is  <em>bad</em>  for <code>W</code> if it divides a coefficient  of some  root on  the simple  roots. The  function <code>badprimes</code> returns the list of primes which are bad for <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,8)
E₈

julia&gt; badprimes(W)
3-element Vector{Int64}:
 5
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L566-L583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.standard_parabolic" href="#Gapjm.Weyl.standard_parabolic"><code>Gapjm.Weyl.standard_parabolic</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>standard_parabolic(W::PermRootGroup, H)</code></p><p>Let  <code>H</code> be a  reflection subgroup of  <code>W</code>. Returns an  element <code>w∈ W</code> such that  <code>H^w</code> is a standard  parabolic subgroup of <code>W</code>  (or nothing if <code>H</code> is not parabolic or not conjugate to a standard parabolic).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Eigenspaces.jl#L374-L380">source</a></section><section><div><p><code>standard_parabolic(W,H)</code></p><p>Given  a reflection subgroup <code>H</code> or the indices of its simple roots returns <code>nothing</code> if <code>H</code> is not parabolic, otherwise returns <code>w</code> such that <code>H^w</code> is a standard parabolic subgroup of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,6)
E₆

julia&gt; R=reflection_subgroup(W,[20,30,19,22])
E₆₍₁₉‚₁‚₉‚₂₀₎=A₄₍₃₁₂₄₎Φ₁²

julia&gt; p=standard_parabolic(W,R)
(1,4,49,12,10)(2,54,62,3,19)(5,17,43,60,9)(6,21,34,36,20)(7,24,45,41,53)(8,65,50,15,22)(11,32,31,27,28)(13,48,46,37,40)(14,51,58,44,29)(16,23,35,33,30)(18,26,39,55,38)(42,57,70,72,56)(47,68,67,63,64)(52,59,71,69,66)

julia&gt; reflection_subgroup(W,[20,30,19,22].^p)
E₆₍₂₄₅₆₎=A₄Φ₁²

julia&gt; R=reflection_subgroup(W,[1,2,3,5,6,35])
E₆₍₁‚₃‚₂‚₃₅‚₅‚₆₎=A₂₍₁₃₎×A₂₍₂₆₎×A₂₍₄₅₎

julia&gt; standard_parabolic(W,R)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L515-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.inversions" href="#Gapjm.CoxGroups.inversions"><code>Gapjm.CoxGroups.inversions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>inversions(W,w)</code></p><p>Returns  the inversions of the element <code>w</code> of the finite Coxeter group <code>W</code>, that  is, the list of the  indices of reflections <code>r</code> of <code>W</code> such that <code>l(rw)&lt;l(w)</code> where <code>l</code> is the Coxeter length.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; inversions(W,W(1,2,1))
3-element Vector{Int64}:
 1
 2
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L639-L656">source</a></section><section><div><p><code>inversions(W::FiniteCoxeterGroup, w::AbstractVector{&lt;:Integer})</code></p><p>Given  a word <code>w=s₁…sₙ</code>  (a vector of  integers) representing an element of <code>W</code>, returns the inversions of <code>w</code> in the order of the reflections: <code>W(s₁), W(s₁,s₂,s₁), …, W(s₁,s₂,…,sₙ,sₙ₋₁,…,s₁)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; inversions(W,W(1,2,1))
3-element Vector{Int64}:
 1
 2
 4

julia&gt; inversions(W,[2,1,2])
3-element Vector{Int16}:
 2
 4
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L452-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.with_inversions" href="#Gapjm.Weyl.with_inversions"><code>Gapjm.Weyl.with_inversions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>with_inversions(W,N)</code></p><p><code>W</code>  should be  a finite  Coxeter group  and <code>N</code>  a subset  of <code>1:nref(W)</code>. Returns  the  element  <code>w</code>  of  <code>W</code> such that <code>N==inversions(W,w)</code>. Returns <code>nothing</code> if no such element exists.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; map(N-&gt;with_inversions(W,N),combinations(1:nref(W)))
8-element Vector{Union{Nothing, Perm{Int16}}}:
 ()
 (1,4)(2,3)(5,6)
 (1,3)(2,5)(4,6)
 nothing
 nothing
 (1,6,2)(3,5,4)
 (1,2,6)(3,4,5)
 (1,5)(2,4)(3,6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L479-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.torus" href="#Gapjm.Weyl.torus"><code>Gapjm.Weyl.torus</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>torus(m::Matrix)</code></p><p><code>m</code>  should be an integral matrix of finite order. The function returns the coset <code>T</code> of the trivial Coxeter group such that <code>T.F==m</code>. This corresponds to  an algebraic torus <code>𝐓</code> of rank <code>size(m,1)</code>, with an isogeny which acts by <code>m</code> on <code>X(𝐓)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; torus([0 -1;1 -1])
Φ₃</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Cosets.jl#L615-L627">source</a></section><section><div><p><code>torus(W,i)</code></p><p>This  returns the torus twisted by a representative of the <code>i</code>-th conjugacy class of <code>W</code>. This is the same as <code>twistings(W,Int[])[i]</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; twistings(W,Int[])
5-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:
 A₃₍₎=Φ₁³
 A₃₍₎=Φ₁²Φ₂
 A₃₍₎=Φ₁Φ₂²
 A₃₍₎=Φ₁Φ₃
 A₃₍₎=Φ₂Φ₄

julia&gt; torus(W,2)
A₃₍₎=Φ₁²Φ₂

julia&gt; WF=spets(W,Perm(1,3))
²A₃

julia&gt; twistings(WF,Int[])
5-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:
 ²A₃₍₎=Φ₂³
 ²A₃₍₎=Φ₁Φ₂²
 ²A₃₍₎=Φ₁²Φ₂
 ²A₃₍₎=Φ₂Φ₆
 ²A₃₍₎=Φ₁Φ₄

julia&gt; torus(WF,2)
²A₃₍₎=Φ₁Φ₂²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Cosets.jl#L630-L665">source</a></section><section><div><p><code>torus(rank)</code></p><p>This  function returns the object corresponding to the notion of a torus of dimension  <code>rank</code>, a Coxeter  group of semisimple  rank 0 and given <code>rank</code>. This  corresponds to a split torus; the extension to Coxeter cosets is more useful.</p><pre><code class="language-julia-repl hljs">julia&gt; torus(3)
Φ₁³</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L787-L799">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.istorus" href="#Gapjm.Weyl.istorus"><code>Gapjm.Weyl.istorus</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>istorus(W)</code> whether <code>W</code> is a torus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L802">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Semisimple.SubTorus" href="#Gapjm.Semisimple.SubTorus"><code>Gapjm.Semisimple.SubTorus</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SubTorus(W,Y::Matrix{&lt;:Integer})</code></p><p>The  function  returns  the  subtorus  𝐒  of  the  maximal torus <code>𝐓</code> of the reductive  group represented by the Weyl group  <code>W</code> such that <code>Y(𝐒)</code> is the (pure)  sublattice of  <code>Y(𝐓)</code> generated  by the  (integral) vectors  <code>Y</code>. A basis  of <code>Y(𝐒)</code>  adapted to  <code>Y(𝐓)</code> is  computed and  stored in  the field <code>S.gens</code> of the returned SubTorus struct. Here, adapted means that there is a   set  of   integral  vectors,   stored  in   <code>S.complement</code>,  such  that <code>M=vcat(S.gens,S.complement)</code>   is   a   basis   of   <code>Y(𝐓)</code>  (equivalently <code>M∈GL(Z^{rank(W)})</code>.  An  error  is  raised  if  <code>Y</code> does not define a pure sublattice.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,4)
A₄

julia&gt; SubTorus(W,[1 2 3 4;2 3 4 1;3 4 1 1])
SubTorus(A₄,[1 0 3 -13; 0 1 2 7; 0 0 4 -3])

julia&gt; SubTorus(W,[1 2 3 4;2 3 4 1;3 4 1 2])
ERROR: not a pure sublattice
Stacktrace:
 [1] error(::String) at ./error.jl:33
 [2] Gapjm.Weyl.SubTorus(::FiniteCoxeterGroup{Perm{Int16},Int64}, ::Matrix{Int64}) at /home/jmichel/julia/Gapjm.jl/src/Weyl.jl:1082
 [3] top-level scope at REPL[25]:1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Semisimple.jl#L317-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.relative_group" href="#Gapjm.Weyl.relative_group"><code>Gapjm.Weyl.relative_group</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>relative_group(W::FiniteCoxeterGroup,J)</code></p><p><code>J</code>  should be a if <em>distinguished</em> subset of <code>S==eachindex(gens(W))</code>, that is  if for <code>s∈ S-J</code> we set <code>v(s,J)=w₀^{J∪  s}w₀ᴶ</code> then <code>J</code> is stable by all <code>v(s,J)</code>.  Then <span>$R=N_W(W_J)/W_J$</span> is  a Coxeter group  with Coxeter system the  <code>v(s,J)</code>. The program returns <code>R</code>  in its reflection representation on <span>$X(ZL_J/ZG)$</span>.  (according to Lusztig&#39;s &quot;Coxeter Orbits...&quot;, the images of the roots of <code>W</code> in <span>$X(ZL_J/ZG)$</span> form a root system).</p><p><code>R.prop</code> has the fields: <code>:relativeIndices=setdiff(S,J)</code> <code>:parentMap=</code> the list of <code>v(s,J)</code> <code>:MappingFromNormalizer</code> maps <code>J</code>-reduced elements of <span>$N_W(W_J)$</span> to   elements of <code>R</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L1033-L1048">source</a></section></article><h1 id="Finite-reflection-groups"><a class="docs-heading-anchor" href="#Finite-reflection-groups">Finite reflection groups</a><a id="Finite-reflection-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-reflection-groups" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot" href="#Gapjm.PermRoot"><code>Gapjm.PermRoot</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Let  <code>V</code>  be  a  vector  space  over  a subfield <code>K</code> of the complex numbers (usually  in Julia elements  of <code>K</code> are  <code>Rational</code>s or <code>Cyc</code>s). A <em>complex reflection</em>  is an element <code>s∈ GL(V)</code> of finite order whose fixed point set is  an hyperplane, called the reflecting hyperplane  of <code>s</code> (we will in the following just call it a <em>reflection</em> to abbreviate; in some literature the term  reflection is only employed when the  order is 2 and the more general case  is  called  a  <em>pseudo-reflection</em>).  Thus  a reflection has a unique eigenvalue  <code>ζ</code> not equal  to <code>1</code>, which  is a root  of unity. If  <code>K</code> is a subfield of the real numbers, this eigenvalue is necessarily equal to <code>-1</code>. A  reflection is determined by a vector <code>r∈ V</code> (a &quot;root&quot;) and a linear form <code>rᵛ</code>  on <code>V</code> (a &quot;coroot&quot;) such that <code>rᵛ(r)=1-ζ</code>. The reflection <code>s</code> is then the  map on <code>V</code> defined by <code>s(x)=x-rᵛ(x)r</code>. The root and the coroot for <code>s</code> are unique up to scaling the root and inversely scaling the coroot.</p><p>A  complex reflection group <code>W</code> is a  group generated by a finite number of complex reflections.</p><p>Since  when <code>W</code> contains  a reflection <code>s</code>  it contains its  powers, <code>W</code> is always  generated  by  reflections  <code>s</code>  with non-trivial eigenvalue <code>E(d)</code> where  <code>d</code> is the order of <code>s</code>; we may in addition assume that <code>s</code> is not a power  of another  reflection with  larger order  <code>d</code>. Such a reflection is called  <em>distinguished</em>; it is a canonical generator of the cyclic subgroup of <code>W</code> centralizing its reflecting hyperplane. The generators of reflection groups  we  construct  are  always  distinguished  reflections  (in  a real reflection group all reflections are distinguished).</p><p>We  deal in  this package  with finite  complex reflection groups. They are groups for which the following methods are defined:</p><p><code>gens(W)</code>: the (distinguished) reflections which generate <code>W</code></p><p><code>reflections(W)</code>:  the  list  of  distinguished  reflections  of <code>W</code>, which starts with gens(W).</p><p>Note  that <code>W</code> does <em>not</em> need to be a matrix group. But <code>W</code> has a faithful representation    (called    the    <em>reflection    representation</em>)   where <code>reflections(W)</code>  act as  reflections. Note  that the  set of distinguished reflections are in bijection with the reflecting hyperplanes.</p><p>It is  much more efficient to compute with permutation groups than with matrix groups, when possible. The  efficient  representation  that  we  use  for  computing with <code>W</code>, is a permutation  representation  on  a  <code>W</code>-invariant  set  of  root and coroot vectors  for reflections of <code>W</code>; that is, a set <code>R</code> of pairs <code>(r,rᵛ)∈ V×Vᵛ</code> invariant  by <code>W</code> and such each  distinguished reflection in <code>W</code> is defined by some pair in <code>R</code> (see <code>reflection</code>). There may be several pairs for each reflection,  differing  by  roots  of  unity.  This  generalizes  the usual construction  for Coxeter groups (the case <code>K=ℝ</code>) where to each reflection of  <code>W</code>  is  associated  two  roots,  a  positive  and  a negative one. For irreducible  complex  reflection  groups,  since  we  want  a  set  of root invariant  by <code>W</code>, there are at least as  many roots on a given line as the order of the center of <code>W</code>.</p><p>The  finite  irreducible  complex  reflection  groups  have been completely classified   by  Shepard  and  Todd.   They  contain  one  infinite  family <code>G(de,e,r)</code> depending on 3 parameters, and 34 exceptional groups which have been  given by Shephard and Todd names which range from <code>G₄</code> to <code>G₃₇</code>. They cover the exceptional Coxeter groups, e.g., <code>coxgroup(:E,8)</code> is the same as <code>G₃₇</code>.</p><p>We provide functions to build any finite reflection group, either by giving a  list of  roots and  coroots defining  the generating  reflections, or in terms  of the classification. The  output is a permutation  group on set of roots (see <code>ComplexReflectionGroup</code> and <code>PRG</code>). In the context e.g. of Weyl groups,  one wants to describe the particular root system chosen in term of the  traditional classification  of crystallographic  root systems. This is done  via  calls  to  the  function  <code>coxgroup</code>  (see the chapter on finite Coxeter  groups). There is not  yet a general theory  on how to construct a nice  set of roots for  a non-real reflection group;  the roots chosen here where  obtained  case-by-case;  however,  they  satisfy  several  important properties:</p><ul><li><p>The  generating  reflections  satisfy  braid relations which  present the braid group associated to <code>W</code> (see <code>Diagram</code>).</p></li><li><p>The <em>field of definition</em> of <code>W</code> is the field <code>K</code> generated by the traces of the elements of <code>W</code> acting on <code>V</code>.</p></li></ul><p>It  is a theorem that  <code>W</code> may be realized  as a reflection group over <code>K</code>. For  almost  all  irreducible  complex  reflection  groups,  the generating matrices  for <code>W</code>  we give  have coefficients  in <code>K</code>.  Further, the set of matrices  for all  elements of  <code>W</code> is  globally invariant under the Galois group  of <code>K/ℚ</code>, thus the Galois  action induces automorphisms of <code>W</code>. The exceptions  are <code>G₂₂, G₂₇</code> where the matrices are in a degree two extension of   <code>K</code>  (this  is  needed  to   have  a  globally  invariant  model,  see <a href="biblio.htm#MarinMichel10">MarinMichel2010</a>)  and  some  dihedral groups as well  as  <code>H_3</code>  and  <code>H_4</code>,  where  the  matrices given (the usual Coxeter reflection representation over <code>K</code>) are not globally invariant.</p><p>It turns out that all representations of a complex reflection group <code>W</code> are defined  over the  field of  definition of  <code>W</code> (cf.  [Ben76] and D.~Bessis thesis).  This has been known f/home/jmichel/or a long  time in the case <code>K=ℚ</code>, the case of Weyl groups: their representations are defined over the rationals.</p><ul><li>The Cartan matrix (see &quot;cartan&quot;) for the generating roots (those which  correspond  to the generating reflections) has  entries in the ring <code>ℤₖ</code>  of integers of <code>K</code>, and the roots (resp. coroots) are linear combination  with coefficients in <code>ℤₖ</code> of a linearly independent subset of them.</li></ul><p>The finite reflection groups have the following additional methods:</p><p><code>roots(W)</code>:  a set  of complex  roots in  <code>V</code>, given  as a list of vectors,      on which <code>W</code> has a faithful permutation representation.</p><p><code>coroots(W,1:ngens(W))</code>: the  coroots for <code>gens(W)</code>.</p><p>Let <code>SV</code> be the symmetric algebra of <code>V</code>. The invariants of <code>W</code> in <code>SV</code> are called  the  <em>polynomial  invariants</em>  of  <code>W</code>.  They  are  generated  as a polynomial   ring   by   <code>dim   V</code>  homogeneous  algebraically  independent polynomials  <code>f₁,…,f_{dim  V}</code>.  The  polynomials  <code>fᵢ</code>  are  not  uniquely determined   but  their  degrees  are.  The  <code>fᵢ</code>  are  called  the  <em>basic invariants</em>  of <code>W</code>, and their degrees the <em>reflection degrees</em> of <code>W</code>; the function <code>degrees(W)</code> returns these invariants.</p><p>Let  <code>I</code> be the  ideal generated by  the homogeneous invariants of positive degree  in <code>SV</code>. Then <code>SV/I</code> is isomorphic to the regular representation of <code>W</code>  as a  <code>W</code>-module. It  is thus  a graded  (by the degree of elements of <code>SV</code>)  version of the  regular representation of  <code>W</code>. The polynomial which gives  the graded  multiplicity of  a character  <code>φ</code> of  <code>W</code> in  the graded module   <code>SV/I</code>  is  called   the  <em>fake  degree</em>   of  <code>φ</code>.  The  function <code>fakedegrees</code> returns these polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection" href="#Gapjm.PermRoot.reflection"><code>Gapjm.PermRoot.reflection</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reflection(root, coroot)</code> the reflection of given root and coroot</p><p>A (complex) reflection is a finite order element <code>s</code> of <code>GL(V)</code>, the linear group of a vector space over a subfield of the complex numbers, whose fixed points  form  a  hyperplane  <code>H</code>  (the  <em>reflecting hyperplane</em> of <code>s</code>); an eigenvector  <code>r</code> for  the non-trivial  eigenvalue <code>ζ</code>  (a root of unity) is called  a <em>root</em> of <code>s</code>. If we choose  a linear form <code>rᵛ</code> defining <code>H</code> such that <code>rᵛ(r)=1-ζ</code> (a <em>coroot</em> of <code>s</code>) then <code>s</code> is given by <code>x↦ x-rᵛ(x)r</code>.</p><p>A  way  of  specifying  <code>s</code>  is  by  giving  a root and a coroot, which are uniquely determined by <code>s</code> up to multiplication of the root by a scalar and of  the coroot by  the inverse scalar.  The function <code>reflection</code> gives the matrix  of the corresponding reflection in the standard basis of <code>V</code>, where the  <code>root</code> and the <code>coroot</code> are vectors given in the standard bases of <code>V</code> and <code>Vᵛ</code>, so the pairing <code>rᵛ(r)</code> is obtained as <code>transpose(root)*coroot</code>.</p><pre><code class="nohighlight hljs">julia&gt; r=reflection([1,0,0],[2,-1,0])
3×3 Matrix{Int64}:
 -1  0  0
  1  1  0
  0  0  1

julia&gt; r==reflrep(coxgroup(:A,3),1)
true

julia&gt; r*[2,-1,0]
3-element Vector{Int64}:
 -2
  1
  0

julia&gt; [1 0 0]*r
1×3 Matrix{Int64}:
 -1  0  0</code></pre><p>As  we see in the last lines, in  Julia a matrix operates from the right on the  vector space <code>V</code>  of row vectors  and from the  left on the dual space <code>Vᵛ</code> of column vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L146-L186">source</a></section><section><div><p><code>reflection(r, ζ=-1)</code> </p><p>returns the matrix of the complex reflection determined by the root <code>r</code> and the  eigenvalue <code>ζ</code> when the  vector space and its  dual are identified via the  scalar product <code>&lt;x,y&gt;=transpose(x)*y</code>; the coroot <code>rᵛ</code> is then equal to the linear form <code>x-&gt;(1-ζ)&lt;x,r&gt;/&lt;r,r&gt;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L193-L200">source</a></section><section><div><p><code>reflection(W,i)</code></p><p>reflection for <code>i</code>-th root of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L477-L481">source</a></section><section><div><p><code>reflection(s::Matrix [,r::AbstractVector])</code></p><p>Here  <code>s</code> is  a square  matrix, and  if given  <code>r</code> is  a vector of the same length  as <code>size(s)[1]</code>. The function determines if  <code>s</code> is the matrix of a reflection  (resp. if <code>r</code> is  given if it is  the matrix of a reflection of root  <code>r</code>; the point of  giving <code>r</code> is to  specify exactly the desired root and  coroot, which  otherwise are  determined only  up to  a scalar and its inverse).  The function  returns <code>nothing</code>  if <code>s</code>  if is  not a reflection (resp. not a reflection with root <code>r</code>), and otherwise returns a named tuple with four fields:</p><p><code>.root</code>:   the root of the reflection <code>s</code> (equal to <code>r</code> if given)</p><p><code>.coroot</code>:  the coroot of <code>s</code></p><p><code>.eigenvalue</code>:  the non-trivial eigenvalue of <code>s</code></p><p><code>.isOrthogonal</code>:   a  boolean  which is  <code>true</code> if  and  only if  <code>s</code> is   orthogonal  with respect to  the usual scalar  product (then the root and   eigenvalue are sufficient to determine <code>s</code>)</p><pre><code class="language-julia-repl hljs">julia&gt; reflection([-1 0 0;1 1 0;0 0 1])
(root = [2, 0, 0], coroot = Rational{Int64}[1//1, -1//2, 0//1], eig = -1, isOrthogonal = false)

julia&gt; reflection([-1 0 0;1 1 0;0 0 1],[1,0,0])
(root = [1, 0, 0], coroot = Rational{Int64}[2//1, -1//1, 0//1], eig = -1, isOrthogonal = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1728-L1757">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.cartan-Tuple{PermRootGroup}" href="#Gapjm.PermRoot.cartan-Tuple{PermRootGroup}"><code>Gapjm.PermRoot.cartan</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>cartan(W::PermRootGroup)</code>    Cartan matrix of <code>W</code>.</p><p>Let  <code>s₁,…,sₙ</code> be reflections with associated  roots <code>rᵢ</code> and coroots <code>cᵢ</code>. The  matrix <code>C</code> with  entries <code>Cᵢ,ⱼ=cᵢ(rⱼ)</code> is  called a <em>Cartan matrix</em> of <code>s₁,…,sₙ</code>.  It is uniquely  determined by <code>s₁,…,sₙ</code>  up to conjugation by a diagonal matrix.</p><p>If <code>s₁,…,sₙ</code> generate a reflection group <code>W</code>, then <code>C</code> up to conjugation by a  diagonal matrix is an invariant of the reflection representation of <code>W</code>. If invertible <code>C</code> determines this representation since then the <code>rᵢ</code> form a basis  in which the matrix  for <code>sᵢ</code> differs from  the identity only on the <code>i</code>-th line, where the corresponding line of <code>C</code> has been subtracted.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; cartan(W)
3×3 Matrix{Int64}:
  2  -1   0
 -1   2  -1
  0  -1   2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L508-L532">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.cartan-Tuple{PermRootGroup, Any, Any}" href="#Gapjm.PermRoot.cartan-Tuple{PermRootGroup, Any, Any}"><code>Gapjm.PermRoot.cartan</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>cartan(W::PermRootGroup,i,j)</code> the cartan coefficient <code>cᵢ(rⱼ)</code> of the <code>i</code>-th coroot and the <code>j</code>-th root of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L498-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.Diagram" href="#Gapjm.PermRoot.Diagram"><code>Gapjm.PermRoot.Diagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Diagram(W)</code> diagram of finite reflection group <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.hyperplane_orbits" href="#Gapjm.PermRoot.hyperplane_orbits"><code>Gapjm.PermRoot.hyperplane_orbits</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>hyperplane_orbits(W)</code></p><p>returns  a  list  of  named  tuples,  one  for each hyperplane orbit of the reflection  group <code>W</code>. If <code>o</code> is the named tuple for such an orbit, and <code>s</code> is  the first  element of  <code>gens(W)</code> whose  hyperplane is  in the orbit, it contains the following fields</p><p><code>o.s</code>:     index of <code>s</code> in <code>gens(W)</code></p><p><code>o.cl_s</code>:  <code>map(i-&gt;position_class(W,s^i),1:o.order-1)</code></p><p><code>o.order</code>: order of s</p><p><code>.N_s</code>:    Size of orbit</p><p><code>.det_s</code>:  for i in <code>1:o.order-1</code>, position in CharTable of <code>(det_s)^i</code></p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; hyperplane_orbits(W)
2-element Vector{NamedTuple{(:s, :cl_s, :order, :N_s, :det_s), Tuple{Int64, Vector{Int64}, Int64, Int64, Vector{Int64}}}}:
 (s = 1, cl_s = [2], order = 2, N_s = 2, det_s = [5])
 (s = 2, cl_s = [4], order = 2, N_s = 2, det_s = [1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L854-L881">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.rank" href="#Gapjm.PermRoot.rank"><code>Gapjm.PermRoot.rank</code></a> — <span class="docstring-category">Function</span></header><section><div><p>rank(W::Group)</p><p>This  function  returns  the  <em>rank</em>  of  a  reflection group, which is the dimension of the space where it acts.</p><pre><code class="language-julia-repl hljs">julia&gt; rank(ComplexReflectionGroup(31))
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L542-L552">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.semisimplerank" href="#Gapjm.PermRoot.semisimplerank"><code>Gapjm.PermRoot.semisimplerank</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>semisimpleRank(W)</code></p><p>This  function returns the  <em>semisimple rank</em> of  the reflection group <code>W</code>, which  is the dimension of the space  where it effectively acts. If <code>W</code>is a reflection  group acting on <code>V</code>, and <code>V₁</code>  is the subspace generated by the <code>roots(W)</code>,  then  the  dimension  of  <code>V₁</code>  is the semisimple rank. <code>W</code> is called <em>essential</em> if <code>V₁=V</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=reflection_subgroup(coxgroup(:A,3),[1,3])
A₃₍₁₃₎=A₁×A₁Φ₁

julia&gt; semisimplerank(W)
2

julia&gt; rank(W)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1153-L1172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.degrees-Tuple{Group}" href="#Gapjm.degrees-Tuple{Group}"><code>Gapjm.degrees</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>degrees(W)</code></p><p>returns  a list  holding the  degrees of  <code>W</code> as  a reflection group on the vector  space <code>V</code> on which  it acts. These are  the degrees <code>d₁,…,dₙ</code> where <code>n</code>  is the dimension of  <code>V</code> of the basic  invariants of <code>W</code> in <code>SV</code>. They reflect various properties of <code>W</code>; in particular, their product is the size of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=ComplexReflectionGroup(30)
H₄

julia&gt; degrees(W)
4-element Vector{Int64}:
  2
 12
 20
 30

julia&gt; length(W)
14400</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/ComplexR.jl#L104-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.ComplexR.codegrees" href="#Gapjm.ComplexR.codegrees"><code>Gapjm.ComplexR.codegrees</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>codegrees(W)</code></p><p>returns  the vector of codegrees of <code>W</code>  as a reflection group on the space <code>V</code>  of <code>reflrep(W)</code>.  These are  one less  than the  degrees of  the basic derivations of <code>W</code> on <code>SV⊗ V^vee</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=ComplexReflectionGroup(4)
G₄

julia&gt; codegrees(W)
2-element Vector{Int64}:
 0
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/ComplexR.jl#L243-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.nref" href="#Gapjm.PermRoot.nref"><code>Gapjm.PermRoot.nref</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>nref(W)</code></p><p>number of reflections of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L670-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.nhyp" href="#Gapjm.PermRoot.nhyp"><code>Gapjm.PermRoot.nhyp</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>nhyp(W)</code></p><p>number of reflecting hyperplanes of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L427-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.roots" href="#Gapjm.roots"><code>Gapjm.roots</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>roots(W)</code> the roots of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1548">source</a></section><section><div><p><code>roots(W,i)</code> same as but better than <code>roots(W)[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1550">source</a></section><section><div><p><code>roots(C::AbstractMatrix)</code></p><p>returns the set of positive roots defined by the Cartan matrix <code>C</code>. Works for the Cartan matrix of any finite Coxeter group</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Weyl.jl#L420-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.coroots" href="#Gapjm.PermRoot.coroots"><code>Gapjm.PermRoot.coroots</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>coroots(W)</code> the coroots of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1554">source</a></section><section><div><p><code>coroots(W,i)</code> same as but better than <code>coroots(W)[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.coroot" href="#Gapjm.PermRoot.coroot"><code>Gapjm.PermRoot.coroot</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>coroot(r,λ=1)</code> </p><p>the coroot for an orthogonal reflection of root <code>r</code> and eigenvalue <code>λ</code>&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.simpleroots" href="#Gapjm.PermRoot.simpleroots"><code>Gapjm.PermRoot.simpleroots</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>simpleroots(W)</code> the simple roots as a matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1552">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.simplecoroots" href="#Gapjm.PermRoot.simplecoroots"><code>Gapjm.PermRoot.simplecoroots</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>simplecoroots(W)</code> the simple coroots as a matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.braid_relations" href="#Gapjm.CoxGroups.braid_relations"><code>Gapjm.CoxGroups.braid_relations</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>braid_relations(W)</code></p><p>this  function returns the  relations which present  the braid group of the reflection group <code>W</code>. These are homogeneous (both sides of the same length) relations  between generators in bijection  with the generating reflections of  <code>W</code>. A presentation  of <code>W</code> is  obtained by adding relations specifying the order of the generators.</p><pre><code class="language-julia-repl hljs">julia&gt; W=ComplexReflectionGroup(29)
G₂₉

julia&gt; braid_relations(W)
7-element Vector{Vector{Vector{Int64}}}:
 [[1, 2, 1], [2, 1, 2]]
 [[2, 4, 2], [4, 2, 4]]
 [[3, 4, 3], [4, 3, 4]]
 [[2, 3, 2, 3], [3, 2, 3, 2]]
 [[1, 3], [3, 1]]
 [[1, 4], [4, 1]]
 [[4, 3, 2, 4, 3, 2], [3, 2, 4, 3, 2, 4]]</code></pre><p>each  relation  is  represented  as  a  pair  of lists, specifying that the product  of the  generators according  to the  indices on  the left side is equal  to the product according to the  indices on the right side. See also <code>Diagram</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/CoxGroups.jl#L760-L788">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.bipartite_decomposition" href="#Gapjm.PermRoot.bipartite_decomposition"><code>Gapjm.PermRoot.bipartite_decomposition</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>bipartite_decomposition(W)</code></p><p>Returns  a bipartite decomposition <code>[L,R]</code> of the indices of the generators of  the  reflection  group  <code>W</code>,  such  that <code>reflection_subgroup(W,L)</code> and <code>reflection_subgroup(W,R)</code> are abelian subgroups, and <code>W=reflection_subgroup(W,   vcat(L,R))</code>.   Gives   an   error  if  no  such decomposition is possible.</p><pre><code class="language-julia-repl hljs">julia&gt; bipartite_decomposition(coxgroup(:E,8))
([1, 4, 6, 8], [3, 2, 5, 7])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L911-L925">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.catalan-Tuple{Any, Any}" href="#Gapjm.Combinat.catalan-Tuple{Any, Any}"><code>Gapjm.Combinat.catalan</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Catalan(W)</code></p><p>returns the Catalan Number of the irreducible complex reflection group <code>W</code>. For well-generated groups, this number is equal to the number of simples in the  dual Braid  monoid. For  other groups  it was  defined by  <a href="biblio.htm#gg12">Gordon and Griffeth2012</a>.  For Weyl groups, it also counts the number of antichains of roots.</p><pre><code class="language-julia-repl hljs">julia&gt; catalan(coxgroup(:A,7))
1430</code></pre><p><code>Catalan(W,i)</code></p><p>returns   the  <code>i</code>-th  Fuss-Catalan  Number   of  the  irreducible  complex reflection  group <code>W</code>. For  well-generated groups, this  number is equal to the  number of chains  <code>s₁,…,sᵢ</code> of simples  in the dual  monoid where <code>sⱼ</code> divides  <code>sⱼ₊₁</code>. For these groups, it is also equal to <code>∏ⱼ(ih+dⱼ)/dⱼ</code> where the  product runs over the reflection degrees  of <code>W</code>, and where <code>h</code> is the Coxeter  number of <code>W</code>. For non-well generated groups, the definition is in <a href="biblio.htm#gg12">Gordon and Griffeth2012</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; catalan(ComplexReflectionGroup(7),2)
16</code></pre><p><code>Catalan(W;q=1)</code>, resp. <code>Catalan(W,i;q=1)</code></p><p>for  <code>q</code>  a  variable  (like  <code>Pol()</code>  or an &#39;Mvp&#39;) returns the <code>q</code>-Catalan number  (resp.  the  <code>i</code>-th  <code>q</code>-Fuss  Catalan  number)  of  <code>W</code>. Again the definitions in general are in <a href="biblio.htm#gg12">Gordon and Griffeth2012</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; catalan(ComplexReflectionGroup(7),2;q=Pol())
Pol{Int64}: q⁷²+2q⁶⁰+3q⁴⁸+4q³⁶+3q²⁴+2q¹²+1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1670-L1709">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflrep-Tuple{PermRootGroup, Any}" href="#Gapjm.PermRoot.reflrep-Tuple{PermRootGroup, Any}"><code>Gapjm.PermRoot.reflrep</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflrep(W,w)</code>  Reflection representation</p><p>Let  <code>W</code> be a  finite reflection group  on the space  <code>V</code> and let  <code>w</code> be a permutation  of the roots of <code>W</code>. The function <code>reflrep</code> returns the matrix of  <code>w</code> acting on <code>V</code>. This is  the linear transformation of <code>V</code> which acts trivially  on the orthogonal of  the coroots and has  same effect as <code>w</code> on the simple roots. The function makes sense more generally for an element of the normalizer of <code>W</code> in the whole permutation group of the roots.</p><pre><code class="language-julia-repl hljs">julia&gt; W=reflection_subgroup(rootdatum(&quot;E7sc&quot;),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia&gt; reflrep(W,longest(W))
7×7 Matrix{Int64}:
  0   0   0   0   0  -1  2
  0  -1   0   0   0   0  2
  0   0   0   0  -1   0  3
  0   0   0  -1   0   0  4
  0   0  -1   0   0   0  3
 -1   0   0   0   0   0  2
  0   0   0   0   0   0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1390-L1414">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflrep-Tuple{PRG}" href="#Gapjm.PermRoot.reflrep-Tuple{PRG}"><code>Gapjm.PermRoot.reflrep</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflrep(W)</code> returns the list of <code>reflrep(W,x)</code> for <code>x</code> in <code>gens(W)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflrep-Tuple{PRG, Integer}" href="#Gapjm.PermRoot.reflrep-Tuple{PRG, Integer}"><code>Gapjm.PermRoot.reflrep</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflrep(W,i)</code> same as but better than <code>reflrep(W,W(i))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.PermX" href="#Gapjm.PermRoot.PermX"><code>Gapjm.PermRoot.PermX</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>PermX(W,M::AbstractMatrix)</code></p><p>Let  <code>M</code> be  a linear  transformation of  reflection representation  of <code>W</code> which  preserves the set  of roots of  <code>parent(W)</code>, and normalizes <code>W</code> (for the  action of  matrices on  the right).  <code>PermX</code> returns the corresponding permutation  of the roots of <code>parent(W)</code>;  it returns <code>nothing</code> if <code>M</code> does not normalize the set of roots.</p><pre><code class="language-julia-repl hljs">julia&gt; W=reflection_subgroup(rootdatum(&quot;E7sc&quot;),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia&gt; PermX(W,reflrep(W,longest(W)))==longest(W)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1209-L1225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflections" href="#Gapjm.PermRoot.reflections"><code>Gapjm.PermRoot.reflections</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reflections(W)</code></p><p>list of same length as <code>W.roots</code> giving the corresponding reflections. In particular this list is much longer than <code>unique(reflections(W))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L469-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.refleigen" href="#Gapjm.PermRoot.refleigen"><code>Gapjm.PermRoot.refleigen</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>refleigen(W)</code> Reflection eigenvalues</p><p>Let  <code>W</code>  be  a  reflection  group  on the vector space <code>V</code>. <code>refleigen(W)</code> returns   for  each  conjugacy   class  representative  <code>x</code>   of  <code>W</code>  (see <code>classreps</code>) the eigenvalues of <code>x</code> on <code>V</code>, as a list of <code>Root1</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; refleigen(coxgroup(:B,2))
5-element Vector{Vector{Root1}}:
 [1, 1]
 [1, -1]
 [-1, -1]
 [1, -1]
 [ζ₄, ζ₄³]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L986-L1002">source</a></section><section><div><p><code>refleigen(W,i)</code> faster than <code>refleigen(W)[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1032">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflchar" href="#Gapjm.PermRoot.reflchar"><code>Gapjm.PermRoot.reflchar</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reflchar(W,w)</code> Reflection character</p><p>Returns  the trace  of the  element <code>w</code>  of the  reflection group <code>W</code> as an endomorphism of the vector space <code>V</code> on which <code>W</code> acts. This is the same as <code>trace(reflrep(W,w))</code>.</p><p>julia-repl``` julia&gt; W=coxgroup(:B,3) B₃</p><p>julia&gt; reflchar(W,longest(W)) -3 julia-repl```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L950-L964">source</a></section><section><div><p><code>reflchar(W)</code></p><p>Returns  the reflection character of the  reflection group <code>W</code>. This is the same  as <code>map(c-&gt;reflchar(W,c),class-reps(W))</code>. When <code>W</code> is irreducible, it is also <code>CharTable(W).irr[charinfo(W).extRefl[2]]</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; reflchar(coxgroup(:A,3))
5-element Vector{Int64}:
  3
  1
 -1
  0
 -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L967-L983">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.simple_conjugating" href="#Gapjm.PermRoot.simple_conjugating"><code>Gapjm.PermRoot.simple_conjugating</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>simple_conjugating(W)</code></p><p>For each root <code>i</code>, an element conjugating it to <code>simple_reps(W,i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L484-L488">source</a></section><section><div><p><code>simple_conjugating(W,i)</code></p><p>an element <code>w</code> such that <code>simple_reps(W,i)^w==i</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L491-L495">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.simple_reps" href="#Gapjm.PermRoot.simple_reps"><code>Gapjm.PermRoot.simple_reps</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>simple_reps(W)</code></p><p>for each root, the index of the first simple root conjugate to it</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L438-L442">source</a></section><section><div><p><code>simple_reps(W,i)</code></p><p>the  smallest index  of a root in the same <code>W</code>-orbit as the <code>i</code>-th root.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L462-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.invariant_form" href="#Gapjm.PermRoot.invariant_form"><code>Gapjm.PermRoot.invariant_form</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>invariant_form(W)</code></p><p>This  function returns the matrix <code>F</code>  of an Hermitian form invariant under the action of the reflection group <code>W</code>. That is, if <code>M</code> is the matrix of an element of <code>W</code>, then <code>M*F*M&#39;=F</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=ComplexReflectionGroup(4)
G₄

julia&gt; invariant_form(W)
2×2 Matrix{Int64}:
 1  0
 0  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1774-L1790">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.invariants" href="#Gapjm.PermRoot.invariants"><code>Gapjm.PermRoot.invariants</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>invariants(W)</code></p><p>returns  the fundamental invariants of <code>W</code> in its reflection representation <code>V</code>.  That is, returns  a set of  algebraically independent elements of the symmetric  algebra  of  the  dual  of  <code>V</code> which generate the <code>W</code>-invariant polynomial  functions on <code>V</code>. Each such invariant function is returned as a function:  if <code>e₁,…,eₙ</code> is a basis of <code>V</code> and <code>f</code> is the function, then the value  of the polynomial  function on <code>a₁e₁+…+aₙeₙ</code>  is obtained by calling <code>f(a₁,…,aₙ)</code>. This function depends on the classification, and is dependent on the exact reflection representation of <code>W</code>. So for the moment it is only implemented   when  the  reflection   representation  for  the  irreducible components has the same Cartan matrix as the one provided by Chevie for the corresponding  irreducible  group.  The  polynomials  are invariant for the natural   action  of   the  group   elements  as   matrices;  that  is,  if <code>m==reflrep(W,w)</code>  for some  <code>w</code> in  <code>W</code>, then  an invariant  <code>f</code> satisfies <code>f(a₁,…,aₙ)=f(v₁,…,vₙ)</code>   where  <code>[v₁,…,vₙ]=[a₁,…,aₙ]×m</code>.  This  action  is implemented on <code>Mvp</code>s by the function <code>^</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; @Mvp x,y,z

julia&gt; i=invariants(W);

julia&gt; i[1](x,y)
Mvp{Int64}: -2x²+2xy-2y²

julia&gt; i[2](x,y)
Mvp{Int64}: 6x²y-6xy²

julia&gt; W=ComplexReflectionGroup(24)
G₂₄

julia&gt; i=invariants(W)[1];

julia&gt; p=i(x,y,z)
Mvp{Rational{Int64}}: (14//1)x⁴+(-12//1)x²y²+(-42//1)x²yz+(21//2)x²z²+(18//7)y⁴+(-6//1)y³z+(-9//2)y²z²+(-21//8)z⁴

julia&gt; p^reflrep(W,1)-p
Mvp{Cyc{Rational{Int64}}}: 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1841-L1885">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.generic_order" href="#Gapjm.PermRoot.generic_order"><code>Gapjm.PermRoot.generic_order</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>generic_order(W,q)</code></p><p>returns  the &quot;compact&quot; generic order of <code>W</code> as a polynomial in <code>q</code>. This is <code>q^(Nₕ)Πᵢ(q^(dᵢ)-1)</code>  where <code>dᵢ</code>  are the  reflection degrees  and <code>Nₕ</code> the number  of reflecting hyperplanes. For a Weyl group, it is the order of the associated  semisimple  finite  reductive  group  over  the  field with <code>q</code> elements.</p><pre><code class="language-julia-repl hljs">julia&gt; @Pol q
Pol{Int64}: q

julia&gt; PermRoot.generic_order(ComplexReflectionGroup(4),q)
Pol{Int64}: q¹⁴-q¹⁰-q⁸+q⁴</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1822-L1838">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.torus_order" href="#Gapjm.PermRoot.torus_order"><code>Gapjm.PermRoot.torus_order</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>torus_order(W,i,q)</code></p><p>returns  as a  polynomial in  <code>q</code> the  toric order  of the <code>i</code>-th conjugacy class  of <code>W</code>. This is the characteristic  polynomial of an element of that class  on  the  reflection  representation  of  <code>W</code>.  It is the same as the generic  order of the reflection subcoset  of <code>W</code> determined by the trivial subgroup and a representative of the <code>i</code>-th conjugacy class.</p><pre><code class="language-julia-repr hljs">julia&gt; W=ComplexReflectionGroup(4)

julia&gt; torus_order.(Ref(W),1:HasType.NrConjugacyClasses(W),Pol(:q))
7-element Vector{Pol{Cyc{Int64}}}:
 q²-2q+1
 q²+2q+1
 q²+1
 q²-ζ₃q+ζ₃²
 q²+ζ₃q+ζ₃²
 q²+ζ₃²q+ζ₃
 q²-ζ₃²q+ζ₃</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1060-L1082">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.parabolic_reps" href="#Gapjm.PermRoot.parabolic_reps"><code>Gapjm.PermRoot.parabolic_reps</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>parabolic_reps(W)</code></p><p>Returns  a list  of indices  of roots  of <code>W</code> describing representatives of orbits of parabolic subgroups under conjugation by <code>W</code>. For Coxeter groups, each   orbit  has   a  representative   whose  indices   is  a   subset  of <code>eachindex(gens(W))</code>. This may not be the case in general.</p><pre><code class="language-julia-repl hljs">julia&gt; parabolic_reps(coxgroup(:A,4))
7-element Vector{Vector{Int64}}:
 []
 [1]
 [1, 2]
 [1, 3]
 [1, 2, 3]
 [1, 2, 4]
 [1, 2, 3, 4]</code></pre><p>gap&gt; ParabolicRepresentatives(ComplexReflectionGroup(3,3,3)); [ [  ], [ 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 20 ], [ 2, 3 ], [ 1, 2, 3 ] ]</p><p><code>parabolic_reps(W,r)</code></p><p>If  a second  argument <code>r</code>  is given,  returns only  representatives of the parabolic subgroups of semisimple rank <code>r</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; parabolic_reps(coxgroup(:A,4),2)
2-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]</code></pre><p>gap&gt; ParabolicRepresentatives(ComplexReflectionGroup(3,3,3),2); [ [ 1, 2 ], [ 1, 3 ], [ 1, 20 ], [ 2, 3 ] ]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1285-L1319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.parabolic_closure" href="#Gapjm.PermRoot.parabolic_closure"><code>Gapjm.PermRoot.parabolic_closure</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>parabolic_closure(W,I)</code></p><p><code>I</code>  should be a  list of indices  of reflections of  <code>W</code>. Returns <code>J</code> such that  <code>reflection_subgroup(W,J)</code> is the smallest  parabolic subgroup of <code>W</code> containing <code>reflection_subgroup(W,I)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=ComplexReflectionGroup(7)
G₇

julia&gt; parabolic_closure(W,[1])
1-element Vector{Int64}:
 1

julia&gt; parabolic_closure(W,[1,2])
3-element Vector{Int64}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1451-L1472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.is_parabolic" href="#Gapjm.PermRoot.is_parabolic"><code>Gapjm.PermRoot.is_parabolic</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>is_parabolic(W)</code></p><p>whether the reflection group <code>W</code> is a parabolic subgroup of <code>parent(W)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=ComplexReflectionGroup(7)
G₇

julia&gt; is_parabolic(reflection_subgroup(W,[1,2]))
false

julia&gt; is_parabolic(reflection_subgroup(W,[1]))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/PermRoot.jl#L1426-L1441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.ComplexR.ComplexReflectionGroup" href="#Gapjm.ComplexR.ComplexReflectionGroup"><code>Gapjm.ComplexR.ComplexReflectionGroup</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>ComplexReflectionGroup(STnumber)</code></p><p><code>ComplexReflectionGroup(p,q,r)</code></p><p>The  first form of <code>ComplexReflectionGroup</code>  returns the complex reflection group which has Shephard-Todd number <code>STnumber</code>, see <a href="biblio.htm#ST54">Shephard-Todd1954</a>.   The   second   form   returns   the imprimitive complex reflection group <code>G(p,q,r)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; G=ComplexReflectionGroup(4)
G₄

julia&gt; degrees(G)
2-element Vector{Int64}:
 4
 6

julia&gt; length(G)
24

julia&gt; fakedegrees(G,Pol(:q))
7-element Vector{Pol{Int64}}:
 1       
 q⁴      
 q⁸      
 q⁷+q⁵   
 q⁵+q³   
 q³+q    
 q⁶+q⁴+q²

julia&gt; ComplexReflectionGroup(2,1,6)
B₆</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/ComplexR.jl#L22-L57">source</a></section></article><h1 id="Hecke-algebras"><a class="docs-heading-anchor" href="#Hecke-algebras">Hecke algebras</a><a id="Hecke-algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Hecke-algebras" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras" href="#Gapjm.HeckeAlgebras"><code>Gapjm.HeckeAlgebras</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This   module  ports   Chevie  functionality   for  Iwahori-Hecke  algebras associated to Coxeter groups.</p><p>Let  (W,S) be a Coxeter  system where <code>mₛₜ</code> is  the order of <code>st</code> for <code>s,t∈ S</code>. Let <code>R</code> be a commutative ring with 1 and for <code>s∈ S</code> let <code>uₛ₀,uₛ₁∈ R</code> be elements which depend ony on the conjugacy class of <code>s</code> in <code>W</code> (this is the same  as requiring that <code>uₛᵢ=uₜᵢ</code> whenever <code>mₛₜ</code> is odd). The Iwahori-Hecke algebra of <code>W</code> over <code>R</code> with parameters <code>uₛᵢ</code> is a deformation of the group algebra  of <code>W</code> over <code>R</code> defined as  follows: it is the unitary associative <code>R</code>-algebra generated by elements <code>Tₛ, s∈ S</code> subject to the relations:</p><p><span>$(Tₛ-uₛ₀)(Tₛ-uₛ₁)=0$</span> for all <code>s∈ S</code> (the quadratic relations)</p><p><span>$TₛTₜTₛ…= TₜTₛTₜ…$</span> with <code>mₛₜ</code> factors on each side (the braid relations)</p><p>If  <code>uₛ₀=1</code> and  <code>uₛ₁=-1</code> for  all <code>s</code>  then the quadratic relations become <code>Tₛ²=1</code> and the deformation of the group algebra is trivial.</p><p>Since  the generators <code>Tₛ</code> satisfy the  braid relations, the algebra <code>H</code> is in  fact a quotient of the group algebra of the braid group associated with <code>W</code>.  It follows that, if <code>w=s_1⋯ s_m</code>  is a reduced expression of <code>w ∈ W</code> then  the  product  <code>Tₛ_1⋯ Tₛ_m</code>  depends  only  on <code>w</code>. We will therefore denote by <code>T_w</code>. We have <code>T_1=1</code>.</p><p>If  one of <code>uₛ₀</code> or <code>uₛ₁</code> is invertible  in <code>R</code>, for example <code>uₛ₁</code>, then by changing  the generators  to <code>T′ₛ=-Tₛ/uₛ₁</code>,  and setting <code>qₛ=-uₛ₀/uₛ₁</code>, the braid  relations do no change  (since when <code>mₛₜ</code> is  odd we have <code>uₛᵢ=uₜᵢ</code>) but  the quadratic relations become  <code>(T′ₛ-qₛ)(T′ₛ+1)=0</code>. This last form is the  most common  form considered  in the  literature. Another common form, considered  in  the  context  of  Kazhdan-Lusztig  theory, is <code>uₛ₀=√qₛ</code> and <code>uₛ₁=-√qₛ⁻¹</code>.  The general form of parameters provided is a special case of general cyclotomic Hecke algebras, and can be useful in many contexts.</p><p>For  some  algebras  the  character  table,  and in general Kazhdan-Lusztig bases,  require a square root of <code>-uₛ₀uₛ₁</code>.  We provide a way to specify it with  the  field  <code>.rootpara</code>  which  can  be  given  when constructing the algebra. If not given a root is automatically extracted when needed (and we know  how to compute it) by the function <code>RootParameter</code>. Note however that sometimes  an  explicit  choice  of  root  is  necessary  which  cannot  be automatically determined.</p><p>There  is a universal choice  for <code>R</code> and <code>uₛᵢ</code>:  Let <code>uₛᵢ:s∈ S,i∈[0,1]</code> be indeterminates   such  that  <code>uₛᵢ=uₜᵢ</code>  whenever  <code>mₛₜ</code>  is  odd,  and  let <code>A=ℤ[uₛᵢ]</code> be the corresponding polynomial ring. Then the Hecke algebra <code>H</code> of  <code>W</code> over a  with parameters <code>uₛᵢ</code>  is called the <em>generic Iwahori-Hecke algebra</em>  of  with  <code>W</code>.  Any  other  algebra  with parameters <code>vₛᵢ</code> can be obtained  by specialization from  <code>H</code>: There is  a unique ring homomorphism <code>f:A  → R</code> such that <code>f(uₛᵢ)=vₛᵢ</code>  for all <code>i</code>. Then we  can view <code>R</code> as an <code>A</code>-module via <code>f</code> and we can identify the other algebra to <span>$R⊗ _A H$</span>.</p><p>The  elements <code>{T_w∣w∈ W}</code> actually form an  <code>R</code>-basis of <code>H</code> if one of the <code>uₛᵢ</code>  is invertible for all <code>s</code>. The  structure constants in that basis is obtained  as  follows.  To  multiply  <code>T_v</code>  by  <code>T_w</code>,  choose  a  reduced expression for <code>v</code>, say <code>v=s_1 ⋯ s_k</code> and apply inductively the formula:</p><p><span>$T_sT_w=T_{sw}$</span>               if <code>l(sw)=l(w)+1</code></p><p><span>$T_sT_w=-uₛ₀uₛ₁T_{sw}+(uₛ₀+uₛ₁)T_w$</span> if <code>l(sw)=l(w)-1</code>.</p><p>If all <code>s</code> we have <code>uₛ₀=q</code>, <code>uₛ₁=-1</code> then we call the corresponding algebra the one-parameter or Spetsial Iwahori-Hecke algebra associated with <code>W</code>; it can  be obtained with the  simplified call &#39;hecke(W,q)&#39;. Certain invariants of  the irreducible characters of  this algebra play a  special role in the representation  theory of the underlying  finite Coxeter groups, namely the <code>a</code>- and <code>A</code>-invariants. For basic properties of Iwahori-Hecke algebras and their  relevance to the representation theory of finite groups of Lie type, see for example Curtis and Reiner 1987, Sections~67 and 68.</p><p>In  the  following  example,  we  compute  the multiplication table for the <code>0</code>-Iwahori–Hecke algebra associated with the Coxeter group of type <code>A_2</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; H=hecke(W,0)            # One-parameter algebra with `q=0`
hecke(A₂,0)

julia&gt; T=Tbasis(H);            # Create the `T` basis

julia&gt; el=words(W)
6-element Vector{Vector{Int8}}:
 []       
 [2]      
 [1]      
 [2, 1]   
 [1, 2]   
 [1, 2, 1]

julia&gt; T.(el)*permutedims(T.(el))        # multiplication table
6×6 Matrix{HeckeTElt{Perm{Int16}, Int64, HeckeAlgebra{Int64, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 T.    T₂     T₁     T₂₁    T₁₂    T₁₂₁ 
 T₂    -T₂    T₂₁    -T₂₁   T₁₂₁   -T₁₂₁
 T₁    T₁₂    -T₁    T₁₂₁   -T₁₂   -T₁₂₁
 T₂₁   T₁₂₁   -T₂₁   -T₁₂₁  -T₁₂₁  T₁₂₁ 
 T₁₂   -T₁₂   T₁₂₁   -T₁₂₁  -T₁₂₁  T₁₂₁ 
 T₁₂₁  -T₁₂₁  -T₁₂₁  T₁₂₁   T₁₂₁   -T₁₂₁
</code></pre><p>Thus,  we work  with algebras  with arbitrary  parameters. We will see that this also works on the level of characters and representations.</p><p>finally, benchmarks on julia 1.0.2</p><pre><code class="language-benchmark hljs">julia&gt; function test_w0(n)
         W=coxgroup(:A,n)
         Tbasis(hecke(W,Pol()))(longest(W))^2
       end
test_w0 (generic function with 1 method)

julia&gt; @btime test_w0(7);
  132.737 ms (1788153 allocations: 157.37 MiB)</code></pre><p>Compare to GAP3 where the following function takes 0.92s</p><pre><code class="nohighlight hljs">test_w0:=function(n)local W,T,H;
  W:=CoxeterGroup(&quot;A&quot;,n);H:=Hecke(W,X(Rationals));T:=Basis(H,&quot;T&quot;);
  T(LongestCoxeterWord(W))^2;
end;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/HeckeAlgebras.jl#L1-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.hecke" href="#Gapjm.HeckeAlgebras.hecke"><code>Gapjm.HeckeAlgebras.hecke</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>hecke( W [, parameter][,rootpara=r])</code></p><p>Hecke  algebra for the complex reflection group or Coxeter group <code>W</code>. If no <code>parameter</code> is given, <code>1</code> is assumed which gives the group algebra of <code>W</code>.</p><p>The  following forms are accepted for  <code>parameter</code>: if <code>parameter</code> is not a vector,  it is  replaced by  <code>fill(parameter,ngens(W))</code>. If  it is a vector with   one  entry,  it   is  replaced  with  <code>fill(parameter[1],ngens(W))</code>. Otherwise,  <code>parameter</code> should be  a list of  length <code>ngens(W)</code>. Entries of <code>parameter</code>  corresponding to  the same  <code>W</code>-orbit of  generators should be identical.  <code>parameter</code> can be shorter than <code>ngens(W)</code> provided there is at least one entry bound for each orbit of reflections.</p><p>An  entry in  <code>parameter</code> for  a reflection  of order  <code>e</code> can  be either a single  value or  a <code>Vector</code>  of length  &#39;e&#39;. If  it is  a <code>Vector</code>,  it is interpreted as the list <code>[u₀,…,u_(e-1)]</code> of parameters for that reflection. If  it is a single  value <code>q</code>, it is  interpreted as the partly specialized list of parameters <code>[q,ζ_e,…,ζ_{e-1}]</code> (thus <code>[q,-1]</code> for Coxeter groups).</p><p>Computing characters or representations of Hecke algebra needs sometimes to extract  roots of the  parameters. These roots  are extracted automatically (when  possible). For Coxeter groups it  is possible to give explicit roots by  giving a keyword argument <code>rootpara</code>:  it should be a vector containing at  the <code>i</code>-th position a square root of <code>-parameter[i][1]*parameter[i][2]</code> (if <code>rootpara</code> is not a <code>Vector</code> it is replaced by <code>fill(rootpara,ngens(W))</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; @Pol q
Pol{Int64}: q

julia&gt; H=hecke(W,q)
hecke(B₂,q)

julia&gt; H.para
2-element Vector{Vector{Pol{Int64}}}:
 [q, -1]
 [q, -1]

julia&gt; H=hecke(W,q^2,rootpara=q)
hecke(B₂,q²,rootpara=q)

julia&gt; H.para,rootpara(H)
(Vector{Pol{Int64}}[[q², -1], [q², -1]], Pol{Int64}[q, q])

julia&gt; H=hecke(W,[q^2,q^4],rootpara=[q,q^2])
hecke(B₂,Pol{Int64}[q², q⁴],rootpara=Pol{Int64}[q, q²])

julia&gt; H.para,rootpara(H)
(Vector{Pol{Int64}}[[q², -1], [q⁴, -1]], Pol{Int64}[q, q²])

julia&gt; H=hecke(W,9,rootpara=3)
hecke(B₂,9,rootpara=3)

julia&gt; H.para,rootpara(H)
([[9, -1], [9, -1]], [3, 3])

julia&gt; @Mvp x,y,z,t

julia&gt; H=hecke(W,[[x,y]])
hecke(B₂,Vector{Mvp{Int64, Int64}}[[x, y]])

julia&gt; H.para,rootpara(H)
(Vector{Mvp{Int64, Int64}}[[x, y], [x, y]], Mvp{Cyc{Int64}, Rational{Int64}}[ζ₄x½y½, ζ₄x½y½])

julia&gt; H=hecke(W,[[x,y],[z,t]])
hecke(B₂,Vector{Mvp{Int64, Int64}}[[x, y], [z, t]])

julia&gt; H.para,rootpara(H)
(Vector{Mvp{Int64, Int64}}[[x, y], [z, t]], Mvp{Cyc{Int64}, Rational{Int64}}[ζ₄x½y½, ζ₄t½z½])

julia&gt; hecke(ComplexReflectionGroup(3,1,2),q).para
2-element Vector{Vector{Pol{Cyc{Int64}}}}:
 [q, ζ₃, ζ₃²]
 [q, -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/HeckeAlgebras.jl#L135-L216">source</a></section><section><div><p><code>hecke(WF::Spets, H)</code></p><p><code>hecke(WF::Spets, params)</code></p><p>Construct  a <code>HeckeCoset</code>  from a  Coxeter coset  <code>WF</code> and an Hecke algebra associated  to the CoxeterGroup  of <code>WF</code>. The  second form is equivalent to <code>Hecke(WF,Hecke(Group(WF),params))</code>. See the doc for <code>HeckeCoset</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/HeckeAlgebras.jl#L1076-L1084">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.central_monomials" href="#Gapjm.HeckeAlgebras.central_monomials"><code>Gapjm.HeckeAlgebras.central_monomials</code></a> — <span class="docstring-category">Function</span></header><section><div><p>central_monomials(H)   Let  <code>H</code> be an Hecke  algebra for the reflection  group <code>W</code>. The function   returns  the  scalars  by  which  the  image  in  <code>H</code>  of  π  acts on the   irreducible  representations of  the Iwahori-Hecke  algebra. When  <code>W</code> is   irreducible, π is the generator of the center of the pure braid group. In   general,  it  is  the  product  of  such  elements  for  each irreducible   component. When <code>W</code> is an irreducible Coxeter group, π is the lift to the   braid group of the square of the longest element of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(coxgroup(:H,3),Pol(:q))
hecke(H₃,q)

julia&gt; central_monomials(H)
10-element Vector{Pol{Cyc{Int64}}}:
 1  
 q³⁰
 q¹²
 q¹⁸
 q¹⁰
 q¹⁰
 q²⁰
 q²⁰
 q¹⁵
 q¹⁵</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/HeckeAlgebras.jl#L463-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.class_polynomials" href="#Gapjm.HeckeAlgebras.class_polynomials"><code>Gapjm.HeckeAlgebras.class_polynomials</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>class_polynomials(h)</code></p><p>returns the class polynomials of the Hecke element <code>h</code> of the Hecke algebra <code>H=h.H</code>  with respect  to representatives  <code>reps</code> of  minimal length in the conjugacy  classes  of  the  Coxeter  group  <code>W=H.W</code>.  Such  minimal length representatives  are given by  the function <code>classinfo(W)[:classtext]</code>. The vector  <code>p</code> of these polynomials has the property that if <code>X</code> is the matrix of  the values of  the irreducible characters  of <code>H</code> on  <code>T_w</code> (for <code>w</code> in <code>reps</code>),  then the product <code>X*p</code>  is the list of  values of the irreducible characters on <code>h</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=CoxSym(4)
𝔖 ₄

julia&gt; H=hecke(W,Pol(:q))
hecke(𝔖 ₄,q)

julia&gt; h=Tbasis(H,longest(W))
T₁₂₁₃₂₁

julia&gt; p=class_polynomials(h)
5-element Vector{Pol{Int64}}:
 0        
 0        
 q²       
 q³-2q²+q 
 q³-q²+q-1</code></pre><p>The class polynomials were introduced in <a href="biblio.htm#GP93">Geck-Pfeiffer1993</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/HeckeAlgebras.jl#L671-L703">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.char_values" href="#Gapjm.HeckeAlgebras.char_values"><code>Gapjm.HeckeAlgebras.char_values</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>char_values(h)</code></p><p><code>h</code>  is an  element of  an Iwahori-Hecke  algebra <code>H</code>  (in any  basis). The function  returns the  values of  the irreducible  characters of <code>H</code> on <code>h</code> (the   method  used  is  to  convert  to   the  <code>T</code>  basis,  and  then  use <code>class_polynomials</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; H=hecke(W,q^2;rootpara=q)
hecke(B₂,q²,rootpara=q)

julia&gt; char_values(Cpbasis(H)(1,2,1))
5-element Vector{Pol{Int64}}:
 -q-q⁻¹        
 q+q⁻¹         
 0             
 q³+2q+2q⁻¹+q⁻³
 0             </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/HeckeAlgebras.jl#L759-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.alt" href="#Gapjm.HeckeAlgebras.alt"><code>Gapjm.HeckeAlgebras.alt</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>alt(a::HeckeTElt)</code></p><p>the  involution on the Hecke algebra defined by <code>x↦ bar(x)</code> on coefficients and <code>Tₛ↦ uₛ,₀uₛ,₁Tₛ</code>. Essentially it corresponds to tensoring with the sign representation.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2);H=hecke(W,Pol(:q))
hecke(G₂,q)

julia&gt; T=Tbasis(H);h=T(1,2)*T(2,1)
q²T.+(q²-q)T₁+(q-1)T₁₂₁

julia&gt; alt(h)
q⁻²T.+(q⁻²-q⁻³)T₁+(q⁻³-q⁻⁴)T₁₂₁</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/HeckeAlgebras.jl#L641-L658">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.α-Tuple{HeckeTElt}" href="#Gapjm.Garside.α-Tuple{HeckeTElt}"><code>Gapjm.Garside.α</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>α(a::HeckeTElt)</code></p><p>the anti-involution on the Hecke algebra defined by <code>T_w↦T_inv(w)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/HeckeAlgebras.jl#L664-L668">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.schur_elements" href="#Gapjm.HeckeAlgebras.schur_elements"><code>Gapjm.HeckeAlgebras.schur_elements</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>schur_elements(H)</code></p><p>returns the list of Schur elements for the (cyclotomic) Hecke algebra <code>H</code></p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(ComplexReflectionGroup(4),Pol(:q))
hecke(G₄,q)

julia&gt; s=schur_elements(H)
7-element Vector{Pol{Cyc{Rational{Int64}}}}:
 q⁸+2q⁷+3q⁶+4q⁵+4q⁴+4q³+3q²+2q+1              
 2√-3+(6+4√-3)q⁻¹+12q⁻²+(6-4√-3)q⁻³-2√-3q⁻⁴
 -2√-3+(6-4√-3)q⁻¹+12q⁻²+(6+4√-3)q⁻³+2√-3q⁻⁴
 2+2q⁻¹+4q⁻²+2q⁻³+2q⁻⁴
 ζ₃²√-3q³+(3-√-3)q²+3q+3+√-3-ζ₃√-3q⁻¹
 -ζ₃√-3q³+(3+√-3)q²+3q+3-√-3+ζ₃²√-3q⁻¹
 q²+2q+2+2q⁻¹+q⁻²

julia&gt; CycPol.(s)
7-element Vector{CycPol{Cyc{Rational{Int64}}}}:
 Φ₂²Φ₃Φ₄Φ₆
 2√-3q⁻⁴Φ₂²Φ′₃Φ′₆
 -2√-3q⁻⁴Φ₂²Φ″₃Φ″₆
 2q⁻⁴Φ₃Φ₄
 ζ₃²√-3q⁻¹Φ₂²Φ′₃Φ″₆
 -ζ₃√-3q⁻¹Φ₂²Φ″₃Φ′₆
 q⁻²Φ₂²Φ₄</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/HeckeAlgebras.jl#L804-L833">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.FactorizedSchurElement" href="#Gapjm.HeckeAlgebras.FactorizedSchurElement"><code>Gapjm.HeckeAlgebras.FactorizedSchurElement</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>FactorizedSchurElement(H,phi)</code></p><p>returns  the factorized <code>schur_element</code>  (see <code>FactorizedSchurElements</code>) of the  Hecke algebra  <code>H</code> for  the irreducible  character of <code>H</code> of parameter <code>phi</code> (see <code>charinfo(W).charparams</code>)</p><pre><code class="language-julia-repl hljs">julia&gt; W=ComplexReflectionGroup(4)
G₄

julia&gt; @Mvp x,y; H=hecke(W,[[1,x,y]])
hecke(G₄,Vector{Mvp{Int64, Int64}}[[1, x, y]])

julia&gt; FactorizedSchurElement(H,[[2,5]])
-x⁻¹yΦ₂(xy)Φ₁(x)Φ₆(xy⁻¹)Φ₁(y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/HeckeAlgebras.jl#L985-L1002">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.FactorizedSchurElements" href="#Gapjm.HeckeAlgebras.FactorizedSchurElements"><code>Gapjm.HeckeAlgebras.FactorizedSchurElements</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>FactorizedSchurElements(H)</code></p><p>Let  <code>H</code> be  a Hecke  algebra for  the complex  reflection group <code>W</code>, whose parameters are all (Laurent) monomials in some variables <code>x₁,…,xₙ</code>, and let K  be the field of definition of <code>W</code>. Then Maria Chlouveraki has shown that the  Schur elements  of <code>H</code>  then take  the particular  form <code>M ∏_Φ Φ(M_Φ)</code> where  <code>Φ</code> runs over a list of  K-cyclotomic polynomials, and <code>M</code> and <code>M_Φ</code> are  (Laurent)  monomials  (in  possibly  some  fractional  powers)  of the variables  <code>xᵢ</code>.  The  function  <code>FactorizedSchurElements</code>  returns  a data structure which shows this factorization.</p><pre><code class="language-julia-repl hljs">julia&gt; W=ComplexReflectionGroup(4)
G₄

julia&gt; @Mvp x,y; H=hecke(W,[[1,x,y]])
hecke(G₄,Vector{Mvp{Int64, Int64}}[[1, x, y]])

julia&gt; FactorizedSchurElements(H)
7-element Vector{Gapjm.HeckeAlgebras.FactSchur}:
 x⁻⁴y⁻⁴Φ₂(xy)Φ₁Φ₆(x)Φ₁Φ₆(y)
 Φ₂(x²y⁻¹)Φ₁Φ₆(x)Φ₁Φ₆(xy⁻¹)
 -x⁻⁴y⁵Φ₁Φ₆(xy⁻¹)Φ₂(xy⁻²)Φ₁Φ₆(y)
 -x⁻¹yΦ₂(xy)Φ₁(x)Φ₆(xy⁻¹)Φ₁(y)
 -x⁻⁴yΦ₂(x²y⁻¹)Φ₁(x)Φ₁(xy⁻¹)Φ₆(y)
 x⁻¹y⁻¹Φ₆(x)Φ₁(xy⁻¹)Φ₂(xy⁻²)Φ₁(y)
 x⁻²yΦ₂(x²y⁻¹)Φ₂(xy)Φ₂(xy⁻²)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/HeckeAlgebras.jl#L1013-L1042">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.isrepresentation" href="#Gapjm.HeckeAlgebras.isrepresentation"><code>Gapjm.HeckeAlgebras.isrepresentation</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>isrepresentation(H::HeckeAlgebra,r)</code></p><p>returns <code>true</code> or <code>false</code>, according to whether a given set <code>r</code> of elements corresponding  to  the  standard  generators  of the reflection group <code>H.W</code> defines a representation of the Hecke algebra <code>H</code> or not.</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(coxgroup(:F,4))
hecke(F₄,1)

julia&gt; isrepresentation(H,reflrep(H))
true

julia&gt; isrepresentation(H,Tbasis(H).(1:4))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/HeckeAlgebras.jl#L335-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflrep-Tuple{HeckeAlgebra}" href="#Gapjm.PermRoot.reflrep-Tuple{HeckeAlgebra}"><code>Gapjm.PermRoot.reflrep</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflrep(H)</code></p><p>returns  a list of matrices which give the reflection representation of the Iwahori-Hecke algebra <code>H</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2);H=hecke(W,Pol(:q))
hecke(B₂,q)

julia&gt; reflrep(H)
2-element Vector{Matrix{Pol{Int64}}}:
 [-1 0; -q q]
 [q -2; 0 -1]

julia&gt; H=hecke(coxgroup(:H,3))
hecke(H₃,1)

julia&gt; reflrep(H)
3-element Vector{Matrix{Cyc{Int64}}}:
 [-1 0 0; -1 1 0; 0 0 1]
 [1 (-3-√5)/2 0; 0 -1 0; 0 -1 1]
 [1 0 0; 0 1 -1; 0 0 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/HeckeAlgebras.jl#L373-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.HeckeCoset" href="#Gapjm.HeckeAlgebras.HeckeCoset"><code>Gapjm.HeckeAlgebras.HeckeCoset</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>HeckeCoset</code>s  are <code>Hϕ</code> where <code>H</code> is a  Hecke algebra of some Coxeter group <code>W</code>  on  which  the  reduced  element  <code>ϕ</code>  acts by <code>ϕ(T_w)=T_{ϕ(w)}</code>. This corresponds  to the action  of the Frobenius  automorphism on the commuting algebra  of the  induced of  the trivial  representation from  the rational points of some <code>F</code>-stable Borel subgroup to <code>𝐆 ^F</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(:u,3)
u₃

julia&gt; HF=hecke(WF,Pol(:v)^2;rootpara=Pol())
hecke(u₃,v²,rootpara=v)

julia&gt; CharTable(HF)
CharTable(hecke(u₃,v²,rootpara=v))
   │ 111 21  3
───┼───────────
111│  -1  1 -1
21 │-2v³  .  v
3  │  v⁶  1 v²</code></pre><p>Thanks  to the work of Xuhua  He and Sian Nie, &#39;HeckeClassPolynomials&#39; also make sense for these cosets. This is used to compute such character tables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/HeckeAlgebras.jl#L1046-L1070">source</a></section></article><h1 id="Kazhdan-Lusztig-polynomials-and-bases"><a class="docs-heading-anchor" href="#Kazhdan-Lusztig-polynomials-and-bases">Kazhdan-Lusztig polynomials and bases</a><a id="Kazhdan-Lusztig-polynomials-and-bases-1"></a><a class="docs-heading-anchor-permalink" href="#Kazhdan-Lusztig-polynomials-and-bases" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.KL" href="#Gapjm.KL"><code>Gapjm.KL</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This  module ports Chevie functionality for Kazhdan-Lusztig polynomials and bases.</p><p>Let  <code>ℋ</code> be  the Iwahori-Hecke algebra  of a Coxeter  system <code>(W,S)</code>, with quadratic  relations <code>(Tₛ-uₛ₀)(Tₛ-uₛ₁)=0</code>  for <code>s∈  S</code>. If  <code>-uₛ₀uₛ₁</code> has a square  root  <code>wₛ</code>,  we  can  scale  the  basis  <code>Tₛ</code>  to  get  a new basis <code>tₛ=-Tₛ/wₛ</code>    with   quadratic    relations   <code>(tₛ-vₛ)(tₛ+vₛ⁻¹)=0</code>   where <code>vₛ=wₛ/uₛ₁</code>.   The  most  general  case   when  Kazhdan-Lusztig  bases  and polynomials  can be defined is when the parameters <code>vₛ</code> belong to a totally ordered abelian group <code>Γ</code> for multiplication, see <a href="biblio.htm#Lus83">Lusztig1983</a>.  We set  <code>Γ⁺= {γ∈  Γ∣γ&gt;0}</code> and <code>Γ⁻={γ⁻¹∣γ∈ Γ⁺}={γ∈ Γ∣γ&lt;0}</code>.</p><p>Thus  we assume <code>ℋ</code> defined over the ring <code>ℤ[Γ]</code>, the group algebra of <code>Γ</code> over  <code>ℤ</code>, and the quadratic  relations of <code>ℋ</code>  associate to each <code>s∈ S</code> a <code>vₛ∈  Γ⁺</code> such that  <code>(tₛ-vₛ)(tₛ+vₛ⁻¹)=0</code>. We also  set <code>qₛ=vₛ²</code> and define the  basis <code>Tₛ=vₛtₛ</code> with quadratic relations <code>(Tₛ-qₛ)(Tₛ+1)=0</code>; for <code>w∈ W</code> with reduced expression <code>w=s₁…sₙ</code> we define <span>$q_w∈ Γ⁺$</span> by <span>$q_w^½=v_{s₁}…v_{sₙ}$</span> and let <span>$q_w=(q_w^½)²$</span>.</p><p>We  define the bar involution on <code>ℋ</code>  by linearity: on <code>ℤ[Γ]</code> we define it by  <span>$\overline{∑_{γ∈ Γ}a_γγ}= ∑_{γ∈ Γ} a_γ γ⁻¹$</span> and we extend it to <code>ℋ</code> by  <span>$\overline  Tₛ=Tₛ⁻¹$</span>.  Then  the Kazhdan-Lusztig basis <span>$C′_w$</span> is defined  as  the  only  basis  of  <code>ℋ</code>  stable  by the bar involution and congruent to <span>$t_w$</span> modulo <span>$∑_{w∈ W}Γ⁻ t_w$</span>.</p><p>The  basis  <span>$C′_w$</span>  can  be  computed  as  follows.  We  define  elements <span>$R_{x,y}$</span>  of <code>ℤ[Γ]</code> by  <span>$T_y⁻¹=∑_x \overline{R_{x,y⁻¹}} q_x⁻¹T_x$</span>. We then  define inductively  the Kazhdan-Lusztig  polynomials (in this general context  we should say the Kazhdan-Lusztig elements of <code>ℤ[Γ]</code>, which belong to the subalgebra of <code>ℤ[Γ]</code> generated by the <code>qₛ</code>) by <span>$P_{x,w}=τ_{≤(q_w/q_x)^½}  (∑_{x&lt;y≤w}R_{x,y}P_{y,w})$</span>  where  <code>τ</code>  is the truncation:  <span>$τ_≤\nu ∑_{γ∈  Γ} a_γγ=  ∑_{γ≤\nu}a_γγ$</span>; the  induction is thus on decreasing <code>x</code> for the Bruhat order and starts at <span>$P_{w,w}=1$</span>. We have then <span>$C′_w=∑_y q_w^{-1/2} P_{y,w}T_y$</span>.</p><p>The  Chevie code  for the  Kazhdan-Lusztig bases  <code>C</code>, <code>D</code> and their primed versions, has been initially written by Andrew Mathas around 1994, who also contributed  to  the  design  of  the programs dealing with Kazhdan-Lusztig bases. He also implemented some other bases, such as the Murphy basis which can  be  found  in  the  Chevie  contributions  directory. The code for the unequal  parameters  case  has  been  written  around  1999  by F.Digne and J.Michel. The other Kazhdan-Lusztig bases are computed in terms of the <code>C′</code> basis.</p><p>When  the <code>ℤ[Γ]</code> is a  Laurent polynomial ring the  bar operation is taking the  inverse of  the variables,  and truncation  is keeping terms of degree smaller or equal to that of <code>ν</code>. It is possible to use arbitrary groups <code>Γ</code> as   long   as   methods   <code>bar</code>:<span>$∑_{γ∈   Γ}   a_γγ↦  ∑_{γ∈  Γ}  a_γγ⁻¹$</span>, <code>positive_part</code>  : <span>$∑_{γ∈  Γ} a_γγ↦  ∑_{γ≥ 1}  a_γγ$</span> and <code>negative_part</code>: <span>$∑_{γ∈  Γ}  a_γγ  ↦  ∑_{γ≤  1}  a_γγ$</span>  have been defined on <code>ℤ[Γ]</code>. These operations   will   be   used   internally   by  the  programs  to  compute Kazhdan-Lusztig bases.</p><p>finally, benchmarks on julia 1.6.2</p><pre><code class="language-benchmark hljs">julia&gt; function test_kl(W)
         q=Pol(); H=hecke(W,q^2,rootpara=q)
         C=Cpbasis(H); T=Tbasis(H)
         [T(C(w)) for w in elements(W)]
       end
test_kl (generic function with 1 method)

julia&gt; @btime test_kl(coxgroup(:F,4));
2.019 s (17905502 allocations: 2.64 GiB)</code></pre><p>Compare to GAP3 where the following function takes 11s for F4</p><pre><code class="nohighlight hljs">test_kl:=function(W)local q,H,T,C;
  q:=X(Rationals);H:=Hecke(W,q^2,q);
  T:=Basis(H,&quot;T&quot;);C:=Basis(H,&quot;C&#39;&quot;);
  List(Elements(W),e-&gt;T(C(e)));
end;</code></pre><p>Another benchmark:</p><pre><code class="language-benchmark hljs">function test_kl2(W)
  el=elements(W)
  [KLPol(W,x,y) for x in el, y in el]
end

test_kl2 (generic function with 1 method)

julia&gt;@btime test_kl2(coxgroup(:F,4));
5.915 s (49702830 allocations: 6.98 GiB)</code></pre><p>Compare to GAP3 where the following function takes 42s for F4</p><pre><code class="nohighlight hljs">test_kl2:=function(W)local el;
  el:=Elements(W);
  List(el,x-&gt;List(el,y-&gt;KazhdanLusztigPolynomial(W,x,y)));
end;</code></pre><p>We provide also functionality to study the Kazhdan-Lusztig left cells (for the equal-parameter Hecke algebra).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:H,3)
H₃

julia&gt; c=LeftCells(W)
22-element Vector{LeftCell{FiniteCoxeterGroup{Perm{Int16},Cyc{Int64}}}}:
 LeftCell&lt;H₃: duflo= character=φ₁‚₀&gt;
 LeftCell&lt;H₃: duflo=123 character=φ₁‚₁₅&gt;
 LeftCell&lt;H₃: duflo=(15) character=φ₅‚₅&gt;
 LeftCell&lt;H₃: duflo=(10) character=φ₅‚₅&gt;
 LeftCell&lt;H₃: duflo=(14) character=φ₅‚₅&gt;
 LeftCell&lt;H₃: duflo=7 character=φ₅‚₅&gt;
 LeftCell&lt;H₃: duflo=(12) character=φ₅‚₅&gt;
 LeftCell&lt;H₃: duflo=(9,12) character=φ₅‚₂&gt;
 LeftCell&lt;H₃: duflo=(5,11) character=φ₅‚₂&gt;
 LeftCell&lt;H₃: duflo=13 character=φ₅‚₂&gt;
 ⋮
 LeftCell&lt;H₃: duflo=(8,13) character=φ₃‚₆+φ₃‚₈&gt;
 LeftCell&lt;H₃: duflo=(1,15) character=φ₃‚₆+φ₃‚₈&gt;
 LeftCell&lt;H₃: duflo=3 character=φ₃‚₁+φ₃‚₃&gt;
 LeftCell&lt;H₃: duflo=2 character=φ₃‚₁+φ₃‚₃&gt;
 LeftCell&lt;H₃: duflo=1 character=φ₃‚₁+φ₃‚₃&gt;
 LeftCell&lt;H₃: duflo=6 character=φ₄‚₃+φ₄‚₄&gt;
 LeftCell&lt;H₃: duflo=(13) character=φ₄‚₃+φ₄‚₄&gt;
 LeftCell&lt;H₃: duflo=(11) character=φ₄‚₃+φ₄‚₄&gt;
 LeftCell&lt;H₃: duflo=9 character=φ₄‚₃+φ₄‚₄&gt;</code></pre><p>see  also  the  functions  <code>elements</code>,  <code>character</code>,  <code>representation</code>  and <code>Wgraph</code>  for left  cells. The  operations <code>length</code>,  <code>in</code> (which  refer to <code>elements</code>)  and <code>==</code> (which  compares Duflo involutions)  are also defined for  left cells. When <code>Character(c)</code> has been computed, then <code>c.a</code> also has been  bound which holds the common  value of Lusztig&#39;s <code>a</code>-function for the elements of <code>c</code> and The irreducible constituents of <code>character(c)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/KL.jl#L22-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.KL.KLPol" href="#Gapjm.KL.KLPol"><code>Gapjm.KL.KLPol</code></a> — <span class="docstring-category">Function</span></header><section><div><p>KLPol(W,y,w) returns the Kazhdan-Lusztig polynomial P_{y,w} of W</p><p>To  compute Kazhdan-Lusztig polynomials in  the one-parameter case it seems that  the best  approach still  is by  using the  recursion formula  in the original  article KL79. One can first run  a number of standard checks on a given  pair  of  elements  to  see  if the computation of the corresponding polynomial  can be reduced to a similar computation for elements of smaller length. One such check involves the notion of critical pairs (cf. Alv87): a pair  of elements <code>w₁,w₂∈  W</code> such that  <code>w₁≤w₂</code> is <em>critical</em>  if <code>ℒ(w₂) ⊆ ℒ(w₁)</code>  and <code>ℛ (w₂)⊆ ℛ (w₁)</code>, where <code>ℒ</code>  and <code>ℛ</code> denote the left and right descent  set, respectively.  Now if  <code>y≤w ∈  W</code> are arbitrary elements then there   always  exists  a  critical  pair   <code>z≤w</code>  with  <code>y≤z≤w</code>  and  then <span>$P_{y,w}=P_{z,w}$</span>.  Given two elements <code>y</code> and  <code>w</code>, such a critical pair is   found  by  the  function   &#39;critical_pair&#39;.  Whenever  the  polynomial corresponding  to  a  critical  pair  is  computed  then  this pair and the polynomial  are stored in  the property <code>:klpol</code>  of the underlying Coxeter group.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,3)
B₃

julia&gt; map(i-&gt;map(x-&gt;KLPol(W,one(W),x),elements(W,i)),1:W.N)
9-element Vector{Vector{Pol{Int64}}}:
 [1, 1, 1]
 [1, 1, 1, 1, 1]
 [1, 1, 1, 1, 1, 1, 1]
 [1, 1, 1, x+1, 1, 1, 1, 1]
 [x+1, 1, 1, x+1, x+1, 1, x+1, 1]
 [1, x+1, 1, x+1, x+1, x²+1, 1]
 [x+1, x+1, x²+x+1, 1, 1]
 [x²+1, x+1, 1]
 [1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/KL.jl#L225-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.Tbasis" href="#Gapjm.HeckeAlgebras.Tbasis"><code>Gapjm.HeckeAlgebras.Tbasis</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>Tbasis(h::HeckeCpElt)</code> </p><p>converts the element <code>h</code> of the <code>C&#39;</code> basis to the <code>T</code> basis.</p><p>Implementation Jean Michel and François Digne 1999. </p><p>For one-parameter Hecke algebras, we use the formulae: <span>$C&#39;_w=Σ_{y≤w}P_{y,w}(q)q^{-l(w)/2}T_y$</span> and if <span>$sw&lt;w$</span> then</p><p><span>$C&#39;ₛ C&#39;_{sw}=C&#39;_w+Σ_{y&lt;sw}μ(y,sw)C&#39;_y=Σ_{v≤w}μᵥ Tᵥ$</span></p><p>where</p><p><span>$μᵥ=P_{v,w}(q)q^{-l(w)/2}+Σ_{v≤y≤sw}μ(y,sw)P_{v,y}(q)q^{-l(y)/2}$</span></p><p>It  follows that if <span>$deg(μᵥ)&gt;=-l(v)$</span>  then <span>$deg(μᵥ)=-l(v)$</span> with leading coefficient  <span>$μ(v,sw)$</span> (this happens exactly for <span>$y=v$</span> in the sum which occurs in the formula for <span>$μᵥ$</span>).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,3)
B₃

julia&gt; @Pol v;H=hecke(W,v^2,rootpara=v)
hecke(B₃,v²,rootpara=v)

julia&gt; C=Cpbasis(H); Tbasis(C(1,2))
v⁻²T.+v⁻²T₂+v⁻²T₁+v⁻²T₁₂</code></pre><p>For general Hecke algebras, we follow formula 2.2 in  <a href="biblio.htm#Lus83">Lusztig1983</a></p><p><span>$\overline{P̄̄_{x,w}}-P_{x,w}=∑_{x&lt;y≤w} R_{x,y} P_{y,w}$</span></p><p>where <span>$R_{x,y}=\overline{(t_{y⁻¹}⁻¹|t_x)}$</span> where <code>t</code>  is the basis with parameters  <code>qₛ,-qₛ⁻¹</code>. It follows that <span>$P_{x,w}$</span> is the negative part of <span>$∑_{x&lt;y≤w}  R_{x,y} P_{y,w}$</span> which  allows to compute  it by induction on <code>l(w)-l(x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/KL.jl#L453-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.KL.Cbasis" href="#Gapjm.KL.Cbasis"><code>Gapjm.KL.Cbasis</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>Cbasis(H::HeckeAlgebra)</code></p><p>returns  a function which gives the  <code>C</code>-basis of the Iwahori-Hecke algebra <code>H</code>. The algebra <code>H</code> should have the functon <code>rootpara</code> defined. This basis is  defined as follows (see e.g. <a href="biblio.htm#Lus85">(5.1)Lusztig1985</a>). Let <code>W</code>  be the underlying Coxeter group. For  <code>x,y ∈ W</code> let <span>$P_{x,y}$</span> be the corresponding  Kazhdan–Lusztig polynomial. If <span>$\{T_w ∣ w∈ W\}$</span> denotes the usual T-basis, then <span>$C_x=\sum_{y\le x}(-1)^{l(x)-l(y)}P_{y,x}(q^{-1})q_x^{1/2}q_y^{-1}  T_y$</span> for <code>x  ∈ W</code>. For example,  we have <code>Cₛ=qₛ⁻½Tₛ-qₛ½T₁</code>  for <code>s ∈  S</code>. Thus, the transformation matrix between the <code>T</code>-basis and the <code>C</code>-basis is lower unitriangular, with monomials  in <code>qₛ</code> along the diagonal.  In the one-parameter case (all <code>qₛ</code> are equal to <code>v²</code>) the multiplication rules for the <code>C</code> basis are given by:</p><p><code>Cₛ⋅Cₓ =-(v+v^-1)Cₓ</code>, if <code>sx&lt;x</code>, and <code>Cₛₓ+∑ₜ μ(t,x)Cₜ</code> if <code>sx&gt;x</code>.</p><p>where  the sum is over  all <code>t</code> such that  <code>t&lt;x, l(t)≢l(x)~mod~2 and st&lt;t</code>. The  coefficient <code>μ(t,x)</code> is the coefficient of degree <code>(l(x)-l(t)-1)/2</code> in the Kazhdan–Lusztig polynomial <span>$P_{x,t}$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,3);H=hecke(W,Pol(:v)^2)
hecke(B₃,v²)

julia&gt; T=Tbasis(H);C=Cbasis(H);T(C(1))
-vT.+v⁻¹T₁

julia&gt; C(T(1))
v²C.+vC₁</code></pre><p>We  can  also  compute  character  values  on  elements in the <code>C</code>-basis as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; ref=reflrep(H)
3-element Vector{Matrix{Pol{Int64}}}:
 [-1 0 0; -v² v² 0; 0 0 v²]
 [v² -2 0; 0 -1 0; 0 -v² v²]
 [v² 0 0; 0 v² -1; 0 0 -1]</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; c=CharTable(H).irr[charinfo(W).extRefl[[2]],:]
1×10 Matrix{Pol{Int64}}:
 3  2v²-1  v⁸-2v⁴  -3v¹²  2v²-1  v⁴  v⁴-2v²  -v⁶  v⁴-v²  0

julia&gt; hcat(char_values.(C.(classreps(W)),Ref(c))...)
1×10 Matrix{Pol{Int64}}:
 3  -v-v⁻¹  0  0  -v-v⁻¹  2  0  0  1  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/KL.jl#L335-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.KL.Cpbasis" href="#Gapjm.KL.Cpbasis"><code>Gapjm.KL.Cpbasis</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>Cpbasis(H)</code></p><p>returns  a function which gives the <code>C&#39;</code>-basis of the Iwahori-Hecke algebra <code>H</code>  (see <a href="biblio.htm#Lus85">(5.1)Lusztig1985</a>).  This basis  is defined by <span>$C&#39;_x= ∑_{y≤x}P_{y,x}q_x^{-1/2} T_y$</span> for <code>x ∈ W</code>. We have <span>$C&#39;_x=(-1)^{l(x)}alt(C_x)$</span> for all <code>x ∈ W</code> (see <code>alt</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2);@Pol v;H=hecke(W,[v^4,v^2])
hecke(B₂,Pol{Int64}[v⁴, v²])

julia&gt; Cp=Cpbasis(H);h=Cp(1)^2
(v²+v⁻²)C′₁

julia&gt; k=Tbasis(h)
(1+v⁻⁴)T.+(1+v⁻⁴)T₁

julia&gt; Cp(k)
(v²+v⁻²)C′₁</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/KL.jl#L307-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.KL.character" href="#Gapjm.KL.character"><code>Gapjm.KL.character</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>character(c)</code></p><p>Returns  a list <code>l</code>  such that the  character of <code>c.group</code>  afforded by the left cell <code>c</code> is <code>sum(CharTable(c.group).irr[l])</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; c=LeftCells(coxgroup(:G,2))[3]
LeftCell&lt;G₂: duflo=2 character=φ₂‚₁+φ′₁‚₃+φ₂‚₂&gt;

julia&gt; character(c)
3-element Vector{Int64}:
 3
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/KL.jl#L529-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.representation-Tuple{LeftCell, Any}" href="#Gapjm.Chars.representation-Tuple{LeftCell, Any}"><code>Gapjm.Chars.representation</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>representation(c::LeftCell,H)</code></p><p>returns matrices giving the representation of <code>H</code> on the left cell <code>c</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:H,3)
H₃

julia&gt; c=LeftCells(W)[3]
LeftCell&lt;H₃: duflo=(15) character=φ₅‚₅&gt;

julia&gt; @Mvp q;H=hecke(W,q)
hecke(H₃,q)

julia&gt; representation(c,H)
3-element Vector{Matrix{Mvp{Int64, Rational{Int64}}}}:
 [-1 0 … 0 0; 0 -1 … 0 -q½; … ; 0 0 … q 0; 0 0 … 0 q]
 [-1 -q½ … 0 0; 0 q … 0 0; … ; 0 0 … -1 0; 0 -q½ … 0 -1]
 [q 0 … 0 0; -q½ -1 … 0 0; … ; 0 0 … q 0; 0 0 … 0 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/KL.jl#L651-L672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.KL.Wgraph" href="#Gapjm.KL.Wgraph"><code>Gapjm.KL.Wgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>Wgraph(c::LeftCell)</code></p><p>return the W-graph for a left cell for the one-parameter Hecke algebra of a finite Coxeter group. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/KL.jl#L908-L913">source</a></section><section><div><p><code>Wgraph(W::CoxeterGroup,i)</code></p><p>return the W-graph for the <code>i</code>-th irreducible representation of <code>W</code> (or of the 1-parameter Hecke algebra of <code>W</code>).</p><p>Only implemented for irreducible groups of type <code>E</code>, <code>F</code> or <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/KL.jl#L943-L950">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.KL.LeftCells" href="#Gapjm.KL.LeftCells"><code>Gapjm.KL.LeftCells</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>LeftCells(W[,i])</code> left cells of <code>W</code> [in <code>i</code>-th 2-sided cell]   for the 1-parameter Hecke algebra <code>hecke(W,q)</code></p><p>The  program uses precomputed  data(see <a href="biblio.htm#GH14">Geck-Halls 2014</a>) for  exceptional types and for type <code>:A</code>,  so is quite fast for these types (it  takes 13 seconds to compute the  101796 left cells for type <code>E₈</code>). For other  types, left cells are computed from first principles, thus computing many  Kazhdan-Lusztig polynomials. It takes 60  seconds to compute the left cells of <code>D₆</code>, for example.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; LeftCells(W)
4-element Vector{LeftCell{FiniteCoxeterGroup{Perm{Int16},Int64}}}:
 LeftCell&lt;G₂: duflo= character=φ₁‚₀&gt;
 LeftCell&lt;G₂: duflo=12 character=φ₁‚₆&gt;
 LeftCell&lt;G₂: duflo=2 character=φ₂‚₁+φ′₁‚₃+φ₂‚₂&gt;
 LeftCell&lt;G₂: duflo=1 character=φ₂‚₁+φ″₁‚₃+φ₂‚₂&gt;</code></pre><p>Printing such a record displays the character afforded by the left cell and its  Duflo involution; the Duflo involution <code>r</code>  is printed as a subset <code>I</code> of    <code>1:W.N</code>   such    that   <code>r=longest(reflection_subgroup(W,I))</code>,   see <code>describe_involution</code>.</p><p>If  a second argument <code>i</code> is given, the program returns only the left cells which  are in the <code>i</code>-th two-sided cell,  that is whose character is in the <code>i</code>-th family of <code>W</code> (see &quot;Families of unipotent characters&quot;).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2);
julia&gt; LeftCells(W,1)
2-element Vector{LeftCell{FiniteCoxeterGroup{Perm{Int16},Int64}}}:
 LeftCell&lt;G₂: duflo=2 character=φ₂‚₁+φ′₁‚₃+φ₂‚₂&gt;
 LeftCell&lt;G₂: duflo=1 character=φ₂‚₁+φ″₁‚₃+φ₂‚₂&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/KL.jl#L793-L832">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.KL.LeftCell" href="#Gapjm.KL.LeftCell"><code>Gapjm.KL.LeftCell</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>LeftCell(W,w)</code></p><p>returns  a  record  describing  the  left  cell  of  <code>W</code>  for  <code>hecke(W,q)</code> containing element <code>w</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,8)
E₈

julia&gt; LeftCell(W,W((1:8)...))
LeftCell&lt;E₈: duflo=(42,43) character=φ₃₅‚₂&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/KL.jl#L882-L895">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.KL.Lusztigaw" href="#Gapjm.KL.Lusztigaw"><code>Gapjm.KL.Lusztigaw</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>Lusztigaw(W,w)</code></p><p>For  <code>w</code> an element  of the Coxeter  groups <code>W</code>, this  function returns the coefficients  on the irreducible characters of the virtual Character <code>ca_w</code> defined  in <a href="biblio.htm#Lus85">5.10.2 Lusztig1985</a>.  This character has the property that the corresponding almost character is integral and positive.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; l=Lusztigaw(W,W(1))
6-element Vector{Int64}:
 0
 0
 1
 0
 1
 1

julia&gt; sum(l.*map(i-&gt;almostChar(W,i),eachindex(l)))
[G₂]:&lt;φ′₁‚₃&gt;+&lt;φ₂‚₁&gt;+&lt;φ₂‚₂&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/KL.jl#L959-L983">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.KL.LusztigAw" href="#Gapjm.KL.LusztigAw"><code>Gapjm.KL.LusztigAw</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>LusztigAw( &lt;W&gt;, &lt;w&gt;)</code></p><p>For  &lt;w&gt; an element  of the Coxeter  groups &lt;W&gt;, this  function returns the coefficients  on the irreducible  characters of the  virtual Character cA_w defined  in <a href="biblio.htm#Lus85">5.11.6 Lusztig1985</a>.  This character has the property that the corresponding almost character is integral and positive.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; l=LusztigAw(W,W(1))
6-element Vector{Int64}:
 0
 0
 0
 1
 1
 1

julia&gt; sum(l.*map(i-&gt;almostChar(W,i),eachindex(l)))
[G₂]:&lt;φ″₁‚₃&gt;+&lt;φ₂‚₁&gt;+&lt;φ₂‚₂&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/KL.jl#L990-L1014">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.KL.AsymptoticAlgebra" href="#Gapjm.KL.AsymptoticAlgebra"><code>Gapjm.KL.AsymptoticAlgebra</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AsymptoticAlgebra(W,i)</code></p><p>The  asymptotic algebra <code>A</code> associated to  the algebra <code>H=Hecke(W,q)</code> is an algebra   with   basis   <span>$\{tₓ\}_{x∈   W}$</span>   and   structure  constants <span>$t_xt_y=\sum_z  γ_{x,y,z}  t_z$</span>  given  by:  let  <span>$h_{x,y,z}$</span>  be  the coefficient  of  <span>$C_x  C_y$</span>  on  <span>$C_z$</span>. Then <span>$h_{x,y,z}=γ_{x,y,z^{-1}} q^{a(z)/2}+$</span>lower terms, where <span>$q^{a(z)/2}$</span> is the maximum over <code>x,y</code> of the degree of <span>$h_{x,y,z}$</span>.</p><p>The  algebra <code>A</code>  is the  direct product  of the subalgebras <span>$A_{\mathcal C}$</span>  generated  by  the  elements  <span>$\{t_x\}_{x∈{\mathcal  C}}$</span>, where <span>$\mathcal C$</span> runs over the two-sided cells of <code>W</code>. If <span>$\mathcal C$</span> is the  <code>i</code>-th  two-sided  cell  of  <code>W</code>, the command &#39;AsymptoticAlgebra(W,i)&#39; returns  the algebra <span>$A_{\mathcal C}$</span>. Note  that the function <code>a(z)</code> is constant  over  a  two-sided  cell,  equal  to  the  common value of the <code>a</code>-function   attached  to  the  characters   of  the  two-sided  cell  (see &#39;Character&#39; for left cells).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; A=AsymptoticAlgebra(W,1)
Asymptotic Algebra dim.10

julia&gt; b=basis(A)
10-element Vector{AlgebraElt{AsymptoticAlgebra, Int64}}:
 t₂
 t₁₂
 t₂₁₂
 t₁₂₁₂
 t₂₁₂₁₂
 t₁
 t₂₁
 t₁₂₁
 t₂₁₂₁
 t₁₂₁₂₁

julia&gt; b*permutedims(b)
10×10 Matrix{AlgebraElt{AsymptoticAlgebra, Int64}}:
 t₂      0            t₂₁₂            …  0               t₂₁₂₁        0
 t₁₂     0            t₁₂+t₁₂₁₂          0               t₁₂₁+t₁₂₁₂₁  0
 t₂₁₂    0            t₂+t₂₁₂+t₂₁₂₁₂     0               t₂₁+t₂₁₂₁    0
 t₁₂₁₂   0            t₁₂+t₁₂₁₂          0               t₁+t₁₂₁      0
 t₂₁₂₁₂  0            t₂₁₂               0               t₂₁          0
 0       t₁₂          0               …  t₁₂₁            0            t₁₂₁₂₁
 0       t₂+t₂₁₂      0                  t₂₁+t₂₁₂₁       0            t₂₁₂₁
 0       t₁₂+t₁₂₁₂    0                  t₁+t₁₂₁+t₁₂₁₂₁  0            t₁₂₁
 0       t₂₁₂+t₂₁₂₁₂  0                  t₂₁+t₂₁₂₁       0            t₂₁
 0       t₁₂₁₂        0                  t₁₂₁            0            t₁

julia&gt; CharTable(A)
CharTable(Asymptotic Algebra dim.10)
     │2 12 212 1212 21212 1 21 121 2121 12121
─────┼────────────────────────────────────────
φ′₁‚₃│.  .   .    .     . 1  .  -1    .     1
φ₂‚₁ │1  .   2    .     1 1  .   2    .     1
φ₂‚₂ │1  .   .    .    -1 1  .   .    .    -1
φ″₁‚₃│1  .  -1    .     1 .  .   .    .     .</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/KL.jl#L1029-L1090">source</a></section></article><h1 id="Garside-monoids-and-groups,-braids."><a class="docs-heading-anchor" href="#Garside-monoids-and-groups,-braids.">Garside monoids and groups, braids.</a><a id="Garside-monoids-and-groups,-braids.-1"></a><a class="docs-heading-anchor-permalink" href="#Garside-monoids-and-groups,-braids." title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside" href="#Gapjm.Garside"><code>Gapjm.Garside</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Garside  monoids  are  a  general  class  of monoids whose most famous examples  are the braid and dual braid monoids. The implementation of these last  monoids is  in the  framework of  a general implementation of Garside monoids.</p><p>To  define Garside monoids we first need to introduce some vocabulary about divisibility  in monoids. A <em>left divisor</em> of  <code>x</code> is a <code>d</code> such that there exists  <code>y</code> with <code>x=dy</code> (and then we say  that <code>x</code> is a <em>right multiple</em> of <code>d</code>,  and write <code>d≼ x</code>). We say that a monoid <code>M</code> is left cancellable if an equality  <code>dx=dy</code> implies  <code>x=y</code>. We  define symmetrically  right divisors, left  multiples and right cancellability.  We say that <code>x</code>  is an <em>atom</em> if <code>1</code>  and <code>x</code> are its only divisors. A <em>left gcd</em> of <code>x</code> and <code>y</code> is a common left  divisor <code>d</code> of <code>x</code> and <code>y</code> such that any other common left divisor is a  left divisor of <code>d</code>. Similarly a <em>right  lcm</em> of <code>x</code> and <code>y</code> is a common multiple which is a left divisor of any other common multiple.</p><p>We  call <em>Garside</em> a monoid <code>M</code> which:</p><ul><li>is left and right cancellable.</li><li>is generated by its atoms,  which are finite in number.</li><li>admits left and  right  gcds  and  lcms.</li><li>is such that any element has only finitely many left (or right) divisors.</li><li>admits a <em>Garside element</em>, which is an element <code>Δ</code> whose set of left and right divisors coincide and generate <code>M</code>.</li></ul><p>Garside  elements are not  unique, but there  is a unique  minimal one (for divisibility);  we assume a  Garside element <code>Δ</code>  has been chosen. Then the divisors  of <code>Δ</code> are called  the <em>simples</em> of <code>M</code>.  A Garside monoid embeds into  its group of fractions, which is  called a <em>Garside group</em> (a Garside group  may have  several distinct  Garside structures,  as we  will see for Braid groups of finite Coxeter groups).</p><p>We  also implement <em>locally Garside</em> monoids,  which are monoids where lcms do  not always exist, but exist when any common multiple exists; the set of simples  is then not defined using a  Garside element, but by the condition that  they contain the atoms and are  closed under lcms and taking divisors (see  <a href="biblio.htm#BDM01">BDM01</a>); since it is  not ensured by the existence of  <code>Δ</code>, one  has to  add the  condition that  any element  is divisible by finitely many simples (but the number of simples can be infinite). The main example  is the braid monoid of an  infinite Coxeter group. It is not known if  these monoids embed in  their group of fractions  (though that has been proved for braid monoids of Coxeter groups by Paris <a href="biblio.htm#Paris01">Paris01</a>)  and thus  computing in  the monoid does not help  for computing in the group (only  the monoid is implemented for these cases).</p><p>What allows computing with Garside and locally Garside monoids, and Garside groups,  is the fact  that they admit  normal forms –-  these normal forms where   exhibited  for   braid  monoids   of  Coxeter   groups  by  Deligne <a href="biblio.htm#Del72">Del72</a>,  who extended previous  work of Brieskorn, Saito <a href="biblio.htm#BS72">BS72</a> and Garside <a href="biblio.htm#Gar69">Gar69</a>:</p><p>(i) Let  <code>M</code> be a locally Garside monoid and let <code>b∈ M</code>. Then there is a unique maximal left simple divisor <code>α(b)</code> of <code>b</code> –- any other simple dividing <code>b</code> on the left divides <code>α(b)</code> on the left.</p><p>(ii) Assume  <code>M</code> is a Garside monoid, <code>Δ</code> is  its Garside element and <code>G</code> is its group  of fractions. Then,  given any element  <code>x∈ G</code>, there  is some power <code>i</code> such that <code>Δⁱ x∈ M</code>.</p><p>A consequence of (i) is that any element has a canonical decomposition as a product of simples, called its left-greedy normal form. If we define <code>ω(x)</code> by  <code>x=α(x)ω(x)</code>, then the normal form of <code>x</code> is <code>α(x)α(ω(x))α(ω^2(x))…</code> We use  the normal form to represent elements  of <code>M</code>, and when <code>M</code> is Garside (ii)  to represent elements  of <code>G</code>: given  <code>x∈ G</code> we  compute the smallest power  <code>i</code>  such  that  <code>Δⁱ  x∈  M</code>,  and  we  represent  <code>x</code> by the couple <code>(i,Δ⁻ⁱx)</code>.  We are thus reduced to the case where <code>x∈ M</code>, not divisible by <code>Δ</code>,  where we represent  <code>x</code> by the  sequence of simples which constitutes its normal form. </p><p>We  now describe Artin-Tits braid monoids. Let <code>(W,S)</code> be a Coxeter system, that is <code>W</code> has presentation</p><p><code>⟨s∈ S∣s^2=1, sts⋯ =tst⋯   (mₛₜ factors on each side) for s,t∈ S⟩</code></p><p>for  some Coxeter matrix <code>mₛₜ</code> for <code>s,t∈ S</code>. The braid group <code>B</code> associated to <code>(W,S)</code> is the group defined by the presentation</p><p><code>⟨𝐬∈ 𝐒∣ 𝐬𝐭𝐬⋯ =𝐭𝐬𝐭⋯  (mₛₜ factors on each side) for 𝐬,𝐭∈ 𝐒⟩</code></p><p>The <em>positive</em> braid monoid <code>B⁺</code> associated to <code>W</code> is the monoid defined by the  presentation above –- it identifies to the submonoid of <code>B</code> generated by  <code>𝐒</code> by  the result  of Paris  mentioned above.  This monoid  is locally Garside,  with set of simples  in bijection with elements  of <code>W</code> and atoms the elements of <code>𝐒</code>; we will denote by <code>𝐖</code> the set of simples, and by <code>𝐰 ↦ w</code>  the bijection between simples and elements  of <code>W</code>. The group <code>W</code> has a length  defined  in  terms  of  reduced expressions. Similarly, having only homogeneous relations, <code>B⁺</code> has a natural length function. Then <code>𝐖</code> can be characterized  as the subset of the elements  of <code>B⁺</code> of the same length as their image in <code>W</code>.</p><p>If  <code>W</code> is finite, then <code>B⁺</code> is Garside with Garside element the element of <code>𝐖</code> whose image is the longest element  of <code>W</code>. A finite Coxeter group is also  a reflection group in  a real vector space,  thus in its complexified <code>V</code>,  and <code>B</code> has also a topological definition as the fundamental group of the  space <code>Vʳᵉᵍ/W</code>, where <code>Vʳᵉᵍ</code>  is the set of  elements of <code>V</code> which are fixed  by no  non-identity element  of <code>S</code>;  however, we  will not use this here.</p><p>Given a Coxeter group <code>W</code>,</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,4)
A₄

julia&gt; B=BraidMonoid(W)
BraidMonoid(A₄)</code></pre><p>constructs  the  associated  braid  monoid,  and  then  as  a  function &#39;B&#39; constructs  elements of the braid monoid (or group when <code>W</code> is finite) from a list of generators.</p><pre><code class="language-julia-repl hljs">julia&gt; w=B(1,2,3,4)
1234

julia&gt; w^3
121321432.343

julia&gt; word(α(w^3))
9-element Vector{Int64}:
 1
 2
 1
 3
 2
 1
 4
 3
 2

julia&gt; w^4
Δ.232432

julia&gt; inv(w)
(1234)⁻¹</code></pre><p>How  an element of  a Garside group  is printed is  controlled by IOcontext &#39;:greedy&#39;.  By default, elements are printed  as fractions <code>a⁻¹b</code> where <code>a</code> and  <code>b</code> have no left common divisor. Each  of <code>a</code> and <code>b</code> is printed using its left-greedy normal form, that is a maximal power of the Garside element followed  by the rest. One can print  the entire element in the left-greedy normal  from by setting the &#39;:greedy&#39; IOContext; with the same <code>w</code> as above we have:</p><pre><code class="language-julia-repl hljs">julia&gt; repr(w^-1,context=IOContext(stdout,:greedy=&gt;true,:limit=&gt;true))
&quot;Δ⁻¹.232432&quot;</code></pre><p>Finally,  <code>repr</code> gives   <code>w</code>  back   in  a   form  which   after  assigning &#39;B=BraidMonoid(W)&#39; can be input back into Julia:</p><pre><code class="language-julia-repl hljs">julia&gt; repr(w)
&quot;B(1,2,3,4)&quot;

julia&gt; repr(w^3)
&quot;B(1,2,1,3,2,1,4,3,2,3,4,3)&quot;

julia&gt; repr(w^-1)
&quot;B(-4,-3,-2,-1)&quot;</code></pre><p>In  general elements of a Garside monoid  are displayed similarly as a list of their constituting atoms.</p><p>We  now describe the dual braid monoid.  For that, we first give a possible approach  to construct Garside monoids. Given a  group <code>W</code> and a set <code>S</code> of generators  of <code>W</code> as a monoid, we  define the length <code>l(w)</code> as the minimum number of elements of <code>S</code> needed to write <code>w</code>. We then define left divisors of   <code>x</code>  as  the  <code>d</code>   such  that  there  exists   <code>y</code>  with  <code>x=dy</code>  and <code>l(d)+l(y)=l(x)</code>.  We say that  <code>w∈ W</code> is  balanced if its  set of left and right  divisors coincide, and we  say that <code>w</code> is  Garside if that set is a lattice (where upper and lower bounds are lcms and gcds) and generates <code>W</code>. Then we have:</p><p>suppose <code>w</code> is Garside and let <code>[1,w]</code> be its set of divisors (an interval for  the partial order  defined by divisibility).  Then the monoid <code>M</code> with generators  <code>[1,w]</code> and relations  <code>xy=z</code> whenever <code>xy=z</code>  holds in <code>W</code> and <code>l(x)+l(y)=l(z)</code>  is Garside,  with simples  <code>[1,w]</code> and  atoms <code>S</code>.  It is called the interval monoid defined by the interval <code>[1,w]</code>.</p><p>The  Artin-Tits braid monoid  is an interval  monoid by taking  for <code>S</code> the Coxeter generators, in which case <code>l</code> is the Coxeter length, and taking for <code>w</code>  the longest element of <code>W</code>. The dual monoid, constructed by Birman, Ko and  Lee  for  type  <code>A</code>  and  by  Bessis  for  all  well-generated complex reflection  groups, is obtained in  a similar way, by  taking this time for <code>w</code>  a Coxeter element,  for <code>l</code> the  reflection length &#39;reflength&#39; and for <code>S</code> the reflections which divide <code>w</code> for the reflection length (for Coxeter groups all reflections divide <code>w</code> but for well-generated complex reflection groups  not all reflections divide); for the dual monoid the simples are of cardinality  the generalized Catalan numbers  <code>catalan</code>. An interval monoid has  naturally an inverse morphism from <code>M</code> to <code>W</code>, called &#39;image&#39; which is the  quotient map from the  interval monoid to <code>W</code>  which sends back simple braids to <code>[1,w]</code>.</p><p>A  last notable notion is <em>reversible</em>  monoids. Since we store left normal forms,  it is easy to compute left lcms and gcds, but hard to compute right lcms  and gcds. But this becomes easy to  do if the monoid has an operation &#39;reverse&#39;,  which has the property that &#39;a&#39; is a left divisor of &#39;b&#39; if and only  if &#39;reverse(a)&#39;  is a  right divisor  of &#39;reverse(b)&#39;. This holds for Artin-Tits  and dual braid monoids of groups generated by true reflections; Artin-Tits monoids have a <code>reverse</code> operation which consists of reversing a word,  written as  a list  of atoms.  The dual  monoid also has a <code>reverse</code> operation  defined in the  same way, but  this operation changes monoid: it goes  from the dual monoid  for the Coxeter element  <code>w</code> to the dual monoid for  the Coxeter element  <code>w⁻¹</code>. The operations  &#39;rightlcm&#39; and &#39;rightgcd&#39;, and  some other algorithms, have faster implementations if the monoid has a <code>reverse</code> operation.</p><p>This  module implements also  functions to solve  the conjugacy problem and compute  centralizers  in  Garside  groups,  following  the work of Franco, Gebhardt and Gonzalez-Meneses.</p><p>Two  elements <code>w</code> and <code>w&#39;</code> of a monoid  <code>M</code> are <em>conjugate</em> in <code>M</code> if there exists  <code>x∈ M</code> such that <code>wx=xw&#39;</code>; if  <code>M</code> satisfies the Öre conditions, it has  a  group  of  fractions  where  this  becomes  <code>x⁻¹wx=w&#39;</code>,  the  usual definition  of conjugacy. A special case  which is even closer to conjugacy in  the group is if there exists <code>y∈  M</code> such that <code>w=xy</code> and <code>w&#39;=yx</code>. This relation  is not transitive in general,  but we call <em>cyclic conjugacy</em> the transitive closure of this relation, a restricted form of conjugacy.</p><p>The  next  observation  is  that  if  <code>w,w&#39;</code>  are conjugate in the group of fractions  of the Garside monoid <code>M</code> then  they are conjugate in <code>M</code>, since if  <code>wx=xw&#39;</code> then  there is  a power  <code>Δⁱ</code> which  is central and such that <code>xΔⁱ∈ M</code>. Then <code>wxΔⁱ=xΔⁱ w&#39;</code> is a conjugation in <code>M</code>.</p><p>The  crucial observation for solving the  conjugacy problem is to introduce <code>inf(w):=sup{i such  that  Δⁱ   divides  w}</code>  and <code>sup(w):=inf{i such  that  w  divides Δⁱ}</code>, and to notice  that the number of  conjugates of <code>w</code> with  same <code>inf</code> and <code>sup</code> as <code>w</code>  is finite. Further, a  theorem of Birman shows  that the maximum <code>inf</code> and  minimum <code>sup</code> in a conjugacy class can be achieved simultaneously; the elements  achieving this are called the super summit set of <code>w</code>. Thus a way to  determine if two elements are conjugate  is to find a representative of both  of them in  their super summit  set, and then  solve conjugacy within that  set. This can also be used  to compute the centralizer of an element: if  we consider  the super  summit set  as the  objects of a category whose morphisms are the conjugations by simple elements, the centralizer is given by the endomorphisms of the given object.</p><p>We illustrate this on an example:</p><pre><code class="language-julia-repl hljs">julia&gt; b=B(2,1,4,1,4)
214.14

julia&gt; c=B(1,4,1,4,3)
14.143

julia&gt; d=conjugating_elt(b,c)
(1)⁻¹21321432

julia&gt; b^d
14.143

julia&gt; centralizer_gens(b)
3-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 321432.213243
 21.1
 4

julia&gt; C=conjcat(b;ss=:ss)
category with 10 objects and 32 generating maps

julia&gt; C.obj
10-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 1214.4
 214.14
 124.24
 1343.1
 14.124
 143.13
 24.214
 134.14
 13.134
 14.143</code></pre><p>There   is  a   faster  solution   to  the   conjugacy  problem   given  in <a href="biblio.htm#gebgon10">gebgon10</a>:  for each <code>b∈ M</code>, they define a particular simple  left divisor of <code>b</code>, its <em>preferred prefix</em> such that the operation <em>sliding</em>  which  cyclically  conjugates  <code>b</code>  by  its preferred prefix, is eventually periodic, and the period is contained in the super summit set of <code>x</code>.  We say that <code>x</code> is in its sliding circuit if some iterated sliding of <code>x</code> is equal to <code>x</code>. The set of sliding circuits in a given conjugacy class is  smaller than the super  summit set, thus allows  to solve the conjugacy problem faster. Continuing from the above example,</p><pre><code class="language-julia-repl hljs">julia&gt; word(W,preferred_prefix(b))
2-element Vector{Int64}:
 2
 1

julia&gt; b^B(preferred_prefix(b))
1214.4

julia&gt; b1=b^B(preferred_prefix(b))
1214.4

julia&gt; C=conjcat(b)
category with 2 objects and 6 generating maps

julia&gt; C.obj
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 1214.4
 1343.1</code></pre><p>Finally,  we have implemented  Hao Zheng&#39;s algorithm  to extract roots in a Garside monoid:</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; B=BraidMonoid(W)
BraidMonoid(A₃)

julia&gt; Pi=B(B.δ)^2
Δ²

julia&gt; root(Pi,2)
Δ

julia&gt; root(Pi,3)
1232

julia&gt; root(Pi,4)
132</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L1-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.LocallyGarsideMonoid" href="#Gapjm.Garside.LocallyGarsideMonoid"><code>Gapjm.Garside.LocallyGarsideMonoid</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>LocallyGarsideMonoid{T}</code>  is the abstract type of locally Garside monoids, where  <code>T</code>  is  the  type  of  simples.  Such a monoid <code>M</code> needs, for <code>a,b</code> simples, to implement the functions</p><ul><li><code>one(M)</code></li><li><code>isleftdescent(M,a,::Int)</code>  whether <code>M.atoms[i]≼ a</code></li><li><code>isrightdescent(M,a,::Int)</code> whether <code>a≽ M.atoms[i]</code></li><li><code>isrightascent(M,a,::Int)</code>  whether <code>a*M.atoms[i]</code> is simple</li><li><code>*(M,a,b)</code>    when <code>a*b</code> is simple</li><li><code>\(M,a,b)</code>   when <code>a≼ b</code></li><li><code>/(M,a,b)</code>    when <code>a≽ b</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L342-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.GarsideMonoid" href="#Gapjm.Garside.GarsideMonoid"><code>Gapjm.Garside.GarsideMonoid</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>GarsideMonoid{T}</code>  is the abstract  type of Garside  monoids, where <code>T</code> is the type of simples. Such a monoid <code>M</code> should implement the same methods as <code>LocallyGarsideMonoid</code>   except   that   <code>isrightascent</code>  is  automatically defined. It should have fields <code>M.δ</code>,<code>M.stringδ</code>,<code>M.orderδ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L355-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.left_divisors" href="#Gapjm.Garside.left_divisors"><code>Gapjm.Garside.left_divisors</code></a> — <span class="docstring-category">Function</span></header><section><div><p>left_divisors(M::LocallyGarsideMonoid, s)</p><p>all  the left  divisors of  the simple  element <code>s</code>  of <code>M</code>, as a vector of vectors,  where the  i+1-th vector  holds the  divisors of  length i in the atoms.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; B=BraidMonoid(W)
BraidMonoid(A₃)

julia&gt; map(x-&gt;B.(x),left_divisors(B,W(1,3,2)))
4-element Vector{Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}}:
 [.]   
 [1, 3]
 [13]
 [132] 

julia&gt; B=DualBraidMonoid(W)
DualBraidMonoid(A₃,c=[1, 3, 2])

julia&gt; map(x-&gt;B.(x),left_divisors(B,W(1,3,2)))
4-element Vector{Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}}:
 [.]                     
 [1, 2, 3, 4, 5, 6]      
 [12, 13, 15, 25, 34, 45]
 [δ]                     </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L516-L547">source</a></section><section><div><p><code>left_divisors(b::LocallyGarsideElt[, i])</code></p><p>returns all left divisors of <code>b</code> (divisors of length <code>i</code> if specified)</p><pre><code class="language-julia-repl hljs">julia&gt; B=DualBraidMonoid(CoxSym(4))
DualBraidMonoid(𝔖 ₄,c=[1, 3, 2])

julia&gt; left_divisors(B(1,5,4,3))
10-element Vector{GarsideElt{Perm{UInt8}, DualBraidMonoid{Perm{UInt8}, CoxSym{UInt8}}}}:
 .
 1
 1.4
 1.4.2
 1.4.3
 5
 6
 15
 15.4
 15.4.3

julia&gt; left_divisors(B(1,5,4,3),1)
3-element Vector{GarsideElt{Perm{UInt8}, DualBraidMonoid{Perm{UInt8}, CoxSym{UInt8}}}}:
 1
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L822-L850">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.leftgcd" href="#Gapjm.Garside.leftgcd"><code>Gapjm.Garside.leftgcd</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>leftgcd(M::LocallyGarsideMonoid,elts...;complements=false)</code></p><p><code>elts</code>  should be simples of <code>M</code>. The  function returns the left gcd <code>d</code> of the  <code>elts</code>; if <code>complements=true</code>, followed by  a tuple of the complements <code>d^-1*elts[1],…</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L363-L369">source</a></section><section><div><p><code>leftgcd(a₁,…,aₙ;complements=false)</code> </p><p><code>a₁,…,aₙ</code>  should be  elements of  the same  (locally) Garside  monoid. The function returns the left gcd <code>d</code> of <code>a₁,…,aₙ</code>. If <code>complements</code> is true it returns <code>(d,(d⁻¹a₁,…,d⁻¹aₙ))</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; B=BraidMonoid(W)
BraidMonoid(A₃)

julia&gt; leftgcd(B(2,1,2)^2,B(3,2)^2;complements=true)
(2, (121.21, 32.2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L1213-L1230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.rightgcd" href="#Gapjm.Garside.rightgcd"><code>Gapjm.Garside.rightgcd</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>rightgcd(M::LocallyGarsideMonoid,elts...)</code></p><p><code>elts</code>  should be simples of <code>M</code>. The function returns the right gcd <code>d</code> of the  <code>elts</code>; if <code>complements=true</code>, followed by  a tuple of the complements <code>elts[1]*d^-1,…</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L387-L393">source</a></section><section><div><p><code>rightgcd(a₁,…,aₙ;complements=false)</code> </p><p><code>a₁,…,aₙ</code>  should be  elements of  the same  (locally) Garside  monoid. The function returns the right gcd <code>d</code> of <code>a₁,…,aₙ</code>. If <code>complements</code> is true it returns <code>(d,(a₁/d,…,aₙ/d))</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; B=BraidMonoid(W)
BraidMonoid(A₃)

julia&gt; rightgcd(B(2,1,2)^2,B(3,2)^2;complements=true)
(2.2, (12.21, 23))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L1258-L1275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.leftlcm" href="#Gapjm.Garside.leftlcm"><code>Gapjm.Garside.leftlcm</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>leftlcm(M::GarsideMonoid,elts...;complements=false)</code></p><p><code>elts</code>  should be simples of <code>M</code>. The  function returns the left lcm <code>m</code> of the  <code>elts</code>; if <code>complements=true</code>, followed by  a tuple of the complements <code>m/elts[1],…</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L446-L452">source</a></section><section><div><p><code>leftlcm(a₁,…,aₙ;complements=false)</code></p><p><code>a₁,…,aₙ</code>  should  be  elements  of  the  same Garside monoid. The function returns  the least common left multiple  <code>m</code> of <code>a₁,…,aₙ</code>; if <code>complements</code> is true it returns &#39;(m,(m/a₁,…,m/aₙ))`.</p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A₃)

julia&gt; leftlcm(B(2,1,2)^2,B(3,2)^2;complements=true)
(Δ.121, (123, 23.321))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L1284-L1298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.rightlcm" href="#Gapjm.Garside.rightlcm"><code>Gapjm.Garside.rightlcm</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>rightlcm(M::GarsideMonoid,elts...;complements=false)</code></p><p><code>elts</code>  should be simples of <code>M</code>. The function returns the right lcm <code>m</code> of the  <code>elts</code>; if <code>complements=true</code>, followed by  a tuple of the complements <code>elts[1]^-1*m,…</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L434-L440">source</a></section><section><div><p><code>rightlcm(a₁,…,aₙ;complements=false)</code></p><p><code>a₁,…,aₙ</code>  should  be  elements  of  the  same Garside monoid. The function returns  the least common right multiple  <code>m</code> of <code>a₁,…,aₙ</code>; if <code>complements</code> is true it returns &#39;(m,(a₁⁻¹<em>m,…,aₙ⁻¹</em>m))`.</p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A₃)

julia&gt; rightlcm(B(2,1,2)^2,B(3,2)^2;complements=true)
(Δ², (321.123, 12321.321))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L1309-L1323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.α-Tuple{Gapjm.Garside.LocallyGarsideElt}" href="#Gapjm.Garside.α-Tuple{Gapjm.Garside.LocallyGarsideElt}"><code>Gapjm.Garside.α</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>α(b::LocallyGarsideElt)</code></p><p>returns as a Garside element  the first term in  the normal form of  <code>b</code> (this term is <code>b[1]</code> as a simple).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; b=BraidMonoid(W)(2,1,2,1,1)
121.1.1

julia&gt; α(b)
121</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L947-L963">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.α-Tuple{Gapjm.Garside.LocallyGarsideElt, AbstractVector}" href="#Gapjm.Garside.α-Tuple{Gapjm.Garside.LocallyGarsideElt, AbstractVector}"><code>Gapjm.Garside.α</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>α(b::LocallyGarsideElt,I)</code> returns the longest prefix of b which uses only  <code>b.M.atoms[I]</code></p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,4);B=BraidMonoid(W)
BraidMonoid(A₄)

julia&gt; w0=B(longest(W))
Δ

julia&gt; α(w0,[1,2,3])
121321</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L966-L979">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.Brieskorn_normal_form" href="#Gapjm.Garside.Brieskorn_normal_form"><code>Gapjm.Garside.Brieskorn_normal_form</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>Brieskorn_normal_form(b::LocallyGarsideElt)</code></p><p>Brieskorn  citeBri71 has noticed that if <code>L(b)</code>  is the left descent set of <code>b</code>  (see &quot;leftdescents&quot;),  and if  <code>b_(L(b))</code> is  the right lcm of <code>L(b)</code>, then  <code>b_(L(b))</code> left-divides <code>b</code>. We can  now divide <code>b</code> by <code>b_(L(b))</code> and continue  this  process  with  the  quotient.  In  this  way,  we obtain an expression  <code>b=b_(L₁)⋯ b_(Lᵣ)</code>  where <code>Lᵢ=L(b_(Lᵢ)⋯  b_(Lᵣ))</code> for  all <code>i</code>, which   we  call  the   <em>Brieskorn  normal  form</em>   of  <code>b</code>.  The  function <code>Brieskorn_normal_form</code>  returns a  description of  this form, by returning the list of sets <code>L(b)</code> which describe the above decomposition.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,8);B=BraidMonoid(W)
BraidMonoid(E₈)

julia&gt; w=B(2,3,4,2,3,4,5,4,2,3,4,5,6,5,4,2,3,4,5,6,7,6,5,4,2,3,4,5,6,7,8)
2342345423456542345676542345678

julia&gt; Brieskorn_normal_form(w)
2-element Vector{Vector{Int64}}:
 [2, 3, 4, 5, 6, 7]
 [8]

julia&gt; Brieskorn_normal_form(w^2)
2-element Vector{Vector{Int64}}:
 [2, 3, 4, 5, 6, 7, 8]
 [2, 3, 4, 5, 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L856-L885">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.BraidMonoid" href="#Gapjm.Garside.BraidMonoid"><code>Gapjm.Garside.BraidMonoid</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>BraidMonoid(W::CoxeterGroup)</code></p><p>The ordinary monoid of the Artin group associated to <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L676-L680">source</a></section><section><div><p>(B::BraidMonoid)(M::DualBraidMonoid,i::Integer)</p><p>give an expression as an element of <code>B</code> of the <code>i</code>-th atom of <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L1461-L1465">source</a></section><section><div><p>(B::BraidMonoid)(M::DualBraidMonoid,s)</p><p>give an expression as an element of <code>B</code> of the dual simple <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L1467-L1471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.DualBraidMonoid" href="#Gapjm.Garside.DualBraidMonoid"><code>Gapjm.Garside.DualBraidMonoid</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>DualBraidMonoid(W;c=...)</code></p><p>Let  <code>W</code> be a well generated complex  reflection group and <code>c</code> be a Coxeter element  of <code>W</code> (if no <code>c</code> is given  a particular one is chosen for Coxeter groups  by making  the product  of elements  in a  partition of the Coxeter diagram  in two  sets where  in each  set elements  commute pairwise; for a complex  reflection  group  the  Coxeter  element  stored in <code>classinfo</code> is used). The function returns the dual braid monoid determined by <code>W</code> and <code>c</code> (which  should  be  a  <code>Vector{Int}</code>  specifying  a  sequence of indices of reflections of <code>W</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; B=DualBraidMonoid(W)
DualBraidMonoid(A₃,c=[1, 3, 2])

julia&gt; B(2,1,2,1,1)
12.1.1.1

julia&gt; B(-1,-2,-3,1,1)
(25.1)⁻¹1.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L1380-L1405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.hurwitz" href="#Gapjm.Garside.hurwitz"><code>Gapjm.Garside.hurwitz</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>hurwitz(l,i::Integer)</code> the  Hurwitz action of the  generator σᵢ of the  braid group Bₙ on the list <code>l</code>  of  length  <code>n</code>  of  group  elements.  If  <code>i&lt;0</code>  does  the  action of <code>înv(σ₋ᵢ)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L2157-L2162">source</a></section><section><div><p><code>hurwitz(l,b)</code> the  Hurwitz action of the braid  <code>b∈ Bₙ</code> on the list  <code>l</code> of length <code>n</code> of group elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L2176-L2180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.fraction" href="#Gapjm.Garside.fraction"><code>Gapjm.Garside.fraction</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fraction(b::GarsideElt) returns  a tuple <code>(x,y)</code> of two Garside elements with no non-trivial common left divisor and such that <code>b=inv(x)*y</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A₃)

julia&gt; b=B( 2, 1, -3, 1, 1)
(23)⁻¹321.1.1

julia&gt; fraction(b)
(23, 321.1.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L905-L920">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.word-Tuple{GarsideMonoid, Any}" href="#Gapjm.Groups.word-Tuple{GarsideMonoid, Any}"><code>Gapjm.Groups.word</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>word(M::GarsideMonoid,w)</code></p><p>returns a word in the atoms of <code>M</code> representing the simple <code>w</code></p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A₃)

julia&gt; word(B,B.δ)
6-element Vector{Int64}:
 1
 2
 1
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L485-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.word-Tuple{GarsideElt}" href="#Gapjm.Groups.word-Tuple{GarsideElt}"><code>Gapjm.Groups.word</code></a> — <span class="docstring-category">Method</span></header><section><div><p>word(b::GarsideElt) returns  a description  of <code>b</code>  as a  list of  the atoms  of which  it is a product.  If <code>b</code> is in the Garside group  but not the Garside monoid, it is represented  in  fraction  normal  form  where  as a special convention the inverses  of  the  atoms  are  represented  by  negating  the corresponding integer.</p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A₃)

julia&gt; b=B(2,1,2,1,1)*inv(B(2,2))
(21)⁻¹1.12.21

julia&gt; word(b)
7-element Vector{Int64}:
 -1
 -2
  1
  1
  2
  2
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L1002-L1027">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.elements-Tuple{LocallyGarsideMonoid, Any}" href="#Gapjm.Groups.elements-Tuple{LocallyGarsideMonoid, Any}"><code>Gapjm.Groups.elements</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>elements(M::LocallyGarsideMonoid,l)</code></p><p><code>M</code>  should have  an additive  length function  (that is,  a product of <code>l</code> atoms  is not equal to any product of less than <code>l</code> atoms). <code>elements(M,l)</code> returns the list of elements of length <code>l</code> in <code>M</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; M=BraidMonoid(coxgroup(:A,2))
BraidMonoid(A₂)

julia&gt; elements(M,4)
12-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 12.21
 21.12
 1.1.1.1
 2.2.2.2
 1.1.12
 1.12.2
 12.2.2
 2.2.21
 21.1.1
 2.21.1
 Δ.1
 Δ.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L587-L613">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.image" href="#Gapjm.Garside.image"><code>Gapjm.Garside.image</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>image(b::GarsideElt)</code></p><p>This  function is defined only if <code>b</code>  is an element of an interval monoid, for instance a braid. It returns the image of <code>b</code> in the group of which the monoid  is an interval  monoid. For instance  it gives the  projection of a braid in an Artin monoid back to the Coxeter group.</p><pre><code class="language-julia-repl hljs">julia&gt; W=CoxSym(4)
𝔖 ₄

julia&gt; b=BraidMonoid(W)(2,1,2,1,1)
121.1.1

julia&gt; p=image(b)
Perm{UInt8}: (1,3)

julia&gt; word(W,p)
3-element Vector{Int64}:
 1
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L1338-L1362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.conjugating_elt" href="#Gapjm.Garside.conjugating_elt"><code>Gapjm.Garside.conjugating_elt</code></a> — <span class="docstring-category">Function</span></header><section><div><p>conjugating_elt(b,b1[,F];ss=:sc)</p><p><code>b</code>  and <code>b1</code> should  be elements of  the same Garside  group. The function returns  <code>a</code> such that <code>b^a=b1</code> if such exists, and <code>nothing</code> otherwise. If an  argument <code>ss</code>  is given,  the computation  is done in the corresponding category  –- see &quot;conjcat&quot;.  If an argument  <code>F</code> is given  it should be an automorphism  of the braid monoid, like the Frobenius of a reflection coset attached  to <code>b.M.W</code>;  the computation  is then  done in  the corresponding <code>F</code>-conjugacy category.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; B=BraidMonoid(W)
BraidMonoid(D₄)

julia&gt; b=B(2,3,1,2,4,3);b1=B(1,4,3,2,2,2)
1432.2.2

julia&gt; conjugating_elt(b,b1)
(134312.23)⁻¹

julia&gt; c=conjugating_elt(b,b1;ss=:cyc)
232.2

julia&gt; b^c
1432.2.2

julia&gt; WF=spets(W,Perm(1,2,4))
³D₄

julia&gt; F=Frobenius(WF);

julia&gt; c=B(3,4,3,1,2,3)
343123

julia&gt; conjugating_elt(b,c,F)
124312

julia&gt; ^(b,B(1,2,4,3,1,2),F)
343123</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L1767-L1811">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.centralizer_gens" href="#Gapjm.Garside.centralizer_gens"><code>Gapjm.Garside.centralizer_gens</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>centralizer_gens(b[,F];ss=:sc)</code></p><p>a  list of generators of the centralizer of <code>b</code>. The computation is done by computing  the  endomorphisms  of  the  object  <code>b</code>  in the category of its sliding  circuits. If an argument <code>ss</code> is given, the computation is done in the corresponding category –- see <code>conjcat</code>.</p><p>If  an argument  <code>F</code> is  given it  should be  an automorphism  of the braid monoid,  like the Frobenius of a reflection coset attached to <code>b.M.W</code>; then the <code>F</code>-centralizer is computed.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; B=BraidMonoid(W)
BraidMonoid(D₄)

julia&gt; w=B(4,4,4)
4.4.4

julia&gt; cc=centralizer_gens(w)
8-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 1
 (31432)⁻¹231432
 (1)⁻¹34.431
 (2)⁻¹34.432
 (32431)⁻¹132431
 4
 34.43
 2

julia&gt; shrink(cc)
5-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 4            
 2            
 1            
 34.43        
 (3243)⁻¹13243

julia&gt; centralizer_gens(w;ss=:cyc)
Set{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}} with 1 element:
  4

julia&gt; F=Frobenius(spets(W,Perm(1,2,4)));

julia&gt; centralizer_gens(w,F)
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 124      
 312343123</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L1842-L1894">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.conjcat" href="#Gapjm.Garside.conjcat"><code>Gapjm.Garside.conjcat</code></a> — <span class="docstring-category">Function</span></header><section><div><p>&#39;conjcat(b[,F];ss=:sc)&#39;</p><p>returns  the conjugacy category  of the summit  set of <code>b</code>  of the required type.  By default,  computes the  category of  sliding circuits  of <code>b</code>. If <code>ss==:ss</code>,  computes  the  super  summit  set.  If <code>ss==:cyc</code>, computes the cyclic  conjugacy category. Finally, if <code>ss==:inf</code> computes the category of all conjugate elements with same <code>Inf</code> as <code>b</code>.</p><p>If  an argument  <code>F</code> is  given it  should be  the Frobenius of a Reflection coset attached to <code>b.M.W</code>. Then the <code>F</code>-conjugacy category is returned.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,4)
A₄

julia&gt; w=BraidMonoid(W)(4,3,3,2,1)
43.321

julia&gt; C=conjcat(w)
category with 2 objects and 4 generating maps

julia&gt; C.obj
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 32143
 21324</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; xprint(C;graph=true)
category with 2 objects and 4 generating maps
     32143      21343      21324      13214 
32143────→ 32143────→ 21324────→ 21324────→ 32143</code></pre><pre><code class="language-julia-repl hljs">julia&gt; conjcat(w;ss=:ss).obj
4-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 32143
 13243
 21432
 21324</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L1718-L1761">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.endomorphisms" href="#Gapjm.Garside.endomorphisms"><code>Gapjm.Garside.endomorphisms</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>endomorphisms(C::Category,o)</code> returns generators of the endomorphisms of <code>C.obj[o]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L1563-L1566">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Presentations.Presentation-Tuple{GarsideMonoid}" href="#Gapjm.Presentations.Presentation-Tuple{GarsideMonoid}"><code>Gapjm.Presentations.Presentation</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Presentation(M::GarsideMonoid)</code></p><p>returns   a  presentation  of  the  Garside   group  defined  by  <code>M</code>  (the presentation is as given in theorem 4.1 of <a href="biblio.htm#DePa99">Dehornoy-Paris 1999</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; M=DualBraidMonoid(coxgroup(:A,3))
DualBraidMonoid(A₃,c=[1, 3, 2])

julia&gt; p=Presentation(M)
Presentation: 6 generators, 15 relators, total length 62</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; display_balanced(p)
1: ab=da
2: ac=ca
3: ec=cb
4: bd=da
5: bd=ab
6: cd=fc
7: ae=fa
8: be=cb
9: be=ec
10: de=ed
11: ef=fa
12: df=fc
13: df=cd
14: ef=ae
15: def=acb

julia&gt; simplify(p)
&lt;&lt; presentation with 3 generators, 4 relators of total length 26&gt;&gt;
&lt;&lt; presentation with 3 generators, 3 relators of total length 16&gt;&gt;

julia&gt; display_balanced(p)
1: ab=ba
2: cac=aca
3: cbc=bcb</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L1906-L1947">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.shrink" href="#Gapjm.Garside.shrink"><code>Gapjm.Garside.shrink</code></a> — <span class="docstring-category">Function</span></header><section><div><p>shrink(l::Vector{&lt;:GarsideElt})</p><p>The  list <code>l</code> is a  list of  elements of  the same Garside group <code>G</code>. This function  tries to find  another set of  generators of the  subgroup of <code>G</code> generated by the elements of <code>l</code>, of smaller total length (the length being counted  as returned by the function  <code>word</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(CoxSym(3))
BraidMonoid(𝔖 ₃)

julia&gt; b=[B(1)^3,B(2)^3,B(-2,-1,-1,2,2,2,2,1,1,2),B(1,1,1,2)]
4-element Vector{GarsideElt{Perm{UInt8}, BraidMonoid{Perm{UInt8}, CoxSym{UInt8}}}}:
 1.1.1              
 2.2.2              
 (1.12)⁻¹2.2.2.21.12
 1.1.12             

julia&gt; shrink(b)
2-element Vector{GarsideElt{Perm{UInt8}, BraidMonoid{Perm{UInt8}, CoxSym{UInt8}}}}:
 2  
 1  </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Garside.jl#L2075-L2099">source</a></section></article><h1 id="Classes/characters-of-reflection-groups"><a class="docs-heading-anchor" href="#Classes/characters-of-reflection-groups">Classes/characters of reflection groups</a><a id="Classes/characters-of-reflection-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Classes/characters-of-reflection-groups" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars" href="#Gapjm.Chars"><code>Gapjm.Chars</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The  <code>CharTable</code> of a finite complex reflection group <code>W</code> is computed using the  decomposition of <code>W</code> in irreducible  groups (see <code>refltype</code>). For each irreducible  group the character  table is either  computed using recursive formulas  for the infinite series,  or read into the  system from a library file  for the  exceptional types.  Thus, character  tables can  be obtained quickly  even for very large groups  (e.g., E₈). Similar remarks apply for conjugacy classes.</p><p>The  conjugacy  classes  and  irreducible  characters of irreducible finite complex reflection groups have canonical labelings by certain combinatorial objects;  these labelings are used in the  tables we give. For the classes, these  are partitions or partition tuples  for the infinite series, or, for exceptional  Coxeter  groups,  Carter&#39;s  admissible  diagrams <a href="biblio.htm#Car72">Carter1972</a>; for other  primitive  complex  reflection  groups  we  just  use  words  in the generators  to specify  the classes.  For the  characters, these  are again partitions  or partition tuples for the infinite series, and for the others they  are pairs  of two  integers <code>(d,e)</code>  where <code>d</code>  is the  degree of the character  and  <code>e</code>  is  the  smallest  symmetric  power  of the reflection representation  containing  the  given  character  as  a  constituent  (the <code>b</code>-invariant  of the character). This information is obtained by using the functions <code>classinfo</code> and <code>charinfo</code>. When you display the character table, the canonical labelings for classes and characters are those displayed.</p><p>A  typical example  is <code>coxgroup(:A,n)</code>,  the symmetric  group <code>𝔖ₙ₊₁</code> where classes and characters are parameterized by partitions of <code>n+1</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; CharTable(W)
CharTable(A₃)
    │1111 211 22 31  4
────┼──────────────────
1111│   1  -1  1  1 -1
211 │   3  -1 -1  .  1
22  │   2   .  2 -1  .
31  │   3   1 -1  . -1
4   │   1   1  1  1  1

julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; ct=CharTable(W)
CharTable(G₂)
     │A₀ Ã₁ A₁ G₂ A₂ A₁+Ã₁
─────┼─────────────────────
φ₁‚₀ │ 1  1  1  1  1     1
φ₁‚₆ │ 1 -1 -1  1  1     1
φ′₁‚₃│ 1  1 -1 -1  1    -1
φ″₁‚₃│ 1 -1  1 -1  1    -1
φ₂‚₁ │ 2  .  .  1 -1    -2
φ₂‚₂ │ 2  .  . -1 -1     2

julia&gt; ct.charnames
6-element Vector{String}:
 &quot;\phi_{1,0}&quot;
 &quot;\phi_{1,6}&quot;
 &quot;\phi_{1,3}&#39;&quot;
 &quot;\phi_{1,3}&#39;&#39;&quot;
 &quot;\phi_{2,1}&quot;
 &quot;\phi_{2,2}&quot;

julia&gt; ct.classnames
6-element Vector{String}:
 &quot;A_0&quot;
 &quot;\tilde A_1&quot;
 &quot;A_1&quot;
 &quot;G_2&quot;
 &quot;A_2&quot;
 &quot;A_1+\tilde A_1&quot;</code></pre><p>Recall  that our groups acts a reflection group on the vector space <code>V</code>, so have  fake degrees  (see &quot;fakeDegree&quot;).  The valuation  and degree of these give  two  integers  <code>b,B</code>  for  each  irreducible  character  of  <code>W</code> (see <code>charinfo(W).b</code>  and  <code>charinfo(W).B</code>).  For  finite  Coxeter  groups,  the valuation  and degree of  the generic degrees  of the one-parameter generic Hecke  algebra  give  two  more  integers  <code>a,A</code>  (see  <code>charinfo(W).a</code> and <code>charinfo(W).A</code>,   and   <a href="biblio.htm#Car85]  for  more details">Carter1985,   Ch.11</a>. These will also be used in the operations of truncated inductions explained in the chapter &quot;Reflection subgroups&quot;.</p><p>Iwahori-Hecke  algebras and  cyclotomic Hecke  algebras also have character tables, see the corresponding chapters.</p><p>We  now describe for each type our conventions for labeling the classes and characters.</p><p>Type  <code>Aₙ</code> (<code>n≥0</code>). In this  case we have  <code>W ≅ 𝔖ₙ₊₁</code>. The classes and characters  are labeled by partitions of <code>n+1</code>. The partition corresponding to  a class describes  the cycle type  for the elements  in that class; the representative   in  &#39;.classtext&#39;   is  the   concatenation  of  the  words corresponding  to each part, and to a part <code>i</code> is associated the product of <code>i-1</code>  consecutive generators (starting one  higher that the last generator used  for the previous  parts). The partition  corresponding to a character describes  the type of  the Young subgroup  such that the trivial character induced  from this  subgroup contains  that character with multiplicity <code>1</code> and such that every other character occurring in this induced character has a  higher <code>a</code>-value. Thus, the sign  character corresponds to the partition <code>(1ⁿ⁺¹)</code>  and  the  trivial  character  to  the  partition  <code>(n+1)</code>. The character of the reflection representation of <code>W</code> is labeled by <code>(n,1)</code>.</p><p>Type  <code>Bₙ</code>  (<code>n≥2</code>).  In  this  case  <code>W=W(Bₙ)</code> is isomorphic to the wreath product  of the cyclic  group of order  <code>2</code> with the  symmetric group <code>𝔖ₙ</code>. Hence  the classes and characters are  parameterized by pairs of partitions such  that the total sum of their  parts equals <code>n</code>. The pair corresponding to  a class describes the signed cycle type for the elements in that class, as in <a href="biblio.htm#Car72">Carter1972</a>. We use the convention that if <code>(λ,μ)</code> is such a pair then <code>λ</code> corresponds to the positive and <code>μ</code> to the negative cycles.  Thus, <code>(1ⁿ,-)</code> and <code>(-,1ⁿ)</code> label  the trivial class and the class containing  the longest element, respectively. The pair corresponding to an irreducible character is determined via Clifford theory, as follows.</p><p>We  have a semidirect product decomposition <code>W(Bₙ)=N ⋊ 𝔖ₙ</code> where <code>N</code> is the standard  <code>n</code>-dimensional  <code>𝔽₂ⁿ</code>-vector  space.  For  <code>a,b  ≥  0</code> such that <code>n=a+b</code> let <code>η_{a,b}</code> be the irreducible character of <code>N</code> which takes value <code>1</code>  on the first <code>a</code> standard basis vectors and value <code>-1</code> on the next <code>b</code> standard  basis vectors of <code>N</code>. Then  the inertia subgroup of <code>η_{a,b}</code> has the  form <code>T_{a,b}=N.(𝔖_a × 𝔖_b)</code> and  we can extend <code>η_{a,b}</code> trivially to an  irreducible  character  <code>η̃_{a,b}</code>  of  <code>T_{a,b}</code>.  Let  <code>α</code> and <code>β</code> be partitions  of <code>a</code> and <code>b</code>, respectively. We take the tensor product of the corresponding  irreducible characters of <code>𝔖_a</code> and <code>𝔖_b</code> and regard this as an  irreducible  character  of  <code>T_{a,b}</code>.  Multiplying this character with <code>η̃_{a,b}</code>  and  inducing  to  <code>W(Bₙ)</code>  yields an irreducible character <code>χ= χ_{(α,β)}</code>  of <code>W(Bₙ)</code>. This defines the correspondence between irreducible characters and pairs of partitions as above.</p><p>For example, the pair <code>((n),-)</code> labels the trivial character and <code>(-,(1ⁿ))</code> labels  the  sign  character.  The  character  of  the  natural  reflection representation is labeled by <code>((n-1),(1))</code>.</p><p>Type  <code>Dₙ</code> (<code>n≥4</code>). In this case <code>W=W(Dₙ)</code> can be embedded as a subgroup of index  <code>2</code> into the Coxeter  group <code>W(Bₙ)</code>. The intersection  of a class of <code>W(Bₙ)</code> with <code>W(Dₙ)</code> is either empty or a single class in <code>W(Dₙ)</code> or splits up  into two classes in  <code>W(Dₙ)</code>. This also leads  to a parameterization of the  classes of <code>W(Dₙ)</code> by pairs of  partitions <code>(λ,μ)</code> as before but where the  number of parts of <code>μ</code> is even and where there are two classes of this type  if <code>μ</code> is empty and all parts of  <code>λ</code> are even. In the latter case we denote  the two classes in <code>W(Dₙ)</code> by <code>(λ,+)</code> and <code>(λ,-)</code>, where we use the convention  that  the  class  labeled  by <code>(λ,+)</code> contains a representative which  can be written  as a word  in <code>{s₁,s₃,…,sₙ}</code> and  <code>(λ,-)</code> contains a representative which can be written as a word in <code>{s₂,s₃, …,sₙ}</code>.</p><p>By  Clifford theory the restriction of  an irreducible character of <code>W(Bₙ)</code> to  <code>W(Dₙ)</code>  is  either  irreducible  or  splits  up  into  two irreducible components.  Let <code>(α,β)</code> be  a pair of  partitions with total  sum of parts equal to <code>n</code>. If <code>α!=β</code> then the restrictions of the irreducible characters of  <code>W(Bₙ)</code> labeled  by <code>(α,β)</code>  and <code>(β,α)</code>  are irreducible and equal. If <code>α=β</code>  then the restriction of the character labeled by <code>(α,α)</code> splits into two  irreducible components  which we  denote by  <code>(α,+)</code> and <code>(α,-)</code>. Note that  this can only happen if <code>n</code> is  even. In order to fix the notation we use  a  result  of  <a href="biblio.htm#Ste89">Stembridge1989</a>  which describes the value  of the  difference of  these two  characters on  a class of the form <code>(λ,+)</code>  in terms of the character values of the symmetric group <code>𝔖_{n/2}</code>. Recall  that it is implicit  in the notation <code>(λ,+)</code>  that all parts of <code>λ</code> are even. Let <code>λ&#39;</code> be the partition of <code>n/2</code> obtained by dividing each part by  <code>2</code>. Then the value of <code>χ_{(α,-)}-χ_{(α,+)}</code> on an element in the class <code>(λ,+)</code> is given by <code>2^{k(λ)}</code> times the value of the irreducible character of  <code>𝔖_{n/2}</code> labeled by <code>α</code> on the class of cycle type <code>λ&#39;</code>. (Here, <code>k(λ)</code> denotes the number of non-zero parts of <code>λ</code>.)</p><p>The  labels for the trivial, the  sign and the natural reflection character are the same as for <code>W(Bₙ)</code>, since these characters are restrictions of the corresponding characters of <code>W(Bₙ)</code>.</p><p>The groups <code>G(d,1,n)</code>. They  are isomorphic to the wreath product of the cyclic group of order <code>d</code> with  the  symmetric  group  <code>𝔖ₙ</code>.  Hence  the  classes  and characters are parameterized  by <code>d</code>-tuples of partitions such that the total sum of their parts  equals <code>n</code>. The words chosen  as representatives of the classes are, when <code>d&gt;2</code>, computed in a slightly different way than for <code>Bₙ</code>, in order to agree  with the words on which Ram  and Halverson compute the characters of the  Hecke algebra. First the parts of the <code>d</code> partitions are merged in one big  partition and sorted in  increasing order. Then, to  a part <code>i</code> coming from  the <code>j</code>-th partition is  associated the word <code>(l+1…1… l+1)ʲ⁻¹l+2…l+i</code> where <code>l</code> is the highest generator used to express the previous part.</p><p>The  <code>d</code>-tuple corresponding to an  irreducible character is determined via Clifford  theory in  a similar  way than  for the  <code>Bₙ</code> case.  The identity character  has the first  partition with one  part equal <code>n</code>  and the other ones  empty. The character of the  reflection representations has the first two  partitions with one part  equal respectively to <code>n-1</code>  and to <code>1</code>, and the other partitions empty.</p><p>The groups <code>G(de,e,n)</code>. They  are normal  subgroups of  index <code>e</code>  in <code>G(de,1,n)</code>.  The quotient is cyclic,  generated by the image <code>g</code>  of the first generator of <code>G(de,1,n)</code>. The  classes are parameterized as the  classes of <code>G(de,e,n)</code> with an extra information for a component of a class which splits.</p><p>According  to  <a href="biblio.htm#Hu85">Hugues1985</a>,  a  class  <code>C</code> of <code>G(de,1,n)</code> parameterized  by a <code>de</code>-partition <span>$(S₀,…,S_{de-1})$</span> is in <code>G(de,e,n)</code> if <code>e</code>  divides <span>$∑ᵢ i ∑_{p∈ Sᵢ}p$</span>. It  splits in <code>d</code> classes for the largest <code>d</code>  dividing <code>e</code> and all parts of all  <code>Sᵢ</code> and such that <code>Sᵢ</code> is empty if <code>d</code>  does not divide <code>i</code>. If <code>w</code> is in <code>C</code> then &#39;gⁱ w g⁻ⁱ&#39; for &#39;i in 0:d-1&#39; are  representatives of the classes of <code>G(de,e,n)</code> which meet <code>C</code>. They are described by appending the integer <code>i</code> to the label for <code>C</code>.</p><p>The  characters are described by Clifford theory. We make <code>g</code> act on labels for  characters of <code>G(de,1,n)</code>  . The action  of <code>g</code> permutes circularly by <code>d</code>  the partitions in the <code>de</code>-tuple.  A character has same restriction to <code>G(de,e,n)</code>  as its transform by <code>g</code>.  The number of irreducible components of its restriction is equal to the order <code>k</code> of its stabilizer under powers of  <code>g</code>.  We  encode  a  character  of  <code>G(de,e,n)</code>  by first, choosing the smallest  for lexicographical order label  of a character whose restriction contains  it; then this label is periodic with a motive repeated <code>k</code> times; we  represent the  character by  one of  these motives,  to which we append <code>E(k)ⁱ</code> for &#39;i in 0:k-1&#39; to describe which component of the restriction we choose.</p><p>Types <code>G₂</code> and <code>F₄</code>. The matrices of character values and the orderings and labelings  of  the  irreducible  characters  are  exactly  the  same  as in <a href="biblio.htm#Car85">Carter1985,  p.412/413</a>:  in  type  <code>G₂</code>  the  character <code>φ₁,₃&#39;</code>  takes the value -1 on the reflection associated to the long simple root;  in type <code>F₄</code>, the characters <code>φ₁,₁₂&#39;</code>, <code>φ₂,₄&#39;</code>, <code>φ₄,₇&#39;</code>, <code>φ₈,₉&#39;</code> and <code>φ₉,₆&#39;</code> occur in the induced of the identity from the <code>A₂</code> corresponding to the  short  simple  roots;  the  pairs  (<code>φ₂,₁₆&#39;</code>,  <code>φ₂,₄″</code>)  and (<code>φ₈,₃&#39;</code>, <code>φ₈,₉″</code>)  are  related  by  tensoring  by  sign; and finally <code>φ₆,₆″</code> is the exterior  square of the  reflection representation. Note,  however, that we put  the long root at  the left of the  Dynkin diagrams to be in accordance with the conventions in <a href="biblio.htm#Lus85">Lusztig1985, (4.8) and (4.10)</a>.</p><p>The classes are labeled by Carter&#39;s admissible diagrams <a href="biblio.htm#Car72">Carter1972</a>.  A character  is labeled  by a pair <code>(d,b)</code> where  <code>d</code> denotes the  degree and <code>b</code>  the corresponding <code>b</code>-invariant. If there  are several characters with the same  pair <code>(d,b)</code> we attach a prime to them, as in <a href="biblio.htm#Car85">Carter1985</a>.</p><p>Types  <code>E₆,E₇,E₈</code>. The character  tables are obtained  by specialization of those  of the Hecke algebra. The classes are labeled by Carter&#39;s admissible diagrams <a href="biblio.htm#Car72">Carter1972</a>. A character is labeled by the pair <code>(d,b)</code>  where  <code>d</code>  denotes  the  degree  and  <code>b</code>  is  the  corresponding <code>b</code>-invariant.  For  these  types,  this  gives  a  unique  labeling of the characters.</p><p>Non-crystallographic  types <code>I₂(m)</code>, <code>H₃</code>, <code>H₄</code>. In these cases we do not have  canonical  labelings  for  the  classes.  We  label  them  by reduced expressions.</p><p>Each  character for  type <code>H₃</code>  is uniquely  determined by the pair <code>(d,b)</code> where  <code>d</code> is the degree and  <code>b</code> the corresponding <code>b</code>-invariant. For type <code>H₄</code>  there are just  two characters (those  of degree <code>30</code>)  for which the corresponding  pairs are  the same.  These two  characters are nevertheless distinguished  by  their  fake  degrees:  the  character <code>φ₃₀,₁₀&#39;</code> has fake degree  <code>q¹⁰+q¹²+</code> higher terms, while <code>φ₃₀,₁₀″</code> has fake degree <code>q¹⁰+q¹⁴+</code> higher  terms. The characters in the table for type <code>H₄</code> are ordered in the same way as in <a href="biblio.htm#AL82">Alvis and Lusztig1982</a>.</p><p>Finally,  the characters  of degree <code>2</code>  for type  <code>I₂(m)</code> are  ordered as follows.  The matrix representations affording the characters of degree <code>2</code> are given by: <span>$ρ_j : s₁s₂ ↦ \begin{pmatrix}E(m)^j&amp;0\\0&amp;E(m)^{-j}\end{pmatrix},  s₁↦\begin{pmatrix}0&amp;1\\1&amp;0\end{pmatrix},$</span> where  <code>1 ≤ j ≤  ⌊(m-1)/2⌋</code>. The reflection representation is  <code>ρ₁</code>. The  characters in  the table  are ordered by listing first the characters of degree 1 and then <code>ρ₁,ρ₂,…</code>.</p><p>Primitive complex reflection groups <code>G₄</code> to <code>G₃₄</code>. The  groups <code>G₂₃=H₃</code>, <code>G₂₈=F₄</code>, <code>G₃₀=H₄</code> are exceptional Coxeter groups and have  been  explained  above.  Similarly  for  the  other groups labels for characters  consist primarily  of the  pair <code>(d,b)</code>  where <code>d</code>  denotes the degree  and <code>b</code> is the corresponding  <code>b</code>-invariant. This is sufficient for <code>G₄</code>,  <code>G₁₂</code>, <code>G₂₂</code> and <code>G₂₄</code>. For other  groups there are pairs or triples of  characters which  have the  same <code>(d,b)</code>  value. We  disambiguate these according  to  the  conventions  of <a href="biblio.htm#Mal00">Malle2000</a> for <code>G₂₇, G₂₉, G₃₁, G₃₃</code> and <code>G₃₄</code>:</p><ul><li>For <code>G₂₇</code>:</li></ul><p>The  fake degree  of <code>φ₃,₅&#39;</code>  (resp. <code>φ₃,₂₀&#39;</code>,  <code>φ₈,₉″</code>) has smaller degree that  of  <code>φ₃,₅″</code>  (resp.  <code>φ₃,₂₀″</code>,  <code>φ₈,₉&#39;</code>). The characters <code>φ₅,₁₅&#39;</code> and <code>φ₅,₆&#39;</code> occur with multiplicity 1 in the induced from the trivial character of  the parabolic subgroup  of type <code>A₂</code>  generated by the  first and third generator  (it is asserted mistakenly in <a href="biblio.htm#Mal00">Malle2000</a> that <code>φ₅,₆″</code> does not occur in this induced; it occurs with multiplicity 2).</p><ul><li>For <code>G₂₉</code>:</li></ul><p>The  character  <code>φ₆,₁₀‴</code>  is  the  exterior  square  of <code>φ₄,₁</code>; its complex conjugate  is <code>φ₆,₁₀⁗</code>. The  character <code>φ₁₅,₄″</code> occurs  in <code>φ₄,₁⊗φ₄,₃</code>; the character  <code>φ₁₅,₁₂″</code>  is  tensored  by  the  sign  character from <code>φ₁₅,₄″</code>. Finally  <code>φ₆,₁₀&#39;</code> occurs in  the induced from  the trivial character of the standard parabolic subgroup of type <code>A₃</code> generated by the first, second and fourth generators.</p><ul><li>For <code>G₃₁</code>:</li></ul><p>The  characters <code>φ₁₅,₈&#39;</code>, <code>φ₁₅,₂₀&#39;</code> and <code>φ₄₅,₈″</code> occur in <code>φ₄,₁⊗φ₂₀,₇</code>; the character   <code>φ₂₀,₁₃&#39;</code>  is  complex  conjugate  of  <code>φ₂₀,₇</code>;  the  character <code>φ₄₅,₁₂&#39;</code>  is tensored by sign of <code>φ₄₅,₈&#39;</code>. The two terms of maximal degree of  the fakedegree of <code>φ₃₀,₁₀&#39;</code> are  <code>q⁵⁰+q⁴⁶</code> while for <code>φ₃₀,₁₀″</code> they are <code>q⁵⁰+2q⁴⁶</code>.</p><ul><li>For <code>G₃₃</code>:</li></ul><p>The  terms of  maximal degree  of the  fakedegree of <code>φ₁₀,₈&#39;</code> are <code>q²⁸+q²⁶</code> while  for <code>φ₁₀,₈&#39;</code> they are <code>q²⁸+q²⁴</code>. The  terms of maximal degree of the fakedegree   of  <code>φ₄₀,₅&#39;</code>  are  <code>q³¹+q²⁹</code>   while  for  <code>φ₄₀,₅″</code>  they  are <code>q³¹+2q²⁹</code>.  The character  <code>φ₁₀,₁₇&#39;</code> is  tensored by  sign of <code>φ₁₀,₈&#39;</code> and <code>φ₄₀,₁₄&#39;</code> is tensored by sign of <code>φ₄₀,₅&#39;</code>.</p><ul><li>For <code>G₃₄</code>:</li></ul><p>The  character <code>φ₂₀,₃₃&#39;</code> occurs in <code>φ₆,₁⊗φ₁₅,₁₄</code>. The character <code>φ₇₀,₉&#39;</code> is rational.  The character  <code>φ₇₀,₉″</code> occurs  in <code>φ₆,₁⊗φ₁₅,₁₄</code>.  The character <code>φ₇₀,₄₅&#39;</code>   is  rational.The   character  <code>φ₇₀,₄₅″</code>   is  tensored  by  the determinant  character of  <code>φ₇₀,₉″</code>. The  character <code>φ₅₆₀,₁₈&#39;</code> is rational. The character <code>φ₅₆₀,₁₈‴</code> occurs in <code>φ₆,₁⊗φ₃₃₆,₁₇</code>. The character <code>φ₂₈₀,₁₂&#39;</code> occurs    in   <code>φ₆,₁⊗φ₃₃₆,₁₇</code>.   The   character   <code>φ₂₈₀,₃₀″</code>   occurs   in <code>φ₆,₁⊗φ₃₃₆,₁₇</code>.  The  character  <code>φ₅₄₀,₂₁&#39;</code>  occurs  in <code>φ₆,₁⊗φ₁₀₅,₂₀</code>. The character  <code>φ₁₀₅,₈&#39;</code> is  complex conjugate  of <code>φ₁₀₅,₄</code>,  and <code>φ₈₄₀,₁₃&#39;</code> is complex  conjugate  of  <code>φ₈₄₀,₁₁</code>.  The  character  <code>φ₈₄₀,₂₃&#39;</code>  is  complex conjugate  of  <code>φ₈₄₀,₁₉</code>.  Finally  <code>φ₁₂₀,₂₁&#39;</code>  occurs  in induced from the trivial character of the standard parabolic subgroup of type <code>A₅</code> generated by the generators of <code>G₃₄</code> with the third one omitted.</p><p>For  the groups <code>G₅</code> and <code>G₇</code> we  adopt the following conventions. For <code>G₅</code> they are compatible with those of <a href="biblio.htm#MR03">MalleRouquier2003</a> and <a href="biblio.htm#BMM14">BroueMalleMichel2014</a>.</p><ul><li>For <code>G₅</code>:</li></ul><p>We  let <code>W=ComplexReflectionGroup(5)</code>,  so the  generators are  <code>W(1)</code> and <code>W(2)</code>.</p><p>The  character <code>φ₁,₄&#39;</code> (resp. <code>φ₁,₁₂&#39;</code>, <code>φ₂,₃&#39;</code>) takes the value <code>1</code> (resp. <code>ζ₃</code>,  <code>-ζ₃</code>)  on  <code>W(1)</code>.  The  character  <code>φ₁,₈″</code> is complex conjugate to <code>φ₁,₁₆</code>,  and the character  <code>φ₁,₈&#39;</code> is complex  conjugate to <code>φ₁,₄&#39;</code> . The character  <code>φ₂,₅″</code> is complex  conjugate to <code>φ₂,₁</code>;  <code>φ₂,₅&#39;</code> take the value <code>-1</code> on <code>W(1)</code>. The character <code>φ₂,₇&#39;</code> is complex conjugate to <code>φ₂,₅&#39;</code>.</p><ul><li>For <code>G₇</code>:</li></ul><p>We  let <code>W=ComplexReflectionGroup(7)</code>,  so the  generators are <code>W(1)</code>, <code>W(2)</code> and <code>W(3)</code>.</p><p>The  characters  <code>φ₁,₄&#39;</code>  and  <code>φ₁,₁₀&#39;</code>  take  the value <code>1</code> on <code>W(2)</code>. The character  <code>φ₁,₈″</code> is complex  conjugate to <code>φ₁,₁₆</code>  and <code>φ₁,₈&#39;</code> is complex conjugate  to <code>φ₁,₄&#39;</code>. The characters <code>φ₁,₁₂&#39;</code>  and <code>φ₁,₁₈&#39;</code> take the value <code>ζ₃</code>  on <code>W(2)</code>. The character <code>φ₁,₁₄″</code> is complex conjugate to <code>φ₁,₂₂</code> and <code>φ₁,₁₄&#39;</code>  is complex conjugate to <code>φ₁,₁₀&#39;</code>. The character <code>φ₂,₃&#39;</code> takes the value  <code>-ζ₃</code> on  <code>W(2)</code> and  <code>φ₂,₁₃&#39;</code> takes  the value  <code>-1</code> on <code>W(2)</code>. The characters  <code>φ₂,₁₁″</code>, <code>φ₂,₅″</code>, <code>φ₂,₇‴</code> and  <code>φ₂,₁</code> are Galois conjugate, as well  as  the  characters  <code>φ₂,₇&#39;</code>,  <code>φ₂,₁₃&#39;</code>,  <code>φ₂,₁₁&#39;</code>  and  <code>φ₂,₅&#39;</code>. The character  <code>φ₂,₉&#39;</code> is complex  conjugate to <code>φ₂,₁₅</code>  and <code>φ₂,₉‴</code> is complex conjugate to <code>φ₂,₃&#39;</code>.</p><p>Finally,  for the remaining groups <code>G₆, G₈</code>  to <code>G₁₁, G₁₃</code> to <code>G₂₁</code>, <code>G₂₅</code>, <code>G₂₆</code>,  <code>G₃₂</code> and <code>G₃₃</code> there are only  pairs of characters with same value <code>(d,b)</code>.  We give labels uniformly to these characters by applying in order the following rules :</p><ul><li><p>If the two characters have  different fake degrees, label <code>φ_{d,b}&#39;</code> the  one  whose  fake  degree  is  minimal  for  the  lexicographic  order of  polynomials (starting with the highest term).</p></li><li><p>For the not yet labeled pairs, if only one of the two characters has the  property   that  in  its   Galois  orbit  at   least  one  character  is  distinguished by its <code>(d,b)</code>-invariant, label it <code>φ_{d,b}&#39;</code>.</p></li><li><p>For the not yet labeled pairs,  if the minimum of the <code>(d,b)</code>-value (for  the  lexicographic  order  <code>(d,b)</code>)  in  the  Galois  orbits  of the two  character  is different, label <code>φ_{d,b}&#39;</code> the character with the minimal  minimum.</p></li><li><p>We define now a new invariant  for characters: consider all the pairs of  irreducible   characters  <code>χ</code>  and  <code>ψ</code>  uniquely  determined  by  their  <code>(d,b)</code>-invariant such that <code>φ</code> occurs with non-zero multiplicity <code>m</code> in  <code>χ⊗ψ</code>.  We define  <code>t(φ)</code> to  be the  minimal (for  lexicographic order)  possible list <code>(d(χ),b(χ),d(ψ),b(ψ),m)</code>.</p></li></ul><p>For  the not  yet labeled  pairs, if  the t-invariants are different, label <code>φ_{d,b}&#39;</code> the character with the minimal <code>t</code>-invariant.</p><p>After  applying  the  last  rule  all  the  pairs  will be labelled for the considered  groups. The labelling obtained  is compatible for <code>G₂₅</code>, <code>G₂₆</code>, <code>G₃₂</code>  and <code>G₃₃</code>  with that  of <a href="biblio.htm#Mal00">Malle2000</a>  and for <code>G₈</code> with that described in <a href="biblio.htm#MR03">MalleRouquier2003</a>.</p><p>We  should  emphasize  that  for  all  groups  with  a  few exceptions, the parameters  for characters do  not depend on  any non-canonical choice. The exceptions  are <code>G(de,e,n)</code> with <code>e&gt;1</code>, and <code>G₅</code>, <code>G₇</code>, <code>G₂₇</code>, <code>G₂₈</code>, <code>G₂₉</code> and  <code>G₃₄</code>, groups  which admit  outer automorphisms  preserving the set of reflections,  so choices  of a  particular value  on a particular generator must be made for characters which are not invariant by these automorphisms.</p><p>Labels  for the classes. For the exceptional complex reflection groups, the labels  for the classes represent the  decomposition of a representative of the  class as a product of generators, with the additional conventions that &#39;z&#39;  represents the generator  of the center  and for well-generated groups &#39;c&#39;  represents a Coxeter element  (a product of the  generators which is a regular element for the highest reflection degree).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L1-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.CharTable" href="#Gapjm.Chars.CharTable"><code>Gapjm.Chars.CharTable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>CharTable is a structure to hold character tables of groups and Hecke  algebras</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L853-L856">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.on_chars" href="#Gapjm.Chars.on_chars"><code>Gapjm.Chars.on_chars</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>on_chars(G,aut)</code></p><p><code>aut</code>  is an automorphism of  the group <code>G</code> (for  a permutation group, this could  be  given  as  a  permutation  normalizing  <code>G</code>).  The result is the permutation  <code>1:nconjugacy_classes(G)</code> (representing indices of irreducible characters) induced by <code>aut</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(&quot;3D4&quot;)
³D₄

julia&gt; on_chars(Group(WF),WF.phi)
(1,2,7)(8,9,12)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L961-L976">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.charinfo" href="#Gapjm.Chars.charinfo"><code>Gapjm.Chars.charinfo</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>charinfo(W)</code></p><p>returns   information  about  the  irreducible  characters  of  the  finite reflection group <code>W</code>. The result has the following entries:</p><p><code>.charparams</code>:  contains  parameters  for  the  irreducible  characters  as described  in the  introduction to  this chapter.  The parameters are lists with  one  component  for  each  irreducible  component of <code>W</code> (as given by <code>refltype</code>).   For  an  irreducible  component   which  is  an  imprimitive reflection  group the component of the  <code>charparam</code> is a list of partitions (partitions  for type  <code>:A</code>, double  partitions for  type <code>:B</code>),  and for a primitive irreducible group it is a list <code>[d,e]</code> where <code>d</code> is the degree of the  character and <code>e</code> is the smallest  symmetric power of the character of the  reflection  representation  which  contains  the  given character as a component  (the same as <code>b</code> below). In addition, there is an ordinal number if more than one character shares the same <code>[d,e]</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; charinfo(coxgroup(:G,2))[:charparams]
6-element Vector{Vector{Vector{Int64}}}:
 [[1, 0]]
 [[1, 6]]
 [[1, 3, 1]]
 [[1, 3, 2]]
 [[2, 1]]
 [[2, 2]]</code></pre><p>when  you print a <code>charinfo</code> at the Repl  or in Pluto or Jupyter, you get a table synthesizing the information.</p><pre><code class="language-julia-repl hljs">julia&gt; charinfo(coxgroup(:G,2))
n0│ name ext b B a A spaltenstein
──┼───────────────────────────────
1 │ φ₁‚₀  Id 0 0 0 0            1
2 │ φ₁‚₆ det 6 6 6 6            ε
3 │φ′₁‚₃     3 3 1 5           εₗ
4 │φ″₁‚₃     3 3 1 5          ε_c
5 │ φ₂‚₁  Λ¹ 1 5 1 5           θ′
6 │ φ₂‚₂     2 4 1 5           θ″</code></pre><p>the  column <code>name</code>  reflects the  field <code>.charnames</code>,  a name computed from <code>.charparams</code>. This is the same as <code>charnames(io,W)</code> where here <code>io</code> being the Repl has the property <code>:limit</code> on.</p><p>The   column   <code>ext</code>   shows   the   exterior   powers  of  the  reflection representation.   If  <code>W</code>  is  not  irreducible,  only  two  of  these  are irreducible  thus shown:  <code>Id</code> corresponds  to the  field <code>.positionId</code> and shows  which  is  the  trivial  character.  <code>det</code>  corresponds to the field <code>.positionDet</code>  and shows the determinant character (for Coxeter groups the sign  character);  it  is  the  highest  non-trivial  exterior power if the reflection representation.</p><p>The  characters marked <code>Λⁱ</code> are the <code>i</code>-th exterior power of the reflection representation.  They are  only present  if <code>W</code>  is irreducible,  when they correspond  to the field <code>.extRefl</code> whose  <code>i+1</code>-th element is the index of the character <code>Λⁱ</code>.</p><p>The  column  <code>b</code>  shows  the  field  <code>.b</code>  listing  for  each character the valuation  of the fake degree, and the column <code>B</code> shows the field <code>.B</code>, the degree of the fake degree.</p><p>The  columns <code>a</code> and  <code>A</code> only appear  for Spetsial groups. They correspond then  to the fields  <code>.a</code> and <code>.A</code>,  and contain respectively the valuation and the degree of the generic degree of the character (in the one-parameter Hecke algebra <code>hecke(W,Pol())</code> for <code>W</code>).</p><p>For  irreducible  groups,  the  table  shows  sometimes additional columns, corresponding to a field of the same name.</p><p>for  <code>F₄</code>, the column <code>kondo</code> gives the labeling of the characters given by Kondo, also used in <a href="biblio.htm#Lus85">Lusztig1985, (4.10)</a>.</p><p>for  <code>E₆, E₇, E₈</code> the  column <code>frame</code> gives the  labeling of the characters given   by  Frame,   also  used   in  <a href="biblio.htm#Lus85">Lusztig1985,   (4.11),  (4.12),  and (4.13)</a>.</p><p>for  <code>G₂</code> the  column <code>spaltenstein</code>  gives the  labeling of the characters given by Spaltenstein.</p><p>for <code>G(de,e,2)</code> even <code>e</code> and <code>d&gt;1</code>, the column <code>malle</code> gives the parameters for the characters used in <a href="biblio.htm#Mal96">Malle1996</a>.</p><p>Finally,  the  field  <code>.hgal</code>  contains  the  permutation of the characters resulting  from a Galois  action on the  characters of <code>H=hecke(W,Pol()^e)</code> where  <code>e</code> is the order of  the center of <code>W</code>. <code>H</code>  splits by taking <code>v</code> an <code>e</code>-th root of <code>Pol()</code>, and <code>.hgal</code> records the permutation effected by the Galois action <code>v-&gt;E(e)*v</code> (<code>charinfo</code> does not have the key <code>:hgal</code> if this permutation   is  trivial).  <code>.hgal*conj</code>,  where  <code>conj</code>  is  the  complex conjugaison, is the Opdam involution.</p><pre><code class="language-julia-repl hljs">julia&gt; charinfo(ComplexReflectionGroup(24))
n0│ name ext  b  B  a  A
──┼──────────────────────
1 │ φ₁‚₀  Id  0  0  0  0
2 │φ₁‚₂₁ det 21 21 21 21
3 │ φ₃‚₈      8 18  8 20
4 │ φ₃‚₁  Λ¹  1 11  1 13
5 │φ₃‚₁₀  Λ² 10 20  8 20
6 │ φ₃‚₃      3 13  1 13
7 │ φ₆‚₂      2 12  1 13
8 │ φ₆‚₉      9 19  8 20
9 │ φ₇‚₆      6 18  6 18
10│ φ₇‚₃      3 15  3 15
11│ φ₈‚₄      4 16  4 17
12│ φ₈‚₅      5 17  4 17
hgal=(11,12)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L514-L625">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.charnames" href="#Gapjm.Chars.charnames"><code>Gapjm.Chars.charnames</code></a> — <span class="docstring-category">Function</span></header><section><div><p>charnames(uc;options...) charnames(io::IO,uc)</p><p>returns  the list of character names for the unipotent characters uc. The optional  options  are  IOContext  attributes  which can give alternative names  in certain cases,  or a different  formatting of names in general. They can be specified by giving an IO as argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Uch.jl#L286-L293">source</a></section><section><div><p><code>charnames(W;options...)</code> <code>charnames(io::IO,W)</code></p><p>returns  the  list  of  character  names  for the reflection group <code>W</code>. The optional  options are IOContext attributes which can give alternative names in  certain cases, or a different formatting  of names in general. They can be specified by giving an IO as argument.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; charnames(W;limit=true)
6-element Vector{String}:
 &quot;φ₁‚₀&quot;
 &quot;φ₁‚₆&quot;
 &quot;φ′₁‚₃&quot;
 &quot;φ″₁‚₃&quot;
 &quot;φ₂‚₁&quot;
 &quot;φ₂‚₂&quot;

julia&gt; charnames(W;TeX=true)
6-element Vector{String}:
 &quot;\phi_{1,0}&quot;
 &quot;\phi_{1,6}&quot;
 &quot;\phi_{1,3}&#39;&quot;
 &quot;\phi_{1,3}&#39;&#39;&quot;
 &quot;\phi_{2,1}&quot;
 &quot;\phi_{2,2}&quot;

julia&gt; charnames(W;spaltenstein=true,limit=true)
6-element Vector{String}:
 &quot;1&quot;
 &quot;ε&quot;
 &quot;εₗ&quot;
 &quot;ε_c&quot;
 &quot;θ′&quot;
 &quot;θ″&quot;

julia&gt; charnames(W;spaltenstein=true,TeX=true)
6-element Vector{String}:
 &quot;1&quot;
 &quot;\varepsilon&quot;
 &quot;\varepsilon_l&quot;
 &quot;\varepsilon_c&quot;
 &quot;\theta&#39;&quot;
 &quot;\theta&#39;&#39;&quot;</code></pre><p>The  last two  commands show  the character  names used by Spaltenstein and Lusztig when describing the Springer correspondence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L1168-L1220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.classnames" href="#Gapjm.Chars.classnames"><code>Gapjm.Chars.classnames</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>classnames(W;options...)</code> <code>classnames(io::IO,W)</code></p><p>returns  the  list  of  class  names  for the reflection group <code>W</code>. The optional  options are IOContext attributes which can give alternative names in  certain cases, or a different formatting  of names in general. They can be specified by giving an IO as argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L1236-L1244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.classinfo" href="#Gapjm.Chars.classinfo"><code>Gapjm.Chars.classinfo</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>classinfo(W)</code></p><p>returns  information about the  conjugacy classes of  the finite reflection group <code>W</code>. The result is a Dict with three entries:</p><p><code>:classtext</code>:  contains words in  the generators describing representatives of  each  conjugacy  class.  Each  word  is  a  list  of integers where the generator  <code>sᵢ</code>  is  represented  by  the  integer  <code>i</code>. For finite Coxeter groups, it is the same as <code>map(x-&gt;word(W,representative(x)),conjugacyclasses(W))</code>,   and   each  such representative  is of minimal length in its  conjugacy class and is a &quot;very good&quot; element in the sense of <a href="biblio.htm#GM97">GeckMichel1997</a>.</p><p><code>:classparams</code>:  The  elements  of  this  list  are  tuples  which have one component  for each irreducible component of  <code>W</code>. These components for the infinite  series,  contain  partitions  or  partition tuples describing the class  (see  the  introduction).  For  the  exceptional Coxeter groups they contain  Carter&#39;s admissible  diagrams, see <a href="biblio.htm#Car72">Carter1972</a>. For  exceptional complex reflection groups they contain in general the same information as in classtext.</p><p><code>:classnames</code>:  Contains strings describing the conjugacy classes, made out of the information in <code>:classparams</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; classinfo(coxgroup(:A,2))
Dict{Symbol, Any} with 5 entries:
  :classes     =&gt; [1, 3, 2]
  :orders      =&gt; [1, 2, 3]
  :classtext   =&gt; [Int64[], [1], [1, 2]]
  :classnames  =&gt; [&quot;111&quot;, &quot;21&quot;, &quot;3&quot;]
  :classparams =&gt; [[[1, 1, 1]], [[2, 1]], [[3]]]</code></pre><p>See also the introduction of this section.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L784-L820">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.fakedegree" href="#Gapjm.Chars.fakedegree"><code>Gapjm.Chars.fakedegree</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>fakedegree(W, φ, q)</code></p><p>returns  the  fake degree  of  the  character  of parameter  φ  (see :CharParams)  of  the  reflection  group <code>W</code>,  evaluated  at  <code>q</code>  (see &quot;fakeDegrees&quot; for a definition of the fake degrees).</p><pre><code class="language-julia-repl hljs">julia&gt; Chars.fakedegree(coxgroup(:A,2),[[2,1]],Pol(:q))
Pol{Cyc{Int64}}: q²+q</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L401-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.fakedegrees" href="#Gapjm.Chars.fakedegrees"><code>Gapjm.Chars.fakedegrees</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>fakedegrees(W , q=Pol())</code></p><p>returns  a list holding the fake degrees of the reflection group <code>W</code> on the vector  space <code>V</code>, evaluated at <code>q</code>. These are the graded multiplicities of the  irreducible characters of <code>W</code> in the quotient <code>SV/I</code> where <code>SV</code> is the symmetric  algebra of <code>V</code> and <code>I</code> is the ideal generated by the homogeneous invariants  of  positive  degree  in  <code>SV</code>.  The  ordering  of  the  result corresponds to the ordering of the characters in &#39;CharTable(W)&#39;.</p><pre><code class="language-julia-repl hljs">julia&gt; fakedegrees(coxgroup(:A,2),Pol(:q))
3-element Vector{Pol{Int64}}:
 q³
 q²+q
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L426-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.representation" href="#Gapjm.Chars.representation"><code>Gapjm.Chars.representation</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>representation(c::LeftCell,H)</code></p><p>returns matrices giving the representation of <code>H</code> on the left cell <code>c</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:H,3)
H₃

julia&gt; c=LeftCells(W)[3]
LeftCell&lt;H₃: duflo=(15) character=φ₅‚₅&gt;

julia&gt; @Mvp q;H=hecke(W,q)
hecke(H₃,q)

julia&gt; representation(c,H)
3-element Vector{Matrix{Mvp{Int64, Rational{Int64}}}}:
 [-1 0 … 0 0; 0 -1 … 0 -q½; … ; 0 0 … q 0; 0 0 … 0 q]
 [-1 -q½ … 0 0; 0 q … 0 0; … ; 0 0 … -1 0; 0 -q½ … 0 -1]
 [q 0 … 0 0; -q½ -1 … 0 0; … ; 0 0 … q 0; 0 0 … 0 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/KL.jl#L651-L672">source</a></section><section><div><p><code>representation(W,i)</code></p><p>returns a list holding, for the <code>i</code>-th irreducible character of the complex reflection  group  <code>W</code>,  a  list  of  matrices  images  of  the  generating reflections  of <code>W</code>  in a  model of  the corresponding representation. This function  is based on the classification,  and is not yet fully implemented for   <code>G₃₄</code>;  78  representations   are  missing  out   of  169,  that  is, representations  of dimension ≥140, except half of those of dimensions 315, 420 and 840.</p><pre><code class="language-julia-repl hljs">julia&gt; representation(ComplexReflectionGroup(24),3)
3-element Vector{Matrix{Cyc{Int64}}}:
 [1 0 0; -1 -1 0; -1 0 -1]
 [-1 0 -1; 0 -1 (1-√-7)/2; 0 0 1]
 [-1 -1 0; 0 1 0; 0 (1+√-7)/2 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L983-L1001">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.representations" href="#Gapjm.Chars.representations"><code>Gapjm.Chars.representations</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>representations(W)</code></p><p>returns the representations of <code>W</code> (see <code>representation</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; representations(coxgroup(:B,2))
5-element Vector{Vector{Matrix{Int64}}}:
 [[1;;], [-1;;]]
 [[1 0; -1 -1], [1 2; 0 -1]]
 [[-1;;], [-1;;]]
 [[1;;], [1;;]]
 [[-1;;], [1;;]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L1028-L1042">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.InductionTable" href="#Gapjm.Chars.InductionTable"><code>Gapjm.Chars.InductionTable</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>InductionTable(u,g)</code></p><p>returns   an  object  describing  the   decomposition  of  the  irreducible characters  of the subgroup  <code>u</code> induced to  the group <code>g</code>.  In the default show method, the rows correspond to the characters of the parent group, and the  columns  to  those  of  the  subgroup.  The  return object has a field <code>scalar</code>  which is a <code>Matrix{Int}</code> containing  the induction table, and the other  fields contain labeling information  taken from the character tables of <code>u</code> and <code>g</code> when it exists.</p><pre><code class="language-julia-rep1 hljs">julia&gt; g=Group([Perm(1,2),Perm(2,3),Perm(3,4)])
Group([(1,2),(2,3),(3,4)])

julia&gt; u=Group( [ Perm(1,2), Perm(3,4) ])
Group([(1,2),(3,4)])

julia&gt; InductionTable(u,g)
Induction Table from Group([perm&quot;(1,2)&quot;,perm&quot;(3,4)&quot;]) to Group([perm&quot;(1,2)&quot;,perm&quot;(2,3)&quot;,perm&quot;(3,4)&quot;])
   │X.1 X.2 X.3 X.4
───┼────────────────
X.1│  .   1   .   .
X.2│  .   1   1   1
X.3│  1   1   .   .
X.4│  1   .   1   1
X.5│  1   .   .   .</code></pre><pre><code class="language-julia-repl hljs">julia&gt; g=coxgroup(:G,2)
G₂

julia&gt; u=reflection_subgroup(g,[1,6])
G₂₍₁₅₎=A₂

julia&gt; t=InductionTable(u,g)
Induction Table from G₂₍₁₅₎=A₂ to G₂
     │111 21 3
─────┼─────────
φ₁‚₀ │  .  . 1
φ₁‚₆ │  1  . .
φ′₁‚₃│  1  . .
φ″₁‚₃│  .  . 1
φ₂‚₁ │  .  1 .
φ₂‚₂ │  .  1 .</code></pre><p>using an <code>IOContext</code> allows to transmit attributes to the table format method</p><pre><code class="language-julia-rep1 hljs">julia&gt; xprint(t;rows=[5],cols=[3,2])
Induction Table
    │3 21
────┼─────
φ₂‚₁│.  1</code></pre><p>It is also possible to TeX induction tables</p><p><strong>This function also works for Spets (Reflection Cosets)</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L1267-L1328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.jInductionTable" href="#Gapjm.Chars.jInductionTable"><code>Gapjm.Chars.jInductionTable</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>jInductionTable(H, W)</code></p><p>computes  the decomposition  into irreducible  characters of the reflection group  <code>W</code>  of  the  <code>j</code>-induced  of  the  irreducible  characters  of  the reflection  subgroup  <code>H</code>.  The  <code>j</code>-induced  of  <code>φ</code>  is  the  sum  of the irreducible  components of the induced of  <code>φ</code> which have same <code>b</code>-function (see <code>charinfo</code>) as <code>φ</code>. What is returned is an <code>InductionTable</code> struct.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; H=reflection_subgroup(W,[1,3])
D₄₍₁₃₎=A₂Φ₁²

julia&gt; jInductionTable(H,W)
j-Induction Table from D₄₍₁₃₎=A₂Φ₁² to D₄
     │111 21 3
─────┼─────────
11+  │  .  . .
11-  │  .  . .
1.111│  .  . .
.1111│  .  . .
11.2 │  .  . .
1.21 │  1  . .
.211 │  .  . .
2+   │  .  . .
2-   │  .  . .
.22  │  .  . .
1.3  │  .  1 .
.31  │  .  . .
.4   │  .  . 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L1359-L1393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.JInductionTable" href="#Gapjm.Chars.JInductionTable"><code>Gapjm.Chars.JInductionTable</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>JInductionTable(H, W)</code></p><p>computes  the decomposition  into irreducible  characters of the reflection group  <code>W</code>  of  the  <code>J</code>-induced  of  the  irreducible  characters  of  the reflection  subgroup  <code>H</code>.  The  <code>J</code>-induced  of  <code>φ</code>  is  the  sum  of the irreducible  components of the induced of  <code>φ</code> which have same <code>a</code>-function (see <code>charinfo</code>) as <code>φ</code>. What is returned is an <code>InductionTable</code> struct.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; H=reflection_subgroup(W,[1,3])
D₄₍₁₃₎=A₂Φ₁²

julia&gt; JInductionTable(H,W)
J-Induction Table from D₄₍₁₃₎=A₂Φ₁² to D₄
     │111 21 3
─────┼─────────
11+  │  .  . .
11-  │  .  . .
1.111│  .  . .
.1111│  .  . .
11.2 │  1  . .
1.21 │  1  . .
.211 │  .  . .
2+   │  .  . .
2-   │  .  . .
.22  │  .  . .
1.3  │  .  1 .
.31  │  .  . .
.4   │  .  . 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L1409-L1443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.detPerm" href="#Gapjm.Chars.detPerm"><code>Gapjm.Chars.detPerm</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>detPerm(W)</code></p><p>return  the permutation of the characters of the reflection group <code>W</code> which is effected when tensoring by the determinant character (for Coxeter groups this is the sign character).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; detPerm(W)
(1,8)(2,9)(3,11)(4,13)(7,12)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L724-L738">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.conjPerm" href="#Gapjm.Chars.conjPerm"><code>Gapjm.Chars.conjPerm</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>conjPerm(W)</code></p><p>return  the permutation of the characters of the group <code>W</code> which is effected when taking the complex conjugate of the character table.</p><pre><code class="language-julia-repl hljs">julia&gt; W=ComplexReflectionGroup(4)
G₄

julia&gt; conjPerm(W)
(2,3)(5,6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L746-L759">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.WGraphToRepresentation" href="#Gapjm.Chars.WGraphToRepresentation"><code>Gapjm.Chars.WGraphToRepresentation</code></a> — <span class="docstring-category">Function</span></header><section><div><p>`WGraphToRepresentation(H::HeckeAlgebra,gr::Vector)&#39;</p><p><code>H</code>  should be  a one-parameter  Hecke algebra  for a  finite Coxeter group where  <code>rootpara</code>  is  defined.  The  function  returns the matrices of the representation defined by <code>gr</code> of <code>H</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:H,3)
H₃

julia&gt; H=hecke(W,Pol(:x)^2)
hecke(H₃,x²)

julia&gt; g=Wgraph(W,3)
2-element Vector{Vector{Vector{Any}}}:
 [[2], [1, 2], [1, 3], [1, 3], [2, 3]]
 [[-1, [[1, 3], [2, 4], [3, 5], [4, 5]]]]

julia&gt; WGraphToRepresentation(H,g)
3-element Vector{Matrix{Pol{Int64}}}:
 [x² 0 … 0 0; 0 -1 … 0 0; … ; 0 0 … -1 x; 0 0 … 0 x²]
 [-1 0 … 0 0; 0 -1 … x 0; … ; 0 0 … x² 0; 0 0 … x -1]
 [x² 0 … 0 0; 0 x² … 0 0; … ; 0 x … -1 0; 0 0 … 0 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/HeckeAlgebras.jl#L427-L452">source</a></section><section><div><p><code>WGraphToRepresentation(coxrank::Integer,graph,v)</code></p><p>We  store some representations one-parameter  Hecke algebras as <code>W</code>-graphs. For  a  Coxeter  system  <code>(W,S)</code>  where <code>coxrank=length(S)</code>, a <code>W</code>-graph is defined  by a set of vertices <code>C</code> with a function <code>I</code> which attaches to <code>x∈ C</code>  a subset  <code>I(x)⊂ S</code>,  and &quot;edge  labels&quot; which  to <code>(x,y)∈  C^2</code> attach <code>μ(x,y)∈  K</code> where <code>K</code>  is the field  of definition of  <code>W</code>; this defines a representation  of the  Hecke algebra  with parameters  <code>v</code> and <code>-v⁻¹</code> on a space with basis <span>${e_y}_{y∈ C}$</span> by:</p><p>``T<em>s(e</em>y)=\begin{cases}-e<em>y&amp; if s∈ I(y)\
       v^2 e</em>y+∑<em>{x∣s∈ I(x)} vμ(x,y)e</em>x&amp;otherwise\end{cases}``</p><p>The  <code>W</code>-graphs are  stored in  a compact  format to  save space.  They are represented as a pair.</p><ul><li>The  first element is a list describing <code>C</code>.</li></ul><p>Its  elements are  either a  set <code>I(x)</code>,  or an  integer <code>n</code>  specifying to repeat the previous element <code>n</code> more times.</p><ul><li>The  second element is a list which  specifies <code>μ</code>. </li></ul><p>We   first   describe   the   <code>μ</code>-list   for   symmetric  <code>W</code>-graphs  (when <code>μ(x,y)=μ(y,x)</code>).  There is one  element of the  <code>μ</code>-list for each non-zero value <code>m</code> taken by <code>μ</code>, which consists of a pair whose first element is <code>m</code> and  whose second element is a list of  lists; if <code>l</code> is one of these lists each  pair <code>[l[1],l[i]]</code>  represents an  edge (<code>x=l[1]</code>,<code>y=l[i]</code>) such that <code>μ(x,y)=μ(y,x)=m</code>.  For non-symmetric <code>W</code>-graphs, the first element of each pair  in the <code>μ</code>-list  is a pair  <code>[m1,m2]</code> and each  edge <code>[x,y]</code> obtained from  the lists in the second element  has to be interpreted as <code>μ(x,y)=m1</code> and <code>μ(y,x)=m2</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:H,3)
H₃

julia&gt; g=Wgraph(W,3)
2-element Vector{Vector{Vector{Any}}}:
 [[2], [1, 2], [1, 3], [1, 3], [2, 3]]
 [[-1, [[1, 3], [2, 4], [3, 5], [4, 5]]]]

julia&gt; toM.(WGraphToRepresentation(3,g,Pol(:x)))
3-element Vector{Matrix{Pol{Int64}}}:
 [x² 0 … 0 0; 0 -1 … 0 0; … ; 0 0 … -1 -x; 0 0 … 0 x²]
 [-1 0 … 0 0; 0 -1 … -x 0; … ; 0 0 … x² 0; 0 0 … -x -1]
 [x² 0 … 0 0; 0 x² … 0 0; … ; 0 -x … -1 0; 0 0 … 0 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L1045-L1091">source</a></section></article><h1 id="Reductive-groups,-semisimple-elements"><a class="docs-heading-anchor" href="#Reductive-groups,-semisimple-elements">Reductive groups, semisimple elements</a><a id="Reductive-groups,-semisimple-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Reductive-groups,-semisimple-elements" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Semisimple" href="#Gapjm.Semisimple"><code>Gapjm.Semisimple</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>Algebraic groups and semi-simple elements</strong></p><p>Let  us fix an  algebraically closed field  <code>K</code> and let  <code>𝐆</code> be a connected reductive  algebraic group over <code>K</code>. Let <code>𝐓</code> be a maximal torus of <code>𝐆</code>, let <code>X(𝐓)</code>  be the  character group  of <code>𝐓</code>  (resp. <code>Y(𝐓)</code>  the dual lattice of one-parameter  subgroups  of  <code>𝐓</code>)  and  <code>Φ</code>  (resp  <code>Φ^</code>) the roots (resp. coroots) of <code>𝐆</code> with respect to <code>𝐓</code>.</p><p>Then  <code>𝐆</code> is  determined up  to isomorphism  by the  <em>root datum</em> <code>(X(𝐓),Φ, Y(𝐓),Φ^)</code>.  In algebraic terms, this consists  in giving a free <code>ℤ</code>-lattice <code>X=X(𝐓)</code> of dimension the <em>rank</em> of <code>𝐓</code> (which is also called the <em>rank</em> of <code>𝐆</code>),  and a root system <code>Φ ⊂ X</code>,  and giving similarly the dual roots <code>Φ^⊂ Y=Y(𝐓)</code>.</p><p>This  is obtained  by a  slight generalization  of our  setup for a Coxeter group  <code>W</code>. This time we assume the canonical basis of the vector space <code>V</code> on  which <code>W</code> acts is a <code>ℤ</code>-basis of  <code>X</code>, and <code>Φ</code> is specified by a matrix <code>simpleroots(W)</code>  whose lines are the simple  roots expressed in this basis of  <code>X</code>. Similarly <code>Φ^</code>  is described by  a matrix <code>simplecoroots(W)</code> whose lines  are the simple coroots in the basis  of <code>Y</code> dual to the chosen basis of  <code>X</code>. The duality pairing between <code>X</code> and <code>Y</code> is the canonical one, that is   the  pairing  between  vectors   <code>x∈  X</code>  and  <code>y∈   Y</code>  is  given  by <code>transpose(x)*y</code>. Thus, we must have the relation <code>simpleroots(W)*transpose(simplecoroots(W))=cartan(W)</code>.</p><p>We  get that  by a  the function  <code>rootdatum</code>, whose  arguments are the two matrices <code>simpleroots(W)</code> and <code>simplecoroots(W)</code> described above. The roots need  not generate <code>V</code>, so  the matrices need not  be square. For instance, the root datum of the linear group of rank 3 can be specified as:</p><pre><code class="language-julia-repl hljs">julia&gt; W=rootdatum([-1 1 0;0 -1 1],[-1 1 0;0 -1 1])
A₂Φ₁

julia&gt; reflrep(W,W(1))
3×3 Matrix{Int64}:
 0  1  0
 1  0  0
 0  0  1</code></pre><p>here  the symmetric group on 3 letters  acts by permutation of the basis of <code>X</code>.  The dimension of <code>X</code> (<code>size(simpleroots(W),2)</code>) is the <em>rank</em> and the dimension of the subspace generated by the roots (<code>size(simpleroots(W),1)</code>) is  called the  <em>semi-simple rank</em>.  In the  example the  rank is 3 and the semisimple rank is 2.</p><p>The  default form  <code>W=coxgroup(:A,2)</code> defines  the adjoint  algebraic group (the  group with a trivial center). In that  case <code>Φ</code> is a basis of <code>X</code>, so <code>simpleroots(W)</code>  is  the  identity  matrix  and  <code>simplecoroots(W)</code> is the Cartan  matrix <code>cartan(W)</code> of the root system. </p><p>The   form  <code>coxgroup(:A,2,sc=true)</code>   constructs  the   semisimple  simply connected  algebraic  group,  where  <code>simpleroots(W)</code>  is the transposed of <code>cartan(W)</code> and <code>simplecoroots(W)</code> is the identity matrix.</p><p>There  is an extreme form  of root data which  requires another function to specify:  when <code>W</code> is the trivial <code>coxgroup()</code>  and there are thus no roots (in  this case <code>𝐆</code> is a torus), the root datum cannot be determined by the roots,  but is entirely determined by the rank <code>r</code>. The function <code>torus(r)</code> constructs such a root datum.</p><p>Finally,  the function <code>rootdatum</code> also understands some familiar names for the algebraic groups and gives the results that could be obtained by giving the appropriate matrices <code>simpleroots(W)</code> and <code>simplecoroots(W)</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; rootdatum(:gl,3)   # same as the previous example
gl₃</code></pre><p><strong>Semisimple elements</strong></p><p>It  is also possible  to compute with  semi-simple elements. The first type are  finite order elements of <code>𝐓</code>, which over an algebraically closed field <code>K</code>  are in bijection with elements of <code>Y⊗ ℚ /ℤ</code> whose denominator is prime to  the  characteristic  of  <code>K</code>.  These  are  represented  as  a vector of <code>Rational</code>s <code>r</code> such that <code>0≤r&lt;1</code>, or, more to the point, a <code>Vector{Root1}</code>. The  function  <code>SS</code>  constructs  a  semisimple  element  from  a  vector of <code>Rational</code>,  while  the  more  general  function  can  construct semisimple elements from arbitrary ring elements (like elements of <code>K</code>, <code>Mvp</code>s,…</p><pre><code class="language-julia-repl hljs">julia&gt; G=rootdatum(:sl,4)
sl₄

julia&gt; L=reflection_subgroup(G,[1,3])
A₃₍₁₃₎=A₁×A₁Φ₁

julia&gt; C=algebraic_centre(L)
(Z0 = SubTorus(A₃₍₁₃₎=A₁×A₁Φ₁,[1 2 1]), AZ = SSGroup([&lt;1,1,-1&gt;]), descAZ = [[1, 2]], ZD = SSGroup([&lt;-1,1,1&gt;,&lt;1,1,-1&gt;]))

julia&gt; T=torsion_subgroup(C.Z0,3)
SSGroup([&lt;ζ₃,ζ₃²,ζ₃&gt;])

julia&gt; e=sort(elements(T))
3-element Vector{SemisimpleElement{Root1}}:
 &lt;1,1,1&gt;
 &lt;ζ₃,ζ₃²,ζ₃&gt;
 &lt;ζ₃²,ζ₃,ζ₃²&gt;</code></pre><p>First,  the  group  <code>𝐆  =SL₄</code>  is  constructed,  then the Levi subgroup <code>L</code> consisting   of  block-diagonal  matrices  of  shape  <code>2×2</code>.  The  function <code>algebraic_centre</code>  returns a named tuple with : the neutral component <code>Z⁰</code> of  the centre <code>Z</code> of <code>L</code>, represented  by a basis of <code>Y(Z⁰)</code>, a complement subtorus <code>S</code> of <code>𝐓</code> to <code>Z⁰</code> represented similarly by a basis of <code>Y(S)</code>, and semi-simple  elements representing the classes of  <code>Z</code> modulo <code>Z⁰</code> , chosen in <code>S</code>. The classes <code>Z/Z⁰</code> also biject to the fundamental group as given by the  field <code>.descAZ</code>, see &quot;AlgebraicCentre&quot; for an explanation. Finally the semi-simple elements of order 3 in <code>Z⁰</code> are computed.</p><pre><code class="language-julia-repl hljs">julia&gt; e[3]^G(2)
SemisimpleElement{Root1}: &lt;ζ₃²,1,ζ₃²&gt;

julia&gt; orbit(G,e[3])
6-element Vector{SemisimpleElement{Root1}}:
 &lt;ζ₃²,ζ₃,ζ₃²&gt;
 &lt;ζ₃²,1,ζ₃²&gt;
 &lt;ζ₃,1,ζ₃²&gt;
 &lt;ζ₃²,1,ζ₃&gt;
 &lt;ζ₃,1,ζ₃&gt;
 &lt;ζ₃,ζ₃²,ζ₃&gt;</code></pre><p>Here  is the same  computation as above  performed with semisimple elements whose coefficients are in the finite field <code>FF(4)</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; G=rootdatum(:sl,4)
sl₄

julia&gt; s=SemisimpleElement(G,Z(4).^[1,2,1])
SemisimpleElement{FFE{2}}: &lt;Z₄,Z₄²,Z₄&gt;

julia&gt; s^G(2)
SemisimpleElement{FFE{2}}: &lt;Z₄,1,Z₄&gt;

julia&gt; orbit(G,s)
6-element Vector{SemisimpleElement{FFE{2}}}:
 &lt;Z₄,Z₄²,Z₄&gt;
 &lt;Z₄,1,Z₄&gt;
 &lt;Z₄²,1,Z₄&gt;
 &lt;Z₄,1,Z₄²&gt;
 &lt;Z₄²,1,Z₄²&gt;
 &lt;Z₄²,Z₄,Z₄²&gt;</code></pre><p>We  can  compute  the  centralizer  <span>$C_𝐆 (s)$</span>  of  a semisimple element in <code>𝐆</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; G=coxgroup(:A,3)
A₃

julia&gt; s=SS(G,[0,1//2,0])
SemisimpleElement{Root1}: &lt;1,-1,1&gt;

julia&gt; centralizer(G,s)
A₃₍₁₃₎=(A₁A₁)Φ₂</code></pre><p>The  result is an  extended reflection group;  the reflection group part is the Weyl group of <span>$C_𝐆 ⁰(s)$</span> and the extended part are representatives of <span>$C_𝐆  (s)$</span>  modulo  <span>$C_𝐆⁰(s)$</span>  taken  as  diagram  automorphisms of the reflection  part.  Here  it  is  printed  as  a  coset  <span>$C_𝐆 ⁰(s)ϕ$</span> which generates <span>$C_𝐆 (s)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Semisimple.jl#L1-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Semisimple.fundamental_group" href="#Gapjm.Semisimple.fundamental_group"><code>Gapjm.Semisimple.fundamental_group</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>fundamental_group(W)</code></p><p>This  function returns the fundamental group of the algebraic group defined by  the Coxeter  group struct  <code>W</code>. This  group is  returned as  a group of diagram  automorphisms of the corresponding affine Weyl group, that is as a group  of permutations of  the set of  simple roots enriched  by the lowest root  of  each  irreducible  component.  The  definition  we  take  of  the fundamental  group of a (not necessarily semisimple) reductive group is (P∩ Y(𝐓))/Q where P is the coweight lattice (the dual lattice in Y(𝐓)⊗ ℚ of the root lattice) and Q is the coroot latice. The bijection between elements of P/Q   and   diagram   automorphisms   is   explained   in  the  context  of non-irreducible groups for example in <a href="biblio.htm#Bon05">§3.B Bonnafé2005</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; fundamental_group(W)
Group([(1,12,3,2)])

julia&gt; W=rootdatum(:sl,4)
sl₄

julia&gt; fundamental_group(W)
Group([])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Semisimple.jl#L638-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Semisimple.intermediate_group" href="#Gapjm.Semisimple.intermediate_group"><code>Gapjm.Semisimple.intermediate_group</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>intermediate_group(W, indices)</code></p><p>This  computes  a  <code>rootdatum</code>  representing  a  semisimple algebraic group intermediate  between  the  adjoint  group  –-  obtained  by  a  call like <code>rootdatum(:pgl,4)</code>–-  and  the  simply  connected  semi-simple  group –- obtained  by  a  call  like  <code>rootdatum(:sl,4)</code>.  The group is specified by specifying  a subset  of the  <em>minuscule weights</em>,  which are weights whose scalar  product  with  every  coroot  is  in  <code>-1,0,1</code> (the weights are the elements  of the <em>weight  lattice</em>, the lattice  in <code>X(𝐓)⊗ ℚ</code> dual to the coroot  lattice). The non-trivial characters of the (algebraic) center of a semi-simple  simply  connected  algebraic  group  are in bijection with the minuscule  weights; this set is  also in bijection with  <code>P/Q</code> where <code>P</code> is the  weight lattice and <code>Q</code> is the root lattice. If <code>W</code> is irreducible, the minuscule  weights are part of the basis of the weight lattice given by the <em>fundamental  weights</em>, which is the dual basis of the simple coroots. They can  thus be specified by an <code>index</code> in the Dynkin diagram. The constructed group  has lattice <code>X(𝐓)</code> generated by the  sum of the root lattice and the weights  with the given  <code>indices</code>. If <code>W</code>  is not irreducible, a minuscule weight is a sum of minuscule weights in different components. An element of <code>indices</code> is thus itself a list, interpreted as representing the sum of the corresponding weights.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; fundamental_group(intermediate_group(W,Int[])) # adjoint
Group([(1,12,3,2)])

julia&gt; fundamental_group(intermediate_group(W,Int[2])) # intermediate
Group([(1,3)(2,12)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Semisimple.jl#L871-L904">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Semisimple.QuasiIsolatedRepresentatives-Tuple{FiniteCoxeterGroup}" href="#Gapjm.Semisimple.QuasiIsolatedRepresentatives-Tuple{FiniteCoxeterGroup}"><code>Gapjm.Semisimple.QuasiIsolatedRepresentatives</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>QuasiIsolatedRepresentatives(W,p=0)</code></p><p><code>W</code>  should be a Weyl  group corresponding to an  algebraic group 𝐆 over an algebraically  closed field  of characteristic  0. This  function returns a list  of  semisimple  elements  for  𝐆,  which  are  representatives of the 𝐆-orbits  of quasi-isolated  semisimple elements.  It follows the algorithm given  in  <a href="biblio.htm#Bon05">Bonnafe2005</a>.  If  a  second  argument <code>p</code> is given,  it  gives  representatives  of  those quasi-isolated elements which exist in characteristic <code>p</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,6);l=QuasiIsolatedRepresentatives(W)
5-element Vector{SemisimpleElement{Root1}}:
 &lt;1,1,1,1,1,1&gt;
 &lt;1,1,1,ζ₃,1,1&gt;
 &lt;1,-1,1,1,1,1&gt;
 &lt;1,ζ₆,ζ₆,1,ζ₆,1&gt;
 &lt;ζ₃,1,1,1,1,ζ₃&gt;

julia&gt; map(s-&gt;is_isolated(W,s),l)
5-element Vector{Bool}:
 1
 1
 1
 0
 0

julia&gt; W=rootdatum(:E6sc);l=QuasiIsolatedRepresentatives(W)
7-element Vector{SemisimpleElement{Root1}}:
 &lt;1,1,1,1,1,1&gt;
 &lt;-1,1,1,-1,1,-1&gt;
 &lt;ζ₃,1,ζ₃²,1,ζ₃,ζ₃²&gt;
 &lt;ζ₃²,1,ζ₃,1,ζ₃,ζ₃²&gt;
 &lt;ζ₃²,1,ζ₃,1,ζ₃²,ζ₃&gt;
 &lt;ζ₃²,1,ζ₃,1,ζ₃²,ζ₆⁵&gt;
 &lt;ζ₆⁵,1,ζ₃²,1,ζ₃,ζ₃²&gt;

julia&gt; map(s-&gt;is_isolated(W,s),l)
7-element Vector{Bool}:
 1
 1
 1
 1
 1
 1
 1

julia&gt; Semisimple.QuasiIsolatedRepresentatives(W,3)
2-element Vector{SemisimpleElement{Root1}}:
 &lt;1,1,1,1,1,1&gt;
 &lt;-1,1,1,-1,1,-1&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Semisimple.jl#L719-L772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Semisimple.is_isolated" href="#Gapjm.Semisimple.is_isolated"><code>Gapjm.Semisimple.is_isolated</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>is_isolated(WF::Spets,t::SemisimpleElement{Root1})</code></p><p><code>WF</code>  should be  a Coxeter  coset representing  an algebraic  coset <code>𝐆 ⋅σ</code>, where  <code>𝐆</code> is a connected  reductive group (represented by <code>W=Group(WF)</code>), and  <code>σ</code>  is  a  quasi-central  automorphism  of  <code>𝐆</code> defined by <code>WF</code>. The element  <code>t</code> should be a semisimple element of <code>𝐆</code>. The function returns a boolean describing whether <code>tσ</code> is isolated, that is whether the Weyl group of <code>C_𝐆 (tσ)⁰</code> is not in any proper parabolic subgroup of <code>W^σ</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(:u,6)
u₆

julia&gt; l=QuasiIsolatedRepresentatives(WF)
4-element Vector{SemisimpleElement{Root1}}:
 &lt;1,1,1,1,1,1&gt;
 &lt;ζ₄,1,1,1,1,ζ₄³&gt;
 &lt;ζ₄,ζ₄,1,1,ζ₄³,ζ₄³&gt;
 &lt;ζ₄,ζ₄,ζ₄,ζ₄³,ζ₄³,ζ₄³&gt;

julia&gt; is_isolated.(Ref(WF),l)
4-element BitVector:
 1
 0
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Sscoset.jl#L244-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Semisimple.torsion_subgroup" href="#Gapjm.Semisimple.torsion_subgroup"><code>Gapjm.Semisimple.torsion_subgroup</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>torsion_subgroup(S::SubTorus,n)</code></p><p>This  function  returns  the  subgroup  of  semi-simple  elements  of order dividing <code>n</code> in the subtorus <code>S</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; G=rootdatum(:sl,4)
sl₄

julia&gt; L=reflection_subgroup(G,[1,3])
A₃₍₁₃₎=A₁×A₁Φ₁

julia&gt; C=algebraic_centre(L)
(Z0 = SubTorus(A₃₍₁₃₎=A₁×A₁Φ₁,[1 2 1]), AZ = SSGroup([&lt;1,1,-1&gt;]), descAZ = [[1, 2]], ZD = SSGroup([&lt;-1,1,1&gt;,&lt;1,1,-1&gt;]))

julia&gt; T=torsion_subgroup(C.Z0,3)
SSGroup([&lt;ζ₃,ζ₃²,ζ₃&gt;])

julia&gt; sort(elements(T))
3-element Vector{SemisimpleElement{Root1}}:
 &lt;1,1,1&gt;
 &lt;ζ₃,ζ₃²,ζ₃&gt;
 &lt;ζ₃²,ζ₃,ζ₃²&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Semisimple.jl#L376-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Semisimple.algebraic_centre" href="#Gapjm.Semisimple.algebraic_centre"><code>Gapjm.Semisimple.algebraic_centre</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>algebraic_centre(W)</code></p><p><code>W</code>  should  be  a  Weyl  group,  or  an extended Weyl group. This function returns  a description  of the  centre <code>Z</code> of  the algebraic  group <code>𝐆</code> defined by <code>W</code> as a named tuple with the following fields:</p><p><code>Z0</code>: the neutral component <code>Z⁰</code> of <code>Z</code> as a subtorus of <code>𝐓</code>.</p><p><code>AZ</code>: representatives in <code>Z</code> of <code>A(Z):=Z/Z⁰</code> given as a group of semisimple elements.</p><p><code>ZD</code>:  center of the derived subgroup of <code>𝐆</code> given as a group of semisimple elements.</p><p><code>descAZ</code>:  if <code>W</code>  is not  an extended  Weyl group,  describes <code>A(Z)</code>  as a quotient  of the center  <code>pi</code> of the  simply connected covering  of <code>𝐆</code> (an incarnation of the fundamental group). It contains a list of elements given as  words  in  the  generators  of  <code>pi</code>  which  generate the kernel of the quotient map.</p><pre><code class="language-julia_repl hljs">julia&gt; G=rootdatum(:sl,4)
sl₄

julia&gt; L=reflection_subgroup(G,[1,3])
A₃₍₁₃₎=A₁×A₁

julia&gt; algebraic_centre(L)
(Z0 = SubTorus(A₃₍₁₃₎=A₁×A₁Φ₁,[1 2 1]), AZ = SSGroup([&lt;1,1,-1&gt;]), descAZ = [[1, 2]], ZD = SSGroup([&lt;-1,1,1&gt;,&lt;1,1,-1&gt;]))

julia&gt; G=coxgroup(:A,3)
A₃

julia&gt; s=SS(G,[0,1//2,0])
SemisimpleElement{Root1}: &lt;1,-1,1&gt;

julia&gt; C=centralizer(G,s)
A₃₍₁₃₎=(A₁A₁)Φ₂

julia&gt; algebraic_centre(C)
(Z0 = SubTorus(A₃₍₁₃₎=A₁×A₁Φ₁,Matrix{Int64}(undef, 0, 3)), AZ = SSGroup([&lt;1,-1,1&gt;]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Semisimple.jl#L425-L468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Semisimple.weightinfo" href="#Gapjm.Semisimple.weightinfo"><code>Gapjm.Semisimple.weightinfo</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>weightinfo(W)</code></p><p>W  is  a  Coxeter  group  record  describing  an algebraic group 𝐆 , or a IypeIrred.  The function is independent of the isogeny type of 𝐆 (so just depends  on  <code>refltype(W)</code>,  that  is  on  the root system). It returns a dict with the following keys:</p><p><code>:minusculeWeights</code>: the minuscule weights, described as their position in    the list of fundamental weights. For non-irreducible groups, a weight is    the  sum of  at most  one weight  in each  irreducible component.  It is    represented  as the list of its components. For consistency, in the case    of an irreducible system, a weight is represented as a one-element list.</p><p><code>:minusculeCoweights</code>: the minuscule coweights, represented in the same    manner as the minuscule weights</p><p><code>:decompositions</code>: for each coweight, its decomposition in terms of the    generators  of the adjoint  fundamental group (given  by the list of the    exponents of the generators). Together with the next field it enables to    work out the group structure of the adjoint fundamental group.</p><p><code>:moduli</code>: the list of orders of the generators of the fundamental group.</p><p><code>:AdjointFundamentalGroup</code>: the list of generators of the adjoint fundamental    group, given as permutations.</p><p><code>:CenterSimplyConnected</code>: A list of semisimple elements generating the center    of the universal covering of  𝐆 </p><pre><code class="language-julia-repl hljs">julia&gt; weightinfo(coxgroup(:A,2)*coxgroup(:B,2))
Dict{Symbol, Vector} with 6 entries:
  :moduli                  =&gt; [3, 2]
  :minusculeWeights        =&gt; [[1, 3], [1], [2, 3], [2], [3]]
  :decompositions          =&gt; [[1, 1], [1, 0], [2, 1], [2, 0], [0, 1]]
  :minusculeCoweights      =&gt; [[1, 4], [1], [2, 4], [2], [4]]
  :CenterSimplyConnected   =&gt; Vector{Rational{Int64}}[[2//3, 1//3, 0//1, 0//1],…
  :AdjointFundamentalGroup =&gt; [(1,2,12), (4,14)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Semisimple.jl#L538-L579">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Semisimple.weights" href="#Gapjm.Semisimple.weights"><code>Gapjm.Semisimple.weights</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>weights(W)</code> simple weights in the basis of X(T)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Semisimple.jl#L632">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Semisimple.coweights" href="#Gapjm.Semisimple.coweights"><code>Gapjm.Semisimple.coweights</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>coweights(W)</code> simple coweights in the basis of Y(T)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Semisimple.jl#L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.centralizer-Tuple{FiniteCoxeterGroup, SemisimpleElement}" href="#Gapjm.Groups.centralizer-Tuple{FiniteCoxeterGroup, SemisimpleElement}"><code>Gapjm.Groups.centralizer</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Centralizer(W,s)</code></p><p><code>W</code>  should  be  a  Weyl  group  or  an extended reflection group and <code>s</code> a semisimple  element of the  algebraic group <code>G</code>  corresponding to <code>W</code>. This function  returns the  Weyl group  of <span>$C_G(s)$</span>,  which describes  it. The stabilizer  is an extended reflection group, with the reflection group part equal to the Weyl group of <span>$C_{G⁰}(s)$</span>, and the diagram automorphism part being those induced by <span>$C_G(s)$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; G=coxgroup(:A,3)
A₃
julia&gt; s=SS(G,[0,1//2,0])
SemisimpleElement{Root1}: &lt;1,-1,1&gt;
julia&gt; centralizer(G,s)
A₃₍₁₃₎=(A₁A₁)Φ₂</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Semisimple.jl#L681-L699">source</a></section><section><div><p><code>centralizer(G::Group,p;action=^)</code></p><p>computes  the centralizer of <code>p</code> in <code>G</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; G=Group([Perm(1,2),Perm(1,2,3)]);
julia&gt; centralizer(G,1)
Group([(2,3)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Groups.jl#L216-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Semisimple.SScentralizer_reps" href="#Gapjm.Semisimple.SScentralizer_reps"><code>Gapjm.Semisimple.SScentralizer_reps</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>SScentralizer_reps(W [,p])</code></p><p><code>W</code>  should be a Weyl group corresponding  to an algebraic group <code>𝐆</code>. This function  returns a list describing representatives  <code>𝐇</code> of <code>𝐆</code>-orbits of reductive  subgroups  of  <code>𝐆</code>  which  are  the  identity component of the centralizer of a semisimple element. Each group <code>𝐇</code> is specified by a list <code>h</code>   of  reflection  indices  in  <code>W</code>   such  that  <code>𝐇</code>  corresponds  to <code>reflection_subgroup(W,h)</code>.  If a  second argument  <code>p</code> is  given, only the list of the centralizers which occur in characteristic <code>p</code> is returned.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; SScentralizer_reps(W)
6-element Vector{Vector{Int64}}:
 []
 [1]
 [2]
 [1, 2]
 [1, 5]
 [2, 6]

julia&gt; reflection_subgroup.(Ref(W),SScentralizer_reps(W))
6-element Vector{FiniteCoxeterSubGroup{Perm{Int16},Int64}}:
 G₂₍₎=Φ₁²
 G₂₍₁₎=A₁Φ₁
 G₂₍₂₎=Ã₁Φ₁
 G₂
 G₂₍₁₅₎=A₂
 G₂₍₂₆₎=Ã₁×A₁

julia&gt; SScentralizer_reps(W,2)
5-element Vector{Vector{Int64}}:
 []
 [1]
 [2]
 [1, 2]
 [1, 5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Semisimple.jl#L919-L960">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Semisimple.StructureRationalPointsConnectedCentre" href="#Gapjm.Semisimple.StructureRationalPointsConnectedCentre"><code>Gapjm.Semisimple.StructureRationalPointsConnectedCentre</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>StructureRationalPointsConnectedCentre(W,q)</code></p><p><code>W</code>  should be  a Coxeter  group or  a Coxeter  coset representing a finite reductive  group <span>$𝐆 ^F$</span>, and <code>q</code> should  be the prime power associated to the  isogeny <code>F</code>. The function returns the abelian invariants of the finite abelian group <span>$Z⁰𝐆 ^F$</span> where <code>Z⁰𝐆</code> is the connected center of <code>𝐆</code>.</p><p>In  the following example one determines the structure of <code>𝐓(𝔽₃)</code> where <code>𝐓</code> runs over all the maximal tori of <code>SL</code>₄.</p><pre><code class="language-julia-repl hljs">julia&gt; l=twistings(rootdatum(:sl,4),Int[])
5-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:
 A₃₍₎=Φ₁³
 A₃₍₎=Φ₁²Φ₂
 A₃₍₎=Φ₁Φ₂²
 A₃₍₎=Φ₁Φ₃
 A₃₍₎=Φ₂Φ₄

julia&gt; StructureRationalPointsConnectedCentre.(l,3)
5-element Vector{Vector{Int64}}:
 [2, 2, 2]
 [2, 8]
 [4, 8]
 [26]
 [40]</code></pre><p>julia-repl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Semisimple.jl#L829-L858">source</a></section></article><h1 id="Reflection-cosets"><a class="docs-heading-anchor" href="#Reflection-cosets">Reflection cosets</a><a id="Reflection-cosets-1"></a><a class="docs-heading-anchor-permalink" href="#Reflection-cosets" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Cosets" href="#Gapjm.Cosets"><code>Gapjm.Cosets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Let  <code>R</code> be a  root system in  the real vector  space <code>V</code>. We say that <code>F₀∈ GL(V)</code>  is an  <em>automorphism of  <code>R</code></em> if  it permutes  <code>R</code> and is of finite order  (finite  order  is  automatic  if  <code>R</code> generates <code>V</code>). It follows by <a href="biblio.htm#Bou68">chap.  VI,  §1.1,  lemme  1  Bourbaki1968</a> that the dual <code>F₀*∈  GL(V*)</code>  permutes  the  coroots  <code>R*⊂  V*</code>; thus <code>F₀</code> normalizes the reflection  group  <code>W</code>  associated  to  <code>R</code>,  that  is  <code>w↦  F₀wF₀⁻¹</code> is an automorphism  of <code>W</code>. Thus we get a reflection coset <code>WF₀</code>, which we call a <em>Coxeter coset</em>.</p><p>The  motivation for introducing Coxeter  cosets comes from automorphisms of algebraic  reductive groups, giving rise to non-split reductive groups over finite fields. Let <code>𝐆</code> be a connected reductive algebraic group <code>𝐆</code> over an algebraic  closure <code>𝔽̄_q</code> of a finite field <code>𝔽_q</code>, defined over <code>𝔽_q</code>; this corresponds  to a  Frobenius endomorphism  <code>F</code> so  that the finite group of rational  points <code>𝐆(𝔽_q)</code> identifies to the  subgroup <code>𝐆^F</code> of fixed points under <code>F</code>.</p><p>Let <code>𝐓</code> be a maximal torus of <code>𝐆</code>, and <code>Φ</code> (resp. <code>Φ*</code>) be the roots (resp. coroots)  of <code>𝐆</code> with respect  to <code>𝐓</code> in the  character group <code>X(𝐓)</code> (resp. the  group of one-parameter subgroups <code>Y(𝐓)</code>). Then <code>𝐆</code> is determined up to isomorphism  by <code>(X(𝐓),Φ,Y(𝐓),Φ*)</code>; this corresponds  to give a root system in   the  vector  space  <code>V=ℚ ⊗ X(𝐓)</code>   and  a  rational  reflection  group <code>W=N_𝐆(𝐓)/𝐓</code> acting on it.</p><p>If  <code>𝐓</code> is <code>F</code>-stable the Frobenius endomorphism <code>F</code> acts also naturally on <code>X(T)</code>  and defines thus  an endomorphism of  <code>V</code>, which is  of the form <code>q F₀</code>, where <code>F₀∈ GL(V)</code> is of finite order and normalizes <code>W</code>. We get thus a Coxeter  coset <code>WF₀⊂GL(V)</code>.  The data  <code>(X(𝐓), Φ,  Y(𝐓), Φ*,  F₀)</code>, and the integer   <code>q</code>  completely  determine  up   to  isomorphism  the  associated <em>reductive finite group</em> <code>𝐆^F</code>. Thus these data is a way of representing in the  essential  information  which  determines  a  finite  reductive group. Indeed, all properties of Chevalley groups can be computed from that datum: symbols  representing characters, conjugacy classes,  and finally the whole character table of <code>𝐆^F</code>.</p><p>It  turns out that  many interesting objects  attached to this datum depend only on <code>(V,W, F₀)</code>: the order of the maximal tori, the <em>fake degrees</em>, the order  of <code>𝐆^F</code>, symbols representing unipotent characters, Deligne-Lusztig induction  in  terms  of  <em>almost  characters</em>, the Fourier matrix relating characters and almost characters, etc… (see, e.g., <a href="biblio.htm#BMM93">Broue-Malle-Michel1993</a>).  It is thus possible to extend their  construction to non-crystallographic groups (or even to more general complex  reflection groups, see &quot;Spets&quot;); this is  why we did not include a root  system in  the definition  of a  reflection coset. However, unipotent conjugacy classes for instance depend on the root system.</p><p>We assume now that <code>𝐓</code> is contained in an <code>F</code>-stable Borel subgroup of <code>𝐆</code>. This  defines an order  on the roots,  and there is  a unique element <code>ϕ∈ W F₀</code>,  the  <em>reduced  element</em>  of  the  coset,  which  preserves the set of positive  roots.  It  thus  defines  a  <em>diagram  automorphism</em>, that is an automorphism  of the Coxeter system <code>(W,S)</code>.  This element is stored in the component  &#39;.phi&#39; of the coset record. It may be defined without mentioning the  roots,  as  follows:  <code>(W,F₀(S))</code>  is  another  Coxeter  system,  thus conjugate to <code>S</code> by a unique element of <code>W</code>, thus there is a unique element <code>ϕ∈  WF₀</code> which stabilizes <code>S</code> (a proof  follows from <a href="biblio.htm#Bou68">Theoreme 1, chap. V, §3  Bourbaki1968</a>). We  consider thus  cosets of the form <code>Wϕ</code> where <code>ϕ</code> stabilizes <code>S</code>. The coset <code>W ϕ</code> is completely defined by the permutation  &#39;.phi&#39;  when  <code>𝐆</code>  is  semi-simple  –-  equivalently when <code>Φ</code> generates  <code>V</code>; in this  case we just  need to specify  &#39;phi&#39; to define the coset.</p><p>There is a slight generalisation of the above setup, covering in particular the  case of the Ree  and Suzuki groups. We  consider <code>𝐆^F</code> where <code>F</code> not a Frobenius  endomorphism, but  an isogeny  such that  some power  <code>F^n</code> is a Frobenius endomorphism. Then <code>F</code> still defines an endomorphism of <code>V</code> which normalizes  <code>W</code>; we define a real number <code>q</code> such that <code>F^n</code> is attached to an  <code>𝔽_{qⁿ}</code>-structure. Then we still have <code>F=q F₀</code> where <code>F₀</code> is of finite order  but <code>q</code> is no more an integer.  Thus <code>F₀∈ GL(V⊗ ℝ)</code> but <code>F₀∉ GL(V)</code>. For  instance, for the  Ree and Suzuki  groups, <code>F₀</code> is  an automorphism of order  <code>2</code> of <code>W</code>, which is of type <code>G₂</code>, <code>B₂</code> or <code>F₄</code>, and <code>q=√2</code> for <code>B₂</code> and  <code>F₄</code> and <code>q=√3</code>  for <code>G₂</code> This  can be constructed  starting from root systems  for <code>G₂</code>, <code>B₂</code> or  <code>F₄</code> where all the  roots have the same length. This kind of root system is <em>not</em> crystallographic. Such non-crystallographic  root systems exist for all finite Coxeter groups such as  the dihedral groups, <code>H₃</code> and <code>H₄</code>. We will call here <em>Weyl cosets</em> the cosets  corresponding to rational forms  of algebraic groups, which include thus some non-rational roots systems for <code>B₂</code>, <code>G₂</code> and <code>F₄</code>.</p><p><strong>Spets</strong></p><p>We  now extend the above notions  to general complex reflection groups. Let <code>W⊂  GL(V)</code> be a complex reflection group  on the vector space <code>V</code>. Let <code>ϕ</code> be  an element  of <code>GL(V)</code>  which normalizes  <code>W</code>. Then  the coset  <code>Wϕ</code> is called a reflection coset.</p><p>A reference for these cosets is <a href="biblio.htm#BMM99">Broue-Malle-Michel 1999</a> When <code>W</code> is a so-called <em>Spetsial</em> group, they are the basic object for the construction  of  a  <em>Spetses</em>,  which  is  an object attached to a complex reflection  group from which one can derive combinatorially some attributes shared with finite reductive groups, like unipotent degrees, etc….</p><p>We  say that  a reflection  coset is  irreducible if  <code>W</code> is irreducible. A general  coset is a direct  product of <em>descents of  scalars</em>, which is the case  where <code>ϕ</code>  is transitive  on the  irreducible components  of <code>W</code>. The irreducible    cosets   have   been   classified   in   <a href="biblio.htm#BMM99">Broue-Malle-Michel 1999</a>:  up to multiplication of <code>ϕ</code> by a scalar, there is usually only one or two possible cosets for a given irreducible group.</p><p>We  deal only  with <em>finite  order</em> cosets,  that is,  we assume there is a (minimal) integer <code>δ</code> such that <code>(Wϕ)^δ=W</code>. Then the group generated by <code>W</code> and <code>ϕ</code> is finite, of order <code>δ|W|</code>.</p><p>A  subset <code>C</code>  of a  <code>Wϕ</code> is  called a  <em>conjugacy class</em>  if one of the following equivalent conditions is fulfilled:</p><ul><li><p><code>C</code> is the orbit of an element in <code>Wϕ</code> under the conjugation action of <code>W</code>.</p></li><li><p><code>C</code> is a conjugacy class of <code>⟨W,ϕ⟩</code> contained in <code>Wϕ</code>.</p></li><li><p>The set <code>{w∈ W|wϕ∈ C}</code> is  a <code>ϕ</code>-conjugacy  class of <code>W</code> (two elements</p></li></ul><p><code>v,w∈  W</code> are called <code>ϕ</code>-conjugate, if and only if there exists <code>x∈ W</code> with <code>v=xwϕ(x⁻¹)</code>).</p><p>An irreducible character of <code>⟨W,ϕ⟩</code> has some non-zero values on <code>Wϕ</code> if and only if its restriction to <code>W</code> is irreducible. Further, two characters <code>χ₁</code> and  <code>χ₂</code>  which  have  same  irreducible  restriction  to  <code>W</code> differ by a character  of  the  cyclic  group  <code>⟨ϕ⟩</code>  (which identifies to the quotient <code>⟨W,ϕ⟩/W</code>). A set containing one extension to <code>⟨W,ϕ⟩</code> of each <code>ϕ</code>-invariant character  of <code>W</code> is called a <em>set  of irreducible characters of <code>Wϕ</code></em>. Two such  characters  are  orthogonal  for  the  scalar  product  on  the class functions on <code>Wϕ</code> given by <span>$⟨χ,ψ⟩:=|W|¹∑_{w∈ W}χ(wϕ)\overline{ψ(wϕ)}.$</span> For rational groups (Weyl groups), Lusztig has defined a choice of a set of irreducible  characters for  <code>Wϕ</code> (called  the <em>preferred extensions</em>), but for  more  general  reflection  cosets  we  have made some rather arbitrary choices,  which  however  have  the  property  that their values lie in the smallest possible field.</p><p>The  <em>character  table</em>  of  <code>Wϕ</code>  is  the  table  of  values  of  a set of irreducible characters on the conjugacy classes.</p><p>A <em>subcoset</em> <code>Lwϕ</code> of <code>Wϕ</code> is given by a reflection subgroup <code>L</code> of <code>W</code> and an element <code>w</code> of <code>W</code> such that <code>wϕ</code> normalizes <code>L</code>.</p><p>We  then have a natural notion of  <em>restriction</em> of class functions on <code>Wϕ</code> to  class  functions  on  <code>Lwϕ</code>  as  well  as  of  <em>induction</em> in the other direction.  These  maps  are  adjoint  with  respect  to the scalar product defined above (see <a href="biblio.htm#BMM99">Broue-Malle-Michel 1999</a>).</p><p>In  this package the most general construction  of a reflection coset is by starting  from a reflection datum, and giving in addition the matrix &#39;F&#39; of the  map <code>ϕ:V→ V</code>  (see the command  &#39;spets&#39;). However, at present, general cosets are only implemented for groups represented as permutation groups on a  set of roots, and  it is required that  the automorphism given preserves this  set up to  a scalar (it  is allowed that  these scalars depend on the pair  of an  irreducible component  and its  image). It  is also allowed to specify  <code>ϕ</code> by the permutation it induces on the roots; in this case it is assumed  that <code>ϕ</code> acts  trivially on the  orthogonal of the  roots, but the roots  could be those of a parent group, generating a larger space. Thus in any  case we have  a permutation representation  of <code>⟨W,ϕ⟩</code> and we consider the coset to be a set of permutations.</p><p>Reflection  cosets  are  implemented  in  by  a  <code>struct</code> which points to a reflection  group  record  and  has  additional  fields holding &#39;F&#39; and the corresponding  permutation &#39;phi&#39;. In the general case, on each component of <code>W</code>  which is  a descent  of scalars,  &#39;F&#39; will  permute the components and differ  by a scalar on each  component from an automorphism which preserves the  roots. In this case, we have  a permutation &#39;phi&#39; and a &#39;scalar&#39; which is stored for that component.</p><p>The  most common situation where cosets  with non-trivial &#39;phi&#39; arise is as sub-cosets  of reflection groups. Here is an &quot;exotic&quot; example, see the next chapter for more classical examples involving Coxeter groups.</p><pre><code class="language-julia-repl hljs">julia&gt; W=ComplexReflectionGroup(14)
G₁₄

julia&gt; R=reflection_subgroup(W,[2,4])
G₁₄₍₂₄₎=G₅

julia&gt; RF=spets(R,W(1)) # should be ²G₅(√6)
G₁₄₍₂₄₎=²G₅</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; Diagram(RF)
ϕ acts as (1,2) on the component below
G5 1(3)==2(3)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; degrees(RF)
2-element Vector{Tuple{Int64, Cyc}}:
 (6, 1)
 (12, -1)</code></pre><p>The  last line shows for each  reflection degree the corresponding <em>factor</em> of  the coset, which is  the scalar by which  <code>ϕ</code> acts on the corresponding fundamental reflection invariant. The factors characterize the coset.</p><p>A  spets by default is  printed in an abbreviated  form which describes its type,  as above (&#39;G₅&#39; twisted by 2, with a Cartan matrix which differs from the  standard one by  a factor of  <code>√6</code>). The function  <code>repr</code> gives a form which could be input back in Julia. With the same data as above we have:</p><pre><code class="language-julia-rep1 hljs">julia&gt; print(RF)
spets(reflection_subgroup(ComplexReflectionGroup(14),[2, 4]),perm&quot;(1,3)(2,4)(5,9)(6,10)(7,11)(8,12)(13,21)(14,22)(15,23)(16,24)(17,25)(18,26)(19,27)(20,28)(29,41)(30,42)(31,43)(32,44)(33,45)(34,46)(35,47)(36,48)(37,49)(38,50)(39,51)(40,52)(53,71)(54,72)(55,73)(56,74)(57,75)(58,76)(59,77)(60,78)(62,79)(64,80)(65,81)(66,82)(67,69)(68,70)(83,100)(84,101)(85,102)(87,103)(89,99)(90,97)(91,98)(92,96)(93,104)(94,95)(105,113)(106,114)(109,111)(110,112)(115,118)(116,117)(119,120)&quot;)</code></pre><p>Conjugacy  classes and irreducible characters of Coxeter cosets are defined as  for  general  reflection  cosets.  For  irreducible  characters of Weyl cosets,  we choose (following Lusztig) for each <code>ϕ</code>-stable character of <code>W</code> a  particular extension to a character of  <code>W⋊ ⟨ϕ⟩</code>, which we will call the <em>preferred extension</em>. The <em>character table</em> of the coset <code>Wϕ</code> is the table of  the restrictions to  <code>Wϕ</code> of the  preferred extensions. The question of finding the conjugacy classes and character table of a Coxeter coset can be reduced to the case of irreducible root systems <code>R</code>.</p><ul><li><p>The automorphism <code>ϕ</code> permutes the irreducible components of <code>W</code>, and <code>Wϕ</code>  is a direct  product of cosets  where <code>ϕ</code> permutes cyclically the irreducible components of <code>W</code>. The preferred extension is defined to be the  direct  product  of  the  preferred  extension  in  each  of these situations.</p></li><li><p>Assume now that <code>Wϕ</code> is a descent of scalars, that is the decomposition in irreducible components <code>W=W₁× ⋯ × Wₖ</code> is cyclically permuted by <code>ϕ</code>. Then there are natural bijections from the <code>ϕ</code>-conjugacy classes of <code>W</code> to  the <code>ϕᵏ</code>-conjugacy classes  of <code>W₁</code> as  well as from the <code>ϕ</code>-stable characters  of <code>W</code> to the <code>ϕᵏ</code>-stable  characters of <code>W₁</code>, which reduce the  definition of preferred  extensions on <code>Wϕ</code>  to the definition for <code>W₁ϕᵏ</code>.</p></li><li><p>Assume now  that <code>W</code>  is the  Coxeter group  of an  irreducible root system.   <code>ϕ</code>  permutes  the  simple   roots,  hence  induces  a  graph automorphism  on  the  corresponding  Dynkin  diagram.  If  <code>ϕ=1</code>  then conjugacy  classes and  characters coincide  with those  of the Coxeter group <code>W</code>.</p></li></ul><p>The  nontrivial cases for crystallographic roots  systems are (the order of <code>ϕ</code>  is written as left exponent to  the type): <code>²Aₙ</code>, <code>²Dₙ</code>, <code>³D₄</code>, <code>²E₆</code>. For  non-crystallographic root  systems where  all the  roots have the same length the additional cases <code>²B₂</code>, <code>²G₂</code>, <code>²F₄</code> and <code>²I₂(k)</code> arise.</p><ul><li><p>In  case  <code>³D₄</code>  the  group  <code>W⋊ ⟨ϕ⟩</code>  can be embedded into the Coxeter  group of type <code>F₄</code>, which induces a labeling for the conjugacy classes of the coset. The preferred extension is chosen as the (single) extension with rational values.</p></li><li><p>In case  <code>²Dₙ</code> the  group <code>W⋊ ⟨ϕ⟩</code>  is isomorphic  to a Coxeter group of type <code>Bₙ</code>. This induces a canonical labeling for the conjugacy classes  of the coset and allows to define the preferred extension in a combinatorial  way  using  the  labels  (pairs  of  partitions) for the characters of the Coxeter group of type <code>Bₙ</code>.</p></li><li><p>In the remaining crystallographic cases <code>ϕ</code> identifies to <code>-w₀</code> where <code>w₀</code>  is the longest element of <code>W</code>.  So, there is a canonical labeling of  the conjugacy classes and characters of  the coset by those of <code>W</code>. The  preferred extensions  are defined  by describing  the signs of the character values on <code>-w₀</code>.</p></li></ul><p>The  most general  construction of  a Coxeter  coset is  by starting from a Coxeter   datum   specified   by   the   matrices   of   &#39;simpleRoots&#39;  and &#39;simplecoroots&#39;,  and  giving  in  addition  the  matrix &#39;F0Mat&#39; of the map <code>F₀:V→ V</code> (see the commands  &#39;CoxeterCoset&#39; and &#39;CoxeterSubCoset&#39;). As for Coxeter  groups,  the  elements  of  <code>Wϕ</code>  are  uniquely  determined by the permutation  they  induce  on  the  set  of  roots  <code>R</code>.  We consider these permutations as &#39;elements&#39; of the Coxeter coset.</p><p>Coxeter  cosets are implemented by a struct which points to a Coxeter datum record  and  has  additional  fields  holding &#39;F0Mat&#39; and the corresponding element  &#39;phi&#39;. Functions on the coset (for example, &#39;classinfo&#39;) are about properties  of  the  group  coset  <code>W  ϕ</code>  ;  however, most definitions for elements of untwisted Coxeter groups apply without change to elements in <code>W ϕ</code>:  e.g., if we define the length of  an element <code>wϕ∈ Wϕ</code> as the number of positive  roots it sends to negative ones, it  is the same as the length of <code>w</code>,  i.e., <code>ϕ</code> is of length <code>0</code>, since <code>ϕ</code> has been chosen to preserve the set of positive roots. Similarly, the &#39;Coxeter word&#39; describing <code>wϕ</code> is the same as the one for <code>w</code>, etc…</p><p>We associate to a Coxeter coset <code>Wϕ</code> a <em>twisted Dynkin diagram</em>, consisting of  the Dynkin diagram of <code>W</code> and  the graph automorphism induced by <code>ϕ</code> on this  diagram (this specifies the  group <code>W⋊ ⟨F⟩</code>, mentioned above, up to  isomorphism). See the  functions &#39;ReflectionType&#39;, &#39;ReflectionName&#39; and &#39;Diagram&#39; for Coxeter cosets.</p><p>Below  is an example showing first how to <em>not</em> define, then how to define, the Weyl coset for a Suzuki group:</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; spets(W,Perm(1,2))
ERROR: matrix F must preserve the roots
Stacktrace:
 [1] error(::String) at ./error.jl:33
 [2] spets(::Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}, ::Matrix{Int64}) at /home/jmichel/julia/Gapjm/src/Cosets.jl:241 (repeats 2 times)
 [3] top-level scope at REPL[19]:1

julia&gt; W=coxgroup(:Bsym,2)
Bsym₂

julia&gt; WF=spets(W,Perm(1,2))
²Bsym₂

julia&gt; CharTable(WF)
CharTable(²Bsym₂)
   │    1 121
───┼──────────
2. │1   1   1
.11│1  -1  -1
1.1│. -√2  √2</code></pre><p>A <em>subcoset</em> <code>Hwϕ</code> of <code>Wϕ</code> is given by a reflection subgroup <code>H</code> of <code>W</code> and an  element <code>w</code> of <code>W</code>  such that <code>wϕ</code> induces  an automorphism of the root system of <code>H</code>. For algebraic groups, this corresponds to a rational form of a  reductive subgroup of maximal rank.  For example, if <code>Wϕ</code> corresponds to the  algebraic group <code>𝐆</code> and  <code>H</code> is the trivial  subgroup, the coset <code>Hwϕ</code> corresponds to a maximal torus <code>𝐓_w</code> of type <code>w</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:Bsym,2)
Bsym₂

julia&gt; WF=spets(W,Perm(1,2))
²Bsym₂

julia&gt; subspets(WF,Int[],W(1))
²Bsym₂₍₎=Φ‴₈</code></pre><p>A subgroup <code>H</code> which is a parabolic subgroup corresponds to a rational form of  a Levi  subgroup of  <code>𝐆</code>. The  command &#39;twistings&#39;  gives all rational forms of such a Levi.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; twistings(W,[1])
2-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:
 B₂₍₁₎=Ã₁Φ₁
 B₂₍₁₎=Ã₁Φ₂

julia&gt; twistings(W,[2])
2-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:
 B₂₍₂₎=A₁Φ₁
 B₂₍₂₎=A₁Φ₂</code></pre><p>Notice how we distinguish between subgroups generated by short roots and by long  roots. A general  <code>H</code> corresponds to  a reductive subgroup of maximal rank.  Here we consider the subgroup generated  by the long roots in <code>B₂</code>, which  corresponds to a  subgroup of type  <code>SL₂× SL₂</code> in <code>SP₄</code>, and show its possible rational forms.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; twistings(W,[2,4])
2-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:
 B₂₍₂₄₎=A₁×A₁
 B₂₍₂₄₎=(A₁A₁)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Cosets.jl#L1-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.degrees-Tuple{Spets}" href="#Gapjm.degrees-Tuple{Spets}"><code>Gapjm.degrees</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>degrees(WF::Spets)</code></p><p>Let  <code>W</code> be  the group  of the  reflection coset  <code>WF</code>, and  let <code>V</code> be the vector  space  of  dimension  &#39;rank(W)&#39;  on  which <code>W</code> acts as a reflection group.  Let  <code>f₁,…,fₙ</code>  be  the  basic  invariants  of <code>W</code> on the symmetric algebra  <code>SV</code> of <code>V</code>;  they can be  chosen so they  are eigenvectors of the matrix  <code>WF.F</code>. The corresponding  eigenvalues are called  the <em>factors</em> of <code>F</code> acting on <code>V</code>; they characterize the coset –- they are equal to 1 only for  the trivial  coset. The  <em>generalized degrees</em>  of <code>WF</code>  are the pairs formed of the reflection degrees and the corresponding factor.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,6)
E₆

julia&gt; WF=spets(W)
E₆

julia&gt; phi=W(6,5,4,2,3,1,4,3,5,4,2,6,5,4,3,1);

julia&gt; HF=subspets(WF,2:5,phi)
E₆₍₂₃₄₅₎=³D₄Φ₃

julia&gt; Diagram(HF)
ϕ acts as (1,2,4) on the component below
  O 2
  ￨
O—O—O
1 3 4

julia&gt; degrees(HF)
6-element Vector{Tuple{Int64, Cyc{Int64}}}:
 (1, ζ₃) 
 (1, ζ₃²)
 (2, 1)  
 (4, ζ₃) 
 (6, 1)  
 (4, ζ₃²)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/ComplexR.jl#L136-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Cosets.spets" href="#Gapjm.Cosets.spets"><code>Gapjm.Cosets.spets</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>spets(W::FiniteCoxeterGroup,F::Matrix=I(rank(W)))</code></p><p>This  function returns a  Coxeter coset. <code>F</code>  must be an invertible matrix, representing  an  automorphism  of  the  vector  space  <code>V</code> of dimension of dimension  <code>rank(W)</code> which  induces an  automorphism of  the root system of <code>parent(W)</code>.</p><p>The returned struct has in particular the following fields:</p><p><code>.W</code>: the Coxeter group <code>W</code></p><p><code>.F</code>: the matrix acting on <code>V</code> which represents the unique element <code>phi</code> in <code>WF</code> which preserves the positive roots.</p><p>&#39;.phi&#39;: the permutation of the roots of <code>W</code> induced by <code>.F</code> (also the element of smallest length in the Coset  <code>W .phi</code>).</p><p>In the first example we create a Coxeter coset corresponding to the general unitary group <code>GU_3(q)</code> over the finite field <code>FF(q)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=rootdatum(:gl,3)
gl₃

julia&gt; gu3=spets(W,-reflrep(W,W()))
²A₂Φ₂

julia&gt; F4=coxgroup(:F,4);D4=reflection_subgroup(F4,[1,2,16,48])
F₄₍₉‚₂‚₁‚₁₆₎=D₄₍₃₂₁₄₎

julia&gt; spets(D4,[1 0 0 0;0 1 2 0;0 0 0 1;0 0 -1 -1])
F₄₍₉‚₁₆‚₁‚₂₎=³D₄₍₃₄₁₂₎</code></pre><p><code>spets(W::FiniteCoxeterGroup,p::Perm)</code></p><p>In  this version <code>F</code> is  defined by the permutation  of the simple roots it does.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; spets(W,Perm(1,3))
²A₃</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Cosets.jl#L557-L603">source</a></section><section><div><p>spets(s::String) builds a few of the exceptional spets</p><pre><code class="language-julia-repl hljs">julia&gt; spets(&quot;3G422&quot;)
³G₄‚₂‚₂

julia&gt; spets(&quot;2G5&quot;)
²G₅

julia&gt; spets(&quot;3G333&quot;)
³G₃‚₃‚₃₍₁‚₂‚₃‚₄₄₎

julia&gt; spets(&quot;3pG333&quot;)
³G₃‚₃‚₃₍₁‚₂‚₃‚₄₄₎

julia&gt; spets(&quot;4G333&quot;)
⁴G₃‚₃‚₃₍₁‚₂‚₃‚₁₂₎</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Cosets.jl#L934-L953">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Cosets.twistings" href="#Gapjm.Cosets.twistings"><code>Gapjm.Cosets.twistings</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>twistings(W,I)</code></p><p><code>W</code>  should be a  Coxeter group.</p><p>The  function returns the list, up  to <code>W</code>-conjugacy, of Coxeter sub-cosets of  <code>W</code> whose  Coxeter group  is <code>reflection_subgroup(W,I)</code>  –- In term of algebraic groups, it corresponds to representatives of the possible twisted forms of the corresponding reductive subgroup of maximal rank <code>L</code>.</p><p><code>W</code>  could also be a coset <code>Wϕ</code>; then the subgroup <code>L</code> must be conjugate to <code>ϕ(L)</code>  for  a  rational  form  to  exist.  If <code>ϕ</code> normalizes <code>L</code>, then the rational forms are classified by the the <code>ϕ</code>-classes of <code>N_W(L)/L</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,6)
E₆

julia&gt; WF=spets(W,Perm(1,6)*Perm(3,5))
²E₆

julia&gt; twistings(W,2:5)
3-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:
 E₆₍₂₃₄₅₎=D₄Φ₁²
 E₆₍₂₃₄₅₎=³D₄Φ₃
 E₆₍₂₃₄₅₎=²D₄Φ₁Φ₂


julia&gt; twistings(WF,2:5)
3-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:
 ²E₆₍₂₅₄₃₎=²D₄₍₁₄₃₂₎Φ₁Φ₂
 ²E₆₍₂₅₄₃₎=³D₄₍₁₄₃₂₎Φ₆
 ²E₆₍₂₃₄₅₎=D₄Φ₂²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Cosets.jl#L409-L443">source</a></section><section><div><p><code>twistings(W)</code></p><p><code>W</code>  should be a Coxeter group which is not a proper reflection subgroup of another reflection group (so that <code>inclusion(W)==eachindex(roots(W))</code>). The function returns all &#39;spets&#39; representing twisted forms of algebraic groups of type <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; twistings(coxgroup(:A,3)*coxgroup(:A,3))
8-element Vector{Spets{FiniteCoxeterGroup{Perm{Int16},Int64}}}:
 A₃×A₃
 A₃×²A₃
 ²A₃×A₃
 ²A₃×²A₃
 (A₃A₃)
 ²(A₃A₃)
 ²(A₃A₃)₍₁₂₃₆₅₄₎
 (A₃A₃)₍₁₂₃₆₅₄₎

julia&gt; twistings(coxgroup(:D,4))
6-element Vector{Spets{FiniteCoxeterGroup{Perm{Int16},Int64}}}:
 D₄
 ²D₄₍₂₄₃₁₎
 ²D₄
 ³D₄
 ²D₄₍₁₄₃₂₎
 ³D₄₍₁₄₃₂₎

julia&gt; W=rootdatum(:so,8)
so₈

julia&gt; twistings(W)
2-element Vector{Spets{FiniteCoxeterGroup{Perm{Int16},Int64}}}:
 D₄
 ²D₄
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Cosets.jl#L486-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Cosets.graph_automorphisms" href="#Gapjm.Cosets.graph_automorphisms"><code>Gapjm.Cosets.graph_automorphisms</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>graph_automorphisms(t::Vector{TypeIrred})</code></p><p>Given  the <code>refltype</code> of a  finite Coxeter group, returns  the group of all Graph automorphisms of <code>t</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; Cosets.graph_automorphisms(refltype(W*W))
Group([(1,5)(2,6)(3,7)(4,8),(1,2),(1,4)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Cosets.jl#L447-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Cosets.subspets" href="#Gapjm.Cosets.subspets"><code>Gapjm.Cosets.subspets</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>subspets(WF,I,w=one(Group(WF)))</code></p><p>Returns   the   reflection   subcoset   of   the   coset  <code>WF</code>  with  group <code>reflection_subgroup(Group(WF),I)</code>  and torsion <code>w*WF.phi</code>.  <code>w</code> must be an element  of <code>Group(WF)</code> such that  &#39;w*WF.phi&#39; normalizes the subroot system generated by <code>I</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; WF=spets(coxgroup(:F,4))
F₄

julia&gt; w=transporting_elt(Group(WF),[1,2,9,16],[1,9,16,2],action=(s,g)-&gt;s.^g);

julia&gt; LF=subspets(WF,[1,2,9,16],w)
F₄₍₉‚₁₆‚₁‚₂₎=³D₄₍₃₄₁₂₎

julia&gt; Diagram(LF)
ϕ acts as (2,3,4) on the component below
  O 4
  ￨
O—O—O
3 1 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Cosets.jl#L811-L835">source</a></section></article><h1 id="Non-connected-reductive-groups"><a class="docs-heading-anchor" href="#Non-connected-reductive-groups">Non-connected reductive groups</a><a id="Non-connected-reductive-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Non-connected-reductive-groups" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Sscoset" href="#Gapjm.Sscoset"><code>Gapjm.Sscoset</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Section{Quasi-Semisimple elements of non-connected reductive groups}</p><p>We also use Coxeter cosets to represented non-connected reductive groups of the  form <code>𝐆 ⋊ σ</code> where  <code>𝐆</code> is a connected  reductive group and <code>σ</code> is an algebraic automorphism of <code>𝐆</code>; more specifically to represent the coset <code>𝐆 .σ</code>.  We may always  choose <code>σ∈ 𝐆  ⋅σ</code> <em>quasi-semisimple</em>, which means that <code>σ</code>  preserves a pair <code>𝐓 ⊂ 𝐁</code> of a maximal torus and a Borel subgroup of <code>𝐆</code>,  and further  <em>quasi-central</em>, which  means that  the Weyl group of <code>C_𝐆 (σ)</code>  is <code>W^σ</code>. Then  <code>σ</code> defines an  automorphism <code>F_0</code> of  the root datum <code>(X(𝐓 ), Φ, Y(𝐓 ), Φ^∨)</code>, thus a Coxeter coset. We refer to <a href="biblio.htm#ss">Digne-Michel2018</a> for details.</p><p>We  have  extended  the  functions  for  semi-simple  elements to work with quasi-semisimple elements <code>tσ∈ 𝐓 ⋅σ</code>. Here, as in <a href="biblio.htm#ss">Digne-Michel2018</a>,  <code>σ</code>  is  a  quasi-central  automorphism uniquely   defined  by  a  diagram  automorphism  of  <code>(W,S)</code>,  taking  <code>σ</code> symplectic in type <code>A₂ₙ</code>.</p><p>Here are some examples:</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(:u,6)
u₆</code></pre><p>We  can  see  <code>WF</code>  as  the  coset  <code>GL₆⋅σ</code>  where  <code>σ</code>  is the composed of transpose, inverse and the longest element of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; l=QuasiIsolatedRepresentatives(WF)
4-element Vector{SemisimpleElement{Root1}}:
 &lt;1,1,1,1,1,1&gt;
 &lt;ζ₄,1,1,1,1,ζ₄³&gt;
 &lt;ζ₄,ζ₄,1,1,ζ₄³,ζ₄³&gt;
 &lt;ζ₄,ζ₄,ζ₄,ζ₄³,ζ₄³,ζ₄³&gt;</code></pre><p>we  define an element <code>tσ∈ 𝐓 ⋅σ</code> to  be quasi-isolated if the Weyl group of <code>C_𝐆  (tσ)</code>  is  not  in  any  proper  parabolic  subgroup  of  <code>W^σ</code>. This generalizes  the  definition  for  connected  groups.  The  above shows the elements  <code>t</code>  where  <code>tσ</code>  runs  over  representatives  of  quasi-isolated quasi-semisimple  classes of  <code>𝐆 ⋅σ</code>.  The given  representatives have been chosen <code>σ</code>-stable.</p><pre><code class="language-julia-repl hljs">julia&gt; centralizer.(Ref(WF),l)
4-element Vector{ExtendedCox{FiniteCoxeterGroup{Perm{Int16},Rational{Int64}}}}:
 Extended(C₃₍₃₂₁₎)
 B₂Φ₁
 (A₁A₁)₍₁₃₎×A₁₍₂₎
 ²A₃₍₃₁₂₎</code></pre><p>in  the above example, the groups <code>C_𝐆  (tσ)</code> are computed and displayed as extended  Coxeter groups (following the same convention as for centralisers in connected reductive groups).</p><p>We  define an element <code>tσ∈ 𝐓  ⋅σ</code> to be isolated if  the Weyl group of <code>C_𝐆 (tσ)⁰</code>  is not in any proper  parabolic subgroup of <code>W^σ</code>. This generalizes the definition for connected groups.</p><pre><code class="language-julia-repl hljs">julia&gt; is_isolated.(Ref(WF),l)
4-element BitVector:
 1
 0
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Sscoset.jl#L1-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.centralizer-Tuple{Spets, SemisimpleElement{Root1}}" href="#Gapjm.Groups.centralizer-Tuple{Spets, SemisimpleElement{Root1}}"><code>Gapjm.Groups.centralizer</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>centralizer(WF::Spets,t::SemisimpleElement{Root1})</code>  </p><p><code>WF</code>  should be  a Coxeter  coset representing  an algebraic coset <code>𝐆 ⋅σ</code>, where <code>𝐆</code> is a connected reductive group (represented by &#39;W:=Group(WF)&#39;), and  <code>σ</code>  is  a  quasi-central  automorphism  of <code>𝐆</code> defined by <code>WF</code>. The element  <code>t</code> should be a semisimple  element of <code>𝐆</code>. The function returns an  extended reflection  group describing  <code>C_𝐆 (tσ)</code>, with the reflection group  part representing  <code>C_𝐆 ⁰(tσ)</code>, and  the diagram  automorphism part being those induced by <code>C_𝐆 (tσ)/C_𝐆 (tσ)⁰</code> on <code>C_𝐆 (tσ)⁰</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(:u,6)
u₆

julia&gt; s=SS(Group(WF),[1//4,0,0,0,0,3//4])
SemisimpleElement{Root1}: &lt;ζ₄,1,1,1,1,ζ₄³&gt;

julia&gt; centralizer(WF,s)
B₂Φ₁

julia&gt; centralizer(WF,one(s))
Extended(C₃₍₃₂₁₎)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Sscoset.jl#L143-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Semisimple.QuasiIsolatedRepresentatives-Tuple{Spets}" href="#Gapjm.Semisimple.QuasiIsolatedRepresentatives-Tuple{Spets}"><code>Gapjm.Semisimple.QuasiIsolatedRepresentatives</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>QuasiIsolatedRepresentatives(WF::Spets,p=0)</code></p><p><code>WF</code>  should be  a Coxeter  coset representing  an algebraic  coset <code>𝐆 ⋅σ</code>, where  <code>𝐆</code> is a connected  reductive group (represented by <code>W=Group(WF)</code>), and  <code>σ</code>  is  a  quasi-central  automorphism  of  <code>𝐆</code> defined by <code>WF</code>. The function returns a list of semisimple elements of <code>𝐆</code> such that <code>tσ</code>, when <code>t</code>  runs over this  list, are representatives  of the conjugacy classes of quasi-isolated quasisemisimple elements of <code>𝐆 ⋅σ</code> (an element <code>tσ∈ 𝐓 ⋅σ</code> is quasi-isolated  if  the  Weyl  group  of  <code>C_𝐆  (tσ)</code>  is not in any proper parabolic  subgroup of <code>W^σ</code>). If a second  argument <code>p</code> is given, it lists only those representatives which exist in characteristic <code>p</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(&quot;2E6sc&quot;)
²E₆sc

julia&gt; QuasiIsolatedRepresentatives(WF)
5-element Vector{SemisimpleElement{Root1}}:
 &lt;1,1,1,1,1,1&gt;
 &lt;1,1,1,-1,1,1&gt;
 &lt;1,-1,ζ₄,1,ζ₄,1&gt;
 &lt;1,ζ₃²,1,ζ₃,1,1&gt;
 &lt;1,ζ₄³,1,-1,1,1&gt;

julia&gt; QuasiIsolatedRepresentatives(WF,2)
2-element Vector{SemisimpleElement{Root1}}:
 &lt;1,1,1,1,1,1&gt;
 &lt;1,ζ₃²,1,ζ₃,1,1&gt;

julia&gt; QuasiIsolatedRepresentatives(WF,3)
4-element Vector{SemisimpleElement{Root1}}:
 &lt;1,1,1,1,1,1&gt;
 &lt;1,1,1,-1,1,1&gt;
 &lt;1,-1,ζ₄,1,ζ₄,1&gt;
 &lt;1,ζ₄³,1,-1,1,1&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Sscoset.jl#L201-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Semisimple.is_isolated-Tuple{Spets, SemisimpleElement{Root1}}" href="#Gapjm.Semisimple.is_isolated-Tuple{Spets, SemisimpleElement{Root1}}"><code>Gapjm.Semisimple.is_isolated</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>is_isolated(WF::Spets,t::SemisimpleElement{Root1})</code></p><p><code>WF</code>  should be  a Coxeter  coset representing  an algebraic  coset <code>𝐆 ⋅σ</code>, where  <code>𝐆</code> is a connected  reductive group (represented by <code>W=Group(WF)</code>), and  <code>σ</code>  is  a  quasi-central  automorphism  of  <code>𝐆</code> defined by <code>WF</code>. The element  <code>t</code> should be a semisimple element of <code>𝐆</code>. The function returns a boolean describing whether <code>tσ</code> is isolated, that is whether the Weyl group of <code>C_𝐆 (tσ)⁰</code> is not in any proper parabolic subgroup of <code>W^σ</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(:u,6)
u₆

julia&gt; l=QuasiIsolatedRepresentatives(WF)
4-element Vector{SemisimpleElement{Root1}}:
 &lt;1,1,1,1,1,1&gt;
 &lt;ζ₄,1,1,1,1,ζ₄³&gt;
 &lt;ζ₄,ζ₄,1,1,ζ₄³,ζ₄³&gt;
 &lt;ζ₄,ζ₄,ζ₄,ζ₄³,ζ₄³,ζ₄³&gt;

julia&gt; is_isolated.(Ref(WF),l)
4-element BitVector:
 1
 0
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Sscoset.jl#L244-L272">source</a></section></article><h1 id="Unipotent-characters"><a class="docs-heading-anchor" href="#Unipotent-characters">Unipotent characters</a><a id="Unipotent-characters-1"></a><a class="docs-heading-anchor-permalink" href="#Unipotent-characters" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch" href="#Gapjm.Uch"><code>Gapjm.Uch</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Let  <code>𝐆</code> be a connected reductive group defined over the algebraic closure of  a finite field <span>$𝔽_q$</span>,  with corresponding Frobenius automorphism <code>F</code>, or  more generally let  <code>F</code> be an  isogeny of <code>𝐆</code> such that  a power is a Frobenius (this covers the Suzuki and Ree groups).</p><p>If  <code>𝐓</code>  is  an  <code>F</code>-stable  maximal  torus  of  <code>𝐆</code>,  and  <code>𝐁</code> is a (not necessarily  <code>F</code>-stable)  Borel  subgroup  containing  <code>𝐓</code>,  we  define the <em>Deligne-Lusztig</em>  variety <span>$X_𝐁=\{g𝐁 ∈ 𝐆  /𝐁 ∣ g𝐁 ∩  F(g𝐁 )≠∅ \}$</span>. This variety  has a natural action of <span>$𝐆 ^F$</span> on the left, so the corresponding <em>Deligne-Lusztig  virtual module</em>  <span>$∑ᵢ (-1)ⁱ  Hⁱ_c(X_𝐁,ℚ̄ _ℓ)$</span>  also. The character  of this virtual module  is the <em>Deligne-Lusztig</em> character <span>$R_𝐓 ^𝐆  (1)$</span>; the  notation reflects  the fact  that one  can prove  that this character does not depend on the choice of <code>𝐁</code>. Actually, this character is parameterized by an <code>F</code>-conjugacy class of <code>W</code>: if <code>𝐓₀⊂𝐁₀</code> is an <code>F</code>-stable pair,  there  is  an  unique  <span>$w∈  W=N_𝐆  (𝐓₀)/𝐓₀$</span>  such  that the triple <code>(𝐓,𝐁,F)</code> is <code>𝐆</code>-conjugate to <code>(𝐓₀,𝐁₀,wF)</code>. In this case we denote <span>$R_w$</span> for <span>$R_𝐓^𝐆 (1)$</span>; it depends only on the <code>F</code>-class of <code>w</code>.</p><p>The  <em>unipotent characters</em> of <span>$𝐆 ^F$</span> are the irreducible constituents of the  <span>$R_w$</span>. In a  similar way that  the unipotent classes  are a building block  for  describing  the  conjugacy  classes  of  a reductive group, the unipotent characters are a building block for the irreducible characters of a  reductive group.  They can  be parameterized  by combinatorial data that Lusztig  has attached just to the coset <code>Wφ</code>, where <code>φ</code> is the finite order automorphism  of  <code>X(𝐓₀)</code>  such  that  <code>F=qφ</code>.  Thus, from the viewpoint of Chevie, they are objects combinatorially attached to a Coxeter coset.</p><p>A  subset  of  the  unipotent  characters, the <em>principal series</em> unipotent characters,   can  be  described  in  an   elementary  way.  They  are  the constituents  of <code>R₁</code>, or equivalently the characters of the virtual module defined  by the  cohomology of  <span>$X_{𝐁 ₀}$</span>,  which is the discrete variety <span>$(𝐆  /𝐁₀)^F$</span>; the virtual module reduces  to the actual module <span>$ℚ̄ _ℓ[(𝐆 /𝐁₀)  ^F]$</span>. Thus the  Deligne-Lusztig induction <span>$R_{𝐓₀}^𝐆 (1)$</span> reduces to Harish-Chandra  induction,  defined  as  follows:  let  <code>𝐏  =𝐔  ⋊ 𝐋</code> be an <code>F</code>-stable  Levi decomposition of an <code>F</code>-stable parabolic subgroup of <code>𝐆</code>. Then  the <em>Harish-Chandra</em> induced <span>$R_𝐋^𝐆$</span> of a character <code>χ</code> of <span>$𝐋^F$</span> is  the character <span>$Ind_{𝐏^F}^{𝐆 ^F}χ̃$</span>, where <code>χ̃</code> is the lift to <span>$𝐏^F$</span> of  <code>χ</code> via  the quotient  <span>$𝐏^F/𝐔 ^F=𝐋^F$</span>;  Harish-Chandra induction is a particular  case of <em>Lusztig  induction</em>, which is  defined when <code>𝐏</code> is not <code>F</code>-stable  using the variety <span>$X_𝐔 =\{ g𝐔 ∈𝐆 /𝐔 ∣ g𝐔 ∩ F(g𝐔 )≠∅\}$</span>, and gives  for  an  <span>$𝐋^F$</span>-module  a  virtual  <span>$𝐆  ^F$</span>-module. Like ordinary induction,  these functors have adjoint functors going from representations of  <span>$𝐆 ^F$</span> to representations  (resp. virtual representations) of <span>$𝐋^F$</span> called Harish-Chandra restriction (resp. Lusztig restriction).</p><p>The  commuting algebra  of <span>$𝐆^F$</span>-endomorphisms  of <span>$R_{𝐓₀}^𝐆(1)$</span>  is an Iwahori-Hecke algebra for <span>$W^φ$</span>, with parameters which are some powers of <code>q</code>;  they  are  all  equal  to  <code>q</code>  when <span>$W^φ=W$</span>. Thus principal series unipotent characters correspond to characters of <span>$W^φ$</span>.</p><p>To  understand the  decomposition of  Deligne-Lusztig characters,  and thus unipotent  characters,  is  is  useful  to  introduce  another set of class functions  which are parameterized  by irreducible characters  of the coset <code>Wφ</code>.  If  <code>χ</code>  is  such  a  character,  we  define  the associated <em>almost character</em>  by: <span>$Rᵪ=|W|⁻¹∑_{w∈  W}χ(wφ) R_w$</span>.  The reason  to the name is that these class function are close to irreducible characters: they satisfy <span>$⟨Rᵪ,  R_ψ⟩_{𝐆^F}=δ_{χ,ψ}$</span>;  for  the  linear  and unitary group they are actually  unipotent characters (up to sign in the latter case). They are in general  sum (with  rational coefficients)  of a  small number of unipotent characters  in  the  same  <em>Lusztig  family</em>  (see  &quot;Families  of unipotent characters&quot;).  The degree of <code>Rᵪ</code> is a  polynomial in <code>q</code> equal to the fake degree  of  the  character  <code>χ</code>  of  <code>Wφ</code>  (see  &quot;Functions  for Reflection cosets&quot;).</p><p>We  now describe the parameterization of unipotent characters when <code>W^φ=W</code>, thus  when the coset <code>Wφ</code> identifies with <code>W</code> (the situation is similar but a  bit more difficult to describe  in general). The (rectangular) matrix of scalar  products <span>$⟨ρ, Rᵪ⟩_{𝐆  ^F}$</span>, when characters  of <code>W</code> and unipotent characters  are arranged in the right  order, is block-diagonal with rather small blocks which are called <em>Lusztig families</em>.</p><p>For  the characters of <code>W</code> a family <code>𝓕</code> corresponds to a block of the Hecke algebra  over a ring called the Rouquier  ring. To <code>𝓕</code> Lusztig associates a small group <code>Γ</code> (not bigger than <code>(ℤ/2)ⁿ</code>, or <code>𝔖ᵢ</code> for <code>i≤5</code>) such that the unipotent  characters in the family are  parameterized by the pairs <code>(x,θ)</code> taken  up to <code>Γ</code>-conjugacy, where <code>x∈Γ</code> and <code>θ</code> is an irreducible character of <span>$C_Γ(x)$</span>. Further, the elements of <code>𝓕</code> themselves are parameterized by a  subset of such pairs,  and Lusztig defines a  pairing between such pairs which  computes the scalar product <span>$⟨ρ,  Rᵪ⟩_{𝐆^F}$</span>. For more details see &quot;DrinfeldDouble&quot;.</p><p>A  second parameterization  of unipotent  character is  via <em>Harish-Chandra series</em>.  A character is called <em>cuspidal</em> if all its proper Harish-Chandra restrictions  vanish. There are few  cuspidal unipotent characters (none in linear   groups,  and  at   most  one  in   other  classical  groups).  The <span>$𝐆^F$</span>-endomorphism algebra of an Harish-Chandra induced <span>$R_{𝐋^F}^{𝐆^F}λ$</span>,  where <code>λ</code> is a  cuspidal unipotent character turns out to be a Hecke algebra associated to the group <span>$W_{𝐆^F}(𝐋^F):=N_{𝐆^F}(𝐋)/𝐋$</span>, which turns out to be a Coxeter group. Thus another  parameterization is by triples <code>(𝐋,λ,φ)</code>,  where <code>λ</code> is a cuspidal unipotent  character of <span>$𝐋^F$</span> and <code>φ</code>  is an irreducible character of the <em>relative  group</em> <span>$W_{𝐆^F}(𝐋^F)$</span>. Such  characters are said  to belong to the Harish-Chandra series determined by <code>(𝐋,λ)</code>.</p><p>A  final  piece  of  information  attached  to  unipotent characters is the <em>eigenvalues  of Frobenius</em>. Let <code>Fᵟ</code> be  the smallest power of the isogeny <code>F</code>  which is a split Frobenius (that  is, <code>Fᵟ</code> is a Frobenius and <code>φᵟ=1</code>). Then  <code>Fᵟ</code>  acts  naturally  on  Deligne-Lusztig  varieties and thus on the corresponding  virtual modules, and commutes to the action of <span>$𝐆^F$</span>; thus for  a given  unipotent character  <code>ρ</code>, a  submodule of  the virtual module which  affords  <code>ρ</code>  affords  a  single  eigenvalue <code>μ</code> of <code>Fᵟ</code>. Results of Lusztig  and Digne-Michel show that this  eigenvalue is of the form <code>qᵃᵟλᵨ</code> where  <code>2a∈ℤ</code> and <code>λᵨ</code> is a root of unity which depends only on <code>ρ</code> and not the  considered module.  This <code>λᵨ</code>  is called  the eigenvalue  of Frobenius attached  to <code>ρ</code>.  Unipotent characters  in the  Harish-Chandra series of a pair <code>(𝐋,λ)</code> have the same eigenvalue of Frobenius as <code>λ</code>.</p><p>Chevie   contains  tables  of  all   this  information,   and  can  compute Harish-Chandra  and Lusztig  induction of  unipotent characters  and almost characters. We illustrate the information on some examples:</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; uc=UnipotentCharacters(W)
UnipotentCharacters(G₂)
      γ│   Deg(γ)  Feg Fr(γ)    label
───────┼──────────────────────────────
φ₁‚₀   │        1    1     1         
φ₁‚₆   │       q⁶   q⁶     1         
φ′₁‚₃  │  qΦ₃Φ₆/3   q³     1    (1,ρ)
φ″₁‚₃  │  qΦ₃Φ₆/3   q³     1   (g₃,1)
φ₂‚₁   │ qΦ₂²Φ₃/6  qΦ₈     1    (1,1)
φ₂‚₂   │ qΦ₂²Φ₆/2 q²Φ₄     1   (g₂,1)
G₂[-1] │ qΦ₁²Φ₃/2    0    -1   (g₂,ε)
G₂[1]  │ qΦ₁²Φ₆/6    0     1    (1,ε)
G₂[ζ₃] │qΦ₁²Φ₂²/3    0    ζ₃  (g₃,ζ₃)
G₂[ζ₃²]│qΦ₁²Φ₂²/3    0   ζ₃² (g₃,ζ₃²)</code></pre><p>The first column gives the name of the unipotent character; the first 6 are in  the  principal  series  so  are  named  according  to the corresponding characters  of <code>W</code>. The last 4 are cuspidal, and named by the corresponding eigenvalue  of  Frobenius,  which  is  displayed  in  the fourth column. In general   the   names   of   the   unipotent  characters  come  from  their parameterization  by  Harish-Chandra  series;  in  addition,  for classical groups, they are associated to <em>symbols</em>.</p><p>The first two characters are each in a family by themselves. The last eight are  in a family associated to the  group <code>Γ=𝔖₃</code>: the last column shows the parameters  <code>(x,θ)</code>. The  second column  shows the  degree of the unipotent characters, which is transformed by the Lusztig Fourier matrix of the third column,  which gives the  degree of the  corresponding almost character, or equivalently the fake degree of the corresponding character of <code>W</code>.</p><p>One  can get  more information  on the  Lusztig Fourier  matrix of  the big family by asking</p><pre><code class="language-julia-repl hljs">julia&gt; uc.families[1]
Family(D(𝔖 ₃),[5, 6, 4, 3, 8, 7, 9, 10])
Drinfeld double of 𝔖 ₃, Lusztig′s version
   label│eigen                                       
────────┼─────────────────────────────────────────────
(1,1)   │    1 1/6  1/2  1/3  1/3  1/6  1/2  1/3  1/3
(g₂,1)  │    1 1/2  1/2    0    0 -1/2 -1/2    0    0
(g₃,1)  │    1 1/3    0  2/3 -1/3  1/3    0 -1/3 -1/3
(1,ρ)   │    1 1/3    0 -1/3  2/3  1/3    0 -1/3 -1/3
(1,ε)   │    1 1/6 -1/2  1/3  1/3  1/6 -1/2  1/3  1/3
(g₂,ε)  │   -1 1/2 -1/2    0    0 -1/2  1/2    0    0
(g₃,ζ₃) │   ζ₃ 1/3    0 -1/3 -1/3  1/3    0  2/3 -1/3
(g₃,ζ₃²)│  ζ₃² 1/3    0 -1/3 -1/3  1/3    0 -1/3  2/3</code></pre><p>One  can  do  computations  with  individual  unipotent characters. Here we construct  the Coxeter torus, and then the identity character of this torus as a unipotent character.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; T=spets(reflection_subgroup(W,Int[]),W(1,2))
G₂₍₎=Φ₆

julia&gt; u=UniChar(T,1)
[G₂₍₎=Φ₆]:&lt;Id&gt;</code></pre><p>Then  here  are  two  ways  to  construct  the  Deligne-Lusztig  character associated to the Coxeter torus:</p><pre><code class="language-julia-repl hljs">julia&gt; LusztigInduce(W,u)
[G₂]:&lt;φ₁‚₀&gt;+&lt;φ₁‚₆&gt;-&lt;φ₂‚₁&gt;+&lt;G₂[-1]&gt;+&lt;G₂[ζ₃]&gt;+&lt;G₂[ζ₃²]&gt;

julia&gt; v=DLChar(W,[1,2])
[G₂]:&lt;φ₁‚₀&gt;+&lt;φ₁‚₆&gt;-&lt;φ₂‚₁&gt;+&lt;G₂[-1]&gt;+&lt;G₂[ζ₃]&gt;+&lt;G₂[ζ₃²]&gt;

julia&gt; degree(v)
Pol{Int64}: q⁶+q⁵-q⁴-2q³-q²+q+1

julia&gt; v*v
6</code></pre><p>The  last two lines ask for the degree  of <code>v</code>, then for the scalar product of <code>v</code> with itself.</p><p>Finally  we mention  that Chevie  can also  provide unipotent characters of Spetses, as defined in <a href="biblio.htm#BMM14">BroueMalleMichel2014</a>. An example:</p><pre><code class="language-julia-repl hljs">julia&gt; UnipotentCharacters(ComplexReflectionGroup(4))
UnipotentCharacters(G₄)
    γ│           Deg(γ)    Feg Fr(γ)  label
─────┼──────────────────────────────────────
φ₁‚₀ │                1      1     1       
φ₁‚₄ │ -√-3q⁴Φ″₃Φ₄Φ″₆/6     q⁴     1   1∧ζ₆
φ₁‚₈ │  √-3q⁴Φ′₃Φ₄Φ′₆/6     q⁸     1 -1∧ζ₃²
φ₂‚₅ │        q⁴Φ₂²Φ₆/2   q⁵Φ₄     1  1∧ζ₃²
φ₂‚₃ │-ζ₃√-3qΦ″₃Φ₄Φ′₆/3   q³Φ₄     1  1∧ζ₃²
φ₂‚₁ │ζ₃²√-3qΦ′₃Φ₄Φ″₆/3    qΦ₄     1   1∧ζ₃
φ₃‚₂ │           q²Φ₃Φ₆ q²Φ₃Φ₆     1       
Z₃:2 │    -√-3qΦ₁Φ₂Φ₄/3      0   ζ₃² ζ₃∧ζ₃²
Z₃:11│   -√-3q⁴Φ₁Φ₂Φ₄/3      0   ζ₃² ζ₃∧ζ₆⁵
G₄   │       -q⁴Φ₁²Φ₃/2      0    -1  ζ₆∧-1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Uch.jl#L1-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.UnipotentCharacters" href="#Gapjm.Uch.UnipotentCharacters"><code>Gapjm.Uch.UnipotentCharacters</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>UnipotentCharacters(W)</code></p><p><code>W</code>  should be a Coxeter group, a  Coxeter Coset or a Spetses. The function gives  back a record containing  information about the unipotent characters of the associated algebraic group (or Spetses). This contains the following fields:</p><p><code>.harishChandra</code>:  information  about  Harish-Chandra  series  of  unipotent characters.  This is itself a list of records, one for each pair <code>(𝐋,λ)</code> of a  Levi  of  an  <code>F</code>-stable  parabolic  subgroup  and  a cuspidal unipotent character of <span>$𝐋^F$</span>. These records themselves have the following fields:</p><p><code>:levi</code>: a list &#39;l&#39; such that <code>𝐋</code> corresponds to &#39;ReflectionSubgroup(W,l)&#39;.</p><p><code>:cuspidalName</code>: the name of the unipotent cuspidal character <code>lambda</code>.</p><p><code>:eigenvalue</code>: the eigenvalue of Frobenius for <code>λ</code>.</p><p><code>:relativeType</code>: the reflection type of <span>$W_𝐆 (𝐋)$</span>;</p><p><code>:parameterExponents</code>:  the <span>$𝐆 ^F$</span>-endomorphism  algebra of <span>$R_𝐋^𝐆 (λ)$</span> is  a  Hecke  algebra  for  <span>$W_𝐆  (𝐋)$</span>  with  some parameters of the form <span>$q^{a_s}$</span>. This holds the list of exponents <span>$a_s$</span>.</p><p><code>:charNumbers</code>:  the  indices  of  the  unipotent  characters indexed by the irreducible characters of <span>$W_𝐆 (𝐋)$</span>.</p><p><code>.almostHarishChandra</code>:   information   about   Harish-Chandra   series  of unipotent  character sheaves.  This is  identical to  ̀harishChandra` for a split  reductive group,  and reflects  the situation  for the corresponding split group for a nonsplit group.</p><p><code>.families</code>:  information  about  Lusztig  families of unipotent characters. This  is itself a list  of records, one for  each family. These records are described in the section about families below.</p><p>the following information is computed on demand from <code>uc=UnipotentCharacters(W)</code>:</p><p><code>spets(uc)</code>: the reductive group <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:Bsym,2)
Bsym₂

julia&gt; WF=spets(W,Perm(1,2))
²Bsym₂

julia&gt; uc=UnipotentCharacters(WF)
UnipotentCharacters(²Bsym₂)
       γ│   Deg(γ)   Feg Fr(γ) label
────────┼────────────────────────────
2       │        1     1     1      
11      │       q⁴    q⁴     1      
²B₂[1,3]│√2qΦ₁Φ₂/2 qΦ₁Φ₂   ζ₈³     1
²B₂[1,5]│√2qΦ₁Φ₂/2     0   ζ₈⁵     2

julia&gt; uc.families
3-element Vector{Family}:
 Family(C₁,[1]) 
 Family(C₁,[2]) 
 Family(?4,3:4)

julia&gt; uc.families[3]
Family(?4,3:4)
label│eigen    1     2
─────┼─────────────────
1    │  ζ₈³ √2/2 -√2/2
2    │  ζ₈⁵ √2/2  √2/2</code></pre><p><code>charnames(uc)</code>:  the list of names of the unipotent characters.  Using    appropriate keywords, one can control the display in various ways.</p><pre><code class="language-julia-repl hljs">julia&gt; uc=UnipotentCharacters(coxgroup(:G,2));

julia&gt; charnames(uc;limit=true)
10-element Vector{String}:
 &quot;φ₁‚₀&quot;   
 &quot;φ₁‚₆&quot;   
 &quot;φ′₁‚₃&quot;  
 &quot;φ″₁‚₃&quot;  
 &quot;φ₂‚₁&quot;   
 &quot;φ₂‚₂&quot;   
 &quot;G₂[-1]&quot; 
 &quot;G₂[1]&quot;  
 &quot;G₂[ζ₃]&quot; 
 &quot;G₂[ζ₃²]&quot;

julia&gt; charnames(uc;TeX=true)
10-element Vector{String}:
 &quot;\phi_{1,0}&quot;    
 &quot;\phi_{1,6}&quot;    
 &quot;\phi_{1,3}&#39;&quot;   
 &quot;\phi_{1,3}&#39;&#39;&quot;  
 &quot;\phi_{2,1}&quot;    
 &quot;\phi_{2,2}&quot;    
 &quot;G_2[-1]&quot;        
 &quot;G_2[1]&quot;         
 &quot;G_2[\zeta_3]&quot;  
 &quot;G_2[\zeta_3^2]&quot;</code></pre><p>One  can control  the display  of unipotent  characters in  various ways by <code>IOContext</code>  properties. In the display, the row labels are the nems of the unipotent characters. Then the following column numbers display:</p><pre><code class="nohighlight hljs">1: The index of the character in the list of unipotent characters.
2: The degree of the unipotent character.
3: The degree of the corresponding almost character.
4: for classical groups, the symbol attached to the unipotent character.
5: The eigenvalue of Frobenius attached to the unipotent character.
6: The parameter the character has in its Lusztig family.</code></pre><p>Which  columns  are  displayed  can  be  controlled by the property <code>:cols</code> (default [2,3,5,6]).</p><p>In  addition if  &#39;:byfamily=true&#39;, the  characters are  displayed family by family  instead  of  in  index  order.  Finally,  the properties <code>rows</code> and <code>columnrepartition</code>  of  <code>format</code>  can  be  set,  giving more tuning of the table.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; uc=UnipotentCharacters(W)
UnipotentCharacters(B₂)
  γ│Deg(γ) Feg Fr(γ) label
───┼───────────────────────
11.│ qΦ₄/2  q²     1   +,-
1.1│qΦ₂²/2 qΦ₄     1   +,+
.11│    q⁴  q⁴     1      
2. │     1   1     1      
.2 │ qΦ₄/2  q²     1   -,+
B₂ │qΦ₁²/2   0    -1   -,-</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; xdisplay(uc;byfamily=true)
UnipotentCharacters(B₂)
   γ│Deg(γ) Feg Fr(γ) label
────┼───────────────────────
2.ˢ │     1   1     1      
────┼───────────────────────
11. │ qΦ₄/2  q²     1   +,-
1.1ˢ│qΦ₂²/2 qΦ₄     1   +,+
.2  │ qΦ₄/2  q²     1   -,+
B₂  │qΦ₁²/2   0    -1   -,-
────┼───────────────────────
.11ˢ│    q⁴  q⁴     1      
────┼───────────────────────

julia&gt; xdisplay(uc;cols=[1,4])
UnipotentCharacters(B₂)
  γ│n₀   Symbol
───┼────────────
11.│ 1   (12,0)
1.1│ 2   (02,1)
.11│ 3 (012,12)
2. │ 4     (2,)
.2 │ 5   (01,2)
B₂ │ 6   (012,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Uch.jl#L377-L543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.degrees-Tuple{UnipotentCharacters, Any}" href="#Gapjm.degrees-Tuple{UnipotentCharacters, Any}"><code>Gapjm.degrees</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>degrees(uc::UnipotentCharacters,q=Pol())</code></p><p>Returns  the  list  of  degrees  of  the unipotent characters of the finite reductive group (or Spetses) with Weyl group (or Spetsial reflection group) <code>W</code>, evaluated at <code>q</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; uc=UnipotentCharacters(W);

julia&gt; degrees(uc)
10-element Vector{Pol{Rational{Int64}}}:
 1//1                                         
 (1//1)q⁶                                     
 (1//3)q⁵+(1//3)q³+(1//3)q                    
 (1//3)q⁵+(1//3)q³+(1//3)q                    
 (1//6)q⁵+(1//2)q⁴+(2//3)q³+(1//2)q²+(1//6)q  
 (1//2)q⁵+(1//2)q⁴+(1//2)q²+(1//2)q           
 (1//2)q⁵+(-1//2)q⁴+(-1//2)q²+(1//2)q         
 (1//6)q⁵+(-1//2)q⁴+(2//3)q³+(-1//2)q²+(1//6)q
 (1//3)q⁵+(-2//3)q³+(1//3)q                   
 (1//3)q⁵+(-2//3)q³+(1//3)q                   </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Uch.jl#L751-L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.CycPolUnipotentDegrees" href="#Gapjm.Uch.CycPolUnipotentDegrees"><code>Gapjm.Uch.CycPolUnipotentDegrees</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>CycPolUnipotentDegrees(W)</code></p><p>Taking  advantage that  the degrees  of unipotent  characters of the finite reductive group (or Spetses) with Weyl group (or Spetsial reflection group) <code>W</code>  are products  of cyclotomic  polynomials, this  function returns these degrees as a list of <code>CycPol</code>s.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; CycPolUnipotentDegrees(W)
10-element Vector{CycPol{Rational{Int64}}}:
 1     
 q⁶       
 qΦ₃Φ₆/3  
 qΦ₃Φ₆/3  
 qΦ₂²Φ₃/6 
 qΦ₂²Φ₆/2 
 qΦ₁²Φ₃/2 
 qΦ₁²Φ₆/6 
 qΦ₁²Φ₂²/3
 qΦ₁²Φ₂²/3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Uch.jl#L832-L857">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.UniChar" href="#Gapjm.Uch.UniChar"><code>Gapjm.Uch.UniChar</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>UniChar(W,l)</code></p><p>Constructs  an object representing the unipotent character specified by <code>l</code> of  the algebraic  group associated  to the  Coxeter group or Coxeter coset specified  by <code>W</code>. There are 3 possibilities  for <code>l</code>: if it is an integer, the  <code>l</code>-th unipotent character of <code>W</code> is  returned. If it is a string, the unipotent  character of <code>W</code> whose name is <code>l</code> is returned. Finally, <code>l</code> can be  a  list  of  length  the  number  of unipotent characters of <code>W</code>, which specifies the coefficient to give to each.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; u=UniChar(W,7)
[G₂]:&lt;G₂[-1]&gt;

julia&gt; v=UniChar(W,&quot;G2[E3]&quot;)
[G₂]:&lt;G₂[ζ₃]&gt;

julia&gt; w=UniChar(W,[1,0,0,-1,0,0,2,0,0,1])
[G₂]:&lt;φ₁‚₀&gt;-&lt;φ″₁‚₃&gt;+2&lt;G₂[-1]&gt;+&lt;G₂[ζ₃²]&gt;

julia&gt; UniChar(W,fourier(UnipotentCharacters(W))[3,:])
[G₂]:2//3&lt;φ′₁‚₃&gt;-1//3&lt;φ″₁‚₃&gt;+1//3&lt;φ₂‚₁&gt;+1//3&lt;G₂[1]&gt;-1//3&lt;G₂[ζ₃]&gt;-1//3&lt;G₂[ζ₃²]&gt;
</code></pre><p>The  last line shows  the almost character  associated to the 3rd unipotent character of <code>W</code>.</p><p>some limited arithmetic is available on unipotent characters:</p><pre><code class="language-julia-repl hljs">julia&gt; w-2u
[G₂]:&lt;φ₁‚₀&gt;-&lt;φ″₁‚₃&gt;+&lt;G₂[ζ₃²]&gt;

julia&gt; w*w  # scalar product
7

julia&gt; degree(w)
Pol{Int64}: q⁵-q⁴-q³-q²+q+1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Uch.jl#L866-L909">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.DLChar" href="#Gapjm.Uch.DLChar"><code>Gapjm.Uch.DLChar</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>DLChar(W,w)</code></p><p>This  function returns the Deligne-Lusztig character  <span>$R_𝐓 ^𝐆 (1)$</span> of the algebraic  group <code>𝐆</code> associated to the Coxeter group or Coxeter coset <code>W</code>. The  torus  <code>𝐓</code>  can  be  specified  in  3  ways:  if <code>w</code> is an integer, it represents the <code>w</code>-th conjugacy class (or <code>phi</code>-conjugacy class for a coset <code>Wϕ</code>)  of <code>W</code>. Otherwise  <code>w</code> can be  a word or  an element of  <code>W</code>, and it represents the class (or <code>ϕ</code>-class) of <code>w</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; DLChar(W,3)
[G₂]:&lt;φ₁‚₀&gt;-&lt;φ₁‚₆&gt;-&lt;φ′₁‚₃&gt;+&lt;φ″₁‚₃&gt;

julia&gt; DLChar(W,W(1))
[G₂]:&lt;φ₁‚₀&gt;-&lt;φ₁‚₆&gt;-&lt;φ′₁‚₃&gt;+&lt;φ″₁‚₃&gt;

julia&gt; DLChar(W,[1])
[G₂]:&lt;φ₁‚₀&gt;-&lt;φ₁‚₆&gt;-&lt;φ′₁‚₃&gt;+&lt;φ″₁‚₃&gt;

julia&gt; DLChar(W,[1,2])
[G₂]:&lt;φ₁‚₀&gt;+&lt;φ₁‚₆&gt;-&lt;φ₂‚₁&gt;+&lt;G₂[-1]&gt;+&lt;G₂[ζ₃]&gt;+&lt;G₂[ζ₃²]&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Uch.jl#L1060-L1086">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.almostChar" href="#Gapjm.Uch.almostChar"><code>Gapjm.Uch.almostChar</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>almostChar(W,i)</code></p><p>This  function  returns  the  <code>i</code>-th  almost  unipotent  character  of  the algebraic  group 𝐆 associated to the Coxeter group or Coxeter coset <code>W</code>. If <code>φ</code> is the <code>i</code>-th irreducible character of <code>W</code>, the <code>i</code>-th almost character is  <span>$R_φ=W⁻¹∑_{w∈ W}  φ(w) R_{𝐓_w}^𝐆  (1)$</span> where  <span>$𝐓_w$</span> is  the maximal torus  associated  to  the  conjugacy  class  (or <code>ϕ</code>-conjugacy class for a coset) of <code>w</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; almostChar(W,3)
[B₂]:&lt;.11&gt;

julia&gt; almostChar(W,1)
[B₂]:1//2&lt;11.&gt;+1//2&lt;1.1&gt;-1//2&lt;.2&gt;-1//2&lt;B₂&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Uch.jl#L1093-L1113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.on_unipotents" href="#Gapjm.Uch.on_unipotents"><code>Gapjm.Uch.on_unipotents</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>on_unipotents(W,aut)</code></p><p><code>W</code>  is  a  reflection  group  or  reflection  coset  representing a finite reductive group <span>$𝐆 ^F$</span>, and <code>aut</code> is an automorphism of <span>$𝐆 ^F$</span> (for <code>W</code> a  permutation group, this can be given as a permutation of the roots). The function  returns the permutation  of the unipotent  characters of <span>$𝐆 ^F$</span> induced  by <code>aut</code>. This makes sense  for Spetsial complex reflection groups and is implemented for them.</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(&quot;3D4&quot;)
³D₄

julia&gt; on_unipotents(Group(WF),WF.phi)
(1,7,2)(8,12,9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Uch.jl#L1193-L1210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.DLLefschetz" href="#Gapjm.Uch.DLLefschetz"><code>Gapjm.Uch.DLLefschetz</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>DLLefschetz(h)</code></p><p>Here <code>h</code> is an element of a Hecke algebra associated to a Coxeter group <code>W</code> which  itself  is  associated  to  an  algebraic  group <code>𝐆</code>. By results of Digne-Michel,  for <span>$g∈ 𝐆 ^F$</span>,  the number of fixed  points of <code>Fᵐ</code> on the Deligne-Lusztig variety associated to the element <code>wϕ</code> of the Coxeter coset <code>Wϕ</code>, have for <code>m</code> sufficiently divisible, the form <span>$∑_φ φ_{(qᵐ)}(T_wϕ)R_φ(g)$</span>  where <code>φ</code>  runs over  the irreducible characters of <code>Wϕ</code>,  where  <span>$R_φ$</span>  is  the  corresponding  almost  character, and where <span>$φ_{(qᵐ)}$</span>  is a character value of the Hecke algebra <code>ℋ (Wϕ,qᵐ)</code> of <code>Wϕ</code> with parameter <code>qᵐ</code>. This expression is called the <em>Lefschetz character</em> of the  Deligne-Lusztig variety. If we consider  <code>qᵐ</code> as an indeterminate <code>x</code>, it can be seen as a sum of unipotent characters with coefficients character values of the generic Hecke algebra <code>ℋ (Wϕ,x)</code>.</p><p>The  function &#39;DLLefschetz&#39; takes  as argument a  Hecke element and returns the  corresponding Lefschetz character. This is defined on the whole of the Hecke  algebra by linearity.  The Lefschetz character  of various varieties related   to   Deligne-Lusztig   varieties,   like   their  completions  or desingularisation,  can be  obtained by  taking the  Lefschetz character at various elements of the Hecke algebra.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; H=hecke(W,Pol(:q))
hecke(A₂,q)

julia&gt; T=Tbasis(H);

julia&gt; DLLefschetz(T(1,2))
[A₂]:&lt;111&gt;-q&lt;21&gt;+q²&lt;3&gt;

julia&gt; DLLefschetz((T(1)+T())*(T(2)+T()))
[A₂]:q&lt;21&gt;+(q²+2q+1)&lt;3&gt;</code></pre><p>The   last  line  shows  the   Lefschetz  character  of  the  Samelson-Bott desingularisation of the Coxeter element Deligne-Lusztig variety.</p><p>We now show an example with a coset (corresponding to the unitary group).</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(spets(W,Perm(1,2)),Pol(:q)^2)
hecke(²A₂,q²)

julia&gt; T=Tbasis(H);DLLefschetz(T(1))
[²A₂]:-&lt;11&gt;-q&lt;²A₂&gt;+q²&lt;2&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Uch.jl#L1120-L1171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.LusztigInduce" href="#Gapjm.Uch.LusztigInduce"><code>Gapjm.Uch.LusztigInduce</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>LusztigInduce(W,u)</code></p><p><code>u</code>  should be a unipotent character of a parabolic subcoset of the Coxeter coset  <code>W</code>. It represents  a unipotent character  <code>λ</code> of a  Levi <code>𝐋</code> of the algebraic  group  <code>𝐆</code>  attached  to  <code>W</code>.  The  program returns the Lusztig induced <span>$R_𝐋^𝐆(λ)$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; WF=spets(W)
G₂

julia&gt; T=subspets(WF,Int[],W(1))
G₂₍₎=Φ₁Φ₂

julia&gt; u=UniChar(T,1)
[G₂₍₎=Φ₁Φ₂]:&lt;Id&gt;

julia&gt; LusztigInduce(WF,u)
[G₂]:&lt;φ₁‚₀&gt;-&lt;φ₁‚₆&gt;-&lt;φ′₁‚₃&gt;+&lt;φ″₁‚₃&gt;

julia&gt; DLChar(W,W(1))
[G₂]:&lt;φ₁‚₀&gt;-&lt;φ₁‚₆&gt;-&lt;φ′₁‚₃&gt;+&lt;φ″₁‚₃&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Uch.jl#L982-L1009">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.LusztigRestrict" href="#Gapjm.Uch.LusztigRestrict"><code>Gapjm.Uch.LusztigRestrict</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>LusztigRestrict(R,u)</code></p><p><code>u</code>  should be a unipotent character of a parent Coxeter coset <code>W</code> of which <code>R</code> is a parabolic subcoset. It represents a unipotent character <code>γ</code> of the algebraic  group <code>𝐆</code> attached to <code>W</code>,  while <code>R</code> represents a Levi subgroup <code>L</code>. The program returns the Lusztig restriction <span>$*R_𝐋^𝐆(γ)$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; WF=spets(W)
G₂

julia&gt; T=subspets(WF,Int[],W(1))
G₂₍₎=Φ₁Φ₂

julia&gt; u=DLChar(W,W(1))
[G₂]:&lt;φ₁‚₀&gt;-&lt;φ₁‚₆&gt;-&lt;φ′₁‚₃&gt;+&lt;φ″₁‚₃&gt;

julia&gt; LusztigRestrict(T,u)
[G₂₍₎=Φ₁Φ₂]:4&lt;Id&gt;

julia&gt; T=subspets(WF,Int[],W(2))
G₂₍₎=Φ₁Φ₂

julia&gt; LusztigRestrict(T,u)
[G₂₍₎=Φ₁Φ₂]:0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Uch.jl#L1015-L1045">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Lusztig.LusztigInductionTable" href="#Gapjm.Lusztig.LusztigInductionTable"><code>Gapjm.Lusztig.LusztigInductionTable</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>LusztigInductionTable(R,W)</code></p><p><code>R</code>  should be a parabolic subgroup of the Coxeter group <code>W</code> or a parabolic subcoset  of  the  Coxeter  coset  <code>W</code>,  in  each  case representing a Levi subgroup  <code>𝐋</code> of  the algebraic  group <code>𝐆</code>  associated to <code>W</code>. The function returns  an <code>InductionTable</code>  representing the  Lusztig induction <span>$R_𝐋^𝐆$</span> between unipotent characters.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,3)
B₃

julia&gt; t=twistings(W,[1,3])
2-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:
 B₃₍₁₃₎=Ã₁×A₁Φ₁
 B₃₍₁₃₎=Ã₁×A₁Φ₂

julia&gt; LusztigInductionTable(t[2],W)
Lusztig Induction from B₃₍₁₃₎=Ã₁×A₁Φ₂ to B₃
     │11⊗ 11 11⊗ 2 2⊗ 11 2⊗ 2
─────┼────────────────────────
111. │     1    -1    -1    .
11.1 │    -1     .     1   -1
1.11 │     .     .    -1    .
.111 │    -1     .     .    .
21.  │     .     .     .    .
1.2  │     1    -1     .    1
2.1  │     .     1     .    .
.21  │     .     .     .    .
3.   │     .     .     .    1
.3   │     .     1     1   -1
B₂:2 │     .     .     1   -1
B₂:11│     1    -1     .    .</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Lusztig.jl#L223-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Families" href="#Gapjm.Families"><code>Gapjm.Families</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Families of unipotent characters</p><p>The blocks of the (rectangular) matrix <span>$⟨Rᵪ,ρ⟩_{𝐆 ^F}$</span> when <code>χ</code> runs over <code>Irr(W)</code>  and  <code>ρ</code>  runs  over  the  unipotent  characters,  are called the <em>Lusztig  families</em>. When  <code>𝐆</code>  is split  and <code>W</code>  is a Coxeter group they correspond  on the <code>Irr(W)</code> side to two-sided Kazhdan-Lusztig cells –- for split  Spetses they  correspond to  Rouquier blocks  of the  Spetsial Hecke algebra.  The matrix of scalar products  <span>$⟨Rᵪ,ρ⟩_{𝐆 ^F}$</span> can be completed to   a  square  matrix  <span>$⟨A_{ρ&#39;},ρ⟩_{𝐆  ^F}$</span>  where  <span>$A_{ρ&#39;}$</span>  are  the <em>characteristic  functions of character  sheaves</em> on <span>$𝐆  ^F$</span>; this square matrix is called the <em>Fourier matrix</em> of the family.</p><p>The  &#39;UnipotentCharacters&#39; record in Chevie contains a field &#39;.families&#39;, a list of family records containing information on each family, including the Fourier matrix. Here is an example.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; uc=UnipotentCharacters(W);

julia&gt; uc.families
3-element Vector{Family}:
 Family(D(𝔖 ₃),[5, 6, 4, 3, 8, 7, 9, 10])
 Family(C₁,[1])                         
 Family(C₁,[2])                         

julia&gt; uc.families[1]
Family(D(𝔖 ₃),[5, 6, 4, 3, 8, 7, 9, 10])
Drinfeld double of 𝔖 ₃, Lusztig′s version
   label│eigen                                       
────────┼─────────────────────────────────────────────
(1,1)   │    1 1/6  1/2  1/3  1/3  1/6  1/2  1/3  1/3
(g₂,1)  │    1 1/2  1/2    0    0 -1/2 -1/2    0    0
(g₃,1)  │    1 1/3    0  2/3 -1/3  1/3    0 -1/3 -1/3
(1,ρ)   │    1 1/3    0 -1/3  2/3  1/3    0 -1/3 -1/3
(1,ε)   │    1 1/6 -1/2  1/3  1/3  1/6 -1/2  1/3  1/3
(g₂,ε)  │   -1 1/2 -1/2    0    0 -1/2  1/2    0    0
(g₃,ζ₃) │   ζ₃ 1/3    0 -1/3 -1/3  1/3    0  2/3 -1/3
(g₃,ζ₃²)│  ζ₃² 1/3    0 -1/3 -1/3  1/3    0 -1/3  2/3

julia&gt; charnames(uc)[uc.families[1].charNumbers]
8-element Vector{String}:
 &quot;phi2,1&quot;  
 &quot;phi2,2&quot;  
 &quot;phi1,3&#39;&#39;&quot;
 &quot;phi1,3&#39;&quot; 
 &quot;G2[1]&quot;   
 &quot;G2[-1]&quot;  
 &quot;G2[E3]&quot;  
 &quot;G2[E3^2]&quot;</code></pre><p>The  Fourier matrix is obtained  by &#39;fourier(f)&#39;; the field &#39;f.charNumbers&#39; holds  the indices of the unipotent characters  which are in the family. We obtain  the list of eigenvalues of Frobenius for these unipotent characters by  &#39;Eigenvalues(f)&#39;. The Fourier matrix  and vector of eigenvalues satisfy the  properties of  <em>fusion data</em>,  see below.  The field &#39;f.charLabels&#39; is what  is displayed  in the  column &#39;labels&#39;  when displaying the family. It contains  labels naturally attached to lines  of the Fourier matrix. In the case   of  reductive  groups,   the  family  is   always  attached  to  the &quot;drinfeld_double&quot;  of a small finite group  and the &#39;.charLabels&#39; come from this construction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Families.jl#L1-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Families.Family" href="#Gapjm.Families.Family"><code>Gapjm.Families.Family</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Family(f [, charNumbers [, opt]])</code></p><p>This function creates a new family in two possible ways.</p><p>In  the first case <code>f</code> is a string which denotes a family known to  Chevie. Examples are &quot;S3&quot;,   &quot;S4&quot;,   &quot;S5&quot;   which denote the family obtained as the Drinfeld  double of the symmetric group  on 3,4,5 elements, or &quot;C2&quot;   which denotes the Drinfeld double of the cyclic group of order 2.</p><p>In the second case <code>f</code> is already a struct Family.</p><p>The other (optional) arguments add information to the family defined by the first argument. If given, the second argument becomes <code>f.charNumbers</code>. If given,  the third argument  <code>opt</code> is a  <code>Dict</code> whose keys  are added to the resulting family.</p><p>If <code>opt</code> has a key <code>signs</code>, this should be a list of &#39;1&#39; and &#39;-1&#39;, and then the  Fourier matrix  is conjugated  by the  diagonal matrix of those signs. This  is used  in Spetses  to adjust  the matrix  to the choice of signs of unipotent degrees.</p><pre><code class="language-julia-repl hljs">julia&gt; Family(&quot;C2&quot;)
Family(C₂,4)
DrinfeldDouble(Z/2)
 label│eigen                   
──────┼─────────────────────────
(1,1) │    1 1/2  1/2  1/2  1/2
(g₂,1)│    1 1/2  1/2 -1/2 -1/2
(1,ε) │    1 1/2 -1/2  1/2 -1/2
(g₂,ε)│   -1 1/2 -1/2 -1/2  1/2

julia&gt; Family(&quot;C2&quot;,4:7,Dict(:signs=&gt;[1,-1,1,-1]))
Family(C₂,4:7)
DrinfeldDouble(Z/2)
 label│eigen signs                   
──────┼───────────────────────────────
(1,1) │    1     1  1/2 -1/2 1/2 -1/2
(g₂,1)│    1    -1 -1/2  1/2 1/2 -1/2
(1,ε) │    1     1  1/2  1/2 1/2  1/2
(g₂,ε)│   -1    -1 -1/2 -1/2 1/2  1/2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Families.jl#L88-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CyclotomicNumbers.galois-Tuple{Family, Int64}" href="#CyclotomicNumbers.galois-Tuple{Family, Int64}"><code>CyclotomicNumbers.galois</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>galois(f::Family,p::Int)</code></p><p><code>x-&gt;galois(x,p)</code>  is  applied  to  the  Fourier  matrix  and eigenvalues of Frobenius of the family.</p><pre><code class="language-julia-repl hljs">julia&gt; f=UnipotentCharacters(ComplexReflectionGroup(3,1,1)).families[2]
Family(0011,[4, 3, 2])
imprimitive family
label│eigen      1        2        3
─────┼───────────────────────────────
1    │  ζ₃²  √-3/3    √-3/3   -√-3/3
2    │    1  √-3/3 ζ₃²√-3/3 -ζ₃√-3/3
3    │    1 -√-3/3 -ζ₃√-3/3 ζ₃²√-3/3

julia&gt; galois(f,-1)
Family(overline 0011,[4, 3, 2])
ComplexConjugate(imprimitive family)
label│eigen      1        2        3
─────┼───────────────────────────────
1    │   ζ₃ -√-3/3   -√-3/3    √-3/3
2    │    1 -√-3/3 -ζ₃√-3/3 ζ₃²√-3/3
3    │    1  √-3/3 ζ₃²√-3/3 -ζ₃√-3/3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Families.jl#L224-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Families.fourier" href="#Gapjm.Families.fourier"><code>Gapjm.Families.fourier</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>fourier(uc::UnipotentCharacters)</code> the Lusztig Fourier matrix for <code>uc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Uch.jl#L726">source</a></section><section><div><p><code>fourier(f::Family</code>: returns the Fourier matrix for the family <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Families.jl#L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Families.drinfeld_double" href="#Gapjm.Families.drinfeld_double"><code>Gapjm.Families.drinfeld_double</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>drinfeld_double(g[,opt])</code></p><p>Given  a (usually small) finite group  <code>Γ</code>, Lusztig has associated a family (a  Fourier matrix, a list of eigenvalues of Frobenius) which describes the representation ring of the Drinfeld double of the group algebra of <code>Γ</code>, and for   some  appropriate  small  groups  describes  a  family  of  unipotent characters. We do not explain the details of this construction, but explain how its final result building Lusztig&#39;s Fourier matrix, and a variant of it that we use in Spetses, from <code>Γ</code>.</p><p>The  elements of the family are in bijection  with the set <code>𝓜 (Γ)</code> of pairs <code>(x,χ)</code>  taken up to  <code>Γ</code>-conjugacy, where <code>x∈Γ</code>  and <code>χ</code> is an irreducible complex-valued   character  of  <code>C_Γ(x)</code>.  To  such  a  pair  <code>ρ=(x,χ)</code>  is associated  an  eigenvalue  of  Frobenius  defined  by  <span>$ω_ρ:=χ(x)/χ(1)$</span>. Lusztig  then defines a Fourier matrix <code>S₀</code> whose coefficient is given, for <code>ρ=(x,χ)</code> and <code>ρ&#39;=(x&#39;, χ&#39;)</code>, by:</p><p><span>$S₀_{ρ,ρ&#39;}:=|C_Γ(x)⁻¹|∑_{ρ₁=(x₁,χ₁)}χ̄₁(x)χ(y₁)$</span></p><p>where  the sum is over all pairs <code>ρ₁∈𝓜 (Γ)</code> which are <code>Γ</code>-conjugate to <code>ρ&#39;</code> and  such that <span>$y₁∈ C_Γ(x)$</span>. This  coefficient also represents the scalar product <span>$⟨ρ,ρ&#39;⟩_{𝐆^F}$</span> of the corresponding unipotent characters.</p><p>A  way to  understand the  formula for  <span>$S₀_{ρ,ρ&#39;}$</span> better is to consider another  basis of the complex  vector space with basis  <code>𝓜 (Γ)</code>, indexed by the  pairs  <code>(x,y)</code>  taken  up  to  <code>Γ</code>-conjugacy,  where  <code>x</code>  and <code>y</code> are commuting  elements  of  <code>Γ</code>.  This  basis  is  called  the basis of Mellin transforms, and given by:</p><p><span>$(x,y)=∑_{χ∈ Irr(C_Γ(x))}χ(y)(x,χ)$</span></p><p>In  the  basis  of  Mellin  transforms,  the  linear  map  <code>S₀</code> is given by <code>(x,y)↦(x⁻¹,y⁻¹)</code>  and  the  linear  transformation  <code>T</code> which sends <code>ρ</code> to <code>ω_ρρ</code>   becomes  <code>(x,y)↦(x,xy)</code>.   These  are   particular  cases  of  the permutation  representation of <code>GL₂(ℤ)</code>  on the basis  of Mellin transforms where <span>$\begin{pmatrix}a&amp;b\cr c&amp;d\end{pmatrix}$</span> acts by <code>(x,y)↦(xᵃyᵇ,xᶜyᵈ)</code>.</p><p>Fourier  matrices in finite reductive groups  are given by the above matrix <code>S₀</code>.  But for non-rational Spetses, we use a different matrix <code>S</code> which in the  basis of Mellin transforms  is given by <code>(x,y)↦(y⁻¹,x)</code>. Equivalently, the formula <span>$S_{ρ,ρ&#39;}$</span> differs from the formula for <span>$S₀_{ρ,ρ&#39;}$</span> in that there  is no complex conjugation  of <code>χ₁</code>; thus the  matrix <code>S</code> is equal to <code>S₀</code> multiplied on the right by the permutation matrix which corresponds to <code>(x,χ)↦(x,χ̄)</code>.  The advantage of the matrix <code>S</code> over <code>S₀</code> is that the pair <code>S,T</code>  satisfies directly the axioms for a fusion algebra (see below); also the matrix <code>S</code> is symmetric, while <code>S₀</code> is Hermitian.</p><p>Thus there are two variants of &#39;drinfeld_double`:</p><p><code>drinfeld_double(g,lu=true)</code></p><p>returns  a family  containing Lusztig&#39;s  Fourier matrix  <code>S₀</code>, and an extra field  &#39;.perm&#39;  containing  the  permutation  of  the  indices  induced  by <code>(x,χ)↦(x,χ̄)</code>,  which allows  to recover  <code>S</code>, as  well as  an extra field `:lusztig&#39;, set to &#39;true&#39;.</p><p><code>drinfeld_double(g)</code></p><p>returns a family with the matrix <code>S</code>, which does not have fields &#39;.lusztig&#39; or &#39;.perm&#39;.</p><p>The family record &#39;f&#39; returned also has the fields:</p><p><code>:group</code>: the group <code>Γ</code>.</p><p><code>:charLabels</code>: a list of labels describing the pairs <code>(x,χ)</code>, and thus also specifying in which order they are taken.</p><p><code>:fourierMat</code>: the Fourier matrix (the matrix <code>S</code> or <code>S₀</code> depending on the call).</p><p><code>:eigenvalues</code>: the eigenvalues of Frobenius.</p><p><code>:xy</code>: a list of pairs &#39;[x,y]&#39; which are representatives of the <code>Γ</code>-orbits of pairs of commuting elements.</p><p><code>:mellinLabels</code>: a list of labels describing the pairs &#39;[x,y]&#39;.</p><p><code>:mellin</code>:  the base change matrix between  the basis <code>(x,χ)</code> and the basis of   Mellin  transforms,   so  that   |f.fourierMat^(f.mellin^-1)|  is  the permutation  matrix (for <code>(x,y)↦(y⁻¹,x)</code>  or <code>(x,y)↦(y⁻¹,x⁻¹)</code> depending on the call).</p><p><code>:special</code>: the index of the special element, which is <code>(x,χ)=(1,1)</code>.</p><pre><code class="language-julia-rep1 hljs">julia&gt; drinfeld_double(CoxSym(3))
Family(D(CoxSym(3)):8)
   label│eigen                                       
────────┼─────────────────────────────────────────────
(1,X.1) │    1  1/6  1/3 1/6 -3/2 -3/2  1/3  1/3  1/3
(1,X.2) │    1  1/3  2/3 1/3    0    0 -1/3 -1/3 -1/3
(1,1)   │    1  1/6  1/3 1/6  3/2  3/2  1/3  1/3  1/3
(2a,X.1)│   -1 -1/6    0 1/6  1/2 -1/2    0    0    0
(2a,1)  │    1 -1/6    0 1/6 -1/2  1/2    0    0    0
(3a,1)  │    1  1/3 -1/3 1/3    0    0  2/3 -1/3 -1/3
(3a,X.2)│  ζ₃²  1/3 -1/3 1/3    0    0 -1/3 -1/3  2/3
(3a,X.3)│   ζ₃  1/3 -1/3 1/3    0    0 -1/3  2/3 -1/3

julia&gt; drinfeld_double(CoxSym(3);lu=true)
Family(LD(CoxSym(3)):8)
   label│eigen                                       
────────┼─────────────────────────────────────────────
(1,X.1) │    1  1/6  1/3 1/6 -3/2 -3/2  1/3  1/3  1/3
(1,X.2) │    1  1/3  2/3 1/3    0    0 -1/3 -1/3 -1/3
(1,1)   │    1  1/6  1/3 1/6  3/2  3/2  1/3  1/3  1/3
(2a,X.1)│   -1 -1/6    0 1/6  1/2 -1/2    0    0    0
(2a,1)  │    1 -1/6    0 1/6 -1/2  1/2    0    0    0
(3a,1)  │    1  1/3 -1/3 1/3    0    0  2/3 -1/3 -1/3
(3a,X.2)│  ζ₃²  1/3 -1/3 1/3    0    0 -1/3  2/3 -1/3
(3a,X.3)│   ζ₃  1/3 -1/3 1/3    0    0 -1/3 -1/3  2/3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Families.jl#L515-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Families.ndrinfeld_double" href="#Gapjm.Families.ndrinfeld_double"><code>Gapjm.Families.ndrinfeld_double</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>ndrinfeld_double(g)</code></p><p>This  function returns the number of elements that the family associated to the  Drinfeld double of the group <code>g</code> would have, without computing it. The evident advantage is the speed.</p><pre><code class="language-julia-repl hljs">julia&gt; Families.ndrinfeld_double(ComplexReflectionGroup(5))
378</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Families.jl#L688-L699">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Families.family_imprimitive" href="#Gapjm.Families.family_imprimitive"><code>Gapjm.Families.family_imprimitive</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>family_imprimitive(S)</code></p><p><code>S</code> should be a symbol for a unipotent characters of an imprimitive complex reflection  group &#39;G(e,1,n)&#39; or &#39;G(e,e,n)&#39;. The function returns the family containing <code>S</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; family_imprimitive([[0,1],[1],[0]])
Family(0011,3)
imprimitive family
label│eigen      1        2        3
─────┼───────────────────────────────
1    │  ζ₃²  √-3/3   -√-3/3    √-3/3
2    │    1 -√-3/3 ζ₃²√-3/3 -ζ₃√-3/3
3    │    1  √-3/3 -ζ₃√-3/3 ζ₃²√-3/3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Families.jl#L702-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Families.FamiliesClassical" href="#Gapjm.Families.FamiliesClassical"><code>Gapjm.Families.FamiliesClassical</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>FamiliesClassical(l)</code></p><p>The  list  <code>l</code>  should  be  a  list  of symbols as returned by the function <code>symbols</code>,  which classify the unipotent characters of groups of type <code>:B</code>, <code>:C</code>  or <code>:D</code>. <code>FamiliesClassical</code> returns  the list of families determined by these symbols.</p><pre><code class="language-julia-repl hljs">julia&gt; FamiliesClassical(symbols(2,3,1))
6-element Vector{Family}:
 Family(112,[2])
 Family(022,[6])
 Family(3,[9])
 Family(01123,[1, 3, 8, 11])
 Family(0112233,[4])
 Family(013,[5, 7, 10, 12])</code></pre><p>The  above example shows the families of unipotent characters for the group <code>B_3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Families.jl#L820-L840">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Family, Family}" href="#Base.:*-Tuple{Family, Family}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>&lt;f&gt;*&lt;g&gt;</code>:  returns the  tensor product  of two  families &lt;f&gt; and &lt;g&gt;; the Fourier  matrix is the Kronecker  product of the matrices  for &lt;f&gt; and &lt;g&gt;, and the eigenvalues of Frobenius are the pairwise products.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Families.jl#L183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Families.fusion_algebra" href="#Gapjm.Families.fusion_algebra"><code>Gapjm.Families.fusion_algebra</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`fusion_algebra(f::Family)`
`fusion_algebra(S,special=1)`</code></pre><p>All  the Fourier matrices <code>S</code> in Chevie are unitary, that is <code>S⁻¹=conj(S)</code>, and  have a  <em>special</em> line  <code>s</code> (the  line of  index <code>s=special(f)</code>  for a family  <code>f</code>) such that no entry <code>Sₛ,ᵢ</code>  is equal to <code>0</code>. Further, they have the  property that  the sums  <code>Cᵢ,ⱼ,ₖ=sumₗ Sᵢ,ₗ  Sⱼ,ₗ conj(Sₖ,ₗ)/Sₛ,ₗ</code> take integral  values. Finally,  <code>S</code> has  the property  that complex conjugation does a permutation with signs <code>σ</code> of the lines of <code>S</code>.</p><p>It  follows that we can define a <code>Z</code>-algebra <code>A</code> as follows: it has a basis <code>bᵢ</code>  indexed by the lines of <code>S</code>,  and has a multiplication defined by the fact that the coefficient of <code>bᵢbⱼ</code> on <code>bₖ</code> is equal to <code>Cᵢ,ⱼ,ₖ</code>.</p><p><code>A</code>  is commutative, and has as unit  the element <code>bₛ</code>; the basis σ(bᵢ)<code>is</code>dual to <code>bᵢ</code> for the linear form (bᵢ,bⱼ)=Cᵢ,ⱼ,σ₍ₛ₎`.</p><pre><code class="language-julia-repl hljs">julia&gt; W=ComplexReflectionGroup(4)
G₄

julia&gt; uc=UnipotentCharacters(W);f=uc.families[4];

julia&gt; A=fusion_algebra(fourier(f),1)
Fusion Algebra dim.5

julia&gt; b=basis(A)
5-element Vector{AlgebraElt{Gapjm.Families.FusionAlgebra, Int64}}:
 B₁
 B₂
 B₃
 B₄
 B₅

julia&gt; b*permutedims(b)
5×5 Matrix{AlgebraElt{Gapjm.Families.FusionAlgebra, Int64}}:
 B₁  B₂      B₃      B₄        B₅
 B₂  -B₄+B₅  B₁+B₄   B₂-B₃     B₃
 B₃  B₁+B₄   -B₄+B₅  -B₂+B₃    B₂
 B₄  B₂-B₃   -B₂+B₃  B₁+B₄-B₅  -B₄
 B₅  B₃      B₂      -B₄       B₁

julia&gt; CharTable(A)
CharTable(Fusion Algebra dim.5)
 │1    2    3  4  5
─┼──────────────────
1│1  √-3 -√-3  2 -1
2│1    1    1  .  1
3│1   -1   -1  .  1
4│1    .    . -1 -1
5│1 -√-3  √-3  2 -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Families.jl#L936-L989">source</a></section></article><h1 id="d-Harish-Chandra-series"><a class="docs-heading-anchor" href="#d-Harish-Chandra-series">d-Harish-Chandra series</a><a id="d-Harish-Chandra-series-1"></a><a class="docs-heading-anchor-permalink" href="#d-Harish-Chandra-series" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.dSeries" href="#Gapjm.dSeries"><code>Gapjm.dSeries</code></a> — <span class="docstring-category">Module</span></header><section><div><p><code>d</code>-Harish-Chandra   series  describe  unipotent  <code>l</code>-blocks  of  a  finite reductive  group <span>$𝐆(𝔽_q)$</span> for <span>$l|Φ_d(q)$</span> (at least, when <code>l</code> is not too small which means mostly not a bad prime for <code>𝐆</code>). Some of the facts stated below  are still partly conjectural, we do not try to distinguish precisely what has been established and what is still conjectural.</p><p>If  <code>(𝐋,λ)</code> is  a <code>d</code>-cuspidal  pair then  the constituents  of the Lusztig induced  <span>$R_𝐋^𝐆(λ)$</span> are called a <code>d</code>-Harish-Chandra series; they form the unipotent part of an <code>l</code>-block of <span>$𝐆^F$</span>. It is conjectured (and proven in some   cases)  that  the  <span>$𝐆^F$</span>-endomorphism   algebra  of  the  <code>l</code>-adic cohomology  of the  variety <code>𝐗</code>  which defines  the Lusztig  induction is a <code>d</code>-cyclotomic Hecke algebra <span>$H_𝐆(𝐋,λ)$</span> for the group <span>$W_𝐆(𝐋,λ):=N_𝐆(𝐋,λ)/𝐋$</span>,  which  is  a  complex  reflection group –- here <code>d</code>-cyclotomic  means that the parameters  of <span>$H_𝐆(𝐋,λ)$</span> are monomials in <code>q</code>  and that <span>$H_𝐆(𝐋,λ)$</span>  specializes to the  algebra of <span>$W_𝐆(𝐋,λ)$</span> for <span>$q↦ζ_d$</span>.</p><p>It  follows that the decomposition of the  Lusztig induction is of the form <span>$R_𝐋^𝐆(λ)=∑_{ϕ∈Irr(W_𝐆(𝐋,λ))}(-1)^{nᵩ} ϕ(1)γᵩ,$</span> where <code>γᵩ</code> is a unipotent character   of  <code>𝐆^F</code>  attached  to  <code>ϕ</code>  and  where  <code>nᵩ</code>  is  the  degree <span>$H^{nᵩ}_c(𝐗)$</span>  where  <code>γᵩ</code>  occurss;  and  further  for  any  <code>ϕ</code> we have <span>$R_𝐋^𝐆(λ)(1)=  (-1)^{nᵩ} γᵩ(1)Sᵩ$</span> where <code>Sᵩ</code> is  the Schur element of the character  of  <span>$H_𝐆(𝐋,λ)$</span>  which  deforms  to  <code>ϕ</code>. The function |Series| allows to explore a <code>d</code>-Harish-Chandra series.</p><pre><code class="language-julia-repl hljs">julia&gt; W=rootdatum(&quot;3D4&quot;)
³D₄

julia&gt; l=cuspidal_data(W,3)
2-element Vector{NamedTuple{(:levi, :cuspidal, :d), Tuple{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}, Int64, Root1}}}:
 (levi = ³D₄, cuspidal = 8, d = ζ₃)
 (levi = ³D₄₍₎=Φ₃², cuspidal = 1, d = ζ₃)

julia&gt; Series(W,l[2]...)
ζ₃-series R^³D₄_{³D₄₍₎=Φ₃²}(λ==Id)  H_G(L,λ)==hecke(G₄,Vector{Mvp{Cyc{Int64}, Int64}}[[ζ₃q², ζ₃, ζ₃q]])
 │    γᵩ    φ  ε family #
─┼────────────────────────
1│  φ₁‚₀ φ₁‚₀  1        1
2│  φ₁‚₆ φ₁‚₄  1        2
3│  φ₂‚₂ φ₁‚₈ -1        5
6│ φ″₁‚₃ φ₂‚₅  1        4
5│ φ′₁‚₃ φ₂‚₃ -1        3
7│  φ₂‚₁ φ₂‚₁ -1        5
4│³D₄[1] φ₃‚₂  1        5</code></pre><p>Above  we explore the 3-series corresponding  to <span>$R_𝐓^𝐆(Id)$</span> where <code>𝐆</code> is the  triality group  and <code>𝐓</code>  is the  torus of  type <code>(q²+q+1)²</code>. The group <span>$W_𝐆(𝐓)$</span>  is the complex reflection group <code>G₄</code>. The displays shows in the column   &#39;γᵩ&#39;  the  name  of   the  unipotent  characters  constituents  of <span>$R_𝐓^𝐆(Id)$</span>,  and in the  first column the  number of these characters in the  list  of  unipotent  characters.  In  the  column  &#39;φ&#39; the name of the character  of <span>$W_𝐆(𝐓)$</span> corresponding  to the unipotent  character <code>γᵩ</code> is shown;  in the column  &#39;ε&#39; we show  the sign <span>$(-1)^{nᵩ}$</span>.  Finally in the last column we show in which family of unipotent characters is <code>γᵩ</code>.</p><p>The theory of <code>d</code>-Harish-Chandra series can be generalized to spetsial complex reflection groups using some axioms. We show below an example.</p><pre><code class="language-julia-repl hljs">julia&gt; W=ComplexReflectionGroup(4)
G₄

julia&gt; l=cuspidal_data(W,3)
5-element Vector{NamedTuple{(:levi, :cuspidal, :d), Tuple{Spets{PRSG{Cyc{Rational{Int64}}, Int16}}, Int64, Root1}}}:
 (levi = G₄, cuspidal = 3, d = ζ₃)
 (levi = G₄, cuspidal = 6, d = ζ₃)
 (levi = G₄, cuspidal = 7, d = ζ₃)
 (levi = G₄, cuspidal = 10, d = ζ₃)
 (levi = G₄₍₎=Φ₁Φ′₃, cuspidal = 1, d = ζ₃)

julia&gt; Series(W,l[5]...)
ζ₃-series R^G₄_{G₄₍₎=Φ₁Φ′₃}(λ==Id)  W_G(L,λ)==Z₆
 │   γᵩ φ(mod 3)  ε parameter family #
─┼─────────────────────────────────────
1│ φ₁‚₀        1  1      ζ₃q²        1
5│ φ₂‚₃       ζ₆  1      -ζ₃q        2
2│ φ₁‚₄       ζ₃ -1        ζ₃        4
8│ Z₃:2       -1 -1     -ζ₃²q        2
9│Z₃:11      ζ₃² -1       ζ₃²        4
4│ φ₂‚₅      ζ₆⁵ -1       -ζ₃        4</code></pre><p>Above  we explore the <code>3</code>-series corresponding  to the trivial character of the  torus of type <code>(q-1)(q-ζ₃)</code>. For cyclic groups <span>$W_𝐆(𝐋,λ)$</span> we display the  parameters in  the table  since they  are associated  to characters of <span>$W_𝐆(𝐋,λ)$</span>. Finally the mention &#39;(mod 3)&#39; which appears in the &#39;φ&#39; column means that in this case the axioms leave an ambiguity in the correspondence between  unipotent  characters  <code>γᵩ</code>  and  characters  <code>ϕ</code> (as well as with parameters):  the correspondence is known only up to a translation by 3 (in this case, the same as a global multiplication of all <code>ϕ</code> by <code>-1</code>).</p><p>Finally,  we should note that  if the reflection group  or coset <code>W</code> is not defined  over the integers,  what counts is  not cyclotomic polynomials but factors  of them  over the  field of  definition of  <code>W</code>. In this case, one should not give as argument an integer <code>d</code> representing <span>$ζ_d$</span> but specify a  root of unity. For instance, in the above case we get a different answer with:</p><pre><code class="language-julia-repl hljs">julia&gt; cuspidal_data(W,E(3,2))
5-element Vector{NamedTuple{(:levi, :cuspidal, :d), Tuple{Spets{PRSG{Cyc{Rational{Int64}}, Int16}}, Int64, Root1}}}:
 (levi = G₄, cuspidal = 2, d = ζ₃²)
 (levi = G₄, cuspidal = 5, d = ζ₃²)
 (levi = G₄, cuspidal = 7, d = ζ₃²)
 (levi = G₄, cuspidal = 10, d = ζ₃²)
 (levi = G₄₍₎=Φ₁Φ″₃, cuspidal = 1, d = ζ₃²)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/dSeries.jl#L1-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.cuspidal_data" href="#Gapjm.Uch.cuspidal_data"><code>Gapjm.Uch.cuspidal_data</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>cuspidal_data(W[,d[,ad]];proper=false,all=false)</code></p><p>returns  named tuples <code>(levi=LF,cuspidal=λ,d=d)</code> where  <code>LF</code> is a <code>d</code>-split Levi  (with <code>d</code>-center  of dimension  <code>ad</code> if  <code>ad</code> is  given) and <code>λ</code> is a <code>d</code>-cuspidal  character of  <code>LF</code>. If  <code>d=1</code> this  returns ordinary cuspidal characters.  The  character  <code>λ</code>  is  given  as  its  index  in the list of unipotent  characters. If <code>d</code> was given as  an integer, it is returned as a <code>Root1</code> representing <code>E(d)</code>.</p><p>If  the keyword  <code>proper=true</code> is  given, only  the data  where <code>LF!=W</code> (or equivalently <code>ad&gt;0</code>) are returned.</p><p>If  <code>d</code> is omitted, data  for all <code>d</code> orders  of eigenvalues of elements of <code>W</code>  is returned. If in addition  the keyword argument <code>all=true</code> is given, data for all eigenvalues of elements of <code>W</code> is returned.</p><pre><code class="language-julia-repl hljs">julia&gt; cuspidal_data(coxgroup(:F,4),1)
9-element Vector{NamedTuple{(:levi, :cuspidal, :d), Tuple{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}, Int64, Root1}}}:
 (levi = F₄, cuspidal = 31, d = 1)
 (levi = F₄, cuspidal = 32, d = 1)
 (levi = F₄, cuspidal = 33, d = 1)
 (levi = F₄, cuspidal = 34, d = 1)
 (levi = F₄, cuspidal = 35, d = 1)
 (levi = F₄, cuspidal = 36, d = 1)
 (levi = F₄, cuspidal = 37, d = 1)
 (levi = F₄₍₃₂₎=B₂₍₂₁₎Φ₁², cuspidal = 6, d = 1)
 (levi = F₄₍₎=Φ₁⁴, cuspidal = 1, d = 1)

julia&gt; cuspidal_data(ComplexReflectionGroup(4),3)
5-element Vector{NamedTuple{(:levi, :cuspidal, :d), Tuple{Spets{PRSG{Cyc{Rational{Int64}}, Int16}}, Int64, Root1}}}:
 (levi = G₄, cuspidal = 3, d = ζ₃)
 (levi = G₄, cuspidal = 6, d = ζ₃)
 (levi = G₄, cuspidal = 7, d = ζ₃)
 (levi = G₄, cuspidal = 10, d = ζ₃)
 (levi = G₄₍₎=Φ₁Φ′₃, cuspidal = 1, d = ζ₃)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Uch.jl#L1308-L1346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.dSeries.Series" href="#Gapjm.dSeries.Series"><code>Gapjm.dSeries.Series</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Series(W, L, cuspidal, d)</code></p><p>If the reflection coset or group <code>W</code> corresponds to the algebraic group <code>𝐆</code> and  <code>cuspidal</code>  to  the  <code>d</code>-cuspidal  unipotent  character  <code>λ</code>  of  <code>𝐋</code>, constructs  the <code>d</code>-series corresponding to <span>$R_𝐋^𝐆(λ)$</span>. The result <code>s</code> it is a record with the following fields and functions:</p><p><code>s.spets</code>: the reflection group or coset <code>W</code>.</p><p><code>s.levi</code>: the subcoset <code>L</code>.</p><p><code>s.cuspidal</code>: the index of <code>λ</code> in <code>UnipotentCharacters(L)</code>.</p><p><code>s.d</code>: the value of <code>d</code> (a <code>Root1</code>).</p><p><code>relative_group(s)</code>: the group <span>$W_𝐆(𝐋,λ)$</span>.</p><p><code>dSeries.RLG(s)</code>: the <code>UnipotentCharacter</code> given by <span>$R_𝐋^𝐆(λ)$</span>.</p><p><code>dSeries.eps(s)</code>:  for each  character <code>φ</code>  of <code>relative_group(s)</code> the sign <span>$(-1)^{n_φ}$</span>  in the cohomology  of the variety  defining <code>RLG(s)</code> of the corresponding constituent <code>γᵩ</code> of <code>RLG(s)</code>.</p><p><code>degree(s)</code>: the generic degree of <code>RLG(s)</code>, as a <code>CycPol</code>.</p><p><code>dSeries.char_numbers(s)</code>:  the indices in  <code>UnipotentCharacters(W)</code> of the constituents of <code>RLG(s)</code>.</p><p><code>hecke(s)</code>: the hecke algebra <span>$H_𝐆(𝐋,λ)$</span>.</p><p>The function <code>Series</code> has another form:</p><p><code>Series(&lt;W&gt; [,&lt;d&gt; [,&lt;ad&gt;]];k...)</code></p><p>where  it returns a  vector of <code>Series</code>  corresponding to the cuspidal data described   by  the   arguments  and   the  keywords   (see  the  help  for <code>cuspidal_data</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; W=ComplexReflectionGroup(4)
G₄

julia&gt; Series(W,3;proper=true)
1-element Vector{Series}:
 ζ₃-series R^G₄_{G₄₍₎=Φ₁Φ′₃}(λ==Id)  W_G(L,λ)==Z₆

julia&gt; s=Series(W,3,1)[1]
ζ₃-series R^G₄_{G₄₍₎=Φ₁Φ′₃}(λ==Id)  W_G(L,λ)==Z₆
 │   γᵩ φ(mod 3)  ε parameter family #
─┼─────────────────────────────────────
1│ φ₁‚₀        1  1      ζ₃q²        1
5│ φ₂‚₃       ζ₆  1      -ζ₃q        2
2│ φ₁‚₄       ζ₃ -1        ζ₃        4
8│ Z₃:2       -1 -1     -ζ₃²q        2
9│Z₃:11      ζ₃² -1       ζ₃²        4
4│ φ₂‚₅      ζ₆⁵ -1       -ζ₃        4

julia&gt; s.spets
G₄

julia&gt; s.levi
G₄₍₎=Φ₁Φ′₃

julia&gt; s.cuspidal
1

julia&gt; s.d
Root1: ζ₃

julia&gt; hecke(s)
hecke(G₆‚₁‚₁,Vector{Mvp{Cyc{Int64}, Int64}}[[ζ₃q², -ζ₃q, ζ₃, -ζ₃²q, ζ₃², -ζ₃]])

julia&gt; degree(s)
ζ₃Φ₁Φ₂²Φ″₃Φ₄Φ₆

julia&gt; dSeries.RLG(s)
[G₄]:&lt;φ₁‚₀&gt;-&lt;φ₁‚₄&gt;-&lt;φ₂‚₅&gt;+&lt;φ₂‚₃&gt;-&lt;Z₃:2&gt;-&lt;Z₃:11&gt;

julia&gt; dSeries.char_numbers(s)
6-element Vector{Int64}:
 1
 5
 2
 8
 9
 4

julia&gt; dSeries.eps(s)
6-element Vector{Int64}:
  1
  1
 -1
 -1
 -1
 -1

julia&gt; relative_group(s)
G₆‚₁‚₁</code></pre><p>julia-repl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/dSeries.jl#L449-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.dSeries.ennola" href="#Gapjm.dSeries.ennola"><code>Gapjm.dSeries.ennola</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>ennola(W)</code></p><p>Let  <code>W</code> be an irreducible spetsial reflection  group or coset, and <code>z</code> the generator  of the  center of  <code>W</code>, viewed  as a  root of  unity. A property checked case-by case is that, for a unipotent character <code>γ</code> with polynomial generic  degree <code>deg γ(q)</code>  of the spets  attached to <code>W</code>  (this spets is a finite  reductive group, for <code>W</code> a Weyl group, in which case <code>z=-1</code> if <code>-1</code> is  in <code>W</code>),  <code>deg γ(zq)</code>  is equal  to <code>±deg  γ&#39;(q)</code> for another unipotent character  <code>γ&#39;</code>; <code>±γ&#39;</code> is called the  Ennola transform of <code>γ</code>. The function returns  the  permutation-with-signs  done  by  <code>ennola</code>  on  the unipotent degrees (as a permutation-with signs of <code>1:length(UnipotentCharacters(W))</code>). The argument <code>W</code> must be irreducible.</p><p>The  permutation-with-signs is not uniquely determined by the degrees since two  of them may  be equal, but  is uniquely determined  by some additional axioms that we do not recall here.</p><pre><code class="language-julia-repl hljs">julia&gt; dSeries.ennola(rootdatum(&quot;3D4&quot;))
SPerm{Int64}: (3,-4)(5,-5)(6,-6)(7,-8)

julia&gt; dSeries.ennola(ComplexReflectionGroup(14))
SPerm{Int64}: (2,43,-14,16,41,34)(3,35,40,18,-11,42)(4,-37,25,-17,-26,-36)(5,-6,-79)(7,-7)(8,-74)(9,-73)(10,-52,13,31,-50,29)(12,53,15,32,-51,-30)(19,71,70,21,67,68,20,69,72)(22,-39,27,-33,-28,-38)(23,24,-66,-23,-24,66)(44,46,49,-44,-46,-49)(45,48,47,-45,-48,-47)(54,-63,-55,-57,62,-56)(58,-65,-59,-61,64,-60)(75,-77)(76,-76)(78,-78)
</code></pre><p>The  last example  shows that  it may  happen that  the order of <code>z</code>-Ennola (here 18) is greater than the order of <code>z</code> (here 6); this is related to the presence  of irrationalities in  the character table  of the spetsial Hecke algebra of <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/dSeries.jl#L182-L213">source</a></section></article><h1 id="Unipotent-classes-of-reductive-groups"><a class="docs-heading-anchor" href="#Unipotent-classes-of-reductive-groups">Unipotent classes of reductive groups</a><a id="Unipotent-classes-of-reductive-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Unipotent-classes-of-reductive-groups" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Ucl" href="#Gapjm.Ucl"><code>Gapjm.Ucl</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This  module gives information  about the unipotent  conjugacy classes of a connected  reductive  group  over  an  algebraically  closed field <code>k</code>, and various  invariants attached to  them. The unipotent  classes depend on the characteristic of <code>k</code>; their classification differs when the characteristic is  not <em>good</em>  (that is,  when it  divides one  of the coefficients of the highest  root).  In  good  characteristic,  the  unipotent  classes  are in bijection with nilpotent orbits on the Lie algebra.</p><p>We  give  the  following  information  for  a unipotent element <code>u</code> of each class:</p><ul><li><p>the centralizer <span>$C_𝐆 (u)$</span>, that we describe by the reductive part of <span>$C_𝐆  (u)^0$</span>, by the  group of components  <span>$A(u):=C_𝐆 (u)/C_𝐆 (u)^0$</span>, and by the dimension of its radical.</p></li><li><p>in good characteristic, the  Dynkin-Richardson  diagram.</p></li><li><p>the Springer correspondence,  attaching characters of  the Weyl group or relative Weyl groups to each character of <code>A(u)</code>.</p></li></ul><p>The  Dynkin-Richarson diagram is attached to a nilpotent element <code>e</code> of the Lie  algebra <code>𝔤</code>.  By the  Jacobson-Morozov theorem  there exists an <code>𝔰𝔩₂</code> subalgebra of <code>𝔤</code> containing <code>e</code> as the element <span>$\begin{pmatrix}1&amp;0\\0&amp;1 \end{pmatrix}$</span>. Let <code>𝐒</code> be the torus <span>$\begin{pmatrix}h&amp;0\\0&amp;h^{-1} \end{pmatrix}$</span> of <code>SL₂</code> and let <code>𝐓</code> be a maximal  torus containing <code>𝐒</code>, so that <code>𝐒</code>  is the image of a one-parameter subgroup  <code>σ∈ Y(𝐓)</code>. Consider the root decomposition <span>$𝔤=∑_{α∈Σ}𝔤_α$</span> given by  <code>𝐓</code>; then  <code>α↦⟨σ,α⟩</code> defines  a linear  form on  <code>Σ</code>, determined by its value  on simple roots. It  is possible to choose  a system of simple roots <code>Π</code>  so that <code>⟨σ,α⟩≥ 0</code> for <code>α∈Π</code>,  and then <code>⟨σ,α⟩∈{0,1,2}</code> for any <code>α∈Π</code>. The  Dynkin diagram of <code>Π</code> decorated by  these values <code>0,1,2</code> is called the Dynkin-Richardson  diagram of <code>e</code>, and in good characteristic is a complete invariant of its <code>𝔤</code>-orbit.</p><p>Let  <code>𝓑</code>  be  the  variety  of  all  Borel  subgroups  and  let <code>𝓑ᵤ</code> be the subvariety  of Borel subgroups  containing the unipotent  element <code>u</code>. Then <code>dim C_𝐆(u)=rank 𝐆 + 2 dim 𝓑_u</code> and in good characteristic this dimension can  be computed from  the Dynkin-Richardson diagram:  the dimension of the class of <code>u</code> is the number of roots <code>α</code> such that <code>⟨σ,α⟩∉{0,1}</code>.</p><p>We   describe  now  the  Springer  correspondence.  Indecomposable  locally constant  <code>𝐆</code>-equivariant  sheaves  on  <code>C</code>,  called  <em>local  systems</em>, are parameterized  by irreducible characters of <code>A(u)</code>. The <em>ordinary</em> Springer correspondence  is a bijection  between irreducible characters  of the Weyl group  and a large subset  of the local systems  which contains all trivial local  systems (those parameterized by the  trivial character of <code>A(u)</code> for each  <code>u</code>).  More  generally,  the  <em>generalized</em>  Springer  correspondence associates  to each local  system a (unique  up to <code>𝐆</code>-conjugacy) <em>cuspidal pair</em>  of a Levi  subgroup <code>𝐋</code> of  <code>𝐆</code> and a  <code>cuspidal</code> local system on an unipotent  class of <code>𝐋</code>, such that the set of local systems associated to a given cuspidal pair is parameterized by the characters of the relative Weyl group <span>$W_𝐆 (𝐋):=N_𝐆 (𝐋)/𝐋$</span>. There are only few cuspidal pairs.</p><p>The  Springer correspondence gives information on the character values of a finite  reductive  groups  as  follows:  assume  that  <code>k</code> is the algebraic closure of a finite field <span>$𝔽_q$</span> and that <code>F</code> is the Frobenius attached to an  <span>$𝔽_q$</span>-structure of <code>𝐆</code>. Let <code>C</code>  be an <code>F</code>-stable unipotent class and let  <span>$u∈ C^F$</span>;  we  call  <code>C</code>  the  <em>geometric  class</em>  of  <code>u</code>  and the <span>$𝐆^F$</span>-classes  inside  <span>$C^F$</span>  are  parameterized  by  the <code>F</code>-conjugacy classes  of <code>A(u)</code>, denoted <code>H¹(F,A(u))</code> (most of  the time we can find <code>u</code> such  that <code>F</code> acts trivially  on <code>A(u)</code> and <code>H¹(F,A(u))</code>  is then just the conjugacy  classes). To an <code>F</code>-stable character  <code>φ</code> of <code>A(u)</code> we associate the  <em>characteristic function</em> of the  corresponding local system (actually associated to an extension <code>φ̃</code> of <code>φ</code> to <code>A(u).F</code>); it is a class function <span>$Y_{u,φ}$</span> on <span>$𝐆^F$</span> which can be normalized so that: <span>$Y_{u,φ}(u₁)=φ̃(cF)$</span>  if <code>u₁</code> is  geometrically conjugate to  <code>u</code> and its <span>$𝐆^F$</span>-class  is parameterized by the  <code>F</code>-conjugacy class <code>cF</code> of <code>A(u)</code>, otherwise <span>$Y_{u,φ}(u₁)=0$</span>. If the pair <code>u,φ</code> corresponds via the Springer correspondence to the character <code>χ</code> of <span>$W_𝐆(𝐋)$</span>, then <span>$Y_{u,φ}$</span> is also denoted  <code>Yᵪ</code>. There  is another  important class  of functions  indexed by local  systems: to a local system on  class <code>C</code> is attached an intersection cohomology  complex, which is a complex of sheaves supported on the closure <code>C̄</code>.  To  such  a  complex  of  sheaves  is associated its <em>characteristic function</em>,  a class function of <span>$𝐆^F$</span>  obtained by taking the alternating trace  of the Frobenius acting on the  stalks of the cohomology sheaves. If <span>$Y_ψ$</span>   is   the   characteristic   function   of  a  local  system,  the characteristic   function  of  the  corresponding  intersection  cohomology complex  is denoted  by <span>$X_ψ$</span>.  This function  is supported  on <code>C̄</code>, and Lusztig  has shown that <span>$X_ψ=∑ᵩ P_{ψ,χ} Yᵪ$</span> where <span>$P_{ψ,χ}$</span> are integer polynomials  in <code>q</code> and <code>Yᵪ</code> are attached to local systems on classes lying in <code>C̄</code>.</p><p>Lusztig   and  Shoji  have  given  an   algorithm  to  compute  the  matrix <span>$P_{ψ,χ}$</span>,   which  is  implemented  in  Chevie.  The  relationship  with characters   of  <span>$𝐆(𝔽_q)$</span>,  taking  to  simplify  the  ordinary  Springer correspondence,  is that the  restriction to the  unipotent elements of the almost  character <span>$R_χ$</span> is equal to <span>$q^{bᵪ} Xᵪ$</span>, where <code>bᵪ</code> is <code>dim 𝓑ᵤ</code> for  an element <code>u</code> of the class <code>C</code>  such that the support of <code>χ</code> is <code>C̄</code>. The restriction of the Deligne-Lusztig characters <span>$R_w$</span> to the unipotents are  called the <em>Green functions</em>  and can also be  computed by Chevie. The values  of  all  unipotent  characters  on  unipotent  elements can also be computed  in principle by applying  Lusztig&#39;s Fourier transform matrix (see the  section on the Fourier  matrix) but there is  a difficulty in that the <code>Xᵪ</code> must be first multiplied by some roots of unity which are not known in all  cases (and when known may depend on the congruence class of <code>q</code> modulo some small primes).</p><p>We illustrate these computations on some examples:</p><pre><code class="language-julia-repl hljs">julia&gt; UnipotentClasses(rootdatum(:sl,4))
UnipotentClasses(sl₄)
1111&lt;211&lt;22&lt;31&lt;4
   u│D-R dBu B-C          C(u) A₃(A₃₍₎=Φ₁³) A₁(A₃₍₁₃₎=A₁×A₁Φ₁)/-1 .(A₃)/ζ₄
────┼──────────────────────────────────────────────────────────────────────
4   │222   0 222         q³.Z₄          1:4                  -1:2    ζ₄:Id
31  │202   1 22.    q⁴.A₁₍₎=Φ₁        Id:31                               
22  │020   2 2.2      q⁴.A₁.Z₂         2:22                 11:11         
211 │101   3 2.. q⁵.A₂₍₁₎=A₁Φ₁       Id:211                               
1111│000   6 ...            A₃      Id:1111

   u│.(A₃)/ζ₄³
────┼──────────
4   │   ζ₄³:Id
31  │         
22  │         
211 │         
1111│         
</code></pre><p>The  first column in the table gives the name of the unipotent class, which here  is  a  partition  describing  the  Jordan  form. The partial order on unipotent  classes given by Zariski closure  is given before the table. The column   &#39;D-R&#39;,   displayed   only   in   good  characteristic,  gives  the Dynkin-Richardson  diagram  for  each  class;  the  column  &#39;dBu&#39; gives the dimension  of  the  variety  <code>𝓑ᵤ</code>.  The  column &#39;B-C&#39; gives the Bala-Carter classification  of <code>u</code>, that is  in the case of  <code>sl₄</code> it displays <code>u</code> as a regular  unipotent  in  a  Levi  subgroup  by  giving the Dynkin-Richardson diagram  of a regular  unipotent (all 2&#39;s)  at entries corresponding to the Levi  and &#39;.&#39; at  entries which do  not correspond to  the Levi. The column &#39;C(u)&#39;  describes the  group <span>$C_𝐆(u)$</span>:  a power  <code>qᵈ</code> describes  that the unipotent  radical  of  <span>$C_𝐆(u)$</span>  has  dimension  <code>d</code> (thus <code>qᵈ</code> rational points);  then follows a  description of the  reductive part of the neutral component  of <span>$C_𝐆(u)$</span>,  given by  the name  of its  root datum.  Then if <span>$C_𝐆(u)$</span>  is  not  connected,  the  description  of <code>A(u)</code> is given using another  vocabulary: a  cyclic group  of order  4 is  given as  &#39;Z4&#39;, and a symmetric group on 3 points would be given as &#39;S3&#39;.</p><p>For  instance, the first class &#39;4&#39;  has <span>$C_𝐆(u)^0$</span> unipotent of dimension <code>3</code>  and <code>A(u)</code> equal to &#39;Z4&#39;, the cyclic  group of order 4. The class &#39;22&#39; has  <span>$C_G(u)$</span> with unipotent radical of  dimension <code>4</code>, reductive part of type  &#39;A1&#39; and  <code>A(u)</code> is  &#39;Z2&#39;, that  is the  cyclic group of order 2. The other  classes have <span>$C_𝐆(u)$</span> connected. For  the class &#39;31&#39; the reductive part of <span>$C_G(u)$</span> is a torus of rank 1.</p><p>Then  there is one column for each <em>Springer series</em>, giving for each class the pairs &#39;a:b&#39; where &#39;a&#39; is the name of the character of <code>A(u)</code> describing the  local system  involved and  &#39;b&#39; is  the name  of the  character of the (relative)  Weyl group corresponding by the Springer correspondence. At the top  of the column is  written the name of  the relative Weyl group, and in brackets  the name  of the  Levi affording  a cuspidal  local system; next, separated  by a <code>/</code> is a description of the central character associated to the  Springer series  (omitted if  this central  character is trivial): all local  systems  in  a  given  Springer  series have same restriction to the center of <code>𝐆</code>. To find what the picture becomes for another algebraic group in  the  same  isogeny  class,  for  instance the adjoint group, one simply discards the Springer series whose central character becomes trivial on the center  of <code>𝐆</code>; and  each group <code>A(u)</code>  has to be  quotiented by the common kernel  of  the  remaining  characters.  Here  is the table for the adjoint group:</p><pre><code class="language-julia-repl hljs">julia&gt; UnipotentClasses(coxgroup(:A,3))
UnipotentClasses(A₃)
1111&lt;211&lt;22&lt;31&lt;4
   u│D-R dBu B-C          C(u) A₃(A₃₍₎=Φ₁³)
────┼───────────────────────────────────────
4   │222   0 222            q³         Id:4
31  │202   1 22.    q⁴.A₁₍₎=Φ₁        Id:31
22  │020   2 2.2         q⁴.A₁        Id:22
211 │101   3 2.. q⁵.A₂₍₁₎=A₁Φ₁       Id:211
1111│000   6 ...            A₃      Id:1111</code></pre><p>Here is another example:</p><pre><code class="language-julia-repl hljs">julia&gt; UnipotentClasses(coxgroup(:G,2))
UnipotentClasses(G₂)
1&lt;A₁&lt;Ã₁&lt;G₂(a₁)&lt;G₂
     u│D-R dBu B-C  C(u)    G₂(G₂₍₎=Φ₁²)  .(G₂)
──────┼─────────────────────────────────────────
G₂    │ 22   0  22    q²         Id:φ₁‚₀       
G₂(a₁)│ 20   1  20 q⁴.S₃ 21:φ′₁‚₃ 3:φ₂‚₁ 111:Id
Ã₁    │ 01   2  .2 q³.A₁         Id:φ₂‚₂       
A₁    │ 10   3  2. q⁵.A₁        Id:φ″₁‚₃       
1     │ 00   6  ..    G₂         Id:φ₁‚₆       </code></pre><p>which illustrates that on class <code>G₂(a₁)</code> there are two local systems in the principal  series of  the Springer  correspondence, and  a further cuspidal local system. Also, from the &#39;B-C&#39; column, we see that that class is not in a  proper Levi,  in which  case the  Bala-Carter diagram coincides with the Dynkin-Richardson diagram.</p><p>The  characteristics 2 and  3 are not  good for &#39;G2&#39;.  To get the unipotent classes  and the Springer correspondence in bad characteristic, one gives a second argument to the function &#39;UnipotentClasses&#39;:</p><pre><code class="language-julia-repl hljs">julia&gt; UnipotentClasses(coxgroup(:G,2),3)
UnipotentClasses(G₂)
1&lt;A₁,(Ã₁)₃&lt;Ã₁&lt;G₂(a₁)&lt;G₂
     u│dBu B-C  C(u) G₂(G₂₍₎=Φ₁²) .(G₂) .(G₂)  .(G₂)
──────┼──────────────────────────────────────────────
G₂    │  0  22 q².Z₃       1:φ₁‚₀       ζ₃:Id ζ₃²:Id
G₂(a₁)│  1  20 q⁴.Z₂       2:φ₂‚₁ 11:Id             
Ã₁    │  2  .2    q⁶      Id:φ₂‚₂                   
A₁    │  3  2. q⁵.A₁     Id:φ″₁‚₃                   
(Ã₁)₃ │  3  ?? q⁵.A₁     Id:φ′₁‚₃                   
1     │  6  ..    G₂      Id:φ₁‚₆</code></pre><p>The  function &#39;ICCTable&#39; gives the  transition matrix between the functions <code>Xᵪ</code>  and <code>Y_ψ</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; uc=UnipotentClasses(coxgroup(:G,2));
julia&gt; t=ICCTable(uc)
Coefficients of Xᵪ on Yᵩ for G₂
      │G₂ G₂(a₁)⁽²¹⁾ G₂(a₁) Ã₁ A₁  1
──────┼──────────────────────────────
Xφ₁‚₀ │ 1          0      1  1  1  1
Xφ′₁‚₃│ 0          1      0  1  0 q²
Xφ₂‚₁ │ 0          0      1  1  1 Φ₈
Xφ₂‚₂ │ 0          0      0  1  1 Φ₄
Xφ″₁‚₃│ 0          0      0  0  1  1
Xφ₁‚₆ │ 0          0      0  0  0  1</code></pre><p>Here  the row labels  and the column  labels show the  two ways of indexing local  systems: the  row labels  give the  character of the relative Weyl group and the column labels give the class and the name of the local system as  a character  of <code>A(u)</code>:  for instance,  &#39;G2(a1)&#39; is the trivial local system  of the  class &#39;G2(a1)&#39;,  while &#39;G2(a1)(21)&#39;  is the local system on that class corresponding to the 2-dimensional character of <code>A(u)=A₂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Ucl.jl#L1-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Ucl.UnipotentClasses" href="#Gapjm.Ucl.UnipotentClasses"><code>Gapjm.Ucl.UnipotentClasses</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>UnipotentClasses(W[,p])</code></p><p><code>W</code>  should  be  a  <code>CoxeterGroup</code>  record  for a Weyl group or <code>RootDatum</code> describing a reductive algebraic group <code>𝐆</code>. The function returns a record containing   information   about   the   unipotent   classes  of  <code>𝐆</code>  in characteristic   <code>p</code>  (if   omitted,  <code>p</code>   is  assumed   to  be  any  good characteristic for <code>𝐆</code>). This contains the following fields:</p><p><code>group</code>: a pointer to <code>W</code></p><p><code>p</code>: the characteristic of the field for which the unipotent classes were computed. It is <code>0</code> for any good characteristic.</p><p><code>orderclasses</code>:  a list describing the Hasse diagram of the partial order induced   on   unipotent   classes   by   the  closure  relation.  That  is <code>.orderclasses[i]</code>  is the list of <code>j</code> such that <code>C̄ⱼ⊋ C̄ᵢ</code>  and  there  is no  class  <code>Cₖ</code>  such  that <code>C̄ⱼ⊋ C̄ₖ⊋ C̄ᵢ</code>.</p><p><code>classes</code>:  a  list  of  records  holding information for each unipotent class (see below).</p><p><code>springerseries</code>:  a list of records, each  of which describes a Springer series  of <code>𝐆</code>.</p><p>The  records  describing  individual  unipotent  classes have the following fields:</p><p><code>name</code>: the name of the unipotent class.</p><p><code>parameter</code>:  a parameter  describing the  class (for  example, a partition describing the Jordan form, for classical groups).</p><p><code>Au</code>: the group <code>A(u)</code>.</p><p><code>dynkin</code>:  present in good characteristic; contains the Dynkin-Richardson diagram,  given  as  a  list  of  0,1,2  describing  the coefficient on the corresponding simple root.</p><p><code>red</code>:  the reductive part of <span>$C_𝐆(u)$</span>.</p><p><code>dimBu</code>:  the dimension of the variety <code>𝓑ᵤ</code>.</p><p>The  records for classes contain additional  fields for certain groups: for instance,  the names given to classes by Mizuno in <code>E₆, E₇, E₈</code> or by Shoji in <code>F₄</code>.</p><p>The  records  describing  individual  Springer  series  have  the following fields:</p><p><code>levi</code>:the  indices of the  reflections corresponding to  the Levi subgroup <code>𝐋</code>  where  lives  the  cuspidal  local  system <code>ι</code> from which the Springer series is induced.</p><p><code>relgroup</code>: The relative Weyl group <span>$N_𝐆(𝐋,ι)/𝐋$</span>. The first series is the principal series for which <code>.levi=[]</code> and <code>.relgroup=W</code>.</p><p><code>locsys</code>:  a  list  of  length  <code>NrConjugacyClasses(.relgroup)</code>, holding in <code>i</code>-th  position a  pair describing  which local  system corresponds to the <code>i</code>-th  character of  <span>$N_𝐆(𝐋,ι)$</span>. The  first element  of the  pair is the index  of the concerned unipotent class <code>u</code>, and the second is the index of the corresponding character of <code>A(u)</code>.</p><p><code>Z</code>:  the central character associated  to the Springer series, specified by its value on the generators of the centre.</p><pre><code class="language-julia-repl hljs">julia&gt; W=rootdatum(:sl,4)
sl₄

julia&gt; uc=UnipotentClasses(W);

julia&gt; uc.classes
5-element Vector{Gapjm.Ucl.UnipotentClass}:
 UnipotentClass(1111)
 UnipotentClass(211)
 UnipotentClass(22)
 UnipotentClass(31)
 UnipotentClass(4)</code></pre><p>The  <code>show</code>  function  for  unipotent  classes  accepts  all the options of <code>formatTable</code>  and  of  <code>charnames</code>.  Giving  the  option  <code>mizuno</code>  (resp. <code>shoji</code>)  uses  the  names  given  by  Mizuno  (resp.  Shoji) for unipotent classes.  Moreover,  there  is  also  an  option  <code>fourier</code> which gives the correspondence  tensored  with  the  sign  character  of each relative Weyl group, which is the correspondence obtained via a Fourier-Deligne transform (here  we assume that  <code>p</code> is very  good, so that  there is a nondegenerate invariant  bilinear  form  on  the  Lie  algebra, and also one can identify nilpotent orbits with unipotent classes).</p><p>Here is how to display the non-cuspidal part of the Springer correspondence of  the unipotent  classes of  <code>E₆</code> using  the notations  of Mizuno for the classes  and those  of Frame  for the  characters of  the Weyl group and of Spaltenstein  for the characters  of <code>G₂</code> (this  is convenient for checking our data with the original paper of Spaltenstein):</p><pre><code class="language-julia-rep1 hljs">julia&gt; uc=UnipotentClasses(rootdatum(:E6sc));

julia&gt; xdisplay(uc;cols=[5,6,7],spaltenstein=true,frame=true,mizuno=true,
      order=false)
UnipotentClasses(E₆sc)
     u│            E₆(E₆₍₎) G₂(E₆₍₁₃₅₆₎=A₂×A₂)/ζ₃ G₂(E₆₍₁₃₅₆₎=A₂×A₂)/ζ₃²
──────┼──────────────────────────────────────────────────────────────────
E₆    │                1:1ₚ                  ζ₃:1                  ζ₃²:1
E₆(a₁)│                1:6ₚ                ζ₃:ε_c                ζ₃²:ε_c
D₅    │              Id:20ₚ
A₅+A₁ │        -1:15ₚ 1:30ₚ                 ζ₃:θ′                 ζ₃²:θ′
A₅    │              1:15_q                 ζ₃:θ″                 ζ₃²:θ″
D₅(a₁)│              Id:64ₚ
A₄+A₁ │              Id:60ₚ
D₄    │              Id:24ₚ
A₄    │              Id:81ₚ
D₄(a₁)│111:20ₛ 3:80ₛ 21:90ₛ
A₃+A₁ │              Id:60ₛ
2A₂+A₁│               1:10ₛ                 ζ₃:εₗ                 ζ₃²:εₗ
A₃    │             Id:81ₚ′
A₂+2A₁│             Id:60ₚ′
2A₂   │              1:24ₚ′                  ζ₃:ε                  ζ₃²:ε
A₂+A₁ │             Id:64ₚ′
A₂    │      11:15ₚ′ 2:30ₚ′
3A₁   │            Id:15_q′
2A₁   │             Id:20ₚ′
A₁    │              Id:6ₚ′
1     │              Id:1ₚ′</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Ucl.jl#L512-L639">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Ucl.ICCTable" href="#Gapjm.Ucl.ICCTable"><code>Gapjm.Ucl.ICCTable</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ICCTable(uc,seriesNo=1;q=Pol())</code></p><p>This function gives the table of decompositions of the functions <span>$X_ι$</span> in terms  of the functions <span>$Y_ι$</span>. Here <code>ι</code> is a <code>𝐆</code>-equivariant local system on  the  class  <code>C</code>  of  a  unipotent  element  <code>u</code>. Such a local system is parametrized  by the pair  <code>(u,ϕ)</code> of <code>u</code>  and a character  of the group of components   <code>A(u)</code>   of   <span>$C_𝐆   (u)$</span>.   The  function  <span>$Y_ι$</span>  is  the characteristic   function  of  this   local  system  and   <span>$X_ι$</span>  is  the characteristic   function  of  the  corresponding  intersection  cohomology complex  on <code>C̄</code>. The  Springer correspondence says  that the local systems can  also be  indexed by  characters of  a relative  Weyl group.  Since the coefficient of <code>Xᵪ</code> on <code>Yᵩ</code> is <code>0</code> if <code>χ</code> and <code>φ</code> are not characters of the same  relative Weyl group (are not in  the same Springer series), the table is  for one  Springer series,  specified by  the argument  &#39;seriesNo&#39; (this defaults  to &#39;seriesNo=1&#39; which is the principal series). The decomposition multiplicities  are graded,  and are  given as  polynomials in one variable (specified by the argument <code>q</code>; if not given <code>Pol()</code> is assumed).</p><pre><code class="language-julia-repl hljs">julia&gt; t=ICCTable(uc)
Coefficients of Xᵪ on Yᵩ for A₃
     │4 31 22 211 1111
─────┼─────────────────
X4   │1  1  1   1    1
X31  │0  1  1  Φ₂   Φ₃
X22  │0  0  1   1   Φ₄
X211 │0  0  0   1   Φ₃
X1111│0  0  0   0    1</code></pre><p>In  the  above  the  multiplicities  are  given  as  products of cyclotomic polynomials  to display them  more compactly. However  the format of such a table can be controlled more precisely.</p><p>For  instance,  one  can  ask  to  not  display  the entries as products of cyclotomic polynomials:</p><pre><code class="language-julia-rep1 hljs">julia&gt; xdisplay(t;cycpol=false)
Coefficients of Xᵪ on Yᵩ for A3
     │4 31 22 211   1111
─────┼───────────────────
X4   │1  1  1   1      1
X31  │0  1  1 q+1 q²+q+1
X22  │0  0  1   1   q²+1
X211 │0  0  0   1 q²+q+1
X1111│0  0  0   0      1</code></pre><p>Since <code>show</code> uses the function <code>format</code> for tables, all the options of this function  are  also  available.  We  can  use  this to restrict the entries displayed  to a  given sublist  of the  rows and  columns (here the indices correspond  to the number  in Chevie of  the corresponding character of the relative Weyl group of the given Springer series):</p><pre><code class="language-julia-rep1 hljs">julia&gt; uc=UnipotentClasses(coxgroup(:F,4));
julia&gt; t=ICCTable(uc);
julia&gt; sh=[13,24,22,18,14,9,11,19];
julia&gt; show(IOContext(stdout,:rows=&gt;sh,:cols=&gt;sh,:limit=&gt;true),t);
Coefficients of Xᵪ on Yᵩ for F₄
      │A₁+Ã₁ A₂ Ã₂ A₂+Ã₁ Ã₂+A₁ B₂⁽¹¹⁾ B₂ C₃(a₁)⁽¹¹⁾
──────┼─────────────────────────────────────────────
Xφ₉‚₁₀│    1  0  0     0     0      0  0          0
Xφ″₈‚₉│    1  1  0     0     0      0  0          0
Xφ′₈‚₉│    1  0  1     0     0      0  0          0
Xφ″₄‚₇│    1  1  0     1     0      0  0          0
Xφ′₆‚₆│   Φ₄  1  1     1     1      0  0          0
Xφ₄‚₈ │   q²  0  0     0     0      1  0          0
Xφ″₉‚₆│   Φ₄ Φ₄  0     1     0      0  1          0
Xφ′₄‚₇│   q²  0 Φ₄     0     1      0  0          1</code></pre><p>The   function  &#39;ICCTable&#39;  returns  an   object  with  various  pieces  of information which can help further computations.</p><p><code>.scalar</code>:  this contains the table of  multiplicities <code>Pᵪᵩ</code> of the <code>Xᵪ</code> on the  <code>Yᵩ</code>.  One  should  pay  attention  that  by default, the table is not displayed  in the same order as the  stored |.scalar|, which is in order in Chevie  of  the  characters  in  the  relative  Weyl  group;  the  table is transposed,  then lines  and rows  are sorted  by <code>dimBu,class  no,index of character in A(u)</code> while displayed.</p><p><code>.group</code>: The group <code>W</code>.</p><p><code>.relgroup</code>: The relative Weyl group for the Springer series.</p><p><code>.series</code>: The index of the Springer series given for <code>W</code>.</p><p><code>.dimBu</code>: The list of <code>dim𝓑ᵤ</code> for each local system <code>(u,φ)</code> in the series.</p><p><code>:L</code>:  The matrix of  (unnormalized) scalar products  of the functions <code>Yᵩ</code> with themselves, that is the <code>(φ,χ)</code> entry is <span>$∑_{g∈𝐆(𝔽_q)} Yᵩ(g) Yᵪ(g)$</span>. This  is thus a symmetric, block-diagonal  matrix where the diagonal blocks correspond  to  geometric  unipotent  conjugacy  classes.  This  matrix  is obtained as a by-product of Lusztig&#39;s algorithm to compute <code>Pᵩᵪ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Ucl.jl#L965-L1061">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Ucl.XTable" href="#Gapjm.Ucl.XTable"><code>Gapjm.Ucl.XTable</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>XTable(uc;classes=false)</code></p><p>This  function presents  in a  different way  the information obtained from <code>ICCTable</code>.  Let  <code>X̃_{u,ϕ}=q^{1/2(codim  C-dim  Z(𝐋 ))}</code> where <code>C</code> is the class  of <code>u</code> and <code>Z(𝐋 )</code> is the center of Levi subgroup on which lives the cuspidal local system attached to the local system <code>(u,ϕ)</code>.</p><p>Then  <code>XTable</code> gives the decomposition of the functions <code>X̃_{u,ϕ}</code> on local systems,  by  default.  If  <code>classes==true</code>,  it  gives  the  values of the functions <code>X̃_{u,ϕ}</code> on unipotent classes.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; XTable(UnipotentClasses(W))
Values of character sheaves X̃ᵪ on local systems φ
      X̃ᵪ|φ│   1 A₁ Ã₁ G₂(a₁)⁽¹¹¹⁾ G₂(a₁)⁽²¹⁾ G₂(a₁) G₂
──────────┼────────────────────────────────────────────
X_φ₁‚₀^G₂ │   1  1  1           0          0      1  1
X_φ₁‚₆^G₂ │  q⁶  0  0           0          0      0  0
X_φ′₁‚₃^G₂│  q³  0  q           0          q      0  0
X_φ″₁‚₃^G₂│  q³ q³  0           0          0      0  0
X_φ₂‚₁^G₂ │ qΦ₈  q  q           0          0      q  0
X_φ₂‚₂^G₂ │q²Φ₄ q² q²           0          0      0  0
X_Id^.    │   0  0  0          q²          0      0  0</code></pre><p>The functions <code>X̃</code> in the first column are decorated by putting as an exponent the relative groups <span>$W_𝐆 (𝐋)$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; XTable(UnipotentClasses(W);classes=true)
Values of character sheaves X̃ᵪ on unipotent classes
  X̃ᵪ|class│   1 A₁ Ã₁ G₂(a₁) G₂(a₁)₍₂₁₎ G₂(a₁)₍₃₎ G₂
──────────┼──────────────────────────────────────────
X_φ₁‚₀^G₂ │   1  1  1      1          1         1  1
X_φ₁‚₆^G₂ │  q⁶  0  0      0          0         0  0
X_φ′₁‚₃^G₂│  q³  0  q     2q          0        -q  0
X_φ″₁‚₃^G₂│  q³ q³  0      0          0         0  0
X_φ₂‚₁^G₂ │ qΦ₈  q  q      q          q         q  0
X_φ₂‚₂^G₂ │q²Φ₄ q² q²      0          0         0  0
X_Id^.    │   0  0  0     q²        -q²        q²  0

julia&gt; XTable(UnipotentClasses(W,2))
Values of character sheaves X̃ᵪ on local systems φ
      X̃ᵪ|φ│   1 A₁ Ã₁ G₂(a₁)⁽¹¹¹⁾ G₂(a₁)⁽²¹⁾ G₂(a₁) G₂⁽¹¹⁾ G₂
──────────┼───────────────────────────────────────────────────
X_φ₁‚₀^G₂ │   1  1  1           0          0      1      0  1
X_φ₁‚₆^G₂ │  q⁶  0  0           0          0      0      0  0
X_φ′₁‚₃^G₂│  q³  0  q           0          q      0      0  0
X_φ″₁‚₃^G₂│  q³ q³  0           0          0      0      0  0
X_φ₂‚₁^G₂ │ qΦ₈  q  q           0          0      q      0  0
X_φ₂‚₂^G₂ │q²Φ₄ q² q²           0          0      0      0  0
X_Id^.    │   0  0  0          q²          0      0      0  0
X_Id^.    │   0  0  0           0          0      0      q  0

julia&gt; XTable(UnipotentClasses(rootdatum(:sl,4)))
Values of character sheaves X̃ᵪ on local systems φ
    X̃ᵪ|φ│1111 211 22⁽¹¹⁾ 22 31 4 4^(ζ₄) 4⁽⁻¹⁾ 4^(ζ₄³)
────────┼─────────────────────────────────────────────
X₁₁₁₁^A₃│  q⁶   0      0  0  0 0      0     0       0
X₂₁₁^A₃ │q³Φ₃  q³      0  0  0 0      0     0       0
X₂₂^A₃  │q²Φ₄  q²      0 q²  0 0      0     0       0
X₃₁^A₃  │ qΦ₃ qΦ₂      0  q  q 0      0     0       0
X₄^A₃   │   1   1      0  1  1 1      0     0       0
X₁₁^A₁  │   0   0     q³  0  0 0      0     0       0
X₂^A₁   │   0   0     q²  0  0 0      0     q       0
X_Id^.  │   0   0      0  0  0 0   q³⁄₂     0       0
X_Id^.  │   0   0      0  0  0 0      0     0    q³⁄₂</code></pre><p>A  side effect  of calling  <code>XTable</code> with  <code>classes=true</code> is to compute the cardinal of the unipotent conjugacy classes:</p><pre><code class="language-julia-repl hljs">julia&gt; t=Ucl.XTable(UnipotentClasses(coxgroup(:G,2));classes=true);

julia&gt; CycPol.(t.cardClass)
7-element Vector{CycPol{Cyc{Rational{Int64}}}}:
 1
 Φ₁Φ₂Φ₃Φ₆
 q²Φ₁Φ₂Φ₃Φ₆
 q²Φ₁²Φ₂²Φ₃Φ₆/6
 q²Φ₁²Φ₂²Φ₃Φ₆/2
 q²Φ₁²Φ₂²Φ₃Φ₆/3
 q⁴Φ₁²Φ₂²Φ₃Φ₆</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Ucl.jl#L1130-L1219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Ucl.GreenTable" href="#Gapjm.Ucl.GreenTable"><code>Gapjm.Ucl.GreenTable</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>GreenTable(uc;classes=false)</code></p><p>Keeping the same notations as in the description of &#39;XTable&#39;, this function returns  a  table  of  the  functions  <code>Q_{wF}</code>,  attached to elements <code>wF∈ W_𝐆 (𝐋)⋅F</code> where <code>W_𝐆 (𝐋)</code> are the relative weyl groups attached to cuspidal local  systems.  These  functions  are  defined  by  <code>Q_{wF}=∑_{u,ϕ} ϕ̃(wF) X̃_{u,ϕ}</code>.  An point to note is that in the principal Springer series, when <code>𝐓</code>   is  a  maximal  torus,  the  function  <code>Q_{wF}</code>  coincides  with  the Deligne-Lusztig  character <code>R^𝐆 _{𝐓_W}(1)</code>. As for &#39;XTable&#39;, by default the table gives the values of the functions on local systems. If <code>classes=true</code> is  given, then it gives the values  of the functions <code>Q_{wF}</code> on conjugacy classes.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; GreenTable(UnipotentClasses(W))
Values of Green functions Q_wF on local systems φ
   Qᴵ_wF|φ│        1     A₁       Ã₁ G₂(a₁)⁽¹¹¹⁾ G₂(a₁)⁽²¹⁾ G₂(a₁) G₂
──────────┼───────────────────────────────────────────────────────────
Q_A₀^G₂   │  Φ₂²Φ₃Φ₆   Φ₂Φ₃ (2q+1)Φ₂           0          q   2q+1  1
Q_Ã₁^G₂   │-Φ₁Φ₂Φ₃Φ₆  -Φ₁Φ₃       Φ₂           0          q      1  1
Q_A₁^G₂   │-Φ₁Φ₂Φ₃Φ₆   Φ₂Φ₆      -Φ₁           0         -q      1  1
Q_G₂^G₂   │ Φ₁²Φ₂²Φ₃ -Φ₁Φ₂²    -Φ₁Φ₂           0         -q     Φ₂  1
Q_A₂^G₂   │ Φ₁²Φ₂²Φ₆  Φ₁²Φ₂    -Φ₁Φ₂           0          q    -Φ₁  1
Q_A₁+Ã₁^G₂│  Φ₁²Φ₃Φ₆  -Φ₁Φ₆ (2q-1)Φ₁           0         -q  -2q+1  1
Q_^.      │        0      0        0          q²          0      0  0</code></pre><p>The  functions <span>$Q_{wF}$</span> depend only on the conjugacy class of <code>wF</code>, so in the  first column the indices of &#39;Q&#39; are the names of the conjugacy classes of <span>$W_𝐆(𝐋)$</span>. The exponents are the names of the groups <span>$W_𝐆(𝐋)$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; GreenTable(UnipotentClasses(W);classes=true)
Values of Green functions Q_wF on unipotent classes
Qᴵ_wF|class│        1     A₁       Ã₁ G₂(a₁) G₂(a₁)₍₂₁₎ G₂(a₁)₍₃₎ G₂
───────────┼─────────────────────────────────────────────────────────
Q_A₀^G₂    │  Φ₂²Φ₃Φ₆   Φ₂Φ₃ (2q+1)Φ₂   4q+1       2q+1        Φ₂  1
Q_Ã₁^G₂    │-Φ₁Φ₂Φ₃Φ₆  -Φ₁Φ₃       Φ₂   2q+1          1       -Φ₁  1
Q_A₁^G₂    │-Φ₁Φ₂Φ₃Φ₆   Φ₂Φ₆      -Φ₁  -2q+1          1        Φ₂  1
Q_G₂^G₂    │ Φ₁²Φ₂²Φ₃ -Φ₁Φ₂²    -Φ₁Φ₂    -Φ₁         Φ₂      2q+1  1
Q_A₂^G₂    │ Φ₁²Φ₂²Φ₆  Φ₁²Φ₂    -Φ₁Φ₂     Φ₂        -Φ₁     -2q+1  1
Q_A₁+Ã₁^G₂ │  Φ₁²Φ₃Φ₆  -Φ₁Φ₆ (2q-1)Φ₁  -4q+1      -2q+1       -Φ₁  1
Q_^.       │        0      0        0     q²        -q²        q²  0

julia&gt; GreenTable(UnipotentClasses(rootdatum(:sl,4)))
Values of Green functions Q_wF on local systems φ
 Qᴵ_wF|φ│     1111          211 22⁽¹¹⁾       22   31 4 4^(ζ₄) 4⁽⁻¹⁾ 4^(ζ₄³)
────────┼───────────────────────────────────────────────────────────────────
Q₁₁₁₁^A₃│  Φ₂²Φ₃Φ₄ (3q²+2q+1)Φ₂      0 (2q+1)Φ₂ 3q+1 1      0     0       0
Q₂₁₁^A₃ │-Φ₁Φ₂Φ₃Φ₄   -q³+q²+q+1      0       Φ₂   Φ₂ 1      0     0       0
Q₂₂^A₃  │  Φ₁²Φ₃Φ₄        -Φ₁Φ₄      0  2q²-q+1  -Φ₁ 1      0     0       0
Q₃₁^A₃  │ Φ₁²Φ₂²Φ₄        -Φ₁Φ₂      0    -Φ₁Φ₂    1 1      0     0       0
Q₄^A₃   │ -Φ₁³Φ₂Φ₃        Φ₁²Φ₂      0      -Φ₁  -Φ₁ 1      0     0       0
Q₁₁^A₁  │        0            0   q²Φ₂        0    0 0      0     q       0
Q₂^A₁   │        0            0  -q²Φ₁        0    0 0      0     q       0
Q_^.    │        0            0      0        0    0 0   q³⁄₂     0       0
Q_^.    │        0            0      0        0    0 0      0     0    q³⁄₂</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Ucl.jl#L1284-L1346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Ucl.UnipotentValues" href="#Gapjm.Ucl.UnipotentValues"><code>Gapjm.Ucl.UnipotentValues</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>UnipotentValues(uc,classes=false)</code></p><p>This  function returns  a table  of the  values of  unipotent characters on local systems (by default) or on unipotent classes (if <code>classes=true</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; UnipotentValues(UnipotentClasses(W);classes=true)
Values of unipotent characters for G₂ on unipotent classes
       │        1          A₁     Ã₁   G₂(a₁) G₂(a₁)₍₂₁₎ G₂(a₁)₍₃₎ G₂
───────┼──────────────────────────────────────────────────────────────
φ₁‚₀   │        1           1      1        1          1         1  1
φ₁‚₆   │       q⁶           0      0        0          0         0  0
φ′₁‚₃  │  qΦ₃Φ₆/3    -qΦ₁Φ₂/3      q (q+5)q/3     -qΦ₁/3     qΦ₁/3  0
φ″₁‚₃  │  qΦ₃Φ₆/3  (2q²+1)q/3      0    qΦ₁/3     -qΦ₁/3  (q+2)q/3  0
φ₂‚₁   │ qΦ₂²Φ₃/6 (2q+1)qΦ₂/6  qΦ₂/2 (q+5)q/6     -qΦ₁/6     qΦ₁/6  0
φ₂‚₂   │ qΦ₂²Φ₆/2       qΦ₂/2  qΦ₂/2   -qΦ₁/2      qΦ₂/2    -qΦ₁/2  0
G₂[-1] │ qΦ₁²Φ₃/2      -qΦ₁/2 -qΦ₁/2   -qΦ₁/2      qΦ₂/2    -qΦ₁/2  0
G₂[1]  │ qΦ₁²Φ₆/6 (2q-1)qΦ₁/6 -qΦ₁/2 (q+5)q/6     -qΦ₁/6     qΦ₁/6  0
G₂[ζ₃] │qΦ₁²Φ₂²/3    -qΦ₁Φ₂/3      0    qΦ₁/3     -qΦ₁/3  (q+2)q/3  0
G₂[ζ₃²]│qΦ₁²Φ₂²/3    -qΦ₁Φ₂/3      0    qΦ₁/3     -qΦ₁/3  (q+2)q/3  0


julia&gt; UnipotentValues(UnipotentClasses(W,3);classes=true)
Values of unipotent characters for G₂ on unipotent classes
       │        1          A₁         Ã₁ G₂(a₁) G₂(a₁)₍₂₎    G₂       G₂_(ζ₃)
───────┼──────────────────────────────────────────────────────────────────────
φ₁‚₀   │        1           1          1      1         1     1             1
φ₁‚₆   │       q⁶           0          0      0         0     0             0
φ′₁‚₃  │  qΦ₃Φ₆/3    -qΦ₁Φ₂/3        q/3  qΦ₂/3    -qΦ₁/3 -2q/3           q/3
φ″₁‚₃  │  qΦ₃Φ₆/3  (2q²+1)q/3        q/3  qΦ₂/3    -qΦ₁/3 -2q/3           q/3
φ₂‚₁   │ qΦ₂²Φ₃/6 (2q+1)qΦ₂/6  (3q+1)q/6  qΦ₂/6    -qΦ₁/6  2q/3          -q/3
φ₂‚₂   │ qΦ₂²Φ₆/2       qΦ₂/2      qΦ₂/2 -qΦ₁/2     qΦ₂/2     0             0
G₂[-1] │ qΦ₁²Φ₃/2      -qΦ₁/2     -qΦ₁/2 -qΦ₁/2     qΦ₂/2     0             0
G₂[1]  │ qΦ₁²Φ₆/6 (2q-1)qΦ₁/6 (-3q+1)q/6  qΦ₂/6    -qΦ₁/6  2q/3          -q/3
G₂[ζ₃] │qΦ₁²Φ₂²/3    -qΦ₁Φ₂/3        q/3  qΦ₂/3    -qΦ₁/3   q/3 (-ζ₃+2ζ₃²)q/3
G₂[ζ₃²]│qΦ₁²Φ₂²/3    -qΦ₁Φ₂/3        q/3  qΦ₂/3    -qΦ₁/3   q/3  (2ζ₃-ζ₃²)q/3

       │     G₂_(ζ₃²)       (Ã₁)₃
───────┼──────────────────────────
φ₁‚₀   │            1           1
φ₁‚₆   │            0           0
φ′₁‚₃  │          q/3  (2q²+1)q/3
φ″₁‚₃  │          q/3    -qΦ₁Φ₂/3
φ₂‚₁   │         -q/3 (2q+1)qΦ₂/6
φ₂‚₂   │            0       qΦ₂/2
G₂[-1] │            0      -qΦ₁/2
G₂[1]  │         -q/3 (2q-1)qΦ₁/6
G₂[ζ₃] │ (2ζ₃-ζ₃²)q/3    -qΦ₁Φ₂/3
G₂[ζ₃²]│(-ζ₃+2ζ₃²)q/3    -qΦ₁Φ₂/3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Ucl.jl#L1392-L1446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Ucl.induced_linear_form" href="#Gapjm.Ucl.induced_linear_form"><code>Gapjm.Ucl.induced_linear_form</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>induced_linear_form(W, K, h)</code></p><p>This routine can be used to find the Richardson-Dynkin diagram of the class in  the algebraic group <code>𝐆</code>  which contains a given  unipotent class of a reductive subgroup of maximum rank <code>𝐒</code> of <code>𝐆</code>.</p><p>It  takes a linear  form on the  roots of <code>K</code>,  defined by its value on the simple  roots (these values  can define a  Dynkin-Richardson diagram); then extends  this linear form to the roots of <code>𝐆</code> by <code>0</code> on the orthogonal of the  roots of <code>K</code>; and finally conjugates  the resulting form by an element of the Weyl group so that it takes positive values on the simple roots.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:F,4)
F₄

julia&gt; H=reflection_subgroup(W,[1,3])
F₄₍₁₃₎=A₁×Ã₁Φ₁²

julia&gt; Ucl.induced_linear_form(W,H,[2,2])
4-element Vector{Int64}:
 0
 1
 0
 0

julia&gt; uc=UnipotentClasses(W);

julia&gt; uc.classes[4].prop
Dict{Symbol, Any} with 7 entries:
  :dynkin     =&gt; [0, 1, 0, 0]
  :dimred     =&gt; 6
  :red        =&gt; A₁×A₁
  :Au         =&gt; .
  :balacarter =&gt; [1, 3]
  :dimunip    =&gt; 18
  :AuAction   =&gt; A₁×A₁

julia&gt; uc.classes[4]
UnipotentClass(A₁+Ã₁)</code></pre><p>The  example above shows that the class containing the regular class of the Levi subgroup of type <code>A₁× Ã₁</code> is the class |A1+~A1|.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Ucl.jl#L292-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Ucl.special_pieces" href="#Gapjm.Ucl.special_pieces"><code>Gapjm.Ucl.special_pieces</code></a> — <span class="docstring-category">Function</span></header><section><div><p>&#39;special_pieces(&lt;uc&gt;)&#39;</p><p>The  special  pieces  forme  a  partition  of  the  unipotent  variety of a reductive  group <code>𝐆</code> which was defined  the first time in <a href="biblio.htm#spalt82">Spaltenstein1982 chap.  III</a>  as  the  fibers  of  <code>d^2</code>, where <code>d</code> is a &quot;duality  map&quot;. Another definition is as the  set of classes in the Zariski closure  of a special class  and not in the  Zariski closure of any smaller special  class, where  a special  class in  the support  of the  image of a special character by the Springer correspondence.</p><p>Each  piece is a union of unipotent  conjugacy classes so is represented in Chevie  as a  list of  class numbers.  Thus the  list of  special pieces is returned  as  a  list  of  lists  of  class  numbers. The list is sorted by increasing  piece dimension, while each piece is sorted by decreasing class dimension, so the special class is listed first.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; special_pieces(UnipotentClasses(W))
3-element Vector{Vector{Int64}}:
 [1]
 [4, 3, 2]
 [5]

julia&gt; special_pieces(UnipotentClasses(W,3))
3-element Vector{Vector{Int64}}:
 [1]
 [4, 3, 2, 6]
 [5]</code></pre><p>The   example  above  shows  that  the  special  pieces  are  different  in characteristic 3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Ucl.jl#L1549-L1585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Ucl.distinguished_parabolics" href="#Gapjm.Ucl.distinguished_parabolics"><code>Gapjm.Ucl.distinguished_parabolics</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>distinguished_parabolics(W)</code> </p><p>the  list  of  distinguished  parabolic  subgroups  of  <code>W</code> in the sense of Richardson,  each  given  as  the  list  of  the corresponding indices. The distinguished  unipotent  conjugacy  classes  of  <code>W</code>  consist of the dense unipotent orbit in the unipotent radical of such a parabolic.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:F,4)
F₄

julia&gt; distinguished_parabolics(W)
4-element Vector{Vector{Int64}}:
 []
 [3]
 [1, 3]
 [1, 3, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Ucl.jl#L350-L369">source</a></section></article><h1 id="Symbols"><a class="docs-heading-anchor" href="#Symbols">Symbols</a><a id="Symbols-1"></a><a class="docs-heading-anchor-permalink" href="#Symbols" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols" href="#Gapjm.Symbols"><code>Gapjm.Symbols</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The  combinatorial  objects  in  the  module  <code>Symbols</code>  are  <em>partitions</em>, <em>β-sets</em> and <em>symbols</em>.</p><p>A  partition is a  non-increasing list of  positive integers <code>p₁≥p₂≥…pₙ&gt;0</code>, represented as a <code>Vector{Int}</code>.</p><p>A  <em>β-set</em>  is  a  strictly  increasing  <code>Vector{Int}</code>,  up  to the <em>shift</em> equivalence   relation,  the  transitive  closure  of  the  equivalence  of <code>[b₁,…,bₙ]</code>  and  its  elementary  shift  <code>[0,1+b₁,…,1+bₙ]</code>. An equivalence class  has exactly one member which does  not contain <code>0</code>: it is called the normalized β-set.</p><p>To  a  partition  <code>p₁≥p₂≥…pₙ&gt;0</code>  is  associated  a  β-set, whose normalized representative   is   <code>pₙ,pₙ₋₁+1,…,p₁+n-1</code>.   Conversely,   to  each  β-set <code>b₁&lt;b₂&lt;…&lt;bₙ</code> is associated the partition <code>bₙ-n+1≥…≥b₂-1≥b₁</code> (which may have some trailing zeros if starting from a non-normalized representative).</p><p><code>2</code>-symbols  where introduced by [Lusztig1977] and more general <code>e</code>-symbols by  <a href="biblio.htm#Mal95">Malle1995</a>. An <code>e</code>-symbol  is a vector <code>S=[S₁,…,Sₑ]</code> of   β-sets,  taken  modulo  the  equivalence  relation  generated  by  the simultaneous  elementary shift of all β-sets, and the cyclic permutation of the vector (in the particular case where <code>e=2</code> it is thus an unordered pair of  β-sets). This  time there  is a  cyclic permutation class of normalized symbols  where <code>0</code> is not in the intersection of the <code>Sᵢ</code>. The <em>content</em> of <code>S</code>  is <code>mod(sum(length(S)),e)</code>; it is an  invariant of the symbol, as well as the <em>rank</em>, defined for an <code>e</code>-symbol as <code>sum(sum,S)-div((c-1)*(c-e+1),2*e)</code>   where   <code>c=sum(length(S))</code>   and  the <em>shape</em> <code>s-minimum(s)</code> where <code>s=map(length,S)</code>.</p><p>When  <code>e=2</code>  up  to  cyclic  permutation  we  choose representatives of the symbols <code>[S₁,S₂]</code> such that <code>length(S₁)≥length(S₂)</code> so the shape is <code>[d,0]</code> where  <code>d</code> is called  the <em>defect</em> of  the symbol (the  content is equal to <code>mod(d,2)</code>).  For symbols <code>[S₁,S₂]</code> with <code>length(S₁)==length(S₂)</code> we choose representatives  such that <code>P₁≤P₂</code> lexicographically  where <code>P₁,P₂</code> are the partitions associated to <code>S₁,S₂</code>.</p><p>Partitions  and pairs  of partitions  are parameters  for characters of the Weyl groups of classical types, and tuples of partitions are parameters for characters   of  imprimitive  complex   reflection  groups.  2-Symbols  are parameters  for the unipotent characters of classical Chevalley groups, and more  general <code>e</code>-symbols  are parameters  for the  unipotent characters of Spetses  associated to spetsial imprimitive  complex reflection groups. The rank  of a  symbol is  the semi-simple  rank of the corresponding Chevalley group or Spets.</p><p>Symbols  of rank  <code>n</code> and  defect <code>0</code>  parameterize characters  of the Weyl group  of type <code>Dₙ</code>,  and symbols of  rank <code>n</code> and  defect divisible by <code>4</code> parameterize  unipotent characters of split  orthogonal groups of dimension <code>2n</code>.  Symbols of  rank <code>n</code>  and defect<code>≡2  (mod 4)</code> parameterize unipotent characters  of non-split  orthogonal groups  of dimension  <code>2n</code>. Symbols of rank  <code>n</code> and defect <code>1</code> parameterize characters  of the Weyl group of type <code>Bₙ</code>,  and  symbols  of  rank  <code>n</code>  and  odd  defect parameterize unipotent characters  of symplectic groups of dimension  <code>2n</code> or orthogonal groups of dimension <code>2n+1</code>.</p><p><code>e</code>-symbols  of rank <code>n</code> and  content <code>1</code> parameterize unipotent characters of  <code>G(e,1,n)</code>. Those of  content <code>0</code> parameterize  unipotent characters of <code>G(e,e,n)</code>.  The principal series  (characters of the  reflection group) is parametrized  by symbols of shape  <code>[1,0,…,0]</code> for <code>G(e,1,n)</code> and <code>[0,…,0]</code> for <code>G(e,e,n)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Symbols.jl#L1-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.shiftβ" href="#Gapjm.Symbols.shiftβ"><code>Gapjm.Symbols.shiftβ</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>shiftβ( β, n)</code> shift β-set β by n</p><pre><code class="language-julia-repl hljs">julia&gt; shiftβ([2,3],2)
4-element Vector{Int64}:
 0
 1
 4
 5

julia&gt; shiftβ([0,1,4,5],-2)
2-element Vector{Int64}:
 2
 3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Symbols.jl#L120-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.βset" href="#Gapjm.Symbols.βset"><code>Gapjm.Symbols.βset</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>βset(p)</code> normalized β-set of a partition</p><pre><code class="language-julia-repl hljs">julia&gt; βset([3,3,1])
3-element Vector{Int64}:
 1
 4
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Symbols.jl#L145-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.partβ" href="#Gapjm.Symbols.partβ"><code>Gapjm.Symbols.partβ</code></a> — <span class="docstring-category">Function</span></header><section><div><p>&#39;partβ(β)&#39; partition defined by β-set β</p><pre><code class="language-julia-repl hljs">julia&gt; partβ([0,4,5])
2-element Vector{Int64}:
 3
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Symbols.jl#L171-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.ranksymbol" href="#Gapjm.Symbols.ranksymbol"><code>Gapjm.Symbols.ranksymbol</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>ranksymbol(S)</code> rank of symbol <code>S</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; ranksymbol([[1,5,6],[1,2]])
11</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Symbols.jl#L238-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.defectsymbol" href="#Gapjm.Symbols.defectsymbol"><code>Gapjm.Symbols.defectsymbol</code></a> — <span class="docstring-category">Function</span></header><section><div><p>`defectsymbol(s)&#39;</p><p>For an <code>e</code>-symbol <code>[S₁,S₂,…,Sₑ]</code> returns <code>length(S₁)-length(S₂)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; defectsymbol([[1,5,6],[1,2]])
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Symbols.jl#L296-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.symbol_partition_tuple" href="#Gapjm.Symbols.symbol_partition_tuple"><code>Gapjm.Symbols.symbol_partition_tuple</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>symbol_partition_tuple(p, s)</code> symbol of shape <code>s</code> for partition tuple <code>p</code>.</p><p>In  the general case, <code>s</code> is a <code>Vector{Int}</code>  of same length as <code>p</code> and the <code>i</code>-th  element of the result is the β-set for <code>pᵢ</code> shifted to be of length <code>sᵢ</code> (the minimal integer which makes this possible is added to <code>s</code>).</p><p>When  <code>s</code> is  a positive  integer it  is interpreted  as <code>[s,0,0,…]</code>  and a negative  integer is interpreted  as <code>[0,-s,-s,…]</code> so  when <code>p</code> is a double partition  one gets the  symbol of defect  <code>s</code> associated to  <code>p</code>; as other uses  the  unipotent  symbol  for  a  character  of the principal series of <code>G(e,1,r)</code>   parameterized   by   an   <code>e</code>-tuple   <code>p</code>   of  partitions  is <code>symbol_partition_tuple(p,1)</code> and for <code>G(e,e,r)</code> the similar computation is <code>symbol_partition_tuple(p,0)</code>  (the function handles coded periodic <code>p</code> for <code>G(e,e,r)</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; symbol_partition_tuple([[1,2],[1]],1)
2-element Vector{Vector{Int64}}:
 [2, 2]
 [1]

julia&gt; symbol_partition_tuple([[1,2],[1]],0)
2-element Vector{Vector{Int64}}:
 [2, 2]
 [0, 2]

julia&gt; symbol_partition_tuple([[1,2],[1]],-1)
2-element Vector{Vector{Int64}}:
 [2, 2]
 [0, 1, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Symbols.jl#L183-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.fegsymbol" href="#Gapjm.Symbols.fegsymbol"><code>Gapjm.Symbols.fegsymbol</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>fegsymbol(S,p=0)</code></p><p>Let  <code>s=[S₁,…,Sₑ]</code> be an <code>e</code>-symbol  given as a <code>Vector{Vector{Int}}</code>. This function  returns as a <code>CycPol</code> the fake  degree of the character of symbol <code>S</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; fegsymbol([[1,5,6],[1,2]])
q¹⁶Φ₅Φ₇Φ₈Φ₉Φ₁₀Φ₁₁Φ₁₄Φ₁₆Φ₁₈Φ₂₀Φ₂₂</code></pre><p>When  given a  second argument  <code>p</code> dividing  <code>e</code>, and  a first argument of shape  <code>(0,…,0)</code> representing the restriction  to <code>G(e,e,r)</code>, works for the coset <code>G(e,e,r).s₁ᵖ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Symbols.jl#L494-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.gendeg_symbol" href="#Gapjm.Symbols.gendeg_symbol"><code>Gapjm.Symbols.gendeg_symbol</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>gendeg_symbol(s)</code></p><p>Let  <code>s=[S₁,…,Sₑ]</code> be an <code>e</code>-symbol  given as a <code>Vector{Vector{Int}}</code>. This function  returns  as  a  <code>CycPol</code>  the  generic  degree  of  the unipotent character parameterized by <code>s</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; gendeg_symbol([[1,2],[1,5,6]])
q¹³Φ₅Φ₆Φ₇Φ₈²Φ₉Φ₁₀Φ₁₁Φ₁₄Φ₁₆Φ₁₈Φ₂₀Φ₂₂/2</code></pre><p>Works for symbols for:</p><pre><code class="nohighlight hljs">G(e,1,r) (c==1, d==0)
G(e,e,r) (c==0, d==0)</code></pre><p>²G(e,e,r) (c==0, d==1) (e,r even. This includes ²Dₙ, ²B₂, ²G₂)</p><p>here  <code>c</code> is the content  of the symbol and  <code>d</code> the Malle-defect, see <a href="biblio.htm#Mal95">3.9 and 6.4 Malle1995</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Symbols.jl#L547-L566">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.degree_fegsymbol" href="#Gapjm.Symbols.degree_fegsymbol"><code>Gapjm.Symbols.degree_fegsymbol</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>degree_fegsymbol(s)</code></p><p>the  degree  of  the  fake  degree  of  the  character parameterized by the <code>e</code>-symbol <code>s</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; degree_fegsymbol([[1,5,6],[1,2]])
88</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Symbols.jl#L310-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.degree_gendeg_symbol" href="#Gapjm.Symbols.degree_gendeg_symbol"><code>Gapjm.Symbols.degree_gendeg_symbol</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>degree_gendeg_symbol(s)</code></p><p>the  degree of the generic degree  of the unipotent character parameterized by the <code>e</code>-symbol <code>s</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; degree_gendeg_symbol([[1,5,6],[1,2]])
91</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Symbols.jl#L273-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.valuation_fegsymbol" href="#Gapjm.Symbols.valuation_fegsymbol"><code>Gapjm.Symbols.valuation_fegsymbol</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>valuation_fegsymbol(s)</code></p><p>the  valuation of  the fake  degree of  the character  parameterized by the <code>e</code>-symbol <code>s</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; valuation_fegsymbol([[1,5,6],[1,2]])
16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Symbols.jl#L339-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.valuation_gendeg_symbol" href="#Gapjm.Symbols.valuation_gendeg_symbol"><code>Gapjm.Symbols.valuation_gendeg_symbol</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>valuation_gendeg_symbol(s)</code></p><p>the   valuation  of   the  generic   degree  of   the  unipotent  character parameterized by the <code>e</code>-symbol <code>s</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; valuation_gendeg_symbol([[1,5,6],[1,2]])
13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Symbols.jl#L254-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.tableaux" href="#Gapjm.Symbols.tableaux"><code>Gapjm.Symbols.tableaux</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>tableaux(S)</code></p><p><code>S</code>  is a  partition tuple  or a  partition. returns  the list  of standard tableaux  associated to the partition  tuple <code>S</code>, that is  a filling of the associated  young diagrams  with the  numbers <code>1:sum(sum,S)</code>  such that the numbers  increase across the rows  and down the columns.  If the imput is a single partition, the standard tableaux for that partition are returned.</p><pre><code class="language-julia-repl hljs">julia&gt; tableaux([[2,1],[1]])
8-element Vector{Vector{Vector{Vector{Int64}}}}:
 [[[1, 2], [3]], [[4]]]
 [[[1, 2], [4]], [[3]]]
 [[[1, 3], [2]], [[4]]]
 [[[1, 3], [4]], [[2]]]
 [[[1, 4], [2]], [[3]]]
 [[[1, 4], [3]], [[2]]]
 [[[2, 3], [4]], [[1]]]
 [[[2, 4], [3]], [[1]]]

julia&gt; tableaux([2,2])
2-element Vector{Vector{Vector{Int64}}}:
 [[1, 2], [3, 4]]
 [[1, 3], [2, 4]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Symbols.jl#L654-L680">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.symbols" href="#Gapjm.Symbols.symbols"><code>Gapjm.Symbols.symbols</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>symbols(e,r,c=1,def=0)</code> <code>e</code>-symbols of rank <code>r</code>, content <code>c</code> and Malle-defect <code>def</code></p><p>An <code>e</code>-symbol is a symbol of length <code>e</code>. The content of an <code>e</code>-symbol <code>S</code> is <code>sum(length,S)%e</code>. The symbols for unipotent  characters of:</p><ul><li><code>G(d,1,r)</code> are <code>symbols(d,r)</code></li><li><code>G(e,e,r)</code> are <code>symbols(e,r,0)</code>.</li><li><code>G(e,e,r).s₁ᵗ</code> where <code>s₁</code> is the first generator of <code>G(e,1,r)</code> and <code>t|e</code> are <code>symbols(e,r,0,t)</code></li></ul><pre><code class="language-julia-repl hljs">julia&gt; stringsymbol.(symbols(3,2,1))
14-element Vector{String}:
 &quot;(12,0,0)&quot;
 &quot;(02,1,0)&quot;
 &quot;(02,0,1)&quot;
 &quot;(012,12,01)&quot;
 &quot;(01,1,1)&quot;
 &quot;(012,01,12)&quot;
 &quot;(2,,)&quot;
 &quot;(01,2,0)&quot;
 &quot;(01,0,2)&quot;
 &quot;(1,012,012)&quot;
 &quot;(,02,01)&quot;
 &quot;(,01,02)&quot;
 &quot;(0,,012)&quot;
 &quot;(0,012,)&quot;

julia&gt; stringsymbol.(symbols(3,3,0))
12-element Vector{String}:
 &quot;(1+)&quot;
 &quot;(1E(3))&quot;
 &quot;(1E(3,2))&quot;
 &quot;(01,12,02)&quot;
 &quot;(01,02,12)&quot;
 &quot;(012,012,123)&quot;
 &quot;(0,1,2)&quot;
 &quot;(0,2,1)&quot;
 &quot;(01,01,13)&quot;
 &quot;(0,0,3)&quot;
 &quot;(012,,)&quot;
 &quot;(012,012,)&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Symbols.jl#L445-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.XSP" href="#Gapjm.Symbols.XSP"><code>Gapjm.Symbols.XSP</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>XSP(ρ,s,n,even=false)</code></p><p>returns the union of the Lusztig-Spaltenstein <span>$X̃^{ρ-s,s}_{n,d}$</span> for all <code>d</code> even when <code>even=true</code>, all <code>d</code> odd otherwise. In &quot;Character sheaves on disconnected groups II, 13.2&quot; the notation is <span>${}^ρ X^s_{n,d}$</span>. The result is a list of lists, each one corresponding to a similarity class. If <code>s==0</code>, only positive defects are considered.</p><ul><li><code>XSP(2,1,n)</code> gives L-S symbols for Sp₂ₙ</li><li><code>XSP(4,2,n)</code> gives L-S symbols for Sp₂ₙ in char.2</li><li><code>XSP(2,0,n)</code> gives L-S symbols for SO₂ₙ₊₁ [defect odd]</li><li><code>XSP(2,0,n,true)</code> gives L-S symbols for SO₂ₙ [defect even]</li><li><code>XSP(4,0,n,true)</code> gives L-S symbols for SO₂ₙ in char 2</li></ul><p>returns named tuples with fields:</p><ul><li><code>symbol</code></li><li><code>dimBu</code></li><li><code>Au</code>  describes a character of <code>A(u)</code> as a list: <code>true</code>-&gt;sgn, <code>false</code>-&gt;Id  representing the local system of the Springer correspondent</li><li><code>sp</code>  parameter (double partition) of the generalized Springer  correspondent (character of the relative Weyl group)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Symbols.jl#L705-L729">source</a></section></article><h1 id="Eigenspaces"><a class="docs-heading-anchor" href="#Eigenspaces">Eigenspaces</a><a id="Eigenspaces-1"></a><a class="docs-heading-anchor-permalink" href="#Eigenspaces" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Eigenspaces" href="#Gapjm.Eigenspaces"><code>Gapjm.Eigenspaces</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Eigenspaces and <code>d</code>-Harish-Chandra series</p><p>Let <code>Wϕ</code> be a reflection coset on a vector space <code>V</code> and <code>Lwϕ</code> a reflection subcoset  where <code>L</code> is a  parabolic subgroup (the fixator  of a subspace of <code>V</code>).  There  are  several  interesting  cases  where  the <em>relative group</em> <span>$N_W(Lwϕ)/L$</span>,  or a subgroup of it normalizing some further data attached to <code>L</code>, is itself a reflection group.</p><p>A first example is the case where <code>ϕ=1</code> and <code>w=1</code>, <code>W</code> is the Weyl group of a   finite  reductive   group  <span>$𝐆^F$</span>   and  the   Levi  subgroup  <span>$𝐋^F$</span> corresponding  to <code>L</code> has a cuspidal unipotent character. Then <span>$N_W(L)/L$</span> is  a  Coxeter  group  acting  on  the  space  <code>X(Z𝐋)⊗ℝ</code>.  A  combinatorial characterization of such parabolic subgroups of Coxeter groups is that they are  normalized by the  longest element of  larger parabolic subgroups (see <a href="biblio.htm#Lus76">5.7.1 Lusztig1976</a>).</p><p>A  second  example  is  when  <code>L</code>  is  trivial  and  <code>wϕ</code> is a <em><code>ζ</code>-regular element</em>,  that is  the <code>ζ</code>-eigenspace  <span>$V_ζ$</span> of  <code>wϕ</code> contains  a vector outside  all the reflecting hyperplanes of <code>W</code>. Then <span>$N_W(Lwϕ)/L=C_W(wϕ)$</span> is a reflection group in its action on <span>$V_ζ$</span>.</p><p>A similar but more general example is when <span>$V_ζ$</span> is the <code>ζ</code>-eigenspace of some  element of  the reflection  coset <code>Wϕ</code>,  and is  of maximal dimension among such possible <code>ζ</code>-eigenspaces. Then the set of elements of <code>Wϕ</code> which act  by <code>ζ</code> on <span>$V_ζ$</span> is a certain subcoset <code>Lwϕ</code>, and <span>$N_W(Lwϕ)/L$</span> is a reflection group in its action on <span>$V_ζ$</span> (see <a href="biblio.htm#LS99">2.5 Lehrer-Springer1999</a>).</p><p>Finally,  a  still  more  general  example,  but which only occurs for Weyl groups  or  Spetsial  reflection  groups,  is  when <code>𝐋</code> is a <code>ζ</code>-split Levi subgroup  (which means that  the corresponding subcoset  <code>Lwϕ</code> is formed of all  the elements which act by <code>ζ</code> on  some subspace <code>V_ζ</code> of <code>V</code>), and <code>λ</code> is  a  <code>d</code>-cuspidal  unipotent  character  of  <code>𝐋</code>  (which  means  that the multiplicity  of <code>ζ</code>  as a  root of  the degree  of <code>λ</code>  is the same as the multiplicity  of <code>ζ</code> as a root of the generic order of the semi-simple part of  <code>𝐆</code>); then <span>$N_W(Lwϕ,λ)/L$</span> is a complex reflection group in its action on <code>V_ζ</code>.</p><p>Further,  in the above cases the relative group describes the decomposition of a Lusztig induction.</p><p>When  <span>$𝐆^F$</span> is  a finite  reductive group,  and <code>λ</code>  a cuspidal unipotent character  of  the  Levi  subgroup  <span>$𝐋^F$</span>,  then the <span>$𝐆^F$</span>-endomorphism algebra  of  the  Harish-Chandra  induced  representation <span>$R_𝐋^𝐆(λ)$</span> is a Hecke algebra attached to the group <span>$N_W(L)/L$</span>, thus the dimension of the characters  of this group describe the multiplicities in the Harish-Chandra induced.</p><p>Similarly, when <code>𝐋</code> is a <code>ζ</code>-split Levi subgroup, and <code>λ</code> is a <code>d</code>-cuspidal unipotent  character of  <code>𝐋</code> then  (conjecturally) the <span>$𝐆^F$</span>-endomorphism algebra  of the Lusztig induced <span>$R_𝐋^𝐆(λ)$</span>  is a cyclotomic Hecke algebra for  to the  group <span>$N_W(Lwϕ,λ)/L$</span>.  The constituents  of <span>$R_𝐋^𝐆(λ)$</span> are called  a  <code>ζ</code>-Harish-Chandra  series.  In  the  case of rational groups or cosets,  corresponding to finite  reductive groups, the  conjugacy class of <code>Lwϕ</code>  depends  only  on  the  order  <code>d</code>  of  <code>ζ</code>,  so  one  also talks of <code>d</code>-Harish-Chandra  series. These series correspond to <code>ℓ</code>-blocks where <code>l</code> is  a prime divisor of <code>Φ_d(q)</code> which  does not divide any other cyclotomic factor of the order of <span>$𝐆^F$</span>.</p><p>The functions described in this module allow to explore these situations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Eigenspaces.jl#L1-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Eigenspaces.relative_degrees" href="#Gapjm.Eigenspaces.relative_degrees"><code>Gapjm.Eigenspaces.relative_degrees</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>relative_degrees(WF,d)</code></p><p>Let  <code>WF</code> be a reflection group or a reflection coset. Here <code>d</code> specifies a root  of unity <code>ζ</code>: either <code>d</code> is an integer and specifies <code>ζ=E(d)</code> or is a fraction  smaller <code>a/b</code> with <code>0&lt;a&lt;b</code>  and specifies <code>ζ=E(b,a)</code>. If omitted, <code>d</code>  is  taken  to  be  <code>1</code>,  specifying  <code>ζ=1</code>.  Then  if  <span>$V_ζ$</span>  is the <code>ζ</code>-eigenspace  of some element of <code>WF</code>,  and is of maximal dimension among such   possible  <code>ζ</code>-eigenspaces,  and  <code>W</code>  is  the  group  of  <code>WF</code>  then <span>$N_W(V_ζ)/C_W(V_ζ)$</span>  is a reflection group in  its action on <span>$V_ζ$</span>. The function  <code>relative_degrees</code> returns the reflection degrees of this complex reflection group, which are a subset of those of <code>W</code>.</p><p>These   degrees  are   computed  by   an  invariant-theoretic  formula:  if <code>(d₁,ε₁),…,(dₙ,εₙ)</code>  are the generalized degrees of  <code>WF</code> they are the <code>dᵢ</code> such that <code>ζ^{dᵢ}=εᵢ</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,8)
E₈

julia&gt; relative_degrees(W,4)
4-element Vector{Int64}:
  8
 12
 20
 24</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Eigenspaces.jl#L68-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Eigenspaces.regular_eigenvalues" href="#Gapjm.Eigenspaces.regular_eigenvalues"><code>Gapjm.Eigenspaces.regular_eigenvalues</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>regular_eigenvalues(W)</code></p><p>Let <code>W</code> be a reflection group or a reflection coset. A root of unity <code>ζ</code> is a <em>regular eigenvalue</em> for <code>W</code> if some element of <code>W</code> has a <code>ζ</code>-eigenvector which   lies   outside   of   the   reflecting  hyperplanes.  The  function <code>regular_eigenvalues</code> returns the list of regular eigenvalues for <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; regular_eigenvalues(coxgroup(:G,2))
6-element Vector{Root1}:
   1
  -1
  ζ₃
 ζ₃²
  ζ₆
 ζ₆⁵

julia&gt; W=ComplexReflectionGroup(6)
G₆

julia&gt; L=twistings(W,[2])[2]
G₆₍₂₎=G₃‚₁‚₁[ζ₄]Φ′₄

julia&gt; regular_eigenvalues(L)
3-element Vector{Root1}:
    ζ₄
  ζ₁₂⁷
 ζ₁₂¹¹</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Eigenspaces.jl#L103-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Eigenspaces.eigenspace_projector" href="#Gapjm.Eigenspaces.eigenspace_projector"><code>Gapjm.Eigenspaces.eigenspace_projector</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>eigenspace_projector(WF,w[,d=1])</code></p><p>Let  <code>WF</code> be a reflection group or a reflection coset. Here <code>d</code> specifies a root  of unity <code>ζ</code>: either <code>d</code> is an integer and specifies <code>ζ=E(d)&#39; or is a fraction  smaller</code>a/b<code>with</code>0&lt;a&lt;b<code>and  specifies</code>ζ=E(b,a)&#39;, or is a <code>Root1</code>.  The function  returns the  unique <code>w</code>-invariant  projector on the <code>ζ</code>-eigenspace of <code>w</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; w=W(1:3...)
(1,12,3,2)(4,11,10,5)(6,9,8,7)

julia&gt; p=eigenspace_projector(W,w,1//4)
3×3 Matrix{Cyc{Rational{Int64}}}:
  (1+ζ₄)/4   ζ₄/2  (-1+ζ₄)/4
  (1-ζ₄)/4    1/2   (1+ζ₄)/4
 (-1-ζ₄)/4  -ζ₄/2   (1-ζ₄)/4

julia&gt; GLinearAlgebra.rank(p)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Eigenspaces.jl#L187-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Eigenspaces.position_regular_class" href="#Gapjm.Eigenspaces.position_regular_class"><code>Gapjm.Eigenspaces.position_regular_class</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>position_regular_class(WF,d=0)</code></p><p>Let  <code>WF</code> be a reflection group or a reflection coset. Here <code>d</code> specifies a root  of unity <code>ζ</code>:  either <code>d</code> is  a <code>Root1</code>, or  an integer and specifies <code>ζ=E(d)</code>  or is a fraction <code>a//b</code> with <code>0&lt;a&lt;b</code> and specifies <code>ζ=E(b,a)</code>. If omitted, <code>d</code> is taken to be <code>0</code>, specifying <code>ζ=1</code>. The root <code>ζ</code> should be a regular  eigenvalue  for  <code>WF</code>  (see  &quot;regular_eigenvalues&quot;).  The function returns  the index of the  conjugacy class of <code>WF</code>  which has a <code>ζ</code>-regular eigenvector.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,8)
E₈

julia&gt; position_regular_class(W,30)
65

julia&gt; W=ComplexReflectionGroup(6)
G₆

julia&gt; L=twistings(W,[2])[2]
G₆₍₂₎=G₃‚₁‚₁[ζ₄]Φ′₄

julia&gt; position_regular_class(L,7//12)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Eigenspaces.jl#L151-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Eigenspaces.split_levis" href="#Gapjm.Eigenspaces.split_levis"><code>Gapjm.Eigenspaces.split_levis</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>split_levis(WF,d=E(1)[,ad])</code></p><p>Let  <code>WF</code>  be  a  reflection  group  or  a  reflection  coset.  If <code>W</code> is a reflection group it is treated as the trivial coset &#39;Spets(W)&#39;.</p><p>Here  <code>d</code>  specifies  a  root  of  unity  <code>ζ</code>: either <code>d</code> is an integer and specifies  <code>ζ=E(d)</code>  or  is  a  fraction  <code>a/b</code>  with <code>0&lt;a&lt;b</code> and specifies <code>ζ=E(b,a)</code>. If omitted, <code>d</code> is taken to be <code>E(1)</code>, specifying <code>ζ=1</code>.</p><p>A  <em>Levi</em>  is  a  subcoset  of  the  form <code>W₁F₁</code> where <code>W₁</code> is a <em>parabolic subgroup</em> of <code>W</code>, that is the centralizer of some subspace of <code>V</code>, and <code>F₁∈ WF</code>.</p><p><code>split_levis</code> returns  a list  of representatives  of conjugacy  classes of <code>d</code>-split  Levis of <code>W</code>. A  <code>d</code>-split Levi is a  subcoset of <code>WF</code> formed of all  the  elements  which  act  by  <code>ζ</code>  on  a given subspace <code>V_ζ</code>. If the additional  argument <code>ad</code>  is given,  it returns  only those subcosets such that  the common  <code>ζ</code>-eigenspace of  their elements  is of  dimension <code>ad</code>. These  notions  make  sense  and  thus  are  implemented  for  any  complex reflection group.</p><p>In  terms of algebraic groups, an <code>F</code>-stable Levi subgroup of the reductive group  <code>𝐆</code>  is  <code>d</code>-split  if  and  only  if it is the centralizer of the <code>Φ_d</code>-part  of its center. When <code>d=1</code>, we get the notion of a <em>split</em> Levi, which  is the same as a Levi sugroup of an <code>F</code>-stable parabolic subgroup of <code>𝐆</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; split_levis(W,4)
2-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:
 A₃
 A₃₍₎=Φ₂Φ₄

julia&gt; W=spets(coxgroup(:D,4),Perm(1,2,4))
³D₄

julia&gt; split_levis(W,3)
3-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:
 ³D₄
 ³D₄₍₁₃₎=A₂Φ₃
 ³D₄₍₎=Φ₃²

julia&gt; W=coxgroup(:E,8)
E₈

julia&gt; split_levis(W,4,2)
3-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:
 E₈₍₃₂₄₅₎=D₄₍₁₃₂₄₎Φ₄²
 E₈₍₅₇₂₃₎=(A₁A₁)×(A₁A₁)Φ₄²
 E₈₍₃₁₅₆₎=²(A₂A₂)₍₁₄₂₃₎Φ₄²

julia&gt; split_levis(ComplexReflectionGroup(5))
4-element Vector{Spets{PRSG{Cyc{Rational{Int64}}, Int16}}}:
 G₅
 G₅₍₁₎=G₃‚₁‚₁Φ₁
 G₅₍₂₎=G₃‚₁‚₁Φ₁
 G₅₍₎=Φ₁²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Eigenspaces.jl#L266-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.cuspidal" href="#Gapjm.Uch.cuspidal"><code>Gapjm.Uch.cuspidal</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>cuspidal(uc::UnipotentCharacters[,e])</code></p><p>A  unipotent character <code>γ</code> of a  finite reductive group <code>𝐆</code> is <code>e</code>-cuspidal if  its  Lusztig  restriction  to  any  proper <code>e</code>-split Levi is zero. When <code>e==1</code>  (the default when  <code>e</code> is omitted)  we recover the  usual notion of cuspidal character. Equivalently the <code>Φₑ</code>-part of the generic degree of <code>γ</code> is equal to the <code>Φₑ</code>-part of the generic order of the adjoint group of <code>𝐆</code>. This  makes  sense  for  any  Spetsial  complex  reflection  group  and  is implemented for them.</p><p>The  function returns the list of indices of unipotent characters which are <code>e</code>-cuspidal.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; cuspidal(UnipotentCharacters(W))
1-element Vector{Int64}:
 14

julia&gt; cuspidal(UnipotentCharacters(W),6)
8-element Vector{Int64}:
  1
  2
  6
  7
  8
  9
 10
 12

julia&gt; cuspidal(UnipotentCharacters(ComplexReflectionGroup(4)),3)
4-element Vector{Int64}:
  3
  6
  7
 10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Uch.jl#L1259-L1299">source</a></section></article><h1 id="Classtypes"><a class="docs-heading-anchor" href="#Classtypes">Classtypes</a><a id="Classtypes-1"></a><a class="docs-heading-anchor-permalink" href="#Classtypes" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Gt.closed_subsystems" href="#Gapjm.Gt.closed_subsystems"><code>Gapjm.Gt.closed_subsystems</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>closed_subsystems(W)</code> </p><p>the Poset of closed subsystems of the root system of <code>W</code>. Each closed subsystem is represented by the list of indices of its positive roots.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; closed_subsystems(W)
1 2 3 4 5 6&lt;1 4&lt;4&lt;∅
1 2 3 4 5 6&lt;1 5 6&lt;1&lt;∅
1 2 3 4 5 6&lt;2 6&lt;6&lt;∅
1 2 3 4 5 6&lt;3 5&lt;5&lt;∅
1 4&lt;1
1 5 6&lt;6
1 5 6&lt;5
2 6&lt;2&lt;∅
3 5&lt;3&lt;∅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Gt.jl#L12-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Gt.ClassTypes" href="#Gapjm.Gt.ClassTypes"><code>Gapjm.Gt.ClassTypes</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ClassTypes(G[,p])</code></p><p><code>G</code>  should be a root  datum or a twisted  root datum representing a finite reductive  group <span>$𝐆 ^F$</span> and  <code>p</code> should be a  prime. The function returns the class types of <code>G</code> in characteristic <code>p</code> (in good characteristic if <code>p</code> is  omitted). Two elements  of <span>$𝐆 ^F$</span>  have the same  class type if their centralizers  are  conjugate.  If  <code>su</code>  is  the Jordan decomposition of an element  <code>x</code>, the class type of <code>x</code> is  determined by the class type of its semisimple part <code>s</code> and the unipotent class of <code>u</code> in <span>$C_𝐆 (s)$</span>.</p><p>The   function  <code>ClassTypes</code>  is  presently  only  implemented  for  simply connected  groups, where  <span>$C_𝐆 (s)$</span>  is connected.  This section is a bit experimental and may change in the future.</p><p><code>ClassTypes</code>  returns a  <code>struct</code> which  contains a  list of classtypes for semisimple  elements,  which  are  represented  by  <code>subspets</code>  and contain additionnaly information on the unipotent classes of <span>$C_𝐆 (s)$</span>.</p><p>Let us give some examples:</p><pre><code class="language-julia-repl hljs">julia&gt; t=ClassTypes(rootdatum(:sl,3))
ClassTypes(A₂,good characteristic)
    C_G(s)│ |C_G(s)|
──────────┼──────────
A₂₍₎=Φ₁²  │      Φ₁²
A₂₍₎=Φ₁Φ₂ │     Φ₁Φ₂
A₂₍₎=Φ₃   │       Φ₃
A₂₍₁₎=A₁Φ₁│   qΦ₁²Φ₂
A₂        │q³Φ₁²Φ₂Φ₃</code></pre><p>By   default,  only  information  about  semisimple  centralizer  types  is returned:   the type, and its generic order.</p><pre><code class="language-julia-rep1 hljs">julia&gt; xdisplay(t;unip=true)
ClassTypes(A₂,good characteristic)
    C_G(s)│    u |C_G(su)|
──────────┼────────────────
A₂₍₎=Φ₁²  │    1       Φ₁²
A₂₍₎=Φ₁Φ₂ │    1      Φ₁Φ₂
A₂₍₎=Φ₃   │    1        Φ₃
A₂₍₁₎=A₁Φ₁│   11    qΦ₁²Φ₂
          │    2       qΦ₁
A₂        │  111 q³Φ₁²Φ₂Φ₃
          │   21      q³Φ₁
          │    3       3q²
          │ 3_ζ₃       3q²
          │3_ζ₃²       3q²</code></pre><p>Here  we  have  displayed  information  on  unipotent  classes,  with their centralizer.</p><pre><code class="language-julia-rep1 hljs">julia&gt; xdisplay(t;nClasses=true)
ClassTypes(A₂,good characteristic)
    C_G(s)│       nClasses  |C_G(s)|
──────────┼──────────────────────────
A₂₍₎=.Φ₁² │(q²-5q+2q₃+4)/6       Φ₁²
A₂₍₎=.Φ₁Φ₂│       (q²-q)/2      Φ₁Φ₂
A₂₍₎=.Φ₃  │  (q²+q-q₃+1)/3        Φ₃
A₂₍₁₎=A₁Φ₁│       (q-q₃-1)    qΦ₁²Φ₂
A₂        │             q₃ q³Φ₁²Φ₂Φ₃</code></pre><p>Here  we have added information on how many semisimple conjugacy classes of <code>𝐆  ^F</code> have a given type. The  answer in general involves variables of the form <code>qₐ</code> which represent <code>gcd(q-1,a)</code>.</p><p>Finally an example in bad characteristic:</p><pre><code class="language-julia-rep1 hljs">julia&gt; t=ClassTypes(coxgroup(:G,2),2);xdisplay(t;nClasses=true)
ClassTypes(G₂,char. 2)
    C_G(s)│         nClasses     |C_G(s)|
──────────┼───────────────────────────────
G₂₍₎=.Φ₁² │(q²-8q+2q₃+10)/12          Φ₁²
G₂₍₎=.Φ₁Φ₂│        (q²-2q)/4         Φ₁Φ₂
G₂₍₎=.Φ₁Φ₂│        (q²-2q)/4         Φ₁Φ₂
G₂₍₎=.Φ₆  │    (q²-q-q₃+1)/6           Φ₆
G₂₍₎=.Φ₃  │    (q²+q-q₃+1)/6           Φ₃
G₂₍₎=.Φ₂² │ (q²-4q+2q₃-2)/12          Φ₂²
G₂₍₁₎=A₁Φ₂│       (q-q₃+1)/2       qΦ₁Φ₂²
G₂₍₁₎=A₁Φ₁│       (q-q₃-1)/2       qΦ₁²Φ₂
G₂₍₂₎=Ã₁Φ₂│              q/2       qΦ₁Φ₂²
G₂₍₂₎=Ã₁Φ₁│          (q-2)/2       qΦ₁²Φ₂
G₂        │                1 q⁶Φ₁²Φ₂²Φ₃Φ₆
G₂₍₁₅₎=²A₂│         (q₃-1)/2    q³Φ₁Φ₂²Φ₆
G₂₍₁₅₎=A₂ │         (q₃-1)/2    q³Φ₁²Φ₂Φ₃</code></pre><p>We  notice that if <code>q</code> is  a power of <code>2</code> such  that <code>q≡2 (mod 3)</code>, so that <code>q₃=1</code>,  some class types do not exist. We can see what happens by giving a specific value to <code>q₃</code>:</p><pre><code class="language-julia-rep1 hljs">julia&gt; xdisplay(t(;q_3=1);nClasses=true)
ClassTypes(G₂,char. 2) q₃=1
    C_G(s)│     nClasses     |C_G(s)|
──────────┼───────────────────────────
G₂₍₎=Φ₁²  │(q²-8q+12)/12          Φ₁²
G₂₍₎=Φ₁Φ₂ │    (q²-2q)/4         Φ₁Φ₂
G₂₍₎=Φ₁Φ₂ │    (q²-2q)/4         Φ₁Φ₂
G₂₍₎=Φ₆   │     (q²-q)/6           Φ₆
G₂₍₎=Φ₃   │     (q²+q)/6           Φ₃
G₂₍₎=Φ₂²  │   (q²-4q)/12          Φ₂²
G₂₍₁₎=A₁Φ₁│      (q-2)/2       qΦ₁²Φ₂
G₂₍₁₎=A₁Φ₂│          q/2       qΦ₁Φ₂²
G₂₍₂₎=Ã₁Φ₁│      (q-2)/2       qΦ₁²Φ₂
G₂₍₂₎=Ã₁Φ₂│          q/2       qΦ₁Φ₂²
G₂        │            1 q⁶Φ₁²Φ₂²Φ₃Φ₆</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Gt.jl#L95-L206">source</a></section></article><h1 id="Unipotent-Elements"><a class="docs-heading-anchor" href="#Unipotent-Elements">Unipotent Elements</a><a id="Unipotent-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Unipotent-Elements" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Urad" href="#Gapjm.Urad"><code>Gapjm.Urad</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This  module contains  functions for  computing with  unipotent elements of reductive  groups;  specifically  to  compute  with  elements  of unipotent radical  of a Borel subgroup of  a connected algebraic reductive group; the implementation of these functions was initially written by Olivier Dudas in GAP3.</p><p>The  unipotent radical of a  Borel subgroup is the  product in any order of root  subgroups associated  to the  positive roots.  We fix an order, which gives a canonical form to display elements and to compare them.</p><p>The  computations use the Steinberg relations between root subgroups, which come from the choice of a Chevalley basis of the Lie algebra. The reference we  follow is <a href="biblio.htm#Car72b">Carter1972, chapters 4 to 6</a>.</p><p>We  start with  a root  datum specified  by a  Weyl group  <code>W</code> and  build a <code>struct</code> which contains information about the maximal unipotent subgroup of the  corresponding reductive  group, that  is the  unipotent radical of the Borel subgroup determined by the positive roots.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,6)
E₆

julia&gt; U=UnipotentGroup(W)
UnipotentGroup(E₆)</code></pre><p>Now, if <code>α=roots(W,2)</code>, we construct the element <code>u_α(4)</code> of the root subgroup <code>u_α</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; U(2=&gt;4)
u2(4)</code></pre><p>If we do not specify the coefficient we make by default <code>u_α(1)</code>, so we have also:</p><pre><code class="language-julia-repl hljs">julia&gt; U(2)^4
u2(4)</code></pre><p>We can make more complicated elements:</p><pre><code class="language-julia-repl hljs">julia&gt; U(2=&gt;4)*U(4=&gt;5)
u2(4)u4(5)

julia&gt; U(2=&gt;4,4=&gt;5)
u2(4)u4(5)</code></pre><p>If the roots are not in order the element is normalized:</p><pre><code class="language-julia-repl hljs">julia&gt; U(4=&gt;5,2=&gt;4)
u2(4)u4(5)u8(-20)</code></pre><p>It is possible to display the decomposition of the roots in simple roots instead of their index:</p><pre><code class="language-julia-rep1 hljs">julia&gt; xdisplay(U(4=&gt;5,2=&gt;4);root=true)
u₀₁₀₀₀₀(4)u₀₀₀₁₀₀(5)u₀₁₀₁₀₀(-20)</code></pre><p>The coefficients in the root subgroups can be elements of arbitrary rings. Here is an example using <code>Mvp</code>&#39;s:</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,8);U=UnipotentGroup(W)
UnipotentGroup(E₈)

julia&gt; u=U(map(i-&gt;i=&gt;Z(2)*Mvp(Symbol(&quot;x&quot;,Char(i+0x2080))),1:8)...)
u1(x₁)u2(x₂)u3(x₃)u4(x₄)u5(x₅)u6(x₆)u7(x₇)u8(x₈)</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; cut(repr(u^16;context=rio(root=true)),before=&quot;u&quot;,width=60)
u₂₂₃₄₃₂₁₀(x₁²x₂²x₃³x₄⁴x₅³x₆²x₇)
u₁₂₃₄₃₂₁₁(x₁x₂²x₃³x₄⁴x₅³x₆²x₇x₈)
u₁₂₂₄₃₂₂₁(x₁x₂²x₃²x₄⁴x₅³x₆²x₇²x₈)
u₁₂₂₃₃₃₂₁(x₁x₂²x₃²x₄³x₅³x₆³x₇²x₈)
u₂₂₃₄₃₂₁₁(x₁²x₂²x₃³x₄⁴x₅³x₆²x₇x₈)
u₁₂₂₄₃₃₂₁(x₁x₂²x₃²x₄⁴x₅³x₆³x₇²x₈)
u₁₂₂₄₄₃₂₁(x₁x₂²x₃²x₄⁴x₅⁴x₆³x₇²x₈)
u₂₂₃₄₃₃₂₁(x₁²x₂²x₃³x₄⁴x₅³x₆³x₇²x₈)
u₁₂₃₄₄₃₂₁(x₁x₂²x₃³x₄⁴x₅⁴x₆³x₇²x₈)
u₂₂₃₄₄₃₂₁(x₁²x₂²x₃³x₄⁴x₅⁴x₆³x₇²x₈)
u₂₃₃₅₄₃₂₁(x₁²x₂³x₃³x₄⁵x₅⁴x₆³x₇²x₈)
u₂₂₄₅₄₃₂₁(x₁²x₂²x₃⁴x₄⁵x₅⁴x₆³x₇²x₈)
u₂₃₄₆₅₄₃₂(x₁²x₂³x₃⁴x₄⁶x₅⁵x₆⁴x₇³x₈²)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; u^32
()</code></pre><p>The  above computation shows  that in characteristic  2 the exponent of the unipotent  group of <code>E₈</code> is 32. More precisely, squaring doubles the height of  the involved roots, so in the above <code>u¹⁶</code> involves only roots of height 16 or more.</p><p>Various  actions are  defined on  unipotent elements.  Elements of the Weyl group  act (through certain representatives) as long as no root subgroup is in their inversion set:</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; U=UnipotentGroup(W);@Mvp x,y

julia&gt; u=U(1=&gt;x,3=&gt;y)
u1(x)u3(y)

julia&gt; u^W(2,1)
u4(y)u5(x)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; u^W(1)
ERROR: u1(x)u3(y) should have no coefficient on root 1</code></pre><p>Semisimple elements act by conjugation:</p><pre><code class="language-julia-repl hljs">julia&gt; s=SemisimpleElement(W,[E(3),2])
SemisimpleElement{Cyc{Int64}}: &lt;ζ₃,2&gt;

julia&gt; u^s
u1(ζ₃x)u3(2ζ₃y)</code></pre><p>As well as unipotent elements:</p><pre><code class="language-julia-repl hljs">julia&gt; u^U(2)
u1(x)u3(x+y)u4(-x-2y)u5(x+3y)u6(x²+3xy+3y²)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Urad.jl#L1-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Urad.UnipotentGroup" href="#Gapjm.Urad.UnipotentGroup"><code>Gapjm.Urad.UnipotentGroup</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A  <code>struct UnipotentGroup</code>  <code>U</code> represents  the unipotent  radical <code>𝐔</code> of a Borel subgroup of the reductive group with Weyl group <code>U.W</code>.</p><p>See   <a href="biblio.htm#Car72b">Carter1972,  section  4.2</a>  for  details  on  the following.  A Chevalley basis  of the Lie  algebra of <code>𝐔</code>  is a basis <code>eᵣ</code>, where   each  <code>eᵣ</code>  is  in  the  corresponding  root  subspace,  such  that <code>[eᵣ,eₛ]=Nᵣₛ e_{r+s}</code> for some integer constants <code>Nᵣₛ</code>.</p><p>To  build such  a basis,  let <code>&lt;</code>  be a  total order  on the positive roots induced  by a total order on the ambient vector space (the default order of roots  of <code>W</code> in this package  is an example; we use  it in this module). A pair <code>(r,s)</code> of roots is <em>special</em> if <code>0&lt;r&lt;s</code> and <code>r+s</code> is a root.</p><p>Constants  <code>Cᵣₛᵢⱼ</code> are defined, see <a href="biblio.htm#Car72b">Carter1972, 5.2.3</a>, by</p><p><span>$u_s(u)u_r(t)=u_r(t)u_s(u)\prod_{i,j&gt;0}u_{ir+js}(C_{rsij}(-t)^iu^j)$</span></p><p>Where  <code>ir+js</code> runs over the positive  integral combinations of <code>r</code> and <code>s</code> which are roots, taken in lexicographic order.</p><p>The fields of <code>struct Unipotent Group</code> are:</p><ul><li><code>W</code>:         the underlying Weyl group</li><li><code>specialPairs</code>:   triples of indices of the roots <code>(r,s,r+s)</code>               where <code>(r,s)</code> is special, ordered by <code>(r+s,r)</code>, followed               by the triples <code>(s,r,r+s)</code> for the same list.</li><li><code>ns</code>:         The number of   <code>specialPairs</code> where <code>r&lt;s</code>.</li><li><code>N</code>:          the constants <code>Nᵣₛ</code> for <code>specialPairs</code></li><li><code>order</code>:      the order on positive roots used to normalize products</li><li><code>commutatorConstants</code>: stores the <code>Cᵣₛᵢⱼ</code> by storing for each special pair                  <code>(r,s)</code> the list of quadruples <code>[i,j,ir+js,Cᵣₛᵢⱼ]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Urad.jl#L151-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Urad.reorder" href="#Gapjm.Urad.reorder"><code>Gapjm.Urad.reorder</code></a> — <span class="docstring-category">Function</span></header><section><div><p>&#39;reorder(U,l[,order])&#39;</p><p>This  function  takes  a  list  of  pairs  &#39;r=&gt;c&#39;  representing a unipotent element,  where &#39;r&#39;  is a  root and  &#39;c&#39; the corresponding coefficient, and puts  it in  canonical form,  reordering the  terms to agree with &#39;U.order&#39; using  the commutation  relations. If  a second  argument is given, this is used instead of &#39;U.order&#39;.</p><pre><code class="language-julia-repl hljs">julia&gt; U=UnipotentGroup(coxgroup(:G,2))
UnipotentGroup(G₂)

julia&gt; l=reorder(U,[2=&gt;4,1=&gt;2])
6-element Vector{Pair{Int64, Int64}}:
 1 =&gt; 2
 2 =&gt; 4
 3 =&gt; -8
 4 =&gt; 32
 5 =&gt; -128
 6 =&gt; 512

julia&gt; reorder(U,l,6:-1:1)
2-element Vector{Pair{Int64, Int64}}:
 2 =&gt; 4
 1 =&gt; 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Urad.jl#L407-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Urad.abelianpart" href="#Gapjm.Urad.abelianpart"><code>Gapjm.Urad.abelianpart</code></a> — <span class="docstring-category">Function</span></header><section><div><p>&#39;abelianpart(u::UnipotentElement)&#39;</p><p>If  <code>𝐔</code> is the unipotent subgroup and <code>D(𝐔)</code> its derived subgroup, this function   returns  the  projection   of  the  unipotent   element  &#39;u&#39;  on <code>𝐔/D(𝐔)</code>, that is its coefficients on the simple roots.</p><pre><code class="language-julia-repl hljs">julia&gt; U=UnipotentGroup(coxgroup(:G,2));@Mvp x,y

julia&gt; u=U(2=&gt;y,1=&gt;x)
u1(x)u2(y)u3(-xy)u4(xy²)u5(-xy³)u6(2x²y³)

julia&gt; abelianpart(u)
u1(x)u2(y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Urad.jl#L497-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.decompose" href="#Gapjm.Chars.decompose"><code>Gapjm.Chars.decompose</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>decompose(w,u)</code></p><p><code>u</code>  should be a unipotent element and  <code>w</code> an element of the corresponding Weyl  group.  If  <code>𝐔</code>  is  the  unipotent  radical  of  the  Borel subgroup determined  by the  positive roots,  and <code>𝐔⁻</code>  the unipotent radical of the opposite  Borel, this  function decomposes  <code>u</code> into  its component in <code>𝐔 ∩ ʷ𝐔⁻</code> and its component in <code>𝐔 ∩ ʷ𝐔</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; U=UnipotentGroup(W);@Mvp x,y

julia&gt; u=U(2=&gt;y,1=&gt;x)
u1(x)u2(y)u3(-xy)u4(xy²)u5(-xy³)u6(2x²y³)

julia&gt; decompose(W(1),u)
2-element Vector{UnipotentElement{Mvp{Int64, Int64}}}:
 u1(x)
 u2(y)u3(-xy)u4(xy²)u5(-xy³)u6(2x²y³)

julia&gt; decompose(W(2),u)
2-element Vector{UnipotentElement{Mvp{Int64, Int64}}}:
 u2(y)
 u1(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Urad.jl#L517-L545">source</a></section><section><div><p><code>decompose(ct::CharTable,c::Vector)</code> </p><p>decompose character <code>c</code> (given by its values on conjugacy classes)  on irreducible characters as given by <code>CharTable</code> <code>ct</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L951-L956">source</a></section></article><h1 id="Decomposition-Matrices"><a class="docs-heading-anchor" href="#Decomposition-Matrices">Decomposition Matrices</a><a id="Decomposition-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Decomposition-Matrices" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.decomposition_matrix" href="#Gapjm.Chars.decomposition_matrix"><code>Gapjm.Chars.decomposition_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>decomposition_matrix(W,p)</code></p><p>This provides an interface to some decomposition matrices for Weyl groups available in the Chevie library: those for <code>E₆, E₇, E₈</code> for <code>p=2,3,5,7</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/Chars.jl#L1498-L1503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.generic_decomposition_matrix" href="#Gapjm.generic_decomposition_matrix"><code>Gapjm.generic_decomposition_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>generic_decomposition_matrix(W,d)</code></p><p>This function obtains the <code>Φ_d</code> decomposition matrix for the reductive group specified by the Coxeter group or coset <code>W</code> form the package <code>GenDecMats</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=rootdatum(:psu,5)
psu₅</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; generic_decomposition_matrix(W,13)
!!! Φ-decomposition matrices available for ²A₄: Φ₁₀ Φ₂ Φ₄ Φ₆</code></pre><pre><code class="language-julia-repl hljs">julia&gt; generic_decomposition_matrix(W,10)
Φ₁₀-decomposition matrix for psu₅
      │ps 21 ps ps ps 2111 11111
──────┼──────────────────────────
2.    │ 1  .  .  .  .    .     .
²A₂:2 │ .  1  .  .  .    .     .
11.   │ .  .  1  .  .    .     .
1.1   │ 1  .  .  1  .    .     .
.2    │ .  .  .  .  1    .     .
²A₂:11│ .  1  .  .  .    1     .
.11   │ .  .  .  1  .    .     1</code></pre><p>The matrix itself is stored in the field <code>.scalar</code> of the returned <code>struct</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/gendec.jl#L13-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.InducedDecompositionMatrix" href="#Gapjm.InducedDecompositionMatrix"><code>Gapjm.InducedDecompositionMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>InducedDecompositionMatrix(R,W,d)</code></p><p>returns the induced from the Levi <code>L</code> to the reductive group <code>W</code> of the generic <code>Φ_d</code> decomposition matrix of <code>L</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=rootdatum(:psu,6)
psu₆

julia&gt; L=reflection_subgroup(W,[1,2,4,5])
psu₆₍₁₂₅₄₎=(A₂A₂)₍₁₂₄₃₎Φ₁

julia&gt; InducedDecompositionMatrix(L,W,6)
Induced Φ₆-decomposition matrix from psu₆₍₁₂₅₄₎=(A₂A₂)₍₁₂₄₃₎Φ₁ to psu₆

    │ps ps A₂
────┼─────────
²A₅ │ .  .  .
.3  │ 1  .  .
3.  │ 1  .  .
.21 │ 1  1  .
1.2 │ 2  1  .
21. │ 1  1  .
2.1 │ 2  1  .
.111│ .  1  1
111.│ .  1  1
1.11│ 1  2  1
11.1│ 1  2  1</code></pre><p>The matrix itself is stored in the field <code>.scalar</code> of the returned <code>struct</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/ad537cd6906c847d344d8684f7849c43d4587579/src/gendec.jl#L128-L159">source</a></section></article><h1 id="Dictionary-from-GAP3/Chevie"><a class="docs-heading-anchor" href="#Dictionary-from-GAP3/Chevie">Dictionary from GAP3/Chevie</a><a id="Dictionary-from-GAP3/Chevie-1"></a><a class="docs-heading-anchor-permalink" href="#Dictionary-from-GAP3/Chevie" title="Permalink"></a></h1><p>The dictionary from GAP3/Chevie is as follows:</p><pre><code class="nohighlight hljs">AbelianGenerators                           abelian_gens
AlgebraicCentre                             algebraic_centre
AlmostCharacter                             AlmostChar
Arrangements                                arrangements
AsFraction                                  fraction
AsReflection                                reflection
AsRootOfUnity                               Root1
AssociatedPartition                         conjugate_partition
AsWord                                      word
AsymptoticAlgebra                           AsymptoticAlgebra
BadPrimes                                   badprimes
BaseIntMat                                  baseInt
BetaSet                                     βset
BigCellDecomposition                        bigcell_decomposition
Binomial                                    binomial
BipartiteDecomposition                      bipartite_decomposition
BlocksMat                                   blocks
Braid                                       BraidMonoid
BraidMonoid                                 BraidMonoid
BraidRelations                              braid_relations
BrieskornNormalForm                         Brieskorn_normal_form
Bruhat                                      bruhatless
BruhatPoset                                 Poset
BruhatSmaller                               bruhatless
CartanMat(&quot;A&quot;,5)                            cartan(:A,5)
CartanMatFromCoxeterMatrix                  cartan
Cartesian                                   cartesian
CartesianAt                                 lin2cart
Catalan                                     catalan
CentralizerGenerators                       centralizer_gens
CharFFE(x)                                  field(x).p
CharNames                                   charnames
CharParams(W)                               charinfo(W)[:charparams]
CharRepresentationWords                     traces_words_mats
CharTable                                   CharTable
CheckHeckeDefiningRelations                 isrepresentation
ChevieCharInfo                              charinfo
ChevieClassInfo                             classinfo
ClassName                                   see ClassNames
ClassTypes                                  ClassTypes
Coefficient(p,i)                            p[i]
CollectBy(l,f)                              collectby(f,l)
Collected                                   tally
Combinations                                combinations
Comm                                        comm
ComplementIntMat                            complementInt
ComplexConjugate                            conj
ComplexReflectionGroup                      ComplexReflectionGroup
Compositions                                compositions
Concatenation(s::Vector...)                 vcat(s...)
ConcatenationString(s...)                   prod(s)
ConjugacySet(b[,F][,type])                  conjcat(b[,F],ss=type).obj
ConjugatePartition                          conjugate_partition
CoxeterCoset                                spets
CoxeterElements(W[,l])                      elements(W[,l])
CoxeterGroup(&quot;A&quot;,5)                         coxgroup(:A,5)
CoxeterGroupByCartanMatrix(C)               gencox(C)
CoxeterGroupByCoxeterMatrix(C)              gencox(cartan(C))
CoxeterGroupHyperoctaedralGroup(n)          CoxHyperoctaedral(n)
CoxeterGroupSymmetricGroup(n)               CoxSym(n)
CoxeterLength(W,w)                          length(W,w)
CoxeterMatrix                               coxmat
CoxeterMatrixFromCartanMat                  coxmat
CoxeterSubCoset                             subspets
CoxeterWord(W,w)                            word(W,w)
CoxeterWords(W[,l])                         word.(Ref(W),elements(W[,l]))
CuspidalPairs                               cuspidal_data
CuspidalUnipotentCharacters(W[,d])          cuspidal(UnipotentCharacters(W)[,d])
Cycle                                       orbit
Cycles                                      orbits
CyclotomicModP(c,p)                         FFE{p}(c)
CyclotomicPolynomial(R,i)                   cyclotomic_polynomial(i)
CycPol                                      CycPol
CycPolFakeDegreeSymbol                      fegsymbol
CycPolGenericDegreeSymbol                   gendeg_symbol
CycPolUnipotentDegrees                      CycPolUnipotentDegrees
DecomposedMat                               diagblocks
DefectSymbol                                defectsymbol
Degree(p)                                   degree(p)
DegreeFFE(x)                                field(x).n
DeligneLusztigCharacter                     DLChar
DeligneLusztigLefschetz                     DLLeftschetz
DescribeInvolution                          describe_involution
DetPerm(W)                                  vec(detPerm(W))
Digits                                      digits
Dominates                                   dominates
DrinfeldDouble                              drinfeld_double
Drop                                        deleteat!
DualBraid                                   DualBraidMonoid
DualBraidMonoid                             DualBraidMonoid
EigenspaceProjector                         eigenspace_projector
EigenvaluesMat                              eigmat
Elements                                    elements
ElementWithInversions(W,l)                  with_inversions(W,l)
EltBraid                                    image
EltWord(W,w)                                W(w...)
ER                                          root
ExteriorPower                               exterior_power
FactorizedSchurElement                      FactorizedSchurElement
FactorizedSchurElements                     FactorizedSchurElements
FakeDegree                                  fakedegree
FakeDegrees                                 fakedegrees
FamiliesClassical                           FamiliesClassical
Family                                      Family
FamilyImprimitive                           family_imprimitive
FiniteCoxeterTypeFromCartanMat(m)           type_cartan(m)
FirstLeftDescending(W,w)                    firstleftdescent(W,w)
ForEachCoxeterWord(W,f)                     for w in W f(word(W,w)) end
ForEachElement(W,f)                         for w in W f(w) end
FormatTable                                 showtable
Frobenius                                   Frobenius
FullSymbol                                  fullsymbol
FundamentalGroup                            fundamental_group
FusionAlgebra                               fusion_algebra
FusionConjugacyClasses                      fusion_conjugacy_classes
GaloisCyc                                   galois
GarsideAlpha                                α
GarsideWords                                elements
GcdPartitions                               gcd_partitions
GcdRepresentation(x,y)                      gcdx(x,y)[2:3]
GenericOrder                                generic_order
GenericSign                                 generic_sign
GetRoot                                     root
GraphAutomorphisms                          graph_automorphisms
Hasse                                       hasse
Hecke                                       hecke
HeckeCentralMonomials                       central_monomials
HeckeCharValues                             char_values
HeckeClassPolynomials                       class_polynomials
HeckeReflectionRepresentation               reflrep
HermiteNormalFormIntegerMat                 hermite
HermiteNormalFormIntegerMatTransforms(m)    hermite(m;transforms=true)
HighestPowerFakeDegrees(W)                  charinfo(W)[:B]
HighestPowerFakeDegreeSymbol                degree_fegsymbol
HighestPowerGenericDegrees(W)               charinfo(W)[:A]
HighestPowerGenericDegreeSymbol             degree_gendeg_symbol
HyperplaneOrbits                            hyperplane_orbits
ICCTable                                    ICCTable
Incidence                                   incidence
IndependentLines(M)                         echelon(M)[2]
IndependentRoots                            independent_roots
InducedLinearForm                           induced_linear_form
InductionTable                              InductionTable
Inherit                                     look at merge for hashes
IntermediateGroup                           intermediate_group
Intersection                                intersect
IntFFE                                      Int
IntListToString                             joindigits
InvariantForm                               invariant_form
Invariants                                  invariants
Inversions                                  inversions
IsAbelian                                   isabelian
IsCycPol(p)                                 p isa CycPol
IsFamily(f)                                 f isa Family
IsFFE(x)                                    x isa FFE
IsIsolated                                  is_isolated
IsJoinLattice                               is_join_lattice
IsLeftDescending(W,w,i)                     isleftdescent(W,w,i)
IsMeetLattice                               is_meet_lattice
IsomorphismType                             isomorphism_type
IsParabolic                                 is_parabolic
IsSubset(a,b)                               issubset(b,a)
IsUnipotentElement(x)                       x isa UnipotentElement
JInductionTable                             JInductionTable
jInductionTable                             jInductionTable
Join                                        join
KazhdanLusztigPolynomial                    KLPol
KroneckerProduct                            kron
LargestMovedPoint                           largest_moved_point
last                                        ans
LcmPartitions                               lcm_partitions
LeadingCoefficient(p)                       p[end]
LeftCell                                    LeftCell
LeftCells                                   LeftCells
LeftDescentSet(W,w)                         leftdescents(W,w)
LeftDivisorsSimple                          left_divisors
LeftGcd                                     leftgcd
LeftLcm                                     leftlcm
LinearExtension                             linear_extension
List(ConjugacyClasses(G),Representative)    classreps(G)
ListBlist(a,b)                              a[b]
ListPerm(p)                                 vec(p)
LogFFE                                      log
LongestCoxeterElement(W)                    longest(W)
LongestCoxeterWord(W)                       word(W,longest(W))
LowestPowerFakeDegrees(W)                   charinfo(W)[:b]
LowestPowerFakeDegreeSymbol                 valuation_fegsymbol
LowestPowerGenericDegrees(W)                charinfo(W)[:a]
LowestPowerGenericDegreeSymbol              valuation_gendeg_symbol
Lusztigaw                                   Lusztigaw
LusztigAw                                   LusztigAw
LusztigInduction                            LusztigInduce
LusztigInductionTable                       LusztigInductionTable
LusztigRestriction                          LusztigRestrict
M.ToOrdinary(i)                             B(M,i)
MappingPermListList                         mappingPerm
MatStab                                     stab_onmats
MatXPerm(W,p)                               reflrep(W,p)
MatYPerm                                    matY
MovedPoints                                 support
Mvp(&quot;x&quot;)                                    Mvp(:x)
NrArrangements                              narrangements
NrCombinations                              ncombinations
NrConjugacyClasses                          nconjugacy_classes
NrDrinfeldDouble                            ndrinfeld_double
NrPartitions                                npartitions
NrPartitionsSet                             npartitions_set
NrPartitionTuples                           npartition_tuples
NrRestrictedPartitions                      nrestrictedpartitions
NullspaceIntMat                             lnullspaceInt
OnFamily(f,p::Int)                          galois(f,p)
OnFamily(f,p::Perm)                         f^p
OnMatrices(m,p)                             ^(m,p;dims=(1,2))
OnPolynomials(m,p)                          p^m
OnSets(s,g)                                 unique!(sort(s.^g))
OnTuples(l,p)                               l.^p
OrderedPartitions                           compositions
OrderFFE                                    order
OrderMod(n,m)                               order(Mod{m}(n))
ParabolicRepresentatives                    parabolic_reps
PartBeta                                    partβ
Partition                                   partition
Partitions                                  partitions
PartitionsSet                               partitions_set
PartitionTuples                             partition_tuples
PermCosetsSubgroup(H,W)                     D=vcat(reduced(H,W)...);map(s-&gt;Perm(reduced.(Ref(H),D.*s),D),gens(W))
PermList(v)                                 Perm(v)
PermListList(l1,l2)                         Perm(l1,l2)
PermMatMat                                  Perm_onmats
PermMatX                                    PermX
PermutationMat(p,dim)                       Matrix(p,dim)
Permuted(v,p)                               v^p
PermutedByCols(m,p)                         ^(m,p;dims=2)
Poset                                       Poset
Position(l,x)                               findfirst(==(x),l)
PositionCartesian                           cart2lin
PositionCartesian(a,b)                      LinearIndices(reverse(Tuple(a)))[CartesianIndices(Tuple(b))]
PositionClass                               position_class
PositionDet                                 charinfo(W)[:positionDet]
PositionId                                  charinfo(W)[:positionId]
PositionRegularClass                        position_regular_class
Presentation                                Presentation
PrintDiagram(W)                             Diagram(W)
ProportionalityCoefficient(v,w)             ratio(v,w)
QuasiIsolatedRepresentatives                QuasiIsolatedRepresentatives
QuoInt                                      div
Rank                                        rank
RankSymbol                                  ranksymbol
ReducedCoxeterWord(W,w)                     word(W,W(w...))
ReducedExpressions(W,w)                     words(W,w)
ReducedInRightCoset(W,w)                    reduced(W,w)
ReducedRightCosetRepresentatives(W,H)       reduced(H,W)
Reflection                                  reflection
ReflectionCharacter                         reflchar
ReflectionCoDegrees(W)                      codegrees(W)
ReflectionDegrees(W)                        degrees(W)
ReflectionEigenvalues                       refleigen
ReflectionGroup                             reflection_group
ReflectionLength(W,w)                       reflength(W,w)
Reflections                                 reflections
ReflectionSubgroup                          reflection_subgroup
ReflectionType                              refltype
RegularEigenvalues                          regular_eigenvalues
RelativeDegrees                             relative_degrees
RelativeGroup                               relative_group
Replace                                     replace
Representations                             representations
RepresentativeConjugation(b,b&#39;[,F][,type])  conjugating_elt(b,b&#39;[,F],ss=type)
RepresentativeDiagonalConjugation           diagconj_elt
RepresentativeOperation                     transporting_elt
RepresentativeRowColPermutation             Perm_rowcolmat
Restricted                                  restricted
RestrictedPartitions                        restrictedpartitions
RestrictedPerm(p,d)                         restricted(p,d)
Reversed                                    reverse
RightDescentSet(W,w)                        rightdescents(W,w)
RightGcd                                    rightgcd
RightLcm                                    rightlcm
RootDatum                                   rootdatum
RootsCartan(m)                              roots(m)
Rotation(v,i)                               circshift(v,-i)
Rotations(v)                                circshift.(Ref(v),length(v):-1:1)
ScalarProduct                               scalarproduct
ScalMvp                                     scalar
SchurElements                               schur_elements
SchurFunctor                                schur_functor
SemisimpleCentralizerRepresentatives        SScentralizer_reps
SemisimpleElement                           SS
SemisimpleRank                              semisimplerank
SemisimpleSubgroup                          torsion_subgroup
ShiftBeta                                   shiftβ
ShrinkGarsideGeneratingSet                  shrink
SignedMatStab                               sstab_onmats
SignedPerm                                  SPerm
SignedPermListList                          SPerm
SignedPermMatMat                            SPerm_onmats
Size(W)                                     length(W)
SmallestMovedPoint                          smallest_moved_point
SmithNormalFormIntegerMat                   smith
SmithNormalFormIntegerMatTransforms(m)      smith(m;transforms=true)
SolutionMat                                 solutionmat
SpecialPieces                               special_pieces
Spets                                       spets
SplitLevis                                  split_levis
StandardParabolic                           standard_parabolic
StandardParabolicClass                      standard_parabolic_class
StructureRationalPointsConnectedCentre      StructureRationalPointsConnectedCentre
SubSpets                                    subspets
SubTorus                                    SubTorus
SumIntersectionMat(m,n)                     (sum_rowspace(m,n),intersect_rowspace(m,n))
Symbols                                     HasType.BDSymbols
SymbolsDefect(e,r,def,ct)                   symbols(e,r,ct,def)
SymmetricDifference                         symdiff
SymmetricPower                              symmetric_power
Tableaux                                    tableaux
Torus                                       torus
TorusOrder                                  torus_order
TransitiveClosure                           transitive_closure
Transporter                                 transporter
TransposedMat                               permutedims
Transversals                                related to transversals
TriangulizeMat                              echelon!
Twistings                                   twistings
TwoTree(m)                                  twotree(m)
UnipotentAbelianPart                        abelianpart
UnipotentCharacter                          UniChar
UnipotentCharacters                         UnipotentCharacters
UnipotentClasses                            UnipotentClasses
UnipotentDecompose                          decompose
UnipotentDegrees(W,q)                       degrees(UnipotentCharacters(W),q)
UnipotentGroup                              UnipotentGroup
UnorderedTuples                             submultisets
Valuation(p)                                valuation(p)
Value(p,x)                                  p(x)
W.matgens                                   reflrep(W)
W.matgens[i]                                reflrep(W,i)
W.N                                         nref(W)
W.orbitRepresentative                       simple_reps(W)
W.orbitRepresentativeElements[i]            simple_conjugating(W,i)
W.rootInclusion                             inclusion(W)
W.rootLengths                               rootlengths(W)
W.rootRestriction                           restriction(W)
W.roots                                     W.rootdec
W.simpleCoroots                             coroots(W,1:ngens(W))
W.simpleRoots                               roots(W,1:ngens(W))
WeightInfo                                  weightinfo
WGraph                                      Wgraph
WGraphToRepresentation                      WGraphToRepresentation</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Thursday 14 April 2022 19:21">Thursday 14 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
