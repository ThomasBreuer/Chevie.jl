<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gapjm.jl Documentation · Gapjm.jl documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gapjm.jl documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Gapjm.jl Documentation</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Perms.jl-Documentation-1">Perms.jl Documentation</a></li><li class="toplevel"><a class="toctext" href="#Groups.jl-Documentation-1">Groups.jl Documentation</a></li><li class="toplevel"><a class="toctext" href="#PermGroups.jl-Documentation-1">PermGroups.jl Documentation</a></li><li class="toplevel"><a class="toctext" href="#Cycs.jl-Documentation-1">Cycs.jl Documentation</a></li><li class="toplevel"><a class="toctext" href="#Pols.jl-Documentation-1">Pols.jl Documentation</a></li><li class="toplevel"><a class="toctext" href="#CoxGroups.jl-Documentation-1">CoxGroups.jl Documentation</a></li><li class="toplevel"><a class="toctext" href="#Weyl.jl-Documentation-1">Weyl.jl Documentation</a></li><li class="toplevel"><a class="toctext" href="#Hecke.jl-Documentation-1">Hecke.jl Documentation</a></li><li class="toplevel"><a class="toctext" href="#KL.jl-Documentation-1">KL.jl Documentation</a></li><li class="toplevel"><a class="toctext" href="#Garside.jl-Documentation-1">Garside.jl Documentation</a></li><li class="toplevel"><a class="toctext" href="#Chars.jl-Documentation-1">Chars.jl Documentation</a></li><li class="toplevel"><a class="toctext" href="#Uch.jl-Documentation-1">Uch.jl Documentation</a></li><li class="toplevel"><a class="toctext" href="#Ucl.jl-Documentation-1">Ucl.jl Documentation</a></li><li class="toplevel"><a class="toctext" href="#HasType.jl-Documentation-1">HasType.jl Documentation</a></li><li class="toplevel"><a class="toctext" href="#Symbols.jl-Documentation-1">Symbols.jl Documentation</a></li><li class="toplevel"><a class="toctext" href="#Util.jl-Documentation-1">Util.jl Documentation</a></li><li class="toplevel"><a class="toctext" href="#Cycpols.jl-Documentation-1">Cycpols.jl Documentation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Gapjm.jl Documentation</a></li></ul><a class="edit-page" href="https://github.com/jmichel7/Gapjm.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Gapjm.jl Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Gapjm.jl-Documentation-1" href="#Gapjm.jl-Documentation-1">Gapjm.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm" href="#Gapjm"><code>Gapjm</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>This  is  my  effort  porting  GAP  code  to Julia, specifically the Chevie package  of GAP3 plus the minimal other GAP functionality needed for Chevie to   work:  Cyclotomics,  Permutations,   Laurent  polynomials,  and  basic permutation group operations.</p><p>I am rather new to Julia, git and github so I am not even sure this package is  properly constituted; I did not try yet to register it. If you are more competent  that me and see anything to  be improved in this package, please write me or make a pull request.</p><p><strong>Installing</strong></p><p>To install this package, at the Julia command line:</p><ul><li>enter package mode with ]</li><li>do the command</li></ul><pre><code class="language-none">(v1.0) pkg&gt; add &quot;https://github.com/jmichel7/Gapjm.jl&quot;</code></pre><ul><li>exit package mode with backspace and then do </li></ul><pre><code class="language-none">julia&gt; using Gapjm</code></pre><p>and you are set up.</p><p>To update later to the latest version, do</p><pre><code class="language-none">(v1.0) pkg&gt; update &quot;https://github.com/jmichel7/Gapjm.jl&quot;</code></pre><p>The package currently contains:</p><ul><li>infrastructure: permutations,  cyclotomic numbers,  Laurent polynomials.</li></ul><p>There  are also  permutation groups,  for which  I have  often replaced the proper  algorithms of GAP by naive but  easy to write methods only suitable for  small groups (sufficient for the rest of the package but maybe not for your needs).</p><ul><li>ported from  Chevie:  Weyl  groups,  Coxeter  groups,  Hecke  algebras,</li></ul><p>Kazhdan-Lusztig   polynomials,  braid  and   Garside  groups  and  monoids, factorisations into cyclotomic polynomials, character tables of Weyl groups and  Hecke algebras, Unipotent characters  of Spetses, unipotent classes of reductive groups.</p><p>The  code for infrastructure  is often competitive  with GAP, despite being much  shorter (often 100 lines of Julia replace 1000 lines of C); I am sure there  are more optimisations possible. Any comments about the code and the design  are welcome. The code for Chevie  is often 10 times faster than the GAP3 Chevie (after the maddeningly long compilation time on first execution).</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Gapjm.jl#L1-L52">source</a></section><ul><li><a href="#Gapjm.jl-Documentation-1">Gapjm.jl Documentation</a></li><li><a href="#Perms.jl-Documentation-1">Perms.jl Documentation</a></li><li><a href="#Groups.jl-Documentation-1">Groups.jl Documentation</a></li><li><a href="#PermGroups.jl-Documentation-1">PermGroups.jl Documentation</a></li><li><a href="#Cycs.jl-Documentation-1">Cycs.jl Documentation</a></li><li><a href="#Pols.jl-Documentation-1">Pols.jl Documentation</a></li><li><a href="#CoxGroups.jl-Documentation-1">CoxGroups.jl Documentation</a></li><li><a href="#Weyl.jl-Documentation-1">Weyl.jl Documentation</a></li><li><a href="#Hecke.jl-Documentation-1">Hecke.jl Documentation</a></li><li><a href="#KL.jl-Documentation-1">KL.jl Documentation</a></li><li><a href="#Garside.jl-Documentation-1">Garside.jl Documentation</a></li><li><a href="#Chars.jl-Documentation-1">Chars.jl Documentation</a></li><li><a href="#Uch.jl-Documentation-1">Uch.jl Documentation</a></li><li><a href="#Ucl.jl-Documentation-1">Ucl.jl Documentation</a></li><li><a href="#HasType.jl-Documentation-1">HasType.jl Documentation</a></li><li><a href="#Symbols.jl-Documentation-1">Symbols.jl Documentation</a></li><li><a href="#Util.jl-Documentation-1">Util.jl Documentation</a></li><li><a href="#Cycpols.jl-Documentation-1">Cycpols.jl Documentation</a></li></ul><h1><a class="nav-anchor" id="Perms.jl-Documentation-1" href="#Perms.jl-Documentation-1">Perms.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Perms" href="#Gapjm.Perms"><code>Gapjm.Perms</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>This module is a port of the GAP permutations type.</p><p>A  permutation here is a permutation of the set <code>1:n</code> and is represented as a  vector of <code>n</code> integers representing the images of <code>1:n</code>. The integer <code>n</code> is called the degree of the permutation, even if it is not moved. We follow the  GAP design: it is possible to multiply, or to store in the same group, permutations of different degrees; this is implemented by promoting both to the   higher  degree.  Slightly  faster  is  the  MAGMA  design  where  any permutation  has to belong to a group  and the degree is determined by that group. Then multiplication of permutations within a given group is slightly faster,  but  it  is  more  difficult  to multiply permutations coming from different  groups, like a group and one  of its subgroups. The degree is an implementation  detail so usually  it should not  be used. One sould rather use the function <code>largest_moved_point</code>.</p><p>A  permutation  can  be  defined  by  the  list  of  images  of <code>1:n</code>, like <code>Perm([2,3,1,5,4])</code>.  Usually it is rather  given by its cycle decomposion: the  permutation whose cycle decomposition is <code>(1,2,3)(4,5)</code> can be written <code>Perm(1,2,3)*Perm(4,5)</code>  or  <code>perm&quot;(1,2,3)(4,5)&quot;</code>.  The  list  of images of <code>1:n</code>  is gotten back from the permutation by the function <code>vec</code>; note that since  equal  permutations  may  have  different  degrees,  they  may  have different <code>vec</code>.</p><p>The  complete  type  of  our  permutations is <code>Perm{T}</code> where <code>T&lt;:Integer</code>, where <code>Vector{T}</code> is the type of the vector which holds the image of <code>1:n</code>. This   can  used  to  save  space  or  time  when  possible.  For  instance <code>Perm{UInt8}</code>  uses less  space than  <code>Perm{Int}</code> and  can be used for Weyl groups of rank &lt;=8 since they have at most 240 roots.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a=Perm(1,2,3)
(1,2,3)

julia&gt; vec(a)
3-element Array{Int64,1}:
 2
 3
 1

julia&gt; a==Perm(vec(a))
true

julia&gt; b=Perm(1,2,3,4)
(1,2,3,4)

julia&gt; a*b     # product
(1,3,2,4)

julia&gt; inv(a)  # inverse
(1,3,2)

julia&gt; a/b     # quotient  a*inv(b)
(3,4)

julia&gt; a\b     # left quotient inv(a)*b
(1,4)

julia&gt; a^b     # conjugation inv(b)*a*b
(2,3,4)

julia&gt; b^2
(1,3)(2,4)

julia&gt; 1^a     # apply a to point 1
2

julia&gt; one(a)
()

julia&gt; sign(a)
1

julia&gt; order(a)
3

julia&gt; largest_moved_point(a)
3

julia&gt; smallest_moved_point(a)
1

julia&gt; Perm{Int8}(a) # convert to Perm{Int8}
Int8(1,2,3)

julia&gt; Matrix(b)
4×4 Array{Int64,2}:
 0  1  0  0
 0  0  1  0
 0  0  0  1
 1  0  0  0</code></pre><pre><code class="language-not-in-tests">julia&gt; rand(Perm,10)
(1,8,4,2,9,7,5,10,3,6)
</code></pre><p>Perms  have methods <code>copy, hash, ==, cmp, isless</code> (total order) so they can be  keys in hashes or elements of  sets; two permutations are equal if they move   the  same  points.  Permutations   are  considered  as  scalars  for broadcasting.</p><p>other functions are:  <code>cycles, cycletype, orbit, orbits, permuted, rand, restricted, sign</code>.  See individual documentations.</p><p>GAP→ Julia dictionary</p><pre><code class="language-none">     PermList(v)                      →  Perm(v) 
     Permuted(v,p)                    →  permuted(v,p)
     ListPerm(p)                      →  vec(p)
     PermListList(l1,l2)              →  Perm(l1,l2)
     OnTuples(l,p)                    →  l.^p
     RestrictedPerm(p,d)              →  restricted(p,d)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Perms.jl#L1-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Perms.largest_moved_point" href="#Gapjm.Perms.largest_moved_point"><code>Gapjm.Perms.largest_moved_point</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>largest_moved_point(a::Perm)</code> is the largest integer moved by a</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Perms.jl#L248">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Perms.smallest_moved_point" href="#Gapjm.Perms.smallest_moved_point"><code>Gapjm.Perms.smallest_moved_point</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>smallest_moved_point(a::Perm)</code> is the smallest integer moved by a</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Perms.jl#L251">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Perms.order" href="#Gapjm.Perms.order"><code>Gapjm.Perms.order</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>order(a) is the order of the permutation a</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Perms.jl#L373">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Groups.orbit" href="#Gapjm.Groups.orbit"><code>Gapjm.Groups.orbit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>orbit(a::Perm,i::Integer) returns the orbit of a on i</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Perms.jl#L316-L318">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Perms.cycles" href="#Gapjm.Perms.cycles"><code>Gapjm.Perms.cycles</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>cycles(a::Perm) returns the non-trivial cycles of a</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cycles(Perm(1,2)*Perm(4,5))
3-element Array{Array{Int64,1},1}:
 [1, 2]
 [4, 5]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Perms.jl#L353-L362">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Perms.cycletype" href="#Gapjm.Perms.cycletype"><code>Gapjm.Perms.cycletype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>cycletype(a::Perm) describes the partition of degree(a) associated to the   conjugacy class of a in the symmetric group, with ones removed. It is   represented as a Dict of cyclesize=&gt;multiplicity</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cycletype(Perm(1,2)*Perm(3,4))
1-element Array{Pair{Tuple{Int64,Int64},Int64},1}:
 (2, 1) =&gt; 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Perms.jl#L376-L386">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sign" href="#Base.sign"><code>Base.sign</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>sign(a::Perm) is the signature of  the permutation a</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Perms.jl#L425">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Perms.permuted" href="#Gapjm.Perms.permuted"><code>Gapjm.Perms.permuted</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>permuted(l,a) returns l permuted by a as a new list r,    that is r[i^a]==l[i]</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Perms.jl#L429-L432">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.restricted" href="#Gapjm.restricted"><code>Gapjm.restricted</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>restricted(a::Perm{T},l::AbstractVector{&lt;:Integer})</p><p>l should be a union of cycles of p; returns p restricted to l</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Perms.jl#L439-L443">source</a></section><h1><a class="nav-anchor" id="Groups.jl-Documentation-1" href="#Groups.jl-Documentation-1">Groups.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Groups" href="#Gapjm.Groups"><code>Gapjm.Groups</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>This module is a port of some GAP functionality on groups.</p><p>The only field of a Group G at the start is gens, the list of generators of G.  To  mimic  GAP  records  where  attributes/properties  of an object are computed  on demand when asked for, other attributes computed on demand are stored in the field .prop of the Group, which starts as Dict{Symbol,Any}()</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; G=Group([Perm(1,2),Perm(1,2,3)])
Group([(1,2),(1,2,3)])

julia&gt; gens(G)
2-element Array{Perm{Int64},1}:
 (1,2)  
 (1,2,3)

julia&gt; nbgens(G)
2</code></pre><p>The group itself, applied to a sequence of integers, returns the element defined by the corresponding word in the generators</p><pre><code class="language-julia-repl">julia&gt; G(2,1,-2) # returns gens(G)[2]*gens(G)[1]*inv(gens(G)[2])
(1,3)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Groups.jl#L1-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Groups.orbit" href="#Gapjm.Groups.orbit"><code>Gapjm.Groups.orbit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>orbit(a::Perm,i::Integer) returns the orbit of a on i</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Perms.jl#L316-L318">source</a><div><div><p>orbit(G::Group,p;action::Function=^)</p><p>the orbit of p under Group G&quot;</p><pre><code class="language-julia-repl">julia&gt; G=Group([Perm(1,2),Perm(1,2,3)]);
julia&gt; orbit(G,1) 
3-element Array{Int64,1}:
 2
 3
 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Groups.jl#L47-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Groups.orbits" href="#Gapjm.Groups.orbits"><code>Gapjm.Groups.orbits</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>orbits(a::Perm,d::Vector=1:length(vec(a))) returns the orbits of a on domain d</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; orbits(Perm(1,2)*Perm(4,5),1:5)
3-element Array{Array{Int64,1},1}:
 [1, 2]
 [3]
 [4, 5]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Perms.jl#L329-L339">source</a><div><div><pre><code class="language-none">orbits(G,v;action=^) 
the orbits of G on v</code></pre><pre><code class="language-julia-repl">julia&gt; G=Group([Perm(1,2),Perm(1,2,3)]);
julia&gt; orbits(G,1:4)
2-element Array{Array{Int64,1},1}:
 [2, 3, 1]
 [4]      </code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Groups.jl#L119-L129">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Groups.transversal" href="#Gapjm.Groups.transversal"><code>Gapjm.Groups.transversal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>transversal(G::Group,p;action::Function=^)</p><p>returns  a Dict with entries x=&gt;g where x runs over orbit(G,p) and where g  is such that x=action(p,g)</p><pre><code class="language-julia-repl">julia&gt; G=Group([Perm(1,2),Perm(1,2,3)]);
julia&gt; transversal(G,1)
Dict{Int64,Perm{Int64}} with 3 entries:
  2 =&gt; (1,2)
  3 =&gt; (1,3,2)
  1 =&gt; ()</code></pre><p>orbit functions can take any action of G as keyword argument</p><pre><code class="language-julia-repl">julia&gt; transversal(G,[1,2],action=(x,y)-&gt;x.^y)
Dict{Array{Int64,1},Perm{Int64}} with 6 entries:
  [1, 3] =&gt; (2,3)
  [1, 2] =&gt; ()
  [2, 3] =&gt; (1,2,3)
  [3, 2] =&gt; (1,3)
  [2, 1] =&gt; (1,2)
  [3, 1] =&gt; (1,3,2)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Groups.jl#L75-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Groups.centralizer" href="#Gapjm.Groups.centralizer"><code>Gapjm.Groups.centralizer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">centralizer(G,p;action=^) 
computes the centralizer C_G(p)</code></pre><pre><code class="language-julia-repl">julia&gt; G=Group([Perm(1,2),Perm(1,2,3)]);
julia&gt; centralizer(G,1)
Group([(2,3)])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Groups.jl#L140-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.word-Tuple{Group,Any}" href="#Gapjm.word-Tuple{Group,Any}"><code>Gapjm.word</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>word(G::Group,w): a word in  gens(G) representing element w of G</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Groups.jl#L197">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.elements" href="#Gapjm.elements"><code>Gapjm.elements</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>elements(M,l) returns the elements of M of length l.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Garside.jl#L490">source</a><div><div><p>elements(G::Group): the list of elements of G</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Groups.jl#L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>length(G::PermGroup) returns the cardinality of G </p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/PermGroups.jl#L214">source</a><div><div><p>length(G::Group): the number of elements of G</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Groups.jl#L203">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Groups.class_reps" href="#Gapjm.Groups.class_reps"><code>Gapjm.Groups.class_reps</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>class_reps(G::Group): representatives of conjugacy classes of G</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Groups.jl#L217">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Groups.minimal_words" href="#Gapjm.Groups.minimal_words"><code>Gapjm.Groups.minimal_words</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">`minimal_words(G)`</code></pre><p>returns a Dict giving for each element of <code>G</code> a minimal positive word in    the generators representing it.</p><pre><code class="language-julia-repl">julia&gt; G=Group([Perm(1,2),Perm(1,2,3)]);
julia&gt; minimal_words(G)
Dict{Perm{Int64},Array{Int64,1}} with 6 entries:
  ()      =&gt; Int64[]
  (2,3)   =&gt; [2, 1]
  (1,3,2) =&gt; [1, 2, 1]
  (1,3)   =&gt; [1, 2]
  (1,2)   =&gt; [1]
  (1,2,3) =&gt; [2]</code></pre><p>This Dict is stored in <code>G.prop[:words]</code> for further use.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Groups.jl#L156-L173">source</a></section><h1><a class="nav-anchor" id="PermGroups.jl-Documentation-1" href="#PermGroups.jl-Documentation-1">PermGroups.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.PermGroups" href="#Gapjm.PermGroups"><code>Gapjm.PermGroups</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>This module is a port of some GAP functionality on permutation groups.</p><p>This code refers to Holt &quot;Handbook of computational group theory&quot; chapter 4 for basic algorithms.</p><p>A  PermGroup is  a group  where gens  are Perms,  which allows  for all the algorithms like base, centralizer chain, etc...</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; G=Group([Perm(i,i+1) for i in 1:2])
Group([(1,2),(2,3)])

# PermGroups are iterators over their elements
julia&gt; collect(G)  
6-element Array{Perm{Int64},1}:
 (1,2)
 (1,3,2)
 ()
 (1,2,3)
 (1,3)
 (2,3)

# maximum degree of an element of G
julia&gt; degree(G)  
3

julia&gt; Perm(1,2) in G
true

julia&gt; Perm(1,2,4) in G
false

# Elements,  appartenance test and  other function are  computed on G using
# Schreier-Sims theory, that is computing the following

# a list of points that no element of G fixes
julia&gt; base(G) 
2-element Array{Int64,1}:
 1
 2

# the i-th element is the centralizer of base[1:i-1]
julia&gt; centralizers(G) 
2-element Array{PermGroup{Int64},1}:
 Group([(1,2),(2,3)])
 Group([(2,3)])

# i-th element is transversal of centralizer[i] on base[i]
julia&gt; transversals(G)
2-element Array{Dict{Int64,Perm{Int64}},1}:
 Dict(2=&gt;(1,2),3=&gt;(1,3,2),1=&gt;())
 Dict(2=&gt;(),3=&gt;(2,3))</code></pre><p>finally, benchmarks on julia 1.0.1</p><pre><code class="language-benchmark">julia&gt; @btime length(collect(symmetric_group(8)))
  5.481 ms (270429 allocations: 12.40 MiB)

julia&gt; @btime minimal_words(symmetric_group(8));
  10.477 ms (122062 allocations: 15.22 MiB)</code></pre><p>Compare to GAP3 Elements(SymmetricGroup(8)); takes 3.8 ms</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/PermGroups.jl#L1-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.PermGroups.base" href="#Gapjm.PermGroups.base"><code>Gapjm.PermGroups.base</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A list of points stabilized by no element of G </p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/PermGroups.jl#L209">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.PermGroups.centralizers" href="#Gapjm.PermGroups.centralizers"><code>Gapjm.PermGroups.centralizers</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>centralizers: the i-th element is the centralizer of base[1:i-1]</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/PermGroups.jl#L195">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.PermGroups.transversals" href="#Gapjm.PermGroups.transversals"><code>Gapjm.PermGroups.transversals</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The  i-th element  is  a description of  the orbit of :centralizers[i] on   :base[i]  as a Dict where each point q is the key to a permutation p such   that :base[i]^p=q</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/PermGroups.jl#L200-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.PermGroups.symmetric_group" href="#Gapjm.PermGroups.symmetric_group"><code>Gapjm.PermGroups.symmetric_group</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The symmetric group of degree n </p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/PermGroups.jl#L114">source</a></section><h1><a class="nav-anchor" id="Cycs.jl-Documentation-1" href="#Cycs.jl-Documentation-1">Cycs.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Cycs" href="#Gapjm.Cycs"><code>Gapjm.Cycs</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Cyclotomic  numbers means complex numbers which are sums of rationals times roots of unity.</p><p>They are a very important feature of GAP, since entries of character tables of finite groups are cyclotomics.</p><p>They  have a normal form given by the Zumbroich basis, which allows to find the  smallest Cyclotomic field which contains a given number, and decide in particular if a cyclotomic is zero. Let ζ<em>n:=e^{2iπ/n}. The Zumbroich basis of Q(ζ</em>n) is a particular subset of 1,ζ,ζ^2,...,ζ^{n-1} which forms a basis of Q(ζ_n) with good properties.</p><p>I  ported here Christian Stump&#39;s Sage  code, which is simpler to understand than GAP&#39;s code. The reference for the algorithms is</p><p>T. Breuer, Integral bases for subfields of cyclotomic fields AAECC 8 (1997)</p><p>As in GAP, I lower automatically numbers after each computation; this makes this code about twice slower than GAP since lower is not as much optimized. GAP  also converts a Cyclotomic which is rational to a Rational, a Rational which is integral to an Int, etc... This is tremendously useful but needs a new  type of  number to  be added  to Julia,  which requires more competent people than me.</p><p>The main way to build a Cyclotomic number is to use the function <code>E(n,k=1)</code> which constructs ζ_n^k.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; E(3)+E(4)
ζ₁₂⁴-ζ₁₂⁷-ζ₁₂¹¹

julia&gt; E(3,2)
ζ₃²

julia&gt; 1+E(3,2)
-ζ₃

julia&gt; a=E(4)-E(4)
0

julia&gt; conductor(a) # a is lowered to Q(ζ_1)=Q
1

julia&gt; typeof(convert(Int,a))
Int64

julia&gt; convert(Int,E(4))
ERROR: InexactError: convert(Int64, E(4))

julia&gt; c=inv(1+E(4)) # inverses need Rationals
1//2+(-1//2)ζ₄

julia&gt; typeof(c)
Cyc{Rational{Int64}}

julia&gt; typeof(1+E(4))
Cyc{Int64}

julia&gt; Cyc(1+im) # one can convert Gaussian integers or rationals
1+ζ₄

julia&gt; 1//(1+E(4))
1//2+(-1//2)ζ₄

julia&gt; typeof(Cyc(1//2)) # another way of building a Cyc
Cyc{Rational{Int64}}

julia&gt; conj(1+E(4))
1-ζ₄

julia&gt; c=E(9)   # an effect of the Zumbroich basis
-ζ₉⁴-ζ₉⁷

julia&gt; Root1(c) # but you can decide whether a Cyc is a root of unity
Root1(1//9)

julia&gt; c=Complex(E(3))   # convert to float is probably not very useful
-0.4999999999999998 + 0.8660254037844387im

julia&gt; Cyc(c) # even less useful
-0.4999999999999998+0.8660254037844387ζ₄</code></pre><p>For more information see ER, Quadratic, galois. </p><p>Finally, a benchmark:</p><pre><code class="language-benchmark">julia&gt; function testmat(p) 
         ss=vcat([[[i,j] for j in i+1:p-1] for i in 0:p-1]...)
         [(E(p,i&#39;*reverse(j))-E(p,i&#39;*j))//p for i in ss,j in ss]
       end
testmat (generic function with 1 method)

julia&gt; @btime testmat(12)^2;
  472.964 ms (8324504 allocations: 707.18 MiB)</code></pre><p>The equivalent in GAP:</p><pre><code class="language-none">testmat:=function(p)local ss;ss:=Combinations([0..p-1],2);
  return List(ss,i-&gt;List(ss,j-&gt;(E(p)^(i*Reversed(j))-E(p)^(i*j))/p));
end; </code></pre><p>for testmat(12) takes 0.4s in GAP3, 0.3s in GAP4</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Cycs.jl#L1-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Cycs.galois" href="#Gapjm.Cycs.galois"><code>Gapjm.Cycs.galois</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>galois(c::Cyc,n::Int) applies to c the galois automorphism   of Q(ζ_conductor(c)) raising all roots of unity to the n-th power.   n should be prime to c.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; galois(1+E(4),-1) # galois(c,-1) is the same as conj(c)
1-ζ₄

julia&gt; galois(ER(5),2)==-ER(5)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Cycs.jl#L550-L562">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>ER</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>quadratic</code>. Check Documenter&#39;s build log for details.</p></div></div><h1><a class="nav-anchor" id="Pols.jl-Documentation-1" href="#Pols.jl-Documentation-1">Pols.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Pols" href="#Gapjm.Pols"><code>Gapjm.Pols</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>An implementation of univariate Laurent polynomials.  A Pol contains two fields: its vector of coefficients, and its valuation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Pol(:q) # define string used for printing and set variable q
q

julia&gt; Pol([1,2],0) # coefficients should have no leading or trailing zeroes.
2q+1

julia&gt; p=Pol([1,2],-1)
2+q⁻¹

julia&gt; valuation(p)
-1

julia&gt; p=(q+1)^2
q²+2q+1

julia&gt; degree(p)
2

julia&gt; p(1//2) # a Pol is a callable object, where the call evaluates the Pol
9//4

julia&gt; divrem(q^3+1,q+2) # changes coefficients to field elements
(1.0q²-2.0q+4.0, -7.0)

julia&gt; divrem1(q^3+1,q+2) # keeps the ring, but needs second argument unitary
(q²-2q+4, -7)

julia&gt; cyclotomic_polynomial(24) # the 24-th cyclotomic polynomial
q⁸-q⁴+1
</code></pre><p>see also the individual documentation of gcd.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Pols.jl#L1-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.divrem" href="#Base.divrem"><code>Base.divrem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>computes (p,q) such that a=p*b+q</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Pols.jl#L196-L198">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Pols.divrem1" href="#Gapjm.Pols.divrem1"><code>Gapjm.Pols.divrem1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>divrem when b unitary: does not change type</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Pols.jl#L217-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.gcd" href="#Base.gcd"><code>Base.gcd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>gcd(p::Pol, q::Pol)   the coefficients of p and q must be elements of a field for   gcd to be type-stable</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; gcd(q+1,q^2-1)
1.0q+1.0

julia&gt; gcd(q+1//1,q^2-1//1)
(1//1)q+1//1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Pols.jl#L249-L262">source</a></section><h1><a class="nav-anchor" id="CoxGroups.jl-Documentation-1" href="#CoxGroups.jl-Documentation-1">CoxGroups.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.CoxGroups" href="#Gapjm.CoxGroups"><code>Gapjm.CoxGroups</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>A  suitable  reference  for  the  general  theory of Coxeter groups is, for example, Bourbaki &quot;Lie Groups and Lie Algebras&quot; chapter 4.</p><p>A <em>Coxeter group</em> is a group which has the presentation <code>W=⟨S|(st)^m(s,t)=1</code>  for  <code>s,t∈  S⟩</code>  for  some  symmetric  integer matrix <code>m(s,t)</code>  called  the  <em>Coxeter  matrix</em>,  where  <code>m(s,t)&gt;1</code>  for <code>s≠t</code> and <code>m(s,s)=1</code>.  It is true (but a non-trivial theorem) that in a Coxeter group the  order of <code>st</code> is exactly <code>m(s,t)</code>, thus a Coxeter group is the same as a  <em>Coxeter system</em>, that is a pair <code>(W,S)</code> of a group <code>W</code> and a set <code>S</code> of involutions,  such that the group is  presented by relations describing the order  of the product of two elements of <code>S</code>. A Coxeter group has a natural representation, its <em>reflection representation</em>, on a real vector space <code>V</code> of  dimension <code>length(S)</code> (the <em>Coxeter rank</em>  of W), where each element of <code>S</code>  acts as a  reflection; the faithfulness  of this representation in the main  argument to prove  that the order  of <code>st</code> is  exactly <code>m(s,t)</code>. Thus Coxeter groups are real reflection groups. The converse need not be true if the  set of reflecting  hyperplanes has bad  topological properties, but it turns out that finite Coxeter groups are the same as finite real reflection groups.  The possible Coxeter matrices for  finite Coxeter groups have been completely  classified; the corresponding finite groups play a deep role in several areas of mathematics.</p><p>Coxeter  groups  have  a  nice  solution  to the word problem. The <em>length</em> <code>l(w)</code>  of an element  <code>w∈ W</code> is  the minimum number  of elements of <code>S</code> of which it is a product (since the elements of <code>S</code> are involutions, we do not need inverses). An expression of <code>w</code> of minimal length is called a <em>reduced word</em>  for <code>w</code>. The main property of  reduced words is the <em>exchange lemma</em> which  states that if <code>s₁…sₖ</code> is a  reduced word for <code>w</code> (thus<code>k=l(w)</code>) and <code>s∈  S</code> is such that <code>l(sw)≤l(w)</code> then one  of the <code>sᵢ</code> in the word for <code>w</code> can be deleted to obtain a reduced word for <code>sw</code>. Thus given <code>s∈ S</code> and <code>w∈ W</code>,  either <code>l(sw)=l(w)+1</code> or  <code>l(sw)=l(w)-1</code> and we  say in this last case that  <code>s</code> belongs to  the <em>left descent  set</em> of <code>w</code>.  The computation of a reduced word for an element, and other word problems, are easily done if we know  the left descent sets. For the Coxeter groups that we implement, this left  descent set  can be  easily determined  (see e.g. &#39;coxsym&#39; below), so this suggests how to deal with Coxeter groups.</p><p>The type <code>CoxeterGroup</code> is an abstact type; an actual struct which implements it must define a function</p><p><code>isleftdescent(W,w,i)</code> which tells whether the       <code>i</code>-th element of <code>S</code> is in the left descending set of <code>w</code>.</p><p>the other functions needed in an instance of a Coxeter group are</p><ul><li><code>gens(W)</code> which returns the set <code>S</code> (the list of <em>Coxeter generators</em>)</li><li><code>nref(W)</code> which  returns the  number of  reflections of  <code>W</code>, if  <code>W</code> is  finite or <code>nothing</code> if <code>W</code> is infinite</li></ul><p>It  should be  noted that  a Coxeter group can be <em>any</em> kind of group implementing the above functions.</p><p>A  common occurrence in code for Coxeter groups is a loop like:</p><p><code>findfirst(eachindex(gens(W)),x-&gt;isleftdescent(W,w,x))</code></p><p>if you provide a function <code>firstleftdescent(W,w)</code> it will be called instead of the above loop.</p><p>Because  of the  easy solution  of the  word problem  in Coxeter  groups, a convenient  way  to  represent  their  elements  is as words in the Coxeter generators.  They are represented as lists of labels for the generators. By default  these labels are  given as the  index of a  generator in <code>S</code>, so a Coxeter  word is just  a list of  integers in <code>1:length(S)</code>. For reflection subgroups, the labels are indices of the reflections in the parent group.</p><p>The functions &#39;word&#39; and &#39;W(...)&#39; will do the conversion between Coxeter words and elements of the group.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; W=coxsym(4)
𝔖 ₄

julia&gt; p=W(1,3,2,1,3)
UInt8(1,4)

julia&gt; word(W,p)
5-element Array{Int64,1}:
 1
 2
 3
 2
 1
</code></pre><p>We  notice that the word we started with and the one that we ended up with, are not the same, though they represent the same element of <code>W</code>. The reason is  that the function &#39;word&#39; computes a lexicographically smallest word for <code>w</code>.  Below  are  some  other  possible  computations with the same Coxeter group:</p><pre><code class="language-julia-repl">julia&gt; word(W,longest(W))  # the (unique) longest element in W
6-element Array{Int64,1}:
 1
 2
 1
 3
 2
 1

julia&gt; w0=longest(W)
UInt8(1,4)(2,3)
julia&gt; length(W,w0)
6
julia&gt; map(i-&gt;word(W,reflection(W,i)),1:nref(W))
6-element Array{Array{Int64,1},1}:
 [1]            
 [2]            
 [3]            
 [1, 2, 1]      
 [2, 3, 2]      
 [1, 2, 3, 2, 1]
julia&gt; [length(elements(W,i)) for i in 0:nref(W)]
7-element Array{Int64,1}:
 1
 3
 5
 6
 5
 3
 1
</code></pre><p>The above line tells us that there is 1 element of length 0, there are 6 of length 3, …</p><p>For  most basic functions the convention is that the input is an element of the  group, rather than  a Coxeter word.  The reason is  that for a Coxeter group  which  is  a  permutation  group,  using the low level functions for permutations  is usually  much faster  than manipulating lists representing reduced expressions.</p><p>This  file contains mostly a port of  the basic functions on Coxeter groups in  Chevie. The only Coxeter group  constructor implemented here is coxsym. The file Weyl.jl defines coxgroup.</p><p>The dictionary from Chevie is as follows:</p><pre><code class="language-none">     CoxeterElements(W[,l])                → elements(W[,l])
     CoxeterLength(W,w)                    → length(W,w)
     CoxeterWord(W,w)                      → word(W,w)
     LongestCoxeterElement(W)              → longest(W)
     FirstLeftDescending(W,w)              → firstleftdescent(W,w)
     LeftDescenTSet(W,w)                   → leftdescents(W,w)
     ReducedInRightCoset(W,w)              → reduced(W,w)
     ReducedRightCosetRepresentatives(W,H) → reduced(H,W)
     SemiSimpleRank(W)                     → coxrank(W)
     CoxeterGroupSymmetricGroup(n)         → coxsym(n)
     ReflectionSubGroup                    only standard parabolics now
     IsLeftDescending(W,w,i)               → isleftdescent(W,w,i)
     ReflectionDegrees(W)                  → degrees(W)
     ReflectionLength(W,w)                 → reflength(W,w)
     W.N                                   → nref(W)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/CoxGroups.jl#L1-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.CoxGroups.reduced" href="#Gapjm.CoxGroups.reduced"><code>Gapjm.CoxGroups.reduced</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>reduced(W,w)   The unique element in the coset W.w which stabilises the positive roots of W</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; H=reflection_subgroup(W,[2,6])
G₂₍₂₄₎

julia&gt; Set(word.(Ref(W),reduced.(Ref(H),elements(W))))
Set(Array{Int64,1}[[1], []])
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/CoxGroups.jl#L218-L232">source</a><div><div><p>reduced(H,W)   The elements in W which are H-reduced</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; H=reflection_subgroup(W,[2,6])
G₂₍₂₄₎

julia&gt; [word(W,w) for S in reduced(H,W) for w in S]
2-element Array{Array{Int64,1},1}:
 [] 
 [1]
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/CoxGroups.jl#L241-L257">source</a><div><div><p>reduced(H,W,S)   The elements in W which are H-reduced of length i from the set S of length i-1</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/CoxGroups.jl#L269-L272">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.word-Tuple{CoxeterGroup,Any}" href="#Gapjm.word-Tuple{CoxeterGroup,Any}"><code>Gapjm.word</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>word(W::CoxeterGroup,w)   The Coxeter word for element w of W</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/CoxGroups.jl#L182-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.CoxGroups.bruhatless" href="#Gapjm.CoxGroups.bruhatless"><code>Gapjm.CoxGroups.bruhatless</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>bruhatless(W, x, y)</code>  whether x≤y in the Bruhat order, for x, y ∈ W.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/CoxGroups.jl#L347-L349">source</a><div><div><p><code>bruhatless(W, y)</code>  all x≤y in the Bruhat order, for y ∈ W.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/CoxGroups.jl#L366-L368">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.CoxGroups.coxsym" href="#Gapjm.CoxGroups.coxsym"><code>Gapjm.CoxGroups.coxsym</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The symmetric group on n letters as a Coxeter group</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/CoxGroups.jl#L452">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.CoxGroups.longest" href="#Gapjm.CoxGroups.longest"><code>Gapjm.CoxGroups.longest</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The longest element of reflection_subgroup(W,I) –- never ends if infinite</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/CoxGroups.jl#L203-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.CoxGroups.nref" href="#Gapjm.CoxGroups.nref"><code>Gapjm.CoxGroups.nref</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>number of reflections of W</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Weyl.jl#L503">source</a></section><h1><a class="nav-anchor" id="Weyl.jl-Documentation-1" href="#Weyl.jl-Documentation-1">Weyl.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Weyl" href="#Gapjm.Weyl"><code>Gapjm.Weyl</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Let  <code>V</code> be a  real vector space.  Finite Coxeter groups  coincide with the finite  subgroups of  <code>GL(V)</code> which  can be  generated y reflections. <em>Weyl groups</em>  are  the  finite  Coxeter  groups  which  can  be defined over the rational   numbers.  We  implement  finite   Coxter  groups  as  groups  of permutations  of  a  root  system.  Root  systems play an important role in mathematics as they classify semi-simple Lie algebras and algebraic groups.</p><p>Let  us give precise definitions. Let <code>V</code>  be a real vector space, <code>Vⱽ</code> its dual  and let <code>(,)</code>  be the natural  pairing between <code>Vⱽ</code>  and <code>V</code>. A <em>root system</em>  is a finite set  of vectors <code>R</code> which  generate <code>V</code> (the <em>roots</em>), together  with  a  map  <code>r↦  rⱽ</code>  from  <code>R</code>  to  a subset <code>Rⱽ</code> of <code>Vⱽ</code> (the <em>coroots</em>) such that:</p><ul><li>For any <code>r∈  R</code>, we have  <code>(rⱽ,r)=2</code> so that  the formula <code>x↦ x-(rⱽ,x)r</code></li></ul><p>defines a reflection <code>s_r:V→ V</code> with root <code>r</code> and coroot <code>rⱽ</code>.</p><ul><li>The reflection <code>s_r</code> stabilizes <code>R</code>.</li></ul><p>We  will only  consider <em>reduced</em>  root systems,  i.e., such  that the only elements  of <code>R</code> colinear with <code>r∈ R</code> are <code>r</code> and <code>-r</code>; for Weyl groups, we also ask that the root system be <em>crystallographic</em>, that is <code>(rⱽ,s)</code> is an integer, for any <code>s∈ R,rⱽ∈ Rⱽ</code>.</p><p>The  subgroup <code>W=W(R)</code> of  <code>GL(V)</code> generated by  the reflections <code>s_r</code> is a finite  Coxeter group; when <code>R</code> is crystallographic, the representation <code>V</code> of  <code>W</code>  is  defined  over  the  rational  numbers.  All finite-dimensional (complex)  representations of a  finite Coxeter group  can be realized over the  same field  as <code>V</code>.  Weyl groups  can be  characterized amongst finite Coxeter  groups by the fact that all numbers <code>m(s,t)</code> in the Coxeter matrix are in <code>{2,3,4,6}</code>.</p><p>If  we identify  <code>V</code> with  <code>Vⱽ</code> by  choosing a  <code>W</code>-invariant bilinear form <code>(.;.)</code>;  then we have <code>rⱽ=2r/(r;r)</code>. A root system <code>R</code> is <em>irreducible</em> if it is not the union of two orthogonal subsets. If <code>R</code> is reducible then the corresponding  Coxeter group  is the  direct product  of the Coxeter groups associated with the irreducible components of <code>R</code>.</p><p>The  irreducible  crystallographic  root  systems  are  classified  by  the following  list of  <em>Dynkin diagrams</em>,  which, in  addition to  the Coxeter matrix,  encode also the relative length of the roots. We show the labeling of the nodes given by the function &#39;Diagram&#39; described below.</p><pre><code class="language-none">A_n O—O—O—…—O   B_n O⇐O—O—…—O  C_n O⇒ O—O—…—O  D_n  O 2
    1 2 3 … n       1 2 3 … n      1  2 3 … n       ￨
                                                  O—O—…—O
                                                  1 3 … n

G₂ O⇛ O  F₄ O—O⇒ O—O  E₆   O 2   E₇   O 2     E₈    O 2
   1  2     1 2  3 4       ￨          ￨             ￨
                       O—O—O—O—O  O—O—O—O—O—O   O—O—O—O—O—O—O
                       1 3 4 5 6  1 3 4 5 6 7   1 3 4 5 6 7 8</code></pre><p>These diagrams encode the presentation of the Coxeter group <code>W</code> as follows: the vertices represent the generating reflections; an edge is drawn between <code>s</code>  and <code>t</code> if the order <code>m(s,t)</code> of <code>st</code> is greater than <code>2</code>; the edge is single  if  <code>m(s,t)=3</code>,  double  if  <code>m(s,t)=4</code>,  triple if <code>m(s,t)=6</code>. The arrows  indicate the relative root lengths when <code>W</code> has more than one orbit on  <code>R</code>, as explained below; we  get the <em>Coxeter Diagram</em>, which describes the  underlying Weyl group, if  we ignore the arrows:  we see that the root systems <code>B_n</code> and <code>C_n</code> correspond to the same Coxeter group.</p><p>Here  are  the  diagrams  for  the  finite  Coxeter  groups which  are  not crystallographic:</p><pre><code class="language-none">       e        5         5
I₂(e) O—O   H₃ O—O—O  H₄ O—O—O—O
      1 2      1 2 3     1 2 3 4 </code></pre><p>Let us now describe how the root systems are encoded in these diagrams. Let <code>R</code>  be a root system in <code>V</code>. Then we can choose a linear form on <code>V</code> which vanishes  on no element of <code>R</code>. According to  the sign of the value of this linear  form on a root  <code>r ∈ R</code> we  call <code>r</code> <em>positive</em> or <em>negative</em>. Then there  exists a unique subset <code>Π</code> of  the positive roots, called the set of <em>simple  roots</em>, such that  any positive root  is a linear combination with non-negative  coefficients of  roots in  <code>Π</code>. Any  two sets of simple roots (corresponding  to  different  choices  of  linear  forms  as above) can be transformed into each other by a unique element of <code>W(R)</code>. Hence, since the pairing  between <code>V</code> and <code>Vⱽ</code>  is <code>W</code>-invariant, if <code>Π</code>  is a set of simple roots  and if  we define  the <em>Cartan  matrix</em> as  being the  <code>n</code> times <code>n</code> matrix   <code>C={rⱽ(s)}_{rs}</code>,  for  <code>r,s∈Π</code>  this   matrix  is  unique  up  to simultaneous  permutation of rows and columns.  It is precisely this matrix which is encoded in a Dynkin diagram, as follows.</p><p>The  indices for the rows of <code>C</code> label the nodes of the diagram. The edges, for  <code>r ≠ s</code>, are  given as follows. If  <code>C_{rs}</code> and <code>C_{sr}</code> are integers such  that <code>|C_{rs}|≥|C_{sr}|=1</code>  the vertices  are connected by <code>|C_{rs}|</code> lines,  and if <code>|C_{rs}|&gt;1</code>  then we put  an additional arrow  on the lines pointing  towards the node with label <code>s</code>.  In other cases, we simply put a single   line  equipped  with  the  unique  integer  <code>p_{rs}≥1</code>  such  that <code>C_{rs}C_{sr}=cos^2 (π/p_{sr})</code>.</p><p>Conversely,  the whole root  system can be  recovered from the simple roots and  the corresponding coroots. The  reflections in <code>W(R)</code> corresponding to the  simple roots are called  <em>simple</em> reflections or <em>Coxeter generators</em>. They are precisely the generators for which the Coxeter diagram encodes the defining  relations of <code>W(R)</code>. Each root is  in the orbit of a simple root, so  that <code>R</code> is obtained  as the orbit of  the simple roots under the group generated  by  the  simple  reflections.  The  restriction  of  the  simple reflections  to the span of <code>R</code> is  determined by the Cartan matrix, so <code>R</code> is determined by the Cartan matrix and the set of simple roots.</p><p>The  Cartan  matrix  corresponding  to  one  of  the above irreducible root systems  (with the specified labeling) is  returned by the command &#39;cartan&#39; which  takes as input  a <code>Symbol</code> giving  the type (that  is &#39;:A&#39;, &#39;:B&#39;, …, &#39;:I&#39;)  and a positive <code>Int</code> giving the  rank (plus an <code>Int</code> giving the bond for  type <code>:I</code>).  This function  returns a  matrix with  entries in <code>ℤ</code> for crystallographic  types, and a  matrix of <code>Cyc</code>  for the other types. Given two  Cartan matrices <code>c1</code> and <code>c2</code>,  their matrix direct sum (corresponding to  the  orthogonal  direct  sum  of  the  root systems) can be produced by <code>cat(c1,c2,dims=[1,2])</code>.</p><p>The  function &#39;rootdatum&#39; takes as input a  list of simple roots and a list of the corresponding coroots and produces a <code>struct</code> containing information about  the root system <code>R</code> and about <code>W(R)</code>. If we label the positive roots by  &#39;1:N&#39;, and the negative roots  by &#39;N+1:2N&#39;, then each simple reflection is  represented by the permutation of &#39;1:2N&#39; which it induces on the roots. If  only one argument is given, the Cartan matrix of the root system, it is taken  as the list  of coroots and  the list of  roots is assumed to be the canonical basis of <code>V</code>.</p><p>If one only wants to work with Cartan matrices with a labeling as specified by  the  above  list,  the  function  call  can  be  simplified. Instead of &#39;rootdatum(cartan(:D,4))&#39; the following is also possible.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; cartan(W)
4×4 Array{Int64,2}:
  2   0  -1   0
  0   2  -1   0
 -1  -1   2  -1
  0   0  -1   2</code></pre><p>Also,  the Weyl group struct associated to a direct sum of irreducible root systems can be obtained as a product</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,2)*coxgroup(:B,2)
A₂× B₂₍₃₄₎

julia&gt; cartan(W)
4×4 Array{Int64,2}:
  2  -1   0   0
 -1   2   0   0
  0   0   2  -2
  0   0  -1   2</code></pre><p>The  same <code>struct</code>  is constructed  by applying  &#39;coxgroup&#39; to  the matrix &#39;cat(cartan(:A,2), cartan(:B,2),dims=[1,2])&#39;.</p><p>The elements of a Weyl group are permutations of the roots:</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; p=W(1,3,2,1,3)
Int16(1,14,13,2)(3,17,8,18)(4,12)(5,20,6,15)(7,10,11,9)(16,24)(19,22,23,21)

julia&gt; word(W,p)
5-element Array{Int64,1}:
 1
 3
 1
 2
 3
</code></pre><p>This module is mostly a port of the basic functions on Weyl groups in Chevie. The dictionary from Chevie is as follows:</p><pre><code class="language-none">     CartanMat(&quot;A&quot;,5)                       →  cartan(:A,5) 
     CoxeterGroup(&quot;A&quot;,5)                    →  coxgroup(:A,5) 
     Size(W)                                →  length(W) 
     ForEachElement(W,f)                    →  for w in W f(w) end 
     ReflectionDegrees(W)                   →  degrees(W) 
     IsLeftDescending(W,w,i)                →  isleftdescent(W,w,i) 
     ReflectionSubgroup                     →  reflection_subgroup
     TwoTree(m)                             →  twotree(m) 
     FiniteCoxeterTypeFromCartanMat(m)      →  type_cartan(m) 
     RootsCartan(m)                         →  roots(m) 
     PrintDiagram(W)                        →  Diagram(W) 
     Inversions                             →  inversions 
     Reflection                             →  reflection 
     W.orbitRepresentative[i]               →  simple_representative(W,i) 
     ElementWithInversions                  →  with_inversions</code></pre><p>finally, a benchmark on julia 1.0.2</p><pre><code class="language-benchmark">julia&gt; @btime length(elements(coxgroup(:E,7)))
  531.385 ms (5945569 allocations: 1.08 GiB)</code></pre><p>GAP3 for the same computation takes 2.2s</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Weyl.jl#L1-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.PermRoot.cartan" href="#Gapjm.PermRoot.cartan"><code>Gapjm.PermRoot.cartan</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">`cartan(type, rank)`</code></pre><p>Cartan matrix for a Weyl group:</p><pre><code class="language-julia-repl">julia&gt; cartan(:A,4)
4×4 Array{Int64,2}:
  2  -1   0   0
 -1   2  -1   0
  0  -1   2  -1
  0   0  -1   2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Weyl.jl#L208-L221">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Weyl.two_tree" href="#Gapjm.Weyl.two_tree"><code>Gapjm.Weyl.two_tree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">two_tree(m)</code></pre><p>Given  a square  matrix m  with zeroes  (or falses,  for a boolean matrix)  symmetric  with respect to the diagonal, let  G be the graph with vertices  axes(m)[1] and an edge between i and j iff !iszero(m[i,j]).  If G  is a line this function returns it as a Vector{Int}.   If  G  is  a  tree  with  one  vertex  c of valence 3 the function returns  (c,b1,b2,b3)  where b1,b2,b3 are  the branches from  this vertex sorted by  increasing length.  Otherwise the function returns <code>nothing</code></p><pre><code class="language-julia-repl">julia&gt; Weyl.two_tree(cartan(:A,4))
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; Weyl.two_tree(cartan(:E,8))
(4, [2], [3, 1], [5, 6, 7, 8])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Weyl.jl#L271-L293">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.PermRoot.reflection_subgroup" href="#Gapjm.PermRoot.reflection_subgroup"><code>Gapjm.PermRoot.reflection_subgroup</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>reflection_subgroup(W,I) The subgroup of W generated by reflections(W)[I]</p><p>A   theorem  discovered  by  Deodhar  cite{Deo89}  and  Dyer  cite{Dye90} independently  is that a subgroup <code>H</code> of a Coxeter system <code>(W,S)</code> generated by  reflections has  a canonical  Coxeter generating  set, formed of the <code>t ∈Ref(H)</code>  such <code>l(tt&#39;)&gt;l(t)</code> for any <code>t&#39;∈  Ref(H)</code> different from <code>t</code>. This is used by &#39;reflection_subgroup&#39; to determine the Coxeter system of <code>H</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; Diagram(W)
O⇛ O
1  2

julia&gt; H=reflection_subgroup(W,[2,6])
G₂₍₂₄₎

julia&gt; Diagram(H)
O—O
1 2</code></pre><p>The  notation <code>G₂₍₂₃₎</code> means  that &#39;W.roots[2:3]&#39; form  a system of simple roots for <code>H</code>.</p><p>A  reflection subgroup has specific properties  the most important of which is  &#39;inclusion&#39; which gives the positions of the roots of H in the roots of W. The inverse (partial) map is &#39;restriction&#39;.</p><pre><code class="language-julia-repl">julia&gt; inclusion(H)
6-element Array{Int64,1}:
  2
  4
  6
  8
 10
 12

julia&gt; restriction(H)
12-element Array{Int64,1}:
 0
 1
 0
 2
 0
 3
 0
 4
 0
 5
 0
 6
</code></pre><p>If H is a standard parabolic subgroup  of a Coxeter group W then the length function  on H (with respect  to its set of  generators) is the restriction of  the length function on  W. This need not  no longer be true for arbitrary reflection subgroups of W:</p><pre><code class="language-julia-repl">julia&gt; word(W,H(2))
3-element Array{Int64,1}:
 1
 2
 1</code></pre><p>In  this package, finite  reflection groups are  represented as permutation groups  on a set of roots. Consequently,  a reflection subgroup <code>H⊆ W</code> is a permutation  subgroup, thus its elements are represented as permutations of the roots of the parent group.</p><pre><code class="language-julia-repl">julia&gt; elH=word.(Ref(H),elements(H))
6-element Array{Array{Int64,1},1}:
 []       
 [2]      
 [1]      
 [2, 1]   
 [1, 2]   
 [1, 2, 1]

julia&gt; elW=word.(Ref(W),elements(H))
6-element Array{Array{Int64,1},1}:
 []             
 [1, 2, 1]      
 [2]            
 [1, 2, 1, 2]   
 [2, 1, 2, 1]   
 [2, 1, 2, 1, 2]

julia&gt; map(w-&gt;H(w...),elH)==map(w-&gt;W(w...),elW)
true
</code></pre><p>Another  basic result about reflection subgroups  of Coxeter groups is that each  coset of  H in  W contains  a unique  element of  minimal length, see <code>reduced</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Weyl.jl#L697-L802">source</a><div><div><p>Only parabolics defined are I=1:m for m≤n</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/CoxGroups.jl#L493">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Weyl.coxgroup" href="#Gapjm.Weyl.coxgroup"><code>Gapjm.Weyl.coxgroup</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Coxeter group from type</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Weyl.jl#L507">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Weyl.rootdatum" href="#Gapjm.Weyl.rootdatum"><code>Gapjm.Weyl.rootdatum</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Adjoint root datum from cartan mat</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Weyl.jl#L510">source</a><div><div><p>root datum</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Weyl.jl#L513">source</a></section><h1><a class="nav-anchor" id="Hecke.jl-Documentation-1" href="#Hecke.jl-Documentation-1">Hecke.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Hecke" href="#Gapjm.Hecke"><code>Gapjm.Hecke</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>This   module  ports   Chevie  functionality   for  Iwahori-Hecke  algebras associated to Coxeter groups.</p><p>Let  (W,S) be a Coxeter  system where <code>mₛₜ</code> is  the order of <code>st</code> for <code>s,t∈ S</code>. Let <code>R</code> be a commutative ring with 1 and for <code>s∈ S</code> let <code>uₛ₀,uₛ₁∈ R</code> be elements which depend ony on the conjugacy class of <code>s</code> in <code>W</code> (this is the same  as requiring that <code>uₛᵢ=uₜᵢ</code> whenever <code>mₛₜ</code> is odd). The Iwahori-Hecke algebra of <code>W</code> over <code>R</code> with parameters <code>uₛᵢ</code> is a deformation of the group algebra  of <code>W</code> over <code>R</code> defined as  follows: it is the unitary associative <code>R</code>-algebra generated by elements <code>Tₛ, s∈ S</code> subject to the relations:</p><p><span>$(Tₛ-uₛ₀)(Tₛ-uₛ₁)=0$</span> for all <code>s∈ S</code> (the quadratic relations)</p><p><span>$TₛTₜTₛ…= TₜTₛTₜ…$</span> with <code>mₛₜ</code> factors on each side (the braid relations)</p><p>If  <code>uₛ₀=1</code> and  <code>uₛ₁=-1</code> for  all <code>s</code>  then the quadratic relations become <code>Tₛ²=1</code> and the deformation of the group algebra is trivial.</p><p>Since  the generators <code>Tₛ</code> satisfy the  braid relations, the algebra <code>H</code> is in  fact a quotient of the group algebra of the braid group associated with <code>W</code>.  It follows that, if <code>w=s_1⋯ s_m</code>  is a reduced expression of <code>w ∈ W</code> then  the  product  <code>Tₛ_1⋯ Tₛ_m</code>  depends  only  on <code>w</code>. We will therefore denote by <code>T_w</code>. We have <code>T_1=1</code>.</p><p>If  one of <code>uₛ₀</code> or <code>uₛ₁</code> is invertible  in <code>R</code>, for example <code>uₛ₁</code>, then by changing  the generators  to <code>T′ₛ=-Tₛ/uₛ₁</code>,  and setting <code>qₛ=-uₛ₀/uₛ₁</code>, the braid  relations do no change  (since when <code>mₛₜ</code> is  odd we have <code>uₛᵢ=uₜᵢ</code>) but  the quadratic relations become  <code>(T′ₛ-qₛ)(T′ₛ+1)=0</code>. This last form is the  most common  form considered  in the  literature. Another common form, considered  in  the  context  of  Kazhdan-Lusztig  theory, is <code>uₛ₀=√qₛ</code> and <code>uₛ₁=-√qₛ⁻¹</code>.  The general form of parameters provided is a special case of general cyclotomic Hecke algebras, and can be useful in many contexts.</p><p>For  some  algebras  the  character  table,  and in general Kazhdan-Lusztig bases,  require a square root of <code>-uₛ₀uₛ₁</code>.  We provide a way to specify it with  the  field  <code>.rootpara</code>  which  can  be  given  when constructing the algebra. If not given a root is automatically extracted when needed (and we know  how to compute it) by the function <code>RootParameter</code>. Note however that sometimes  an  explicit  choice  of  root  is  necessary  which  cannot  be automatically determined.</p><p>There  is a universal choice  for <code>R</code> and <code>uₛᵢ</code>:  Let <code>uₛᵢ:s∈ S,i∈[0,1]</code> be indeterminates   such  that  <code>uₛᵢ=uₜᵢ</code>  whenever  <code>mₛₜ</code>  is  odd,  and  let <code>A=ℤ[uₛᵢ]</code> be the corresponding polynomial ring. Then the Hecke algebra <code>H</code> of  <code>W</code> over a  with parameters <code>uₛᵢ</code>  is called the <em>generic Iwahori-Hecke algebra</em>  of  with  <code>W</code>.  Any  other  algebra  with parameters <code>vₛᵢ</code> can be obtained  by specialization from  <code>H</code>: There is  a unique ring homomorphism <code>f:A  → R</code> such that <code>f(uₛᵢ)=vₛᵢ</code>  for all <code>i</code>. Then we  can view <code>R</code> as an <code>A</code>-module via <code>f</code> and we can identify the other algebra to <span>$R⊗ _A H$</span>.</p><p>The  elements <code>{T_w∣w∈ W}</code> actually form an  <code>R</code>-basis of <code>H</code> if one of the <code>uₛᵢ</code>  is invertible for all <code>s</code>. The  structure constants in that basis is obtained  as  follows.  To  multiply  <code>T_v</code>  by  <code>T_w</code>,  choose  a  reduced expression for <code>v</code>, say <code>v=s_1 ⋯ s_k</code> and apply inductively the formula:</p><p><span>$T_sT_w=T_{sw}$</span>               if <code>l(sw)=l(w)+1</code></p><p><span>$T_sT_w=-uₛ₀uₛ₁T_{sw}+(uₛ₀+uₛ₁)T_w$</span> if <code>l(sw)=l(w)-1</code>.</p><p>If all <code>s</code> we have <code>uₛ₀=q</code>, <code>uₛ₁=-1</code> then we call the corresponding algebra the one-parameter or Spetsial Iwahori-Hecke algebra associated with <code>W</code>; it can  be obtained with the  simplified call &#39;Hecke(W,q)&#39;. Certain invariants of  the irreducible characters of  this algebra play a  special role in the representation  theory of the underlying  finite Coxeter groups, namely the <code>a</code>- and <code>A</code>-invariants. For basic properties of Iwahori-Hecke algebras and their  relevance to the representation theory of finite groups of Lie type, see for example Curtis and Reiner 1987, Sections~67 and 68.</p><p>In  the  following  example,  we  compute  the multiplication table for the <code>0</code>-Iwahori–Hecke algebra associated with the Coxeter group of type <code>A_2</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; H=hecke(W,0)             # One-parameter algebra with `q=0`
Hecke(A₂,0)

julia&gt; T=Tbasis(H)              # Create the `T` basis
(::getfield(Gapjm.Hecke, Symbol(&quot;#f#25&quot;)){Int64,Perm{Int16},HeckeAlgebra{Int64,Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}}) (generic function with 4 methods)

julia&gt; el=words(W)
6-element Array{Array{Int8,1},1}:
 []       
 [2]      
 [1]      
 [2, 1]   
 [1, 2]   
 [1, 2, 1]

julia&gt; T.(el)*permutedims(T.(el))        # multiplication table
6×6 Array{HeckeTElt{Perm{Int16},Int64,Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}},2}:
 T.    T₂     T₁     T₂₁    T₁₂    T₁₂₁ 
 T₂    -T₂    T₂₁    -T₂₁   T₁₂₁   -T₁₂₁
 T₁    T₁₂    -T₁    T₁₂₁   -T₁₂   -T₁₂₁
 T₂₁   T₁₂₁   -T₂₁   -T₁₂₁  -T₁₂₁  T₁₂₁ 
 T₁₂   -T₁₂   T₁₂₁   -T₁₂₁  -T₁₂₁  T₁₂₁ 
 T₁₂₁  -T₁₂₁  -T₁₂₁  T₁₂₁   T₁₂₁   -T₁₂₁
</code></pre><p>Thus,  we work  with algebras  with arbitrary  parameters. We will see that this also works on the level of characters and representations.</p><p>finally, benchmarks on julia 1.0.2</p><pre><code class="language-benchmark">julia&gt; function test_w0(n)
         W=coxgroup(:A,n)
         Tbasis(hecke(W,Pol([1],1)))(longest(W))^2
       end
test_w0 (generic function with 1 method)

julia&gt; @btime test_w0(7);
  132.737 ms (1788153 allocations: 157.37 MiB)</code></pre><p>Compare to GAP3 where the following function takes 0.92s</p><pre><code class="language-none">test_w0:=function(n)local W,T,H;
  W:=CoxeterGroup(&quot;A&quot;,n);H:=Hecke(W,X(Rationals));T:=Basis(H,&quot;T&quot;);
  T(LongestCoxeterWord(W))^2;
end;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Hecke.jl#L1-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Hecke.hecke" href="#Gapjm.Hecke.hecke"><code>Gapjm.Hecke.hecke</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>hecke( W [, parameter][,rootpara=r]) return a Hecke algebra for W</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; Pol(:q)
q

julia&gt; H=hecke(W,q)
Hecke(B₂,q)

julia&gt; H.para
2-element Array{Array{Pol{Int64},1},1}:
 [q, -1]
 [q, -1]

julia&gt; H=hecke(W,q^2,rootpara=q)
Hecke(B₂,q²,rootpara=q)

julia&gt; [H.para,rootpara(H)]
2-element Array{Array{T,1} where T,1}:
 Array{Pol{Int64},1}[[q², -1], [q², -1]]
 Pol{Int64}[q, q]                                  

julia&gt; H=hecke(W,[q^2,q^4],rootpara=[q,q^2])
Hecke(B₂,Pol{Int64}[q², q⁴],rootpara=Pol{Int64}[q, q²])

julia&gt; [H.para,rootpara(H)]
2-element Array{Array{T,1} where T,1}:
 Array{Pol{Int64},1}[[q², -1], [q⁴, -1]]
 Pol{Int64}[q, q²]

julia&gt; H=hecke(W,9,rootpara=3)
Hecke(B₂,9,rootpara=3)

julia&gt; [H.para,rootpara(H)]
2-element Array{Array{T,1} where T,1}:
 Array{Int64,1}[[9, -1], [9, -1]]
 [3, 3]                              </code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Hecke.jl#L134-L177">source</a></section><h1><a class="nav-anchor" id="KL.jl-Documentation-1" href="#KL.jl-Documentation-1">KL.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.KL" href="#Gapjm.KL"><code>Gapjm.KL</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>This  module ports Chevie functionality for Kazhdan-Lusztig polynomials and bases.</p><p>Let  <code>ℋ</code> be  the Iwahori-Hecke algebra  of a Coxeter  system <code>(W,S)</code>, with quadratic  relations <code>(Tₛ-uₛ₀)(Tₛ-uₛ₁)=0</code>  for <code>s∈  S</code>. If  <code>-uₛ₀uₛ₁</code> has a square  root  <code>wₛ</code>,  we  can  scale  the  basis  <code>Tₛ</code>  to  get  a new basis <code>tₛ=-Tₛ/wₛ</code>    with   quadratic    relations   <code>(tₛ-vₛ)(tₛ+vₛ⁻¹)=0</code>   where <code>vₛ=wₛ/uₛ₁</code>.   The  most  general  case   when  Kazhdan-Lusztig  bases  and polynomials  can be defined is when the parameters <code>vₛ</code> belong to a totally ordered  abelian group <code>Γ</code>  for multiplication, see  Lus83. We set <code>Γ⁺= {γ∈ Γ∣γ&gt;0}</code> and <code>Γ⁻={γ⁻¹∣γ∈ Γ⁺}={γ∈ Γ∣γ&lt;0}</code>.</p><p>Thus  we assume <code>ℋ</code> defined over the ring <code>ℤ[Γ]</code>, the group algebra of <code>Γ</code> over  <code>ℤ</code>, and the quadratic  relations of <code>ℋ</code>  associate to each <code>s∈ S</code> a <code>vₛ∈  Γ⁺</code> such that  <code>(tₛ-vₛ)(tₛ+vₛ⁻¹)=0</code>. We also  set <code>qₛ=vₛ²</code> and define the  basis <code>Tₛ=vₛtₛ</code> with quadratic relations <code>(Tₛ-qₛ)(Tₛ+1)=0</code>; for <code>w∈ W</code> with reduced expression <code>w=s₁…sₙ</code> we define <code>q_w∈ Γ⁺</code> by <code>q_w^½=v_{s₁}…v_{sₙ}</code> and let <code>q_w=(q_w^½)²</code>.</p><p>We  define the bar involution on <code>ℋ</code>  by linearity: on <code>ℤ[Γ]</code> we define it by  <span>$\overline{∑_{γ∈ Γ}a_γγ}= ∑_{γ∈ Γ} a_γ γ⁻¹$</span> and we extend it to <code>ℋ</code> by  <span>$\overline  Tₛ=Tₛ⁻¹$</span>.  Then  the  Kazhdan-Lusztig  basis <code>C′_w</code> is defined  as  the  only  basis  of  <code>ℋ</code>  stable  by the bar involution and congruent to <span>$t_w$</span> modulo <span>$∑_{w∈ W}Γ⁻ t_w$</span>.</p><p>The  basis <code>C′_w</code> can be computed  as follows. We define elements <span>$R_{x,y}$</span> of  <code>ℤ[Γ]</code> by  <span>$T_y⁻¹=∑_x \overline{R_{x,y⁻¹}}  q_x⁻¹T_x$</span>. We  then define inductively  the Kazhdan-Lusztig  polynomials (in  this general  context we should  say the  Kazhdan-Lusztig elements  of <code>ℤ[Γ]</code>,  which belong  to the subalgebra  of <code>ℤ[Γ]</code> generated by  the <code>qₛ</code>) by <span>$P_{x,w}=τ_{≤(q_w/q_x)^½} (∑_{x&lt;y≤w}R_{x,y}P_{y,w})$</span>  where <code>τ</code>  is the  truncation: <span>$τ_≤\nu ∑_{γ∈ Γ} a_γγ= ∑_{γ≤\nu}a_γγ$</span>; the induction is thus on decreasing <code>x</code> for the Bruhat order  and  starts  at  <span>$P_{w,w}=1$</span>.  We  have  then  <span>$C′_w=∑_y q_w^{-1/2} P_{y,w}T_y$</span>.</p><p>The  Chevie code  for the  Kazhdan-Lusztig bases  <code>C</code>, <code>D</code> and their primed versions, has been initially written by Andrew Mathas around 1994, who also contributed  to  the  design  of  the programs dealing with Kazhdan-Lusztig bases. He also implemented some other bases, such as the Murphy basis which can  be  found  in  the  Chevie  contributions  directory. The code for the unequal  parameters  case  has  been  written  around  1999  by F.Digne and J.Michel. The other Kazhdan-Lusztig bases are computed in terms of the <code>C′</code> basis.</p><p>When  the <code>ℤ[Γ]</code> is a  Laurent polynomial ring the  bar operation is taking the  inverse of  the variables,  and truncation  is keeping terms of degree smaller or equal to that of <code>ν</code>. It is possible to use arbitrary groups <code>Γ</code> as   long   as   methods   <code>bar</code>:<span>$∑_{γ∈   Γ}   a_γγ↦  ∑_{γ∈  Γ}  a_γγ⁻¹$</span>, <code>positive_part</code>  : <span>$∑_{γ∈  Γ} a_γγ↦  ∑_{γ≥ 1}  a_γγ$</span> and <code>negative_part</code>: <span>$∑_{γ∈  Γ}  a_γγ  ↦  ∑_{γ≤  1}  a_γγ$</span>  have been defined on <code>ℤ[Γ]</code>. These operations   will   be   used   internally   by  the  programs  to  compute Kazhdan-Lusztig bases.</p><p>finally, benchmarks on julia 1.0.2</p><pre><code class="language-benchmark">julia&gt; function test_kl(W)
         q=Pol([1],1); H=hecke(W,q^2,rootpara=q)
         C=Cpbasis(H); T=Tbasis(H)
         [T(C(w)) for w in elements(W)]
       end
test_kl (generic function with 1 method)

julia&gt; @btime test_kl(coxgroup(:F,4));
2.265 s (22516606 allocations: 1.81 GiB)</code></pre><p>Compare to GAP3 where the following function takes 11s for F4</p><pre><code class="language-none">test_kl:=function(W)local q,H,T,C;
  q:=X(Rationals);H:=Hecke(W,q^2,q);
  T:=Basis(H,&quot;T&quot;);C:=Basis(H,&quot;C&#39;&quot;);
  List(Elements(W),e-&gt;T(C(e)));
end;</code></pre><p>Another benchmark:</p><pre><code class="language-benchmark">function test_kl2(W)
  el=elements(W)
  [KLPol(W,x,y) for x in el, y in el]
end

test_kl2 (generic function with 1 method)

julia&gt;@btime test_kl2(coxgroup(:F,4));
  8s (97455915 allocations: 6.79 GiB)</code></pre><p>Compare to GAP3 where the following function takes 42s for F4</p><pre><code class="language-none">test_kl2:=function(W)local el;
  el:=Elements(W);
  List(el,x-&gt;List(el,y-&gt;KazhdanLusztigPolynomial(W,x,y)));
end;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/KL.jl#L22-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.KL.KLPol" href="#Gapjm.KL.KLPol"><code>Gapjm.KL.KLPol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>KLPol(W,y,w) returns the Kazhdan-Lusztig polynomial P_{y,w} of W</p><p>To  compute Kazhdan-Lusztig polynomials in  the one-parameter case it seems that  the best  approach still  is by  using the  recursion formula  in the original  article KL79. One can first run  a number of standard checks on a given  pair  of  elements  to  see  if the computation of the corresponding polynomial  can be reduced to a similar computation for elements of smaller length. One such check involves the notion of critical pairs (cf. Alv87): a pair  of elements <code>w₁,w₂∈  W</code> such that  <code>w₁≤w₂</code> is <em>critical</em>  if <code>ℒ(w₂) ⊆ ℒ(w₁)</code>  and <code>ℛ (w₂)⊆ ℛ (w₁)</code>, where <code>ℒ</code>  and <code>ℛ</code> denote the left and right descent  set, respectively.  Now if  <code>y≤w ∈  W</code> are arbitrary elements then there   always  exists  a  critical  pair   <code>z≤w</code>  with  <code>y≤z≤w</code>  and  then <code>P_{y,w}=P_{z,w}</code>.  Given two elements <code>y</code> and <code>w</code>, such a critical pair is found by the function &#39;critical_pair&#39;. Whenever the polynomial corresponding to a critical pair is computed then this pair and the polynomial are stored in the property <code>:klpol</code> of the underlying Coxeter group.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:B,3)
B₃

julia&gt; map(i-&gt;map(x-&gt;KLPol(W,one(W),x),elements(W,i)),1:W.N)
9-element Array{Array{Pol{Int64},1},1}:
 [1, 1, 1]                       
 [1, 1, 1, 1, 1]                 
 [1, 1, 1, 1, 1, 1, 1]           
 [1, 1, 1, x+1, 1, 1, 1, 1]      
 [x+1, 1, 1, x+1, x+1, 1, x+1, 1]
 [1, x+1, 1, x+1, x+1, x²+1, 1]  
 [x+1, x+1, x²+x+1, 1, 1]        
 [x²+1, x+1, 1]                  
 [1]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/KL.jl#L186-L220">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Hecke.Tbasis" href="#Gapjm.Hecke.Tbasis"><code>Gapjm.Hecke.Tbasis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:B,3)
B₃

julia&gt; Pol(:v);H=hecke(W,v^2,rootpara=v)
Hecke(B₃,v²,rootpara=v)

julia&gt; C=Cpbasis(H)
(::getfield(Gapjm.KL, Symbol(&quot;#f#10&quot;)){Pol{Int64},Perm{Int16},HeckeAlgebra{Pol{Int64},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}}) (generic function with 4 methods)

julia&gt; T=Tbasis(H)
(::getfield(Gapjm.Hecke, Symbol(&quot;#f#25&quot;)){Pol{Int64},Perm{Int16},HeckeAlgebra{Pol{Int64},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}}) (generic function with 4 methods)

julia&gt; T(C(1,2))
v⁻²T.+v⁻²T₂+v⁻²T₁+v⁻²T₁₂</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/KL.jl#L347-L364">source</a></section><h1><a class="nav-anchor" id="Garside.jl-Documentation-1" href="#Garside.jl-Documentation-1">Garside.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Garside" href="#Gapjm.Garside"><code>Gapjm.Garside</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Garside  monoids are a general class  of monoids whose most famous examples are  the braid  and dual  braid monoids.  The implementation  of these last monoids is in the framework of a general implementation of Garside monoids.</p><p>To   define  them  we  first  need   to  introduce  some  vocabulary  about divisibility  in monoids. A <em>left divisor</em> of  <code>x</code> is a <code>d</code> such that there exists  <code>y</code> with <code>x=dy</code> (and then we say  that <code>x</code> is a <em>right multiple</em> of <code>d</code>).  We say  that a  monoid <code>M</code>  is left  (resp. right) cancellable if an equality <code>dx=dy</code> (resp. <code>xd=yd</code>) implies <code>x=y</code>. The divisor <code>d</code> is <em>proper</em> if  <code>y≠1</code>. We say  that <code>x</code> is  an <em>atom</em> if  it has no proper left divisor apart from <code>1</code>. A <em>left gcd</em> of <code>x</code> and <code>y</code> is a common left divisor <code>d</code> of <code>x</code>  and <code>y</code> such that  any other common left  divisor is a left divisor of <code>d</code>. Similarly a <em>right lcm</em> of <code>x</code> and <code>y</code> is a common multiple which is a left divisor of any other common multiple.</p><p>We  call <em>Garside</em> a monoid <code>M</code> which is:</p><ul><li>left and right cancellable.</li><li>generated by its atoms,  which are finite in number.</li><li>such that any element has only finitely many divisors.</li><li>admits left and  right  gcds  and  lcms.</li><li>admits a <em>Garside element</em>, which is an element <code>Δ</code> whose set of left and right divisors coincide and generate <code>M</code>.</li></ul><p>Garside  elements are not  unique, but there  is a unique  minimal one (for divisibility); we assume such an element has been chosen. Then the divisors of  <code>Δ</code> are called the  <em>simples</em> of <code>M</code>. A  Garside monoid embeds into its group  of fractions, which is called a <em>Garside group</em> (a Garside group may have  several distinct Garside structures, as  we will see for Braid groups of finite Coxeter groups).</p><p>We  also implement <em>locally Garside</em> monoids,  which are monoids where lcms do  not always exist, but exist when any common multiple exists; the set of simples  is then not defined using a  Garside element, but by the condition that  they contain the atoms and are  closed under lcms and taking divisors (see  [BDM01]); since it is not ensured by the existence of <code>Δ</code>, one has to add  the condition that  any element is  divisible by finitely many simples (but  the number of simples can be infinite). The main example is the braid monoid of an infinite Coxeter group. It is not known if these monoids embed in  their group of fractions (though that has been proved for braid monoids of Coxeter groups by Paris [Paris01]) and thus computing in the monoid does not help for computing in the group (only the monoid is implemented here).</p><p>What allows computing with Garside and locally Garside monoids, and Garside groups,  is the fact  that they admit  normal forms –-  these normal forms where  first exhibited for  braid monoids by  Deligne [Del72], who extended previous work of Brieskorn, Saito [BS72] and Garside [Gar69]:</p><p>(i) Let  <code>M</code> be a locally Garside monoid and let <code>b∈ M</code>. Then there is a unique maximal left simple divisor <code>α(b)</code> of <code>b</code>, called the <em>head</em> of <code>b</code> –- any other simple dividing <code>b</code> on the left divides <code>α(b)</code> on the left.</p><p>(ii) Assume  <code>M</code> is a Garside monoid, <code>Δ</code> is  its Garside element and <code>G</code> is its group  of fractions. Then,  given any element  <code>x∈ G</code>, there  is some power <code>Δⁱ</code> such that <code>Δⁱ x∈ M</code>.</p><p>A consequence of (i) is that any element has a canonical decomposition as a product of simples, called its left-greedy normal form. If we define <code>ω(x)</code> by  <code>x=α(x)ω(x)</code>, then the normal form of <code>x</code> is <code>α(x)α(ω(x))α(ω^2(x))…</code> We use  the normal form to represent elements  of <code>M</code>, and when <code>M</code> is Garside (ii)  to represent elements  of <code>G</code>: given  <code>x∈ G</code> we  compute the smallest power  <code>i</code>  such  that  <code>Δⁱ  x∈  M</code>,  and  we  represent  <code>x</code> by the couple <code>(i,Δ⁻ⁱx)</code>.  We are thus reduced to the case where <code>x∈ M</code>, not divisible by <code>Δ</code>,  where we represent  <code>x</code> by the  sequence of simples which constitutes its normal form. We now describe Artin-Tits braid monoids. Let <code>(W,S)</code> be a Coxeter system, that is <code>W</code> has presentation</p><p><code>⟨s∈ S∣s^2=1, sts⋯ =tst⋯   (mₛₜ factors on each side) for s,t∈ S⟩</code></p><p>for  some Coxeter matrix <code>mₛₜ</code> for <code>s,t∈ S</code>. The braid group <code>B</code> associated to <code>(W,S)</code> is the group defined by the presentation</p><p><code>⟨𝐬∈ 𝐒∣ 𝐬𝐭𝐬⋯ =𝐭𝐬𝐭⋯  (mₛₜ factors on each side) for 𝐬,𝐭∈ 𝐒⟩</code></p><p>The <em>positive</em> braid monoid <code>B⁺</code> associated to <code>W</code> is the monoid defined by the  presentation above –- it identifies to the submonoid of <code>B</code> generated by  <code>𝐒</code> by  the result  of Paris  mentioned above.  This monoid  is locally Garside,  with set of simples  in bijection with elements  of <code>W</code> and atoms the elements of <code>𝐒</code>; we will denote by <code>𝐖</code> the set of simples, and by <code>𝐰 ↦ w</code>  the bijection between simples and elements  of <code>W</code>. The group <code>W</code> has a length  defined  in  terms  of  reduced expressions. Similarly, having only homogeneous relations, <code>B⁺</code> has a natural length function. Then <code>𝐖</code> can be characterized  as the subset of the elements  of <code>B⁺</code> of the same length as their image in <code>W</code>.</p><p>If  <code>W</code> is finite, then <code>B⁺</code> is Garside with Garside element the element of <code>𝐖</code> whose image is the longest element  of <code>W</code>. A finite Coxeter group is also  a reflection group in  a real vector space,  thus in its complexified <code>V</code>,  and <code>B</code> has also a topological definition as the fundamental group of the  space <code>Vʳᵉᵍ/W</code>, where <code>Vʳᵉᵍ</code>  is the set of  elements of <code>V</code> which are fixed  by no  non-identity element  of <code>S</code>;  however, we  will not use this here.</p><p>Given a Coxeter group <code>W</code>,</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,4)
A₄

julia&gt; B=BraidMonoid(W)
BraidMonoid(A₄)</code></pre><p>constructs  the  associated  braid  monoid,  and  then  as  a  function &#39;B&#39; constructs  elements of the braid monoid (or group when <code>W</code> is finite) from a list of generators.</p><pre><code class="language-julia-repl">julia&gt; w=B(1,2,3,4)
1234

julia&gt; w^3
121321432.343

julia&gt; word(W,α(w^3))
9-element Array{Int64,1}:
 1
 2
 1
 3
 2
 1
 4
 3
 2

julia&gt; w^4
δ.232432

julia&gt; inv(w)
(1234)⁻¹</code></pre><p>As  seen in the fourth  line above, the function  &#39;α(b)&#39; returns the simple <code>α(b)∈ 𝐖</code> as an element of <code>W</code>.</p><p>How  an element of  a Garside group  is printed is  controlled by IOcontext &#39;:greedy&#39;.  By default, elements are printed  as fractions <code>a⁻¹b</code> where <code>a</code> and  <code>b</code> have no left common divisor. Each  of <code>a</code> and <code>b</code> is printed using its left-greedy normal form, that is a maximal power of the Garside element followed  the rest.  One can  print the  entire element  in the left-greedy normal  from by setting the &#39;:greedy&#39; IOContext; with the same <code>w</code> as above we have:</p><pre><code class="language-julia-repl">julia&gt; repr(w^-1,context=IOContext(stdout,:greedy=&gt;true,:limit=&gt;true))
&quot;δ⁻¹.232432&quot;</code></pre><p>Finally,  <code>repr</code> gives   <code>w</code>  back   in  a   form  which   after  assigning &#39;B=braid(braid_monoid(W))&#39; can be input back into Julia:</p><pre><code class="language-julia-repl">julia&gt; repr(w)
&quot;B(1,2,3,4)&quot;

julia&gt; repr(w^3)
&quot;B(1,2,1,3,2,1,4,3,2,3,4,3)&quot;

julia&gt; repr(w^-1)
&quot;B(-4,-3,-2,-1)&quot;</code></pre><p>In  general elements of  a Garside monoid  are displayed thus  as a list of their constituting atoms.</p><p>We  now describe the dual braid monoid.  For that, we first give a possible approach  to construct Garside monoids. Given a  group <code>W</code> and a set <code>S</code> of generators  of <code>W</code> as a monoid, we  define the length <code>l(w)</code> as the minimum number of elements of <code>S</code> needed to write <code>w</code>. We then define left divisors of   <code>x</code>  as  the  <code>d</code>   such  that  there  exists   <code>y</code>  with  <code>x=dy</code>  and <code>l(d)+l(y)=l(x)</code>.  We say that <code>w∈ W</code> is  balanced if its set of left and right  divisors coincide,  is a  lattice (where  upper and lower bounds are lcms and gcds) and generates <code>W</code>. Then we have:</p><p>suppose <code>w</code> is balanced and let <code>[1,w]</code> be its set of divisors (an interval for  the partial order  defined by divisibility).  Then the monoid <code>M</code> with generators  <code>[1,w]</code> and relations  <code>xy=z</code> whenever <code>xy=z</code>  holds in <code>W</code> and <code>l(x)+l(y)=l(z)</code>  is Garside,  with simples  <code>[1,w]</code> and  atoms <code>S</code>.  It is called the interval monoid defined by the interval <code>[1,w]</code>.</p><p>The  Artin-Tits braid monoid  is an interval  monoid by taking  for <code>S</code> the Coxeter generators, in which case <code>l</code> is the Coxeter length, and taking for <code>w</code>  the longest element of <code>W</code>. The dual monoid, constructed by Birman, Ko and  Lee  for  type  <code>A</code>  and  by  Bessis  for  all  well-generated complex reflection  groups, is obtained in  a similar way, by  taking this time for <code>S</code>  the set of all reflections, and for <code>w</code> a Coxeter element; then <code>l</code> is the  reflection length  &#39;reflength&#39; (for  well-generated complex reflection groups  whihc are not real <code>S</code> contains only those reflections which divide <code>w</code>  for the  reflection length);  for the  dual monoid  the simples are of cardinality  the  generalized  Catalan  numbers.  An  interval  monoid  has naturally  an inverse morphism from <code>M</code>  to <code>W</code>, called &#39;EltBraid&#39; which is the  quotient map from the  interval monoid to <code>W</code>  which sends back simple braids to <code>[1,w]</code>. #A  last notable  notion is  <em>reversible</em> monoids.  Since in Chevie we store #only  left normal forms, it is easy to compute left lcms and gcds, but hard #to  compute right ones.  But this becomes  easy to do  if the monoid has an #operation  &#39;reverse&#39;, which has the property that  &#39;a&#39; is a left divisor of #&#39;b&#39;  if and only if  &#39;reverse(a)&#39; is a right  divisor of &#39;reverse(b)&#39;. This #holds  for Artin-Tits  and dual  braid monoids;  Artin-Tits monoids  have a #reverse  operation which consists of reversing a word, written as a list of #atoms.  The dual monoid  also has a  reverse operation defined  in the same #way,  but this operation changes  monoid: it goes from  the dual monoid for #the  Coxeter element <code>w</code> to the dual  monoid for the Coxeter element <code>w⁻¹</code>. #The  operations &#39;RightLcm&#39; and  &#39;RightGcd&#39;, as well  quite a few algorithms #have faster implementations if the monoid has a reverse operation.</p><p>This module implements functions to solve the conjugacy problem and compute centralizers  in Garside groups, following the work of Franco, Gebhardt and Gonzalez-Meneses.</p><p>Two  elements <code>w</code> and <code>w&#39;</code> of a monoid  <code>M</code> are <em>conjugate</em> in <code>M</code> if there exists  <code>x∈ M</code> such that <code>wx=xw&#39;</code>; if  <code>M</code> satisfies the Öre conditions, it has  a  group  of  fractions  where  this  becomes  <code>x⁻¹wx=w&#39;</code>,  the  usual definition  of conjugacy. A special case  which is even closer to conjugacy in  the group is if there exists <code>y∈  M</code> such that <code>w=xy</code> and <code>w&#39;=yx</code>. This relation  is not transitive in general,  but we call <em>cyclic conjugacy</em> the transitive closure of this relation, a restricted form of conjugacy.</p><p>The  next  observation  is  that  if  <code>w,w&#39;</code>  are conjugate in the group of fractions  of the Garside monoid <code>M</code> then  they are conjugate in <code>M</code>, since if  <code>wx=xw&#39;</code> then  there is  a power  <code>Δⁱ</code> which  is central and such that <code>xΔⁱ∈ M</code>. Then <code>wxΔⁱ=xΔⁱ w&#39;</code> is a conjugation in <code>M</code>.</p><p>The  crucial observation for solving the  conjugacy problem is to introduce <code>inf(w):=sup{i such  that  Δⁱ   divides  w}</code>  and <code>sup(w):=inf{i such  that  w  divides Δⁱ}</code>, and to notice  that the number of  conjugates of <code>w</code> with  same <code>inf</code> and <code>sup</code> as <code>w</code>  is finite. Further, a  theorem of Birman shows  that the maximum <code>inf</code> and  minimum <code>sup</code> in a conjugacy class can be achieved simultaneously; the elements  achieving this are called the super summit set of <code>w</code>. Thus a way to  determine if two elements are conjugate  is to find a representative of both  of them in  their super summit  set, and then  solve conjugacy within that  set. This can also be used  to compute the centralizer of an element: if  we consider  the super  summit set  as the  objects of a category whose morphisms are the conjugations by simple elements, the centralizer is given by the endomorphisms of the given object.</p><p>We illustrate this on an example:</p><pre><code class="language-julia-repl">julia&gt; b=B(2,1,4,1,4)
214.14

julia&gt; c=B(1,4,1,4,3)
14.143

julia&gt; d=representative_operation(b,c)
(1)⁻¹21321432

julia&gt; b^d
14.143

julia&gt; centralizer_generators(b)
3-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}},1}:
 21.1         
 321432.213243
 4

julia&gt; C=conjcat(b,:ss)
category with 10 objects and 32 generating maps

julia&gt; C.obj
10-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}},1}:
 214.14
 14.124
 143.13
 1214.4
 13.134
 124.24
 1343.1
 24.214
 134.14
 14.143</code></pre><p>There  is a faster  solution to the  conjugacy problem given in [gebgon10]: for  each <code>b∈ M</code>, they define a  particular simple left divisor of <code>b</code>, its <em>preferred  prefix</em>  such  that  the  operation  <em>sliding</em> which cyclically conjugates  <code>b</code> by  its preferred  prefix, is  eventually periodic, and the period  is contained in the super summit set  of <code>x</code>. We say that <code>x</code> is in its  sliding circuit if some  iterated sliding of <code>x</code>  is equal to <code>x</code>. The set  of sliding  circuits in  a given  conjugacy class  is smaller than the super  summit  set,  thus  allows  to  solve  the conjugacy problem faster. Continuing from the above example,</p><pre><code class="language-julia-repl">julia&gt; word(W,preferred_prefix(b))
2-element Array{Int64,1}:
 2
 1

julia&gt; b^B(preferred_prefix(b))
1214.4

julia&gt; b1=b^B(preferred_prefix(b))
1214.4

julia&gt; C=conjcat(b)
category with 3 objects and 7 generating maps

julia&gt; C.obj
3-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}},1}:
 214.14
 1214.4
 1343.1</code></pre><p>Finally,  we have implemented  Hao Zheng&#39;s algorithm  to extract roots in a Garside monoid:</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; B=BraidMonoid(W)
BraidMonoid(A₃)

julia&gt; pi=B(B.delta)^2
δ²

julia&gt; root(pi,2)
δ

julia&gt; root(pi,3)
1232

julia&gt; root(pi,4)
132</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Garside.jl#L1-L330">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Garside.left_divisors" href="#Gapjm.Garside.left_divisors"><code>Gapjm.Garside.left_divisors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>left_divisors( M, s)</p><p>all  the left divisors of the simple element <code>s</code> of the Garside monoid <code>M</code>, as  a vector  of vectors,  where the  i+1-th vector  holds the  divisors of length i in the atoms.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; B=BraidMonoid(W)
BraidMonoid(A₃)

julia&gt; map(x-&gt;B.(x),Garside.left_divisors(B,W(1,3,2)))
4-element Array{Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}},1},1}:
 [.]   
 [1, 3]
 [13]  
 [132] 

julia&gt; B=DualBraidMonoid(W)
DualBraidMonoid(A₃,c=[1, 3, 2])

julia&gt; map(x-&gt;B.(x),Garside.left_divisors(B,W(1,3,2)))
4-element Array{Array{Gapjm.Garside.GarsideElm{Perm{Int16},DualBraidMonoid{Perm{Int16},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}},1},1}:
 [.]                     
 [1, 2, 3, 4, 5, 6]      
 [12, 13, 15, 25, 34, 45]
 [δ]                     </code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Garside.jl#L425-L456">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Garside.DualBraidMonoid" href="#Gapjm.Garside.DualBraidMonoid"><code>Gapjm.Garside.DualBraidMonoid</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Let  <code>W</code> be a well generated complex  reflection group and <code>c</code> be a Coxeter element  of <code>W</code> (if <code>W</code> is a Coxeter group and no <code>c</code> is given a particular one  is chosen  by making  the product  of elements  in a  partition of the Coxeter  diagram in two sets where  elements in each commute pairwise). The result  is the dual braid  monoid determined by <code>W</code>  and <code>c</code>: let <code>w</code> be an element  of <code>W</code> or a sequence  <code>s₁,…,sₙ</code> of integers indices of reflections of <code>W</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; B=DualBraidMonoid(W)
DualBraidMonoid(A₃,c=[1, 3, 2])

julia&gt; B(2,1,2,1,1)
12.1.1.1

julia&gt; B(-1,-2,-3,1,1)
(25.1)⁻¹1.1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Garside.jl#L581-L603">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Garside.fraction" href="#Gapjm.Garside.fraction"><code>Gapjm.Garside.fraction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>fraction(b) returns a tuple <code>(x,y)</code>  of two  elements with  no non-trivial  common left divisor and such that <code>b=inv(x)*y</code>.</p><pre><code class="language-julia-repl">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A₃)

julia&gt; b=B( 2, 1, -3, 1, 1)
(23)⁻¹321.1.1

julia&gt; fraction(b)
(23, 321.1.1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Garside.jl#L670-L685">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.word-Tuple{Gapjm.Garside.GarsideElm}" href="#Gapjm.word-Tuple{Gapjm.Garside.GarsideElm}"><code>Gapjm.word</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>word(b::GarsideElm) returns  a description  of <code>b</code>  as a  list of  the atoms  of which  it is a product.  If <code>b</code> is in the Garside group  but not the Garside monoid, it is represented  in  fraction  normal  form  where  as a special convention the inverses  of  the  atoms  are  represented  by  negating  the corresponding integer.</p><pre><code class="language-julia-repl">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A₃)

julia&gt; b=B(2,1,2,1,1)*inv(B(2,2))
(21)⁻¹1.12.21

julia&gt; word(b)
7-element Array{Int64,1}:
 -1
 -2
  1
  1
  2
  2
  1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Garside.jl#L703-L728">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Garside.representative_operation" href="#Gapjm.Garside.representative_operation"><code>Gapjm.Garside.representative_operation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>representative_operation(b,b1)</p><p>The  function returns <code>a</code> such that  <code>b^a=b1</code> if such exists, and <code>nothing</code> otherwise.  If an argument &lt;type&gt; is given,  the computation is done in the corresponding category –- see &quot;conjcat&quot;.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; B=BraidMonoid(coxgroup(:D,4))
BraidMonoid(D₄)

julia&gt; b=B(2,3,1,2,4,3);b1=B(1,4,3,2,2,2)
1432.2.2

julia&gt; representative_operation(b,b1)
(134312.23)⁻¹

julia&gt; representative_operation(b,b1,:cyc)
232.2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Garside.jl#L1042-L1065">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Garside.centralizer_generators" href="#Gapjm.Garside.centralizer_generators"><code>Gapjm.Garside.centralizer_generators</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>centralizer_generators(b)</p><p>a list of generators  of the centralizer of <code>b</code>.  The computation is done by computing the  endomorphisms  of  the  object  <code>b</code>  in  the  category  of its sliding circuits.  If an argument <code>type</code>  is given, the computation  is done in the corresponding  category –- see <code>conjcat</code>. The  main use of this is to compute  the  centralizer  in  the  category  of cyclic conjugacy by giving <code>:cyc</code> as the type.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; B=BraidMonoid(W)
BraidMonoid(D₄)

julia&gt; w=B(4,4,4)
4.4.4

julia&gt; cc=centralizer_generators(w)
8-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}},1}:
 (31432)⁻¹231432
 1              
 (2)⁻¹34.432    
 (1)⁻¹34.431    
 34.43          
 4              
 (32431)⁻¹132431
 2              

julia&gt; shrink(cc)
5-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}},1}:
 4            
 2            
 1            
 34.43        
 (3243)⁻¹13243

julia&gt; centralizer_generators(w,:cyc)
Set(Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}}[4])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Garside.jl#L1094-L1137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Garside.shrink" href="#Gapjm.Garside.shrink"><code>Gapjm.Garside.shrink</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>shrink(l)</p><p>The  list <code>l</code> is a  list of  elements of  the same Garside group <code>G</code>. This function  tries to find  another set of  generators of the  subgroup of <code>G</code> generated by the elements of <code>l</code>, of smaller total length (the length being counted  as returned by the function  <code>word</code>).</p><pre><code class="language-julia-repl">julia&gt; B=BraidMonoid(coxsym(3))
BraidMonoid(𝔖 ₃)

julia&gt; b=[B(1)^3,B(2)^3,B(-2,-1,-1,2,2,2,2,1,1,2),B(1,1,1,2)]
4-element Array{Gapjm.Garside.GarsideElm{Perm{UInt8},BraidMonoid{Perm{UInt8},Gapjm.CoxGroups.CoxSymmetricGroup{UInt8}}},1}:
 1.1.1              
 2.2.2              
 (1.12)⁻¹2.2.2.21.12
 1.1.12             

julia&gt; shrink(b)
2-element Array{Gapjm.Garside.GarsideElm{Perm{UInt8},BraidMonoid{Perm{UInt8},Gapjm.CoxGroups.CoxSymmetricGroup{UInt8}}},1}:
 2  
 1  </code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Garside.jl#L1262-L1286">source</a></section><h1><a class="nav-anchor" id="Chars.jl-Documentation-1" href="#Chars.jl-Documentation-1">Chars.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Chars" href="#Gapjm.Chars"><code>Gapjm.Chars</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>The  <code>CharTable</code> of a finite complex reflection group <code>W</code> is computed using the  decomposition of <code>W</code> in irreducible  groups (see <code>refltype</code>). For each irreducible  group the character  table is either  computed using recursive formulas  for the infinite series,  or read into the  system from a library file  for the  exceptional types.  Thus, character  tables can  be obtained quickly  even for very large groups  (e.g., E₈). Similar remarks apply for conjugacy classes.</p><p>The  conjugacy  classes  and  irreducible  characters of irreducible finite complex reflection groups have canonical labelings by certain combinatorial objects;  these labelings are used in the  tables we give. For the classes, these  are partitions or partition tuples  for the infinite series, or, for exceptional  Coxeter  groups,  Carter&#39;s  admissible  diagrams <a href="for other  primitive  complex  reflection  groups  we  just  use  words  in the generators  to specify  the classes">@Car72</a>.  For the  characters, these are again partitions  or partition tuples for the infinite series, and for the others they  are pairs  of two  integers <code>(d,e)</code>  where <code>d</code>  is the  degree of the character  and  <code>e</code>  is  the  smallest  symmetric  power  of the reflection representation  containing  the  given  character  as  a  constituent  (the <code>b</code>-invariant  of the character). This information is obtained by using the functions <code>classinfo</code> and <code>charinfo</code>. When you display the character table, the canonical labelings for classes and characters are those displayed.</p><p>A  typical example  is <code>coxgroup(:A,n)</code>,  the symmetric  group <code>𝔖ₙ₊₁</code> where classes and characters are parameterized by partitions of <code>n+1</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; CharTable(W)
CharTable(H(G(1,1,4)))
    │1111 211 22 31  4
────┼──────────────────
1111│   1  -1  1  1 -1
211 │   3  -1 -1  .  1
22  │   2   .  2 -1  .
31  │   3   1 -1  . -1
4   │   1   1  1  1  1

julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; ct=CharTable(W)
CharTable(W(G2))
     │A₀ Ã₁ A₁ G₂ A₂ A₁+Ã₁
─────┼─────────────────────
φ₁‚₀ │ 1  1  1  1  1     1
φ₁‚₆ │ 1 -1 -1  1  1     1
φ′₁‚₃│ 1  1 -1 -1  1    -1
φ″₁‚₃│ 1 -1  1 -1  1    -1
φ₂‚₁ │ 2  .  .  1 -1    -2
φ₂‚₂ │ 2  .  . -1 -1     2


julia&gt; ct.charnames
6-element Array{String,1}:
 &quot;\phi_{1,0}&quot;  
 &quot;\phi_{1,6}&quot;  
 &quot;\phi_{1,3}&#39;&quot; 
 &quot;\phi_{1,3}&#39;&#39;&quot;
 &quot;\phi_{2,1}&quot;  
 &quot;\phi_{2,2}&quot;  

julia&gt; ct.classnames
6-element Array{String,1}:
 &quot;A_0&quot;            
 &quot;\tilde A_1&quot;    
 &quot;A_1&quot;            
 &quot;G_2&quot;            
 &quot;A_2&quot;            
 &quot;A_1+\tilde A_1&quot;</code></pre><p>Recall  that our groups acts a reflection group on the vector space <code>V</code>, so have  fake degrees  (see &quot;fakeDegree&quot;).  The valuation  and degree of these give  two  integers  <code>b,B</code>  for  each  irreducible  character  of  <code>W</code> (see <code>charinf(W)[:b]</code>  and  <code>charinfo(W)[:B]</code>).  For  finite Coxeter groups, the valuation  and degree of  the generic degrees  of the one-parameter generic Hecke  algebra  give  two  more  integers  <code>a,A</code> (see <code>charinfo(W)[:a]</code> and <code>charinfo(W)[:A]</code>,  and [@Car85, Ch.11] for  more details). These will also be  used in the operations of truncated inductions explained in the chapter &quot;Reflection subgroups&quot;.</p><p>Iwahori-Hecke  algebras and  cyclotomic Hecke  algebras also have character tables, see the corresponding chapters.</p><p>We  now describe for each type our conventions for labeling the classes and characters.</p><p>Type  <code>Aₙ</code> (<code>n≥0</code>). In this  case we have  <code>W ≅ 𝔖ₙ₊₁</code>. The classes and characters  are labeled by partitions of <code>n+1</code>. The partition corresponding to  a class describes  the cycle type  for the elements  in that class; the representative   in  &#39;.classtext&#39;   is  the   concatenation  of  the  words corresponding  to each part, and to a part <code>i</code> is associated the product of <code>i-1</code>  consecutive generators (starting one  higher that the last generator used  for the previous  parts). The partition  corresponding to a character describes  the type of  the Young subgroup  such that the trivial character induced  from this  subgroup contains  that character with multiplicity <code>1</code> and such that every other character occurring in this induced character has a  higher <code>a</code>-value. Thus, the sign  character corresponds to the partition <code>(1ⁿ⁺¹)</code>  and  the  trivial  character  to  the  partition  <code>(n+1)</code>. The character of the reflection representation of <code>W</code> is labeled by <code>(n,1)</code>.</p><p>Type  <code>Bₙ</code> (<code>n≥2</code>). In this  case <code>W=W(Bₙ)</code> is  isomorphic to the wreath product  of the cyclic  group of order  <code>2</code> with the  symmetric group <code>𝔖ₙ</code>. Hence  the classes and characters are  parameterized by pairs of partitions such  that the total sum of their  parts equals <code>n</code>. The pair corresponding to  a class describes the signed cycle type for the elements in that class, as  in [@Car72]. We use the convention that  if <code>(λ,μ)</code> is such a pair then <code>λ</code>  corresponds  to  the  positive  and  <code>μ</code> to the negative cycles. Thus, <code>(1ⁿ,-)</code>  and <code>(-,1ⁿ)</code> label the trivial class and the class containing the longest  element, respectively.  The pair  corresponding to  an irreducible character is determined via Clifford theory, as follows.</p><p>We  have a semidirect product decomposition <code>W(Bₙ)=N ⋊ 𝔖ₙ</code> where <code>N</code> is the standard  <code>n</code>-dimensional  <code>𝔽₂ⁿ</code>-vector  space.  For  <code>a,b  ≥  0</code> such that <code>n=a+b</code> let <code>η_{a,b}</code> be the irreducible character of <code>N</code> which takes value <code>1</code>  on the first <code>a</code> standard basis vectors and value <code>-1</code> on the next <code>b</code> standard  basis vectors of <code>N</code>. Then  the inertia subgroup of <code>η_{a,b}</code> has the  form <code>T_{a,b}=N.(𝔖_a × 𝔖_b)</code> and  we can extend <code>η_{a,b}</code> trivially to an  irreducible  character  <code>η̃_{a,b}</code>  of  <code>T_{a,b}</code>.  Let  <code>α</code> and <code>β</code> be partitions  of <code>a</code> and <code>b</code>, respectively. We take the tensor product of the corresponding  irreducible characters of <code>𝔖_a</code> and <code>𝔖_b</code> and regard this as an  irreducible  character  of  <code>T_{a,b}</code>.  Multiplying this character with <code>η̃_{a,b}</code>  and  inducing  to  <code>W(Bₙ)</code>  yields an irreducible character <code>χ= χ_{(α,β)}</code>  of <code>W(Bₙ)</code>. This defines the correspondence between irreducible characters and pairs of partitions as above.</p><p>For example, the pair <code>((n),-)</code> labels the trivial character and <code>(-,(1ⁿ))</code> labels  the  sign  character.  The  character  of  the  natural  reflection representation is labeled by <code>((n-1),(1))</code>.</p><p>Type  <code>Dₙ</code> (<code>n≥4</code>). In this case <code>W=W(Dₙ)</code> can be embedded as a subgroup of index  <code>2</code> into the Coxeter  group <code>W(Bₙ)</code>. The intersection  of a class of <code>W(Bₙ)</code> with <code>W(Dₙ)</code> is either empty or a single class in <code>W(Dₙ)</code> or splits up  into two classes in  <code>W(Dₙ)</code>. This also leads  to a parameterization of the  classes of <code>W(Dₙ)</code> by pairs of  partitions <code>(λ,μ)</code> as before but where the  number of parts of <code>μ</code> is even and where there are two classes of this type  if <code>μ</code> is empty and all parts of  <code>λ</code> are even. In the latter case we denote  the two classes in <code>W(Dₙ)</code> by <code>(λ,+)</code> and <code>(λ,-)</code>, where we use the convention  that  the  class  labeled  by <code>(λ,+)</code> contains a representative which  can be written  as a word  in <code>{s₁,s₃,…,sₙ}</code> and  <code>(λ,-)</code> contains a representative which can be written as a word in <code>{s₂,s₃, …,sₙ}</code>.</p><p>By  Clifford theory the restriction of  an irreducible character of <code>W(Bₙ)</code> to  <code>W(Dₙ)</code>  is  either  irreducible  or  splits  up  into  two irreducible components.  Let <code>(α,β)</code> be  a pair of  partitions with total  sum of parts equal to <code>n</code>. If <code>α!=β</code> then the restrictions of the irreducible characters of  <code>W(Bₙ)</code> labeled  by <code>(α,β)</code>  and <code>(β,α)</code>  are irreducible and equal. If <code>α=β</code>  then the restriction of the character labeled by <code>(α,α)</code> splits into two  irreducible components  which we  denote by  <code>(α,+)</code> and <code>(α,-)</code>. Note that  this can only happen if <code>n</code> is  even. In order to fix the notation we use  a result of  [@Ste89] which describes  the value of  the difference of these  two  characters  on  a  class  of  the  form <code>(λ,+)</code> in terms of the character  values  of  the  symmetric  group  <code>𝔖_{n/2}</code>.  Recall that it is implicit  in the notation <code>(λ,+)</code> that all  parts of <code>λ</code> are even. Let <code>λ&#39;</code> be  the partition of <code>n/2</code> obtained by  dividing each part by <code>2</code>. Then the value  of <code>χ_{(α,-)}-χ_{(α,+)}</code> on an element in the class <code>(λ,+)</code> is given by  <code>2^{k(λ)}</code> times  the value  of the  irreducible character of <code>𝔖_{n/2}</code> labeled  by <code>α</code> on the class of  cycle type <code>λ&#39;</code>. (Here, <code>k(λ)</code> denotes the number of non-zero parts of <code>λ</code>.)</p><p>The  labels for the trivial, the  sign and the natural reflection character are the same as for <code>W(Bₙ)</code>, since these characters are restrictions of the corresponding characters of <code>W(Bₙ)</code>.</p><p>The groups <code>G(d,1,n)</code>. They  are isomorphic to the wreath product of the cyclic group of order <code>d</code> with  the  symmetric  group  <code>𝔖ₙ</code>.  Hence  the  classes  and characters are parameterized  by <code>d</code>-tuples of partitions such that the total sum of their parts  equals <code>n</code>. The words chosen  as representatives of the classes are, when <code>d&gt;2</code>, computed in a slightly different way than for <code>Bₙ</code>, in order to agree  with the words on which Ram  and Halverson compute the characters of the  Hecke algebra. First the parts of the <code>d</code> partitions are merged in one big  partition and sorted in  increasing order. Then, to  a part <code>i</code> coming from  the <code>j</code>-th partition is  associated the word <code>(l+1…1… l+1)ʲ⁻¹l+2…l+i</code> where <code>l</code> is the highest generator used to express the previous part.</p><p>The  <code>d</code>-tuple corresponding to an  irreducible character is determined via Clifford  theory in  a similar  way than  for the  <code>Bₙ</code> case.  The identity character  has the first  partition with one  part equal <code>n</code>  and the other ones  empty. The character of the  reflection representations has the first two  partitions with one part  equal respectively to <code>n-1</code>  and to <code>1</code>, and the other partitions empty.</p><p>The groups <code>G(de,e,n)</code>. They  are normal  subgroups of  index <code>e</code>  in <code>G(de,1,n)</code>.  The quotient is cyclic,  generated by the image <code>g</code>  of the first generator of <code>G(de,1,n)</code>. The  classes are parameterized as the  classes of <code>G(de,e,n)</code> with an extra information for a component of a class which splits.</p><p>According  to  [@Hu85],  a  class  <code>C</code>  of  <code>G(de,1,n)</code>  parameterized by a <code>de</code>-partition  <code>(S₀,…,S_{de-1})</code> is  in <code>G(de,e,n)</code>  if <code>e</code>  divides <code>∑ᵢ i ∑_{p∈  Sᵢ}p</code>. It splits in <code>d</code> classes for the largest <code>d</code> dividing <code>e</code> and all  parts of all <code>Sᵢ</code> and  such that <code>Sᵢ</code> is empty  if <code>d</code> does not divide <code>i</code>.  If <code>w</code> is in <code>C</code> then &#39;gⁱ w g⁻ⁱ&#39; for &#39;i in 0:d-1&#39; are representatives of  the  classes  of  <code>G(de,e,n)</code>  which  meet  <code>C</code>.  They are described by appending the integer <code>i</code> to the label for <code>C</code>.</p><p>The  characters are described by Clifford theory. We make <code>g</code> act on labels for  characters of <code>G(de,1,n)</code>  . The action  of <code>g</code> permutes circularly by <code>d</code>  the partitions in the <code>de</code>-tuple.  A character has same restriction to <code>G(de,e,n)</code>  as its transform by <code>g</code>.  The number of irreducible components of its restriction is equal to the order <code>k</code> of its stabilizer under powers of  <code>g</code>.  We  encode  a  character  of  <code>G(de,e,n)</code>  by first, choosing the smallest  for lexicographical order label  of a character whose restriction contains  it; then this label is periodic with a motive repeated <code>k</code> times; we  represent the  character by  one of  these motives,  to which we append <code>E(k)ⁱ</code> for &#39;i in 0:k-1&#39; to describe which component of the restriction we choose.</p><p>Types  <code>G₂</code> and <code>F₄</code>. The matrices  of character values and the orderings and  labelings of  the irreducible  characters are  exactly the  same as in [@Car85,  p.412/413]: in type <code>G₂</code> the character <code>φ₁,₃&#39;</code> takes the value -1 on  the reflection associated  to the long  simple root; in  type <code>F₄</code>, the characters  <code>φ₁,₁₂&#39;</code>, <code>φ₂,₄&#39;</code>, <code>φ₄,₇&#39;</code>, <code>φ₈,₉&#39;</code> and <code>φ₉,₆&#39;</code> occur in the induced  of the  identity from  the <code>A₂</code>  corresponding to the short simple roots;  the  pairs  (<code>φ₂,₁₆&#39;</code>,  <code>φ₂,₄″</code>)  and  (<code>φ₈,₃&#39;</code>, <code>φ₈,₉″</code>) are related by tensoring by sign; and finally <code>φ₆,₆″</code> is the exterior square of  the reflection representation. Note, however, that we put the long root at the left of the Dynkin diagrams to be in accordance with the conventions in [@Lus85, (4.8) and (4.10)].</p><p>The  classes  are  labeled  by  Carter&#39;s  admissible  diagrams  [@Car72]. A character is labeled by a pair <code>(d,b)</code> where <code>d</code> denotes the degree and <code>b</code> the  corresponding <code>b</code>-invariant. If there  are several characters with the same pair <code>(d,b)</code> we attach a prime to them, as in [@Car85].</p><p>Types  <code>E₆,E₇,E₈</code>. The character tables are obtained by specialization of those  of the Hecke algebra. The classes are labeled by Carter&#39;s admissible diagrams  [@Car72]. A  character is  labeled by  the pair <code>(d,b)</code> where <code>d</code> denotes  the degree and  <code>b</code> is the  corresponding <code>b</code>-invariant. For these types, this gives a unique labeling of the characters.</p><p>Non-crystallographic  types <code>I₂(m)</code>, <code>H₃</code>, <code>H₄</code>. In these cases we do not have  canonical  labelings  for  the  classes.  We  label  them  by reduced expressions.</p><p>Each  character for  type <code>H₃</code>  is uniquely  determined by the pair <code>(d,b)</code> where  <code>d</code> is the degree and  <code>b</code> the corresponding <code>b</code>-invariant. For type <code>H₄</code>  there are just  two characters (those  of degree <code>30</code>)  for which the corresponding  pairs are  the same.  These two  characters are nevertheless distinguished  by  their  fake  degrees:  the  character <code>φ₃₀,₁₀&#39;</code> has fake degree  <code>q¹⁰+q¹²+</code> higher terms, while <code>φ₃₀,₁₀″</code> has fake degree <code>q¹⁰+q¹⁴+</code> higher  terms. The characters in the table for type <code>H₄</code> are ordered in the same way as in [@AL82].</p><p>Finally,  the characters  of degree <code>2</code>  for type  <code>I₂(m)</code> are  ordered as follows.  The matrix representations affording the characters of degree <code>2</code> are given by: <code>ρ_j : s₁s₂ ↦ (\begin{array}{cc}E(m)^j&amp;0\0&amp;E(m)^{-j}\end{array}),  s₁↦(\begin{array}{cc}0&amp;1\1&amp;0\end{array}),</code> where  <code>1 ≤ j ≤  ⌊(m-1)/2⌋</code>. The reflection representation is  <code>ρ₁</code>. The  characters in  the table  are ordered by listing first the characters of degree 1 and then <code>ρ₁,ρ₂,…</code>.</p><p>Primitive complex reflection groups <code>G₄</code> to <code>G₃₄</code>. The  groups <code>G₂₃=H₃</code>, <code>G₂₈=F₄</code>, <code>G₃₀=H₄</code> are exceptional Coxeter groups and have  been  explained  above.  Similarly  for  the  other groups labels for characters  consist primarily  of the  pair <code>(d,b)</code>  where <code>d</code>  denotes the degree  and <code>b</code> is the corresponding  <code>b</code>-invariant. This is sufficient for <code>G₄</code>,  <code>G₁₂</code>, <code>G₂₂</code> and <code>G₂₄</code>. For other  groups there are pairs or triples of  characters which  have the  same <code>(d,b)</code>  value. We  disambiguate these according  to  the  conventions  of  [@Mal00]  for <code>G₂₇, G₂₉, G₃₁, G₃₃</code> and <code>G₃₄</code>:</p><ul><li>For <code>G₂₇</code>:</li></ul><p>The  fake degree  of <code>φ₃,₅&#39;</code>  (resp. <code>φ₃,₂₀&#39;</code>,  <code>φ₈,₉″</code>) has smaller degree that  of  <code>φ₃,₅″</code>  (resp.  <code>φ₃,₂₀″</code>,  <code>φ₈,₉&#39;</code>). The characters <code>φ₅,₁₅&#39;</code> and <code>φ₅,₆&#39;</code> occur with multiplicity 1 in the induced from the trivial character of  the parabolic subgroup  of type <code>A₂</code>  generated by the  first and third generator  (it is  asserted mistakenly  in [@Mal00]  that <code>φ₅,₆″</code>  does not occur in this induced; it occurs with multiplicity 2).</p><ul><li>For <code>G₂₉</code>:</li></ul><p>The  character  <code>φ₆,₁₀‴</code>  is  the  exterior  square  of <code>φ₄,₁</code>; its complex conjugate  is <code>φ₆,₁₀⁗</code>. The  character <code>φ₁₅,₄″</code> occurs  in <code>φ₄,₁⊗φ₄,₃</code>; the character  <code>φ₁₅,₁₂″</code>  is  tensored  by  the  sign  character from <code>φ₁₅,₄″</code>. Finally  <code>φ₆,₁₀&#39;</code> occurs in  the induced from  the trivial character of the standard parabolic subgroup of type <code>A₃</code> generated by the first, second and fourth generators.</p><ul><li>For <code>G₃₁</code>:</li></ul><p>The  characters <code>φ₁₅,₈&#39;</code>, <code>φ₁₅,₂₀&#39;</code> and <code>φ₄₅,₈″</code> occur in <code>φ₄,₁⊗φ₂₀,₇</code>; the character   <code>φ₂₀,₁₃&#39;</code>  is  complex  conjugate  of  <code>φ₂₀,₇</code>;  the  character <code>φ₄₅,₁₂&#39;</code>  is tensored by sign of <code>φ₄₅,₈&#39;</code>. The two terms of maximal degree of  the fakedegree of <code>φ₃₀,₁₀&#39;</code> are  <code>q⁵⁰+q⁴⁶</code> while for <code>φ₃₀,₁₀″</code> they are <code>q⁵⁰+2q⁴⁶</code>.</p><ul><li>For <code>G₃₃</code>:</li></ul><p>The  terms of  maximal degree  of the  fakedegree of <code>φ₁₀,₈&#39;</code> are <code>q²⁸+q²⁶</code> while  for <code>φ₁₀,₈&#39;</code> they are <code>q²⁸+q²⁴</code>. The  terms of maximal degree of the fakedegree   of  <code>φ₄₀,₅&#39;</code>  are  <code>q³¹+q²⁹</code>   while  for  <code>φ₄₀,₅″</code>  they  are <code>q³¹+2q²⁹</code>.  The character  <code>φ₁₀,₁₇&#39;</code> is  tensored by  sign of <code>φ₁₀,₈&#39;</code> and <code>φ₄₀,₁₄&#39;</code> is tensored by sign of <code>φ₄₀,₅&#39;</code>.</p><ul><li>For <code>G₃₄</code>:</li></ul><p>The  character <code>φ₂₀,₃₃&#39;</code> occurs in <code>φ₆,₁⊗φ₁₅,₁₄</code>. The character <code>φ₇₀,₉&#39;</code> is rational.  The character  <code>φ₇₀,₉″</code> occurs  in <code>φ₆,₁⊗φ₁₅,₁₄</code>.  The character <code>φ₇₀,₄₅&#39;</code>   is  rational.The   character  <code>φ₇₀,₄₅″</code>   is  tensored  by  the determinant  character of  <code>φ₇₀,₉″</code>. The  character <code>φ₅₆₀,₁₈&#39;</code> is rational. The character <code>φ₅₆₀,₁₈‴</code> occurs in <code>φ₆,₁⊗φ₃₃₆,₁₇</code>. The character <code>φ₂₈₀,₁₂&#39;</code> occurs    in   <code>φ₆,₁⊗φ₃₃₆,₁₇</code>.   The   character   <code>φ₂₈₀,₃₀″</code>   occurs   in <code>φ₆,₁⊗φ₃₃₆,₁₇</code>.  The  character  <code>φ₅₄₀,₂₁&#39;</code>  occurs  in <code>φ₆,₁⊗φ₁₀₅,₂₀</code>. The character  <code>φ₁₀₅,₈&#39;</code> is  complex conjugate  of <code>φ₁₀₅,₄</code>,  and <code>φ₈₄₀,₁₃&#39;</code> is complex  conjugate  of  <code>φ₈₄₀,₁₁</code>.  The  character  <code>φ₈₄₀,₂₃&#39;</code>  is  complex conjugate  of  <code>φ₈₄₀,₁₉</code>.  Finally  <code>φ₁₂₀,₂₁&#39;</code>  occurs  in induced from the trivial character of the standard parabolic subgroup of type <code>A₅</code> generated by the generators of <code>G₃₄</code> with the third one omitted.</p><p>For  the groups <code>G₅</code> and <code>G₇</code> we  adopt the following conventions. For <code>G₅</code> they are compatible with those of [@MR03] and [@BMM14].</p><ul><li>For <code>G₅</code>:</li></ul><p>We  let <code>W=ComplexReflectionGroup(5)</code>,  so the  generators are  <code>W(1)</code> and <code>W(2)</code>.</p><p>The  character <code>φ₁,₄&#39;</code> (resp. <code>φ₁,₁₂&#39;</code>, <code>φ₂,₃&#39;</code>) takes the value <code>1</code> (resp. <code>ζ₃</code>,  <code>-ζ₃</code>)  on  <code>W(1)</code>.  The  character  <code>φ₁,₈″</code> is complex conjugate to <code>φ₁,₁₆</code>,  and the character  <code>φ₁,₈&#39;</code> is complex  conjugate to <code>φ₁,₄&#39;</code> . The character  <code>φ₂,₅″</code> is complex  conjugate to <code>φ₂,₁</code>;  <code>φ₂,₅&#39;</code> take the value <code>-1</code> on <code>W(1)</code>. The character <code>φ₂,₇&#39;</code> is complex conjugate to <code>φ₂,₅&#39;</code>.</p><ul><li>For <code>G₇</code>:</li></ul><p>We  let <code>W=ComplexReflectionGroup(7)</code>,  so the  generators are <code>W(1)</code>, <code>W(2)</code> and <code>W(3)</code>.</p><p>The  characters  <code>φ₁,₄&#39;</code>  and  <code>φ₁,₁₀&#39;</code>  take  the value <code>1</code> on <code>W(2)</code>. The character  <code>φ₁,₈″</code> is complex  conjugate to <code>φ₁,₁₆</code>  and <code>φ₁,₈&#39;</code> is complex conjugate  to <code>φ₁,₄&#39;</code>. The characters <code>φ₁,₁₂&#39;</code>  and <code>φ₁,₁₈&#39;</code> take the value <code>ζ₃</code>  on <code>W(2)</code>. The character <code>φ₁,₁₄″</code> is complex conjugate to <code>φ₁,₂₂</code> and <code>φ₁,₁₄&#39;</code>  is complex conjugate to <code>φ₁,₁₀&#39;</code>. The character <code>φ₂,₃&#39;</code> takes the value  <code>-ζ₃</code> on  <code>W(2)</code> and  <code>φ₂,₁₃&#39;</code> takes  the value  <code>-1</code> on <code>W(2)</code>. The characters  <code>φ₂,₁₁″</code>, <code>φ₂,₅″</code>, <code>φ₂,₇‴</code> and  <code>φ₂,₁</code> are Galois conjugate, as well  as  the  characters  <code>φ₂,₇&#39;</code>,  <code>φ₂,₁₃&#39;</code>,  <code>φ₂,₁₁&#39;</code>  and  <code>φ₂,₅&#39;</code>. The character  <code>φ₂,₉&#39;</code> is complex  conjugate to <code>φ₂,₁₅</code>  and <code>φ₂,₉‴</code> is complex conjugate to <code>φ₂,₃&#39;</code>.</p><p>Finally,  for the remaining groups <code>G₆, G₈</code>  to <code>G₁₁, G₁₃</code> to <code>G₂₁</code>, <code>G₂₅</code>, <code>G₂₆</code>,  <code>G₃₂</code> and <code>G₃₃</code> there are only  pairs of characters with same value <code>(d,b)</code>.  We give labels uniformly to these characters by applying in order the following rules :</p><ul><li><p>If the two characters have  different fake degrees, label <code>φ_{d,b}&#39;</code> the  one  whose  fake  degree  is  minimal  for  the  lexicographic  order of  polynomials (starting with the highest term).</p></li><li><p>For the not yet labeled pairs, if only one of the two characters has the  property   that  in  its   Galois  orbit  at   least  one  character  is  distinguished by its <code>(d,b)</code>-invariant, label it <code>φ_{d,b}&#39;</code>.</p></li><li><p>For the not yet labeled pairs,  if the minimum of the <code>(d,b)</code>-value (for  the  lexicographic  order  <code>(d,b)</code>)  in  the  Galois  orbits  of the two  character  is different, label <code>φ_{d,b}&#39;</code> the character with the minimal  minimum.</p></li><li><p>We define now a new invariant  for characters: consider all the pairs of  irreducible   characters  <code>χ</code>  and  <code>ψ</code>  uniquely  determined  by  their  <code>(d,b)</code>-invariant such that <code>φ</code> occurs with non-zero multiplicity <code>m</code> in  <code>χ⊗ψ</code>.  We define  <code>t(φ)</code> to  be the  minimal (for  lexicographic order)  possible list <code>(d(χ),b(χ),d(ψ),b(ψ),m)</code>.</p></li></ul><p>For  the not  yet labeled  pairs, if  the t-invariants are different, label <code>φ_{d,b}&#39;</code> the character with the minimal <code>t</code>-invariant.</p><p>After  applying  the  last  rule  all  the  pairs  will be labelled for the considered  groups. The labelling obtained  is compatible for <code>G₂₅</code>, <code>G₂₆</code>, <code>G₃₂</code>  and <code>G₃₃</code> with that of [@Mal00]  and for <code>G₈</code> with that described in [@MR03].</p><p>We  should  emphasize  that  for  all  groups  with  a  few exceptions, the parameters  for characters do  not depend on  any non-canonical choice. The exceptions  are <code>G(de,e,n)</code> with <code>e&gt;1</code>, and <code>G₅</code>, <code>G₇</code>, <code>G₂₇</code>, <code>G₂₈</code>, <code>G₂₉</code> and  <code>G₃₄</code>, groups  which admit  outer automorphisms  preserving the set of reflections,  so choices  of a  particular value  on a particular generator must be made for characters which are not invariant by these automorphisms.</p><p>Labels  for the classes. For the exceptional complex reflection groups, the labels  for the classes represent the  decomposition of a representative of the  class as a product of generators, with the additional conventions that &#39;z&#39;  represents the generator  of the center  and for well-generated groups &#39;c&#39;  represents a Coxeter element  (a product of the  generators which is a regular element for the highest reflection degree).</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Chars.jl#L1-L387">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Chars.charinfo" href="#Gapjm.Chars.charinfo"><code>Gapjm.Chars.charinfo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>charinfo(W)</code></p><p>returns   information  about  the  irreducible  characters  of  the  finite reflection group <code>W</code>. The result is a Dict with the following entries:</p><p><code>:charparams</code>:  contains  parameters  for  the  irreducible  characters  as described in the introduction. The parameters are tuples with one component for  each irreducible  component of  <code>W</code> (as  given by  <code>refltype</code>). For an irreducible   component  which  is  an  imprimitive  reflection  group  the component  of the <code>charparam</code> is a tuple of partitions (partitions for type <code>:A</code>,  double partitions  for type  <code>:B</code>), and  for a primitive irreducible group it is a pair <code>(d,e)</code> where <code>d</code> is the degree of the character and <code>e</code> is  the  smallest  symmetric  power  of  the  character  of  the reflection representation  which  contains  the  given  character  as  a component. In addition,  there is an ordinal number if more than one character shares the first two invariants.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:G,2))[:charparams]
6-element Array{Array{Array{Int64,1},1},1}:
 [[1, 0]]   
 [[1, 6]]   
 [[1, 3, 1]]
 [[1, 3, 2]]
 [[2, 1]]   
 [[2, 2]]   </code></pre><p><code>:charnames</code>:  strings describing the  irreducible characters, computed from the <code>charparams</code>. This is the same as <code>CharNames(W)</code>.</p><p><code>:positionId</code>:  the position of the trivial character in the character table of <code>W</code>.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:D,4))[:positionId]
13</code></pre><p><code>:positionDet</code>:  Contains the position  of the determinant  character in the character   table  of  <code>W</code>. For Coxeter groups this is the sign character.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:D,4))[:positionDet]
4</code></pre><p><code>:extRefl</code>: Only present if <code>W</code> is irreducible, in which case the reflection representation  of <code>W</code> and all its exterior powers are irreducible. It then contains   the  position   of  the   exterior  powers   of  the  reflection representation in the character table.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:D,4))[:extRefl]
5-element Array{Int64,1}:
 13
 11
  5
  3
  4</code></pre><p><code>:b</code>:   contains  a  list  holding  the  <code>b</code>-function  for  all  irreducible characters  of <code>W</code>, that is,  for each character <code>χ</code>,  the valuation of the fake  degree of <code>χ</code>. The ordering of the result corresponds to the ordering of  the  characters  in  <code>CharTable(W)</code>.  The  advantage  of  this function compared  to calling <code>fakeDegrees</code> is that one  does not have to provide an indeterminate,  and that  it may  be much  faster to  compute than the fake degrees.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:D,4))[:b]
13-element Array{Int64,1}:
  6
  6
  7
 12
  4
  3
  6
  2
  2
  4
  1
  2
  0</code></pre><p><code>:B</code>:   contains  a  list  holding  the  <code>B</code>-function  for  all  irreducible characters  of <code>W</code>, that is, for each character <code>χ</code>, the degree of the fake degree  of <code>χ</code>. The ordering  of the result corresponds  to the ordering of the  characters in <code>CharTable(W)</code>. The  advantage of this function compared to  calling  <code>fakeDegrees</code>  is  that  one  does  not  have  to  provide  an indeterminate,  and that  it may  be much  faster to  compute than the fake degrees.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:D,4))[:B]
13-element Array{Int64,1}:
 10
 10
 11
 12
  8
  9
 10
  6
  6
  8
  5
  6
  0</code></pre><p><code>:a</code>:  Only  filled  for  Spetsial  groups.  Contains  a  list  holding  the <code>a</code>-function  for  all  irreducible  characters  of  the  Coxeter  group or Spetsial  reflection  group  <code>W</code>,  that  is,  for  each  character <code>χ</code>, the valuation  of the generic degree of <code>χ</code> (in the one-parameter Hecke algebra <code>Hecke(W,Pol(:q))</code>  corresponding  to  <code>W</code>).  The  ordering  of  the result corresponds to the ordering of the characters in <code>CharTable(W)</code>.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:D,4))[:a]
13-element Array{Int64,1}:
  6
  6
  7
 12
  3
  3
  6
  2
  2
  3
  1
  2
  0</code></pre><p><code>:A</code>:  Only  filled  for  Spetsial  groups.  Contains  a  list  holding  the <code>A</code>-function  for  all  irreducible  characters  of  the  Coxeter  group or Spetsial  reflection group <code>W</code>, that is, for each character <code>χ</code>, the degree of   the  generic  degree  of  <code>χ</code>  (in  the  one-parameter  Hecke  algebra <code>Hecke(W,Pol(:q))</code>  corresponding  to  <code>W</code>).  The  ordering  of  the result corresponds to the ordering of the characters in <code>CharTable(W)</code>.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:D,4))[:A]
13-element Array{Int64,1}:
 10
 10
 11
 12
  9
  9
 10
  6
  6
  9
  5
  6
  0</code></pre><p><code>:opdam</code>:  Contains the permutation of  the characters obtained by composing the  Opdam  involution  with  complex  conjugation. This permutation has an interpretation as a Galois action on the characters of <code>H=Hecke(W,Pol(:x))</code>:  if <code>H</code> splits  by taking <code>v</code>  an <code>e</code>-th root of <code>x</code>, <code>.opdam</code> records the permutation effected by the Galois action <code>v-&gt;E(e)*v</code>.</p><pre><code class="language-julia-repl">julia&gt; charinfo(ComplexReflectionGroup(22))[:opdam]
(3,5)(4,6)(11,13)(12,14)(17,18)</code></pre><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:A,2))
Dict{Symbol,Any} with 9 entries:
  :a           =&gt; [3, 1, 0]
  :b           =&gt; [3, 1, 0]
  :positionId  =&gt; 3
  :charnames   =&gt; [&quot;111&quot;, &quot;21&quot;, &quot;3&quot;]
  :A           =&gt; [3, 2, 0]
  :B           =&gt; [3, 2, 0]
  :extRefl     =&gt; [3, 2, 1]
  :charparams  =&gt; Array{Array{Int64,1},1}[[[1, 1, 1]], [[2, 1]], [[3]]]
  :positionDet =&gt; 1</code></pre><p>For  irreducible groups, the returned  record contains sometimes additional information:</p><p>for  <code>F₄</code>: the entry <code>:kondo</code> gives the  labeling of the characters given by Kondo, also used in [@Lus85, (4.10)].</p><p>for  <code>E₆, E₇, E₈</code>: the  entry <code>:frame</code> gives the  labeling of the characters given by Frame, also used in [@Lus85, (4.11), (4.12), and (4.13)].</p><p>for  <code>G₂</code>: the  entry <code>:spaltenstein</code>  gives the  labeling of the characters given by Spaltenstein.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:G,2))[:spaltenstein]
6-element Array{String,1}:
 &quot;1&quot;             
 &quot;\varepsilon&quot;  
 &quot;\varepsilon_l&quot;
 &quot;\varepsilon_c&quot;
 &quot;\theta&#39;&quot;      
 &quot;\theta&#39;&#39;&quot;     </code></pre><p>for  <code>G(de,e,2)</code>  even  <code>e</code>  and  <code>d&gt;1</code>:  the  entry  <code>:malle</code>  gives  the parameters for the characters used by Malle in [@Mal96].</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Chars.jl#L454-L669">source</a></section><h1><a class="nav-anchor" id="Uch.jl-Documentation-1" href="#Uch.jl-Documentation-1">Uch.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Uch" href="#Gapjm.Uch"><code>Gapjm.Uch</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Let  <code>𝐆</code> be a connected reductive  group defined over the algebraic closure of  a finite field <code>𝔽_q</code>, with corresponding Frobenius automorphism <code>F</code>, or more  generally  let  <code>F</code>  be  an  isogeny  of  <code>𝐆</code>  such that a power is a Frobenius (this covers the Suzuki and Ree groups).</p><p>If <code>𝐓</code> is an <code>F</code>-stable maximal torus of <code>𝐆</code>, and <code>𝐁</code> is a (not necessarily <code>F</code>-stable)  Borel subgroup containing <code>𝐓</code>, we define the <em>Deligne-Lusztig</em> variety  <code>X_𝐁={g𝐁 ∈  𝐆/𝐁 ∣  g𝐁 ∩  F(g𝐁 )≠∅  }</code>. This  variety has a natural action of <code>𝐆 ^F</code> on the left, so the corresponding <em>Deligne-Lusztig virtual module</em>  <code>∑ᵢ  (-1)ⁱ  Hⁱ_c(X_𝐁,ℚ̄_ℓ)</code>  also.  The  character of this virtual module  is  the  <em>Deligne-Lusztig</em>  character  <code>R_𝐓^𝐆  (1)</code>;  the  notation reflects the fact that one can prove that this character does not depend on the  choice  of  <code>𝐁</code>.  Actually,  this  character  is  parameterized  by an <code>F</code>-conjugacy  class of <code>W</code>: if <code>𝐓₀⊂𝐁₀</code> is  an <code>F</code>-stable pair, there is an unique <code>w∈ W=N_𝐆(𝐓₀)/𝐓₀</code> such that the triple <code>(𝐓,𝐁,F)</code> is <code>𝐆</code>-conjugate to <code>(𝐓₀,𝐁₀,wF)</code>.  In this case we denote <code>R_w</code> for <code>R_𝐓^𝐆(1)</code>; it depends only on the <code>F</code>-class of <code>w</code>.</p><p>The <em>unipotent characters</em> of <code>𝐆^F</code> are the irreducible constituents of the <code>R_w</code>. In a similar way that the unipotent classes are a building block for describing  the  conjugacy  classes  of  a  reductive  group, the unipotent characters  are  a  building  block  for  the  irreducible  characters of a reductive  group.  They  can  be  parameterized  by combinatorial data that Lusztig  has attached just to the coset <code>Wφ</code>, where <code>φ</code> is the finite order automorphism  of  <code>X(𝐓₀)</code>  such  that  <code>F=qφ</code>.  Thus, from the viewpoint of Chevie, they are objects combinatorially attached to a Coxeter coset.</p><p>A  subset  of  the  unipotent  characters, the <em>principal series</em> unipotent characters,   can  be  described  in  an   elementary  way.  They  are  the constituents of <code>R_1</code>, or equivalently the characters of the virtual module defined  by  the  cohomology  of  <code>X_{𝐁₀}</code>,  which  is the discrete variety <code>(𝐆/𝐁₀)^F</code>; the virtual module reduces to the actual module <code>ℚ̄_ℓ[(𝐆/𝐁₀)^F]</code>.  Thus the Deligne-Lusztig induction <code>R_𝐓₀^𝐆(1)</code> reduces to  Harish-Chandra induction,  defined as  follows: let  <code>𝐏 =𝐔  ⋊ 𝐋</code>  be an <code>F</code>-stable  Levi decomposition of an  <code>F</code>-stable parabolic subgroup of <code>𝐆</code>. Then  the <em>Harish-Chandra</em> induced  <code>R_𝐋^𝐆</code> of a  character <code>χ</code> of <code>𝐋^F</code> is the  character <code>Ind_{𝐏^F}^{𝐆^F}χ̃</code>, where <code>χ̃</code> is  the lift to <code>𝐏^F</code> of <code>χ</code> via  the quotient  <code>𝐏^F/𝐔^F=𝐋^F</code>; Harish-Chandra  induction is a particular case  of <em>Lusztig induction</em>,  which is defined  when <code>𝐏</code> is not <code>F</code>-stable using  the  variety  <code>X_𝐔={  g𝐔∈𝐆/𝐔  ∣  g𝐔∩  F(g𝐔)≠∅}</code>,  and  gives  for an <code>𝐋^F</code>-module   a  virtual  <code>𝐆^F</code>-module.  Like  ordinary  induction,  these functors  have  adjoint  functors  going  from  representations of <code>𝐆^F</code> to representations   (resp.   virtual   representations)   of   <code>𝐋^F</code>   called Harish-Chandra restriction (resp. Lusztig restriction).</p><p>The  commuting  algebra  of  <code>𝐆^F</code>-endomorphisms  of  <code>R_{𝐓₀}^𝐆(1)</code>  is  an Iwahori-Hecke  algebra for <code>W^φ</code>, with parameters  which are some powers of <code>q</code>;  they  are  all  equal  to  <code>q</code>  when  <code>W^φ=W</code>.  Thus principal series unipotent characters correspond to characters of <code>W^φ</code>.</p><p>To  understand the  decomposition of  Deligne-Lusztig characters,  and thus unipotent  characters,  is  is  useful  to  introduce  another set of class functions  which are parameterized  by irreducible characters  of the coset <code>Wφ</code>.  If  <code>χ</code>  is  such  a  character,  we  define  the associated <em>almost character</em> by: <code>R_χ=|W|⁻¹∑_{w∈ W}χ(wφ) R_w</code>. The reason to the name is that these  class  function  are  close  to irreducible characters: they satisfy <code>⟨R_χ, R_ψ⟩_{𝐆^F}=δ_{χ,ψ}</code>;  for  the  linear  and  unitary group they are actually  unipotent characters (up to sign in the latter case). They are in general  sum (with  rational coefficients)  of a  small number of unipotent characters  in  the  same  <em>Lusztig  family</em>  (see  &quot;Families  of unipotent characters&quot;).  The degree of <code>R_χ</code> is a polynomial in <code>q</code> equal to the fake degree  of  the  character  <code>χ</code>  of  <code>Wφ</code>  (see  &quot;Functions  for Reflection cosets&quot;).</p><p>We  now describe the parameterization of unipotent characters when <code>W^φ=W</code>, thus  when the coset <code>Wφ</code> identifies with <code>W</code> (the situation is similar but a  bit more difficult to describe  in general). The (rectangular) matrix of scalar  products  <code>⟨ρ, R_χ⟩_{𝐆 ^F}</code>,  when  characters of <code>W</code> and unipotent characters  are arranged in the right  order, is block-diagonal with rather small blocks which are called <em>Lusztig families</em>.</p><p>For  the characters of <code>W</code> a family <code>𝓕</code> corresponds to a block of the Hecke algebra  over a ring called the Rouquier  ring. To <code>𝓕</code> Lusztig associates a small  group <code>Γ</code> (not bigger  than <code>(ℤ/2)^n</code>, or <code>𝔖ᵢ</code>  for <code>i≤5</code>) such that the  unipotent  characters  in  the  family  are parameterized by the pairs <code>(x,θ)</code>  taken up to  <code>Γ</code>-conjugacy, where <code>x∈Γ</code>  and <code>θ</code> is an irreducible character  of  <code>C_Γ(x)</code>.  Further,  the  elements  of  <code>𝓕</code>  themselves  are parameterized  by a  subset of  such pairs,  and Lusztig  defines a pairing between  such pairs which computes the scalar product <code>⟨ρ, R_χ⟩_{𝐆^F}</code>. For more details see &quot;DrinfeldDouble&quot;.</p><p>A  second parameterization  of unipotent  character is  via <em>Harish-Chandra series</em>.  A character is called <em>cuspidal</em> if all its proper Harish-Chandra restrictions  vanish. There are few  cuspidal unipotent characters (none in linear   groups,  and  at   most  one  in   other  classical  groups).  The <code>𝐆^F</code>-endomorphism  algebra of an  Harish-Chandra induced <code>R_{𝐋^F}^{𝐆^F}λ</code>, where <code>λ</code> is a cuspidal unipotent character turns out to be a Hecke algebra associated to the group <code>W_{𝐆^F}(𝐋^F):=N_{𝐆^F}(𝐋)/𝐋</code>, which turns out to be a  Coxeter group.  Thus another  parameterization is  by triples <code>(𝐋,λ,φ)</code>, where  <code>λ</code>  is  a  cuspidal  unipotent  character  of  <code>𝐋^F</code>  and <code>φ</code> is an irreducible   character  of  the   <em>relative  group</em>  <code>W_{𝐆^F}(𝐋^F)</code>.  Such characters  are said to  belong to the  Harish-Chandra series determined by <code>(𝐋,λ)</code>.</p><p>A  final  piece  of  information  attached  to  unipotent characters is the <em>eigenvalues  of Frobenius</em>. Let <code>F^δ</code> be the smallest power of the isogeny <code>F</code> which is a split Frobenius (that is, <code>F^δ</code> is a Frobenius and <code>φ^δ=1</code>). Then  <code>F^δ</code> acts  naturally on  Deligne-Lusztig varieties  and thus  on the corresponding  virtual modules, and  commutes to the  action of <code>𝐆^F</code>; thus for  a given  unipotent character  <code>ρ</code>, a  submodule of  the virtual module which  affords <code>ρ</code>  affords a  single eigenvalue  <code>μ</code> of  <code>F^δ</code>. Results of Lusztig  and  Digne-Michel  show  that  this  eigenvalue  is  of  the  form <code>q^{aδ}λ_ρ</code> where <code>2a∈ℤ</code> and <code>λ_ρ</code> is a root of unity which depends only on <code>ρ</code>  and not the considered module. This  <code>λ_ρ</code> is called the eigenvalue of Frobenius  attached  to  <code>ρ</code>.  Unipotent  characters  in the Harish-Chandra series of a pair <code>(𝐋,λ)</code> have the same eigenvalue of Frobenius as <code>λ</code>.</p><p>Chevie   contains  tables  of  all   this  information,   and  can  compute Harish-Chandra  and Lusztig  induction of  unipotent characters  and almost characters. We illustrate the information on some examples:</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; uc=UnipotentCharacters(W)
UnipotentCharacters(G₂)
      γ│       Deg(γ)  Feg Fr(γ)    label
───────┼──────────────────────────────────
φ₁‚₀   │            1    1     1         
φ₁‚₆   │           q⁶   q⁶     1         
φ′₁‚₃  │  (1//3)qΦ₃Φ₆   q³     1    (1,ρ)
φ″₁‚₃  │  (1//3)qΦ₃Φ₆   q³     1   (g₃,1)
φ₂‚₁   │ (1//6)qΦ₂²Φ₃  qΦ₈     1    (1,1)
φ₂‚₂   │ (1//2)qΦ₂²Φ₆ q²Φ₄     1   (g₂,1)
G₂[-1] │ (1//2)qΦ₁²Φ₃    0    -1   (g₂,ε)
G₂[1]  │ (1//6)qΦ₁²Φ₆    0     1    (1,ε)
G₂[ζ₃] │(1//3)qΦ₁²Φ₂²    0    ζ₃  (g₃,ζ₃)
G₂[ζ₃²]│(1//3)qΦ₁²Φ₂²    0   ζ₃² (g₃,ζ₃²)</code></pre><p>The first column gives the name of the unipotent character; the first 6 are in  the  principal  series  so  are  named  according  to the corresponding characters  of <code>W</code>. The last 4 are cuspidal, and named by the corresponding eigenvalue  of  Frobenius,  which  is  displayed  in  the fourth column. In general   the   names   of   the   unipotent  characters  come  from  their parameterization  by  Harish-Chandra  series;  in  addition,  for classical groups, they are associated to <em>symbols</em>.</p><p>The first two characters are each in a family by themselves. The last eight are  in a family associated to the group <code>Γ=𝔖_3</code>: the last column shows the parameters  <code>(x,θ)</code>. The  second column  shows the  degree of the unipotent characters, which is transformed by the Lusztig Fourier matrix of the third column,  which gives the  degree of the  corresponding almost character, or equivalently the fake degree of the corresponding character of <code>W</code>.</p><p>One  can get  more information  on the  Lusztig Fourier  matrix of  the big family by asking</p><pre><code class="language-julia-repl">julia&gt; uc.prop[:families][1]
Family(D(S₃):[5, 6, 4, 3, 8, 7, 9, 10])
   label│eigen                                               
────────┼─────────────────────────────────────────────────────
(1,1)   │    1 1//6  1//2  1//3  1//3  1//6  1//2  1//3  1//3
(g₂,1)  │    1 1//2  1//2  0//1  0//1 -1//2 -1//2  0//1  0//1
(g₃,1)  │    1 1//3  0//1  2//3 -1//3  1//3  0//1 -1//3 -1//3
(1,ρ)   │    1 1//3  0//1 -1//3  2//3  1//3  0//1 -1//3 -1//3
(1,ε)   │    1 1//6 -1//2  1//3  1//3  1//6 -1//2  1//3  1//3
(g₂,ε)  │   -1 1//2 -1//2  0//1  0//1 -1//2  1//2  0//1  0//1
(g₃,ζ₃) │   ζ₃ 1//3  0//1 -1//3 -1//3  1//3  0//1  2//3 -1//3
(g₃,ζ₃²)│  ζ₃² 1//3  0//1 -1//3 -1//3  1//3  0//1 -1//3  2//3</code></pre><p>One  can  do  computations  with  individual  unipotent characters. Here we construct  the Coxeter torus, and then the identity character of this torus as a unipotent character.</p><pre><code class="language-julia-repl">|    gap&gt; W:=CoxeterGroup(&quot;G&quot;,2);
    CoxeterGroup(&quot;G&quot;,2)
    gap&gt; T:=ReflectionCoset(ReflectionSubgroup(W,[]),EltWord(W,[1,2]));
    (q^2-q+1)
    gap&gt; u:=UnipotentCharacter(T,1);
    [(q^2-q+1)]=&lt;&gt;|</code></pre><p>Then  here  are  two  ways  to  construct  the  Deligne-Lusztig  character associated to the Coxeter torus:</p><pre><code class="language-julia-repl">|    gap&gt; LusztigInduction(W,u);
    [G2]=&lt;phi{1,0}&gt;+&lt;phi{1,6}&gt;-&lt;phi{2,1}&gt;+&lt;G2[-1]&gt;+&lt;G2[E3]&gt;+&lt;G2[E3^2]&gt;
    gap&gt; v:=DeligneLusztigCharacter(W,[1,2]);
    [G2]=&lt;phi{1,0}&gt;+&lt;phi{1,6}&gt;-&lt;phi{2,1}&gt;+&lt;G2[-1]&gt;+&lt;G2[E3]&gt;+&lt;G2[E3^2]&gt;
    gap&gt; Degree(v);
    q^6 + q^5 - q^4 - 2*q^3 - q^2 + q + 1
    gap&gt; v*v;
    6|</code></pre><p>The  last two lines ask for the degree  of <code>v</code>, then for the scalar product of <code>v</code> with itself.</p><p>Finally  we mention  that Chevie  can also  provide unipotent characters of Spetses, as defined in [@BMM14]. An example:</p><pre><code class="language-julia-repl">julia&gt; UnipotentCharacters(ComplexReflectionGroup(4))
UnipotentCharacters(G₄)
    γ│                         Deg(γ)    Feg Fr(γ)   label
─────┼─────────────────────────────────────────────────────
φ₁‚₀ │                              1      1     1        
φ₁‚₄ │((-1//6)ζ₃+(1//6)ζ₃²)q⁴Φ″₃Φ₄Φ″₆     q⁴     1  1∧-ζ₃²
φ₁‚₈ │((1//6)ζ₃+(-1//6)ζ₃²)q⁴Φ′₃Φ₄Φ′₆     q⁸     1  -1∧ζ₃²
φ₂‚₅ │                  (1//2)q⁴Φ₂²Φ₆   q⁵Φ₄     1   1∧ζ₃²
φ₂‚₃ │((-1//3)ζ₃+(-2//3)ζ₃²)qΦ″₃Φ₄Φ′₆   q³Φ₄     1   1∧ζ₃²
φ₂‚₁ │((-2//3)ζ₃+(-1//3)ζ₃²)qΦ′₃Φ₄Φ″₆    qΦ₄     1    1∧ζ₃
φ₃‚₂ │                         q²Φ₃Φ₆ q²Φ₃Φ₆     1        
Z₃:2 │   ((-1//3)ζ₃+(1//3)ζ₃²)qΦ₁Φ₂Φ₄      0   ζ₃²  ζ₃∧ζ₃²
Z₃:11│  ((-1//3)ζ₃+(1//3)ζ₃²)q⁴Φ₁Φ₂Φ₄      0   ζ₃²  ζ₃∧-ζ₃
G₄   │                 (-1//2)q⁴Φ₁²Φ₃      0    -1 -ζ₃²∧-1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Uch.jl#L1-L215">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Uch.UnipotentCharacters" href="#Gapjm.Uch.UnipotentCharacters"><code>Gapjm.Uch.UnipotentCharacters</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>UnipotentCharacters(&lt;W&gt;)</code></p><p>&lt;W&gt;  should be a Coxeter group, a  Coxeter Coset or a Spetses. The function gives  back a record containing  information about the unipotent characters of the associated algebraic group (or Spetses). This contains the following fields:</p><p><code>:group</code>: a pointer to &lt;W&gt;</p><p><code>:charNames</code>:  the list of names of the unipotent characters.</p><p><code>:charSymbols</code>: the list of symbols associated to unipotent characters, for classical groups.</p><p><code>:harishChandra</code>:  information  about  Harish-Chandra  series  of  unipotent characters.  This is itself a list of records, one for each pair <code>(𝐋,λ)</code> of a  Levi  of  an  <code>F</code>-stable  parabolic  subgroup  and  a cuspidal unipotent character of <code>𝐋^F</code>. These records themselves have the following fields:</p><p><code>:levi</code>: a list &#39;l&#39; such that <code>𝐋</code> corresponds to &#39;ReflectionSubgroup(W,l)&#39;.</p><p><code>:cuspidalName</code>: the name of the unipotent cuspidal character <code>lambda</code>.</p><p><code>:eigenvalue</code>: the eigenvalue of Frobenius for <code>λ</code>.</p><p><code>:relativeType</code>: the reflection type of <code>W_𝐆(𝐋)</code>;</p><p><code>:parameterExponents</code>:  the  <code>𝐆^F</code>-endomorphism  algebra  of <code>R_𝐋^𝐆(λ)</code> is a Hecke algebra for <code>W_𝐆(𝐋)</code> with some parameters of the form <code>q^{a_s}</code>. This holds the list of exponents <code>a_s</code>.</p><p><code>:charNumbers</code>:  the  indices  of  the  unipotent  characters indexed by the irreducible characters of <code>W_𝐆(𝐋)</code>.</p><p><code>:families</code>:  information  about  Lusztig  families of unipotent characters. This  is itself a list  of records, one for  each family. These records are described in the section about families below.</p><p>|    gap&gt; W:=CoxeterGroup(&quot;Bsym&quot;,2);     CoxeterGroup(&quot;Bsym&quot;,2)     gap&gt; WF:=CoxeterCoset(W,(1,2));     2Bsym2     gap&gt; uc:=UnipotentCharacters(W);     UnipotentCharacters( Bsym2 )     gap&gt; Display(uc);     Unipotent characters for Bsym2     Name |  Degree FakeDegree Eigenvalue Label     ___________________________________________     11.  |  1/2qP4        q^2          1   +,-     1.1  |1/2qP2^2        qP4          1   +,+     .11  |     q^4        q^4          1     2.   |       1          1          1     .2   |  1/2qP4        q^2          1   -,+     B2   |1/2qP1^2          0         -1   -,-     gap&gt; uc.harishChandra[1];     rec(       levi := [  ],       relativeType := [ rec(series  := &quot;B&quot;,               indices := [ 1, 2 ],               rank    := 2) ],       eigenvalue := 1,       parameterExponents := [ 1, 1 ],       charNumbers := [ 1, 2, 3, 4, 5 ],       cuspidalName := &quot;&quot; )     gap&gt; uc.families[2];     Family(&quot;012&quot;,[1,2,5,6])     gap&gt; Display(uc.families[2]);     label |eigen  +,- +,+  -,+  -,-     ________________________________     +,-   |    1  1/2 1/2 -1/2 -1/2     +,+   |    1  1/2 1/2  1/2  1/2     -,+   |    1 -1/2 1/2  1/2 -1/2     -,-   |   -1 -1/2 1/2 -1/2  1/2|</p><p>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</p><p><code>:CharNames</code>:  returns  the  names  of  the  unipotent characters. Using the version  with an additional  option record as  the second argument, one can control the display in various ways.</p><p>|    gap&gt; uc:=UnipotentCharacters(CoxeterGroup(&quot;G&quot;,2));     UnipotentCharacters( G2 )     gap&gt; CharNames(uc);     [ &quot;phi{1,0}&quot;, &quot;phi{1,6}&quot;, &quot;phi{1,3}&#39;&quot;, &quot;phi{1,3}&#39;&#39;&quot;, &quot;phi{2,1}&quot;,       &quot;phi{2,2}&quot;, &quot;G2[-1]&quot;, &quot;G2[1]&quot;, &quot;G2[E3]&quot;, &quot;G2[E3^2]&quot; ]     gap&gt; CharNames(uc,rec(TeX:=true));     [ &quot;\phi<em>{1,0}&quot;, &quot;\phi</em>{1,6}&quot;, &quot;\phi<em>{1,3}&#39;&quot;, &quot;\phi</em>{1,3}&#39;&#39;&quot;,       &quot;\phi<em>{2,1}&quot;, &quot;\phi</em>{2,2}&quot;, &quot;G<em>2[-1]&quot;, &quot;G</em>2[1]&quot;, &quot;G<em>2[\zeta</em>3]&quot;,       &quot;G<em>2[\zeta</em>3^2]&quot; ]|</p><p><code>:Display</code>:  One can control the display  of unipotent characters in various ways.  In the record controlling &#39;Display&#39;, a field &#39;items&#39; specifies which columns are displayed. The possible values are</p><p><code>:n0</code>:  The index of the character in the list of unipotent characters.</p><p><code>:Name</code>:   The name of the unipotent character.</p><p><code>:Degree</code>:  The degree of the unipotent character.</p><p><code>:FakeDegree</code>: The degree of the corresponding almost character.</p><p><code>:Eigenvalue</code>:  The eigenvalue of Frobenius attached to the unipotent character.</p><p><code>:Symbol</code>: for classical groups, the symbol attached to the unipotent character.</p><p><code>:Family</code>: The parameter the character has in its Lusztig family.</p><p><code>:Signs</code>: The signs attached to the character in the Fourier transform.</p><p>The default value is  &#39;items:=[:Name,:Degree,:FakeDegree,:Eigenvalue,:Family]`</p><p>This  can be changed by setting the variable &#39;UnipotentCharactersOps.items` which holds this default value. In addition if the field &#39;byFamily&#39; is set, the  characters are displayed  family by family  instead of in index order. Finally,  the field &#39;chars&#39; can be  set, indicating which characters are to be displayed in which order.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; uc=UnipotentCharacters(W)
UnipotentCharacters(B₂)
  γ│    Deg(γ) Feg Fr(γ) label
───┼───────────────────────────
11.│(-1//2)qΦ₄  q²     1   -,-
1.1│ (1//2)qΦ₄ qΦ₄     1   -,+
.11│        q⁴  q⁴     1      
2. │         1   1     1      
.2 │ (1//2)qΦ₄  q²     1   -,+
B₂ │(-1//2)qΦ₄   0    -1   -,-</code></pre><pre><code class="language-julia-repl">    gap&gt; Display(uc,rec(byFamily:=true));
    Unipotent characters for B2
    Name |  Degree FakeDegree Eigenvalue Label
    ___________________________________________
    *.11 |     q^4        q^4          1
    ___________________________________________
    11.  |  1/2qP4        q^2          1   +,-
    *1.1 |1/2qP2^2        qP4          1   +,+
    .2   |  1/2qP4        q^2          1   -,+
    B2   |1/2qP1^2          0         -1   -,-
    ___________________________________________
    *2.  |&#39;|&#39;|       1          1          1
    gap&gt; Display(uc,items=[:n0,:Name,:Symbol]));
    Unipotent characters for B2
    n0 |Name   Symbol
    __________________
    1  | 11.   (12,0)
    2  | 1.1   (02,1)
    3  | .11 (012,12)
    4  |  2.     (2,)
    5  |  .2   (01,2)
    6  |  B2   (012,)|</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Uch.jl#L265-L427">source</a></section><h1><a class="nav-anchor" id="Ucl.jl-Documentation-1" href="#Ucl.jl-Documentation-1">Ucl.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Ucl" href="#Gapjm.Ucl"><code>Gapjm.Ucl</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>This  module gives information  about the unipotent  conjugacy classes of a connected  reductive  group  over  an  algebraically  closed field <code>k</code>, and various  invariants attached to  them. The unipotent  classes depend on the characteristic of <code>k</code>; their classification differs when the characteristic is  not <em>good</em>  (that is,  when it  divides one  of the coefficients of the highest  root).  In  good  characteristic,  the  unipotent  classes  are in bijection with nilpotent orbits on the Lie algebra.</p><p>We  give  the  following  information  for  a unipotent element <code>u</code> of each class:</p><ul><li>the centralizer <code>C_𝐆 (u)</code>, that we describe by the reductive part of `C_𝐆</li></ul><p>(u)^0<code>,  by the group  of components</code>A(u):=C<em>𝐆  (u)/C</em>𝐆 (u)^0`, and by the dimension of its radical.</p><ul><li><p>in good characteristic, the  Dynkin-Richardson  diagram.</p></li><li><p>the Springer correspondence,  attaching characters of  the Weyl group or</p></li></ul><p>relative Weyl groups to each character of <code>A(u)</code>.</p><p>The  Dynkin-Richarson diagram is attached to a nilpotent element <code>e</code> of the Lie  algebra <code>𝔤</code>.  By the  Jacobson-Morozov theorem  there exists an <code>𝔰𝔩_2</code> subalgebra of <code>𝔤</code> containing <code>e</code> as the element |–-|–-| | 1 | 0 | | 0 | 0 | . Let <code>𝐒</code> be the torus </p><p>|–-|––-| | h | 0   | | 0 | h⁻¹ |  of <code>SL_2</code> and let <code>𝐓</code> be a maximal  torus containing <code>𝐒</code>, so that <code>𝐒</code>  is the image of a one-parameter subgroup <code>σ∈ Y(𝐓)</code>. Consider the root decomposition <code>𝔤=∑_{α∈Σ}𝔤_α</code> given by <code>𝐓</code>;  then <code>α↦⟨σ,α⟩</code> defines a linear form  on <code>Σ</code>, determined by its value on  simple roots. It is possible to choose  a system of simple roots <code>Π</code> so that  <code>⟨σ,α⟩≥ 0</code>  for <code>α∈Π</code>,  and then  <code>⟨σ,α⟩∈{0,1,2}</code> for  any <code>α∈Π</code>. The Dynkin  diagram  of  <code>Π</code>  decorated  by  these values <code>0,1,2</code> is called the Dynkin-Richardson  diagram of <code>e</code>, and in good characteristic is a complete invariant of its <code>𝔤</code>-orbit.</p><p>Let  <code>𝓑</code>  be  the  variety  of  all  Borel  subgroups  and let <code>𝓑_u</code> be the subvariety  of Borel subgroups  containing the unipotent  element <code>u</code>. Then <code>dim C_𝐆(u)=rank𝐆+2dim𝓑_u</code> and in good characteristic this dimension can be computed  from the Dynkin-Richardson diagram: the dimension of the class of <code>u</code> is the number of roots <code>α</code> such that <code>⟨σ,α⟩∉{0,1}</code>.</p><p>We   describe  now  the  Springer  correspondence.  Indecomposable  locally constant  <code>𝐆</code>-equivariant  sheaves  on  <code>C</code>,  called  <em>local  systems</em>, are parameterized  by irreducible characters of <code>A(u)</code>. The <em>ordinary</em> Springer correspondence  is a bijection  between irreducible characters  of the Weyl group  and a large subset  of the local systems  which contains all trivial local  systems (those parameterized by the  trivial character of <code>A(u)</code> for each  <code>u</code>).  More  generally,  the  <em>generalized</em>  Springer  correspondence associates  to each local  system a (unique  up to <code>𝐆</code>-conjugacy) <em>cuspidal pair</em>  of a Levi  subgroup <code>𝐋</code> of  <code>𝐆</code> and a  <code>cuspidal</code> local system on an unipotent  class of <code>𝐋</code>, such that the set of local systems associated to a given cuspidal pair is parameterized by the characters of the relative Weyl group <code>W_𝐆(𝐋):=N_𝐆(𝐋)/𝐋</code>. There are only few cuspidal pairs.</p><p>The  Springer correspondence gives information on the character values of a finite  reductive  groups  as  follows:  assume  that  <code>k</code> is the algebraic closure  of a finite field <code>𝔽_q</code> and  that <code>F</code> is the Frobenius attached to an <code>𝔽_q</code>-structure of <code>𝐆</code>. Let <code>C</code> be an <code>F</code>-stable unipotent class and let <code>u∈  C^F</code>; we call <code>C</code>  the <em>geometric class</em> of  <code>u</code> and the <code>𝐆^F</code>-classes inside  <code>C^F</code>  are  parameterized  by  the <code>F</code>-conjugacy classes of <code>A(u)</code>, denoted  <code>H^1(F,A(u))</code> (most of the time we can find <code>u</code> such that <code>F</code> acts trivially  on <code>A(u)</code> and <code>H^1(F,A(u))</code> is then just the conjugacy classes). To  an <code>F</code>-stable character <code>φ</code> of  <code>A(u)</code> we associate the <em>characteristic function</em>  of  the  corresponding  local  system (actually associated to an extension  <code>φ̃</code> of <code>φ</code>  to <code>A(u).F</code>); it  is a class  function <code>Y_{u,φ}</code> on <code>𝐆^F</code>  which can be  normalized so that:  <code>Y_{u,φ}(u_1)=φ̃(cF)</code> if <code>u_1</code> is geometrically  conjugate to <code>u</code> and its <code>𝐆^F</code>-class is parameterized by the <code>F</code>-conjugacy class <code>cF</code> of <code>A(u)</code>, otherwise <code>Y_{u,φ}(u_1)=0</code>. If the pair <code>u,φ</code>  corresponds via the Springer correspondence  to the character <code>χ</code> of <code>W_𝐆(𝐋)</code>,  then <code>Y_{u,φ}</code> is also denoted <code>Y_χ</code>. There is another important class of functions indexed by local systems: to a local system on class <code>C</code> is  attached  an  intersection  cohomology  complex,  which is a complex of sheaves  supported on  the closure  <code>C̄</code>. To  such a  complex of sheaves is associated  its  <em>characteristic  function</em>,  a  class  function  of  <code>𝐆^F</code> obtained  by taking  the alternating  trace of  the Frobenius acting on the stalks  of the cohomology sheaves. If  <code>Y_ψ</code> is the characteristic function of  a  local  system,  the  characteristic  function  of  the corresponding intersection  cohomology  complex  is  denoted  by  <code>X_ψ</code>. This function is supported  on <code>C̄</code>, and Lusztig has  shown that <code>X_ψ=∑_φ P_{ψ,χ} Y_χ</code> where <code>P_{ψ,χ}</code>  are integer polynomials  in <code>q</code> and  <code>Y_χ</code> are attached to local systems on classes lying in <code>C̄</code>.</p><p>Lusztig  and Shoji have given an algorithm to compute the matrix <code>P_{ψ,χ}</code>, which  is  implemented  in  Chevie.  The  relationship  with  characters of <code>𝐆(𝔽_q)</code>,  taking to simplify the ordinary Springer correspondence, is that the  restriction to the unipotent elements of the almost character <code>R_χ</code> is equal  to <code>q^{b_χ} X_χ</code>, where <code>b_χ</code> is <code>dim 𝓑_u</code> for an element <code>u</code> of the class  <code>C</code> such  that the  support of  <code>χ</code> is  <code>C̄</code>. The restriction of the Deligne-Lusztig  characters <code>R_w</code> to  the unipotents are  called the <em>Green functions</em>  and can also be computed by Chevie. The values of all unipotent characters  on  unipotent  elements  can  also  be computed in principle by applying Lusztig&#39;s Fourier transform matrix (see the section on the Fourier matrix)  but  there  is  a  difficulty  in  that  the  <code>X_χ</code>  must be first multiplied  by some roots  of unity which  are not known  in all cases (and when  known may  depend on  the congruence  class of  <code>q</code> modulo some small primes).</p><p>We illustrate these computations on some examples:</p><pre><code class="language-julia-repl">julia&gt; UnipotentClasses(rootdatum(:sl,4))
UnipotentClasses(A₃)
1111&lt;211&lt;22&lt;31&lt;4
   u│D-R dBu B-C     C(u) A₃(A₃₍₎) A₁(A₃₍₁₃₎)/-1 .(A₃)/ζ₄ .(A₃)/-ζ₄
────┼───────────────────────────────────────────────────────────────
4   │222   0 222    q³.Z4      1:4          -1:2    ζ₄:Id    -ζ₄:Id
31  │202   1 22.      q⁴.    Id:31                                 
22  │020   2 2.2 q⁴.A1.Z2     2:22         11:11                   
211 │101   3 2..    q⁵.A1   Id:211                                 
1111│000   6 ...      .A3  Id:1111  </code></pre><p>The  first column in the table gives the name of the unipotent class, which here  is  a  partition  describing  the  Jordan  form. The partial order on unipotent  classes given by Zariski closure  is given before the table. The column   &#39;D-R&#39;,   displayed   only   in   good  characteristic,  gives  the Dynkin-Richardson  diagram  for  each  class;  the  column  &#39;dBu&#39; gives the dimension  of the  variety <code>𝓑_u</code>.  The column  &#39;B-C&#39; gives  the Bala-Carter classification  of <code>u</code>, that is in the case  of <code>sl_4</code> it displays <code>u</code> as a regular  unipotent  in  a  Levi  subgroup  by  giving the Dynkin-Richardson diagram  of a regular  unipotent (all 2&#39;s)  at entries corresponding to the Levi  and &#39;.&#39; at  entries which do  not correspond to  the Levi. The column &#39;C(u)&#39;  describes  the  group  <code>C_𝐆(u)</code>:  a  power <code>q^d</code> describes that the unipotent  radical  of  <code>C_𝐆(u)</code>  has  dimension  <code>d</code>  (thus <code>q^d</code> rational points);  then follows a  description of the  reductive part of the neutral component  of  <code>C_𝐆(u)</code>,  given  by  the  name  of  its root datum. Then if <code>C_𝐆(u)</code> is not connected, the description of <code>A(u)</code> is given using another vocabulary:  a cyclic group  of order 4  is given as  &#39;Z4&#39;, and a symmetric group on 3 points would be given as &#39;S3&#39;.</p><p>For instance, the first class &#39;4&#39; has <code>C_𝐆(u)^0</code> unipotent of dimension <code>3</code> and  <code>A(u)</code> equal to &#39;Z4&#39;, the cyclic group  of order 4. The class &#39;22&#39; has <code>C_G(u)</code>  with unipotent radical  of dimension <code>4</code>,  reductive part of type &#39;A1&#39;  and <code>A(u)</code> is  &#39;Z2&#39;, that is  the cyclic group  of order 2. The other classes  have <code>C_𝐆(u)</code> connected. For the  class &#39;31&#39; the reductive part of <code>C_G(u)</code> is a torus of rank 1.</p><p>Then  there is one column for each <em>Springer series</em>, giving for each class the pairs &#39;a:b&#39; where &#39;a&#39; is the name of the character of <code>A(u)</code> describing the  local system  involved and  &#39;b&#39; is  the name  of the  character of the (relative)  Weyl group corresponding by the Springer correspondence. At the top  of the column is  written the name of  the relative Weyl group, and in brackets  the name  of the  Levi affording  a cuspidal  local system; next, separated  by a |/| is a description of the central character associated to the  Springer series  (omitted if  this central  character is trivial): all local  systems  in  a  given  Springer  series have same restriction to the center of <code>𝐆</code>. To find what the picture becomes for another algebraic group in  the  same  isogeny  class,  for  instance the adjoint group, one simply discards the Springer series whose central character becomes trivial on the center  of <code>𝐆</code>; and  each group <code>A(u)</code>  has to be  quotiented by the common kernel  of  the  remaining  characters.  Here  is the table for the adjoint group:</p><pre><code class="language-julia-repl">julia&gt; UnipotentClasses(coxgroup(:A,3))
UnipotentClasses(A₃)
1111&lt;211&lt;22&lt;31&lt;4
   u│D-R dBu B-C  C(u) A₃(A₃₍₎)
────┼───────────────────────────
4   │222   0 222    q³     Id:4
31  │202   1 22.   q⁴.    Id:31
22  │020   2 2.2 q⁴.A1    Id:22
211 │101   3 2.. q⁵.A1   Id:211
1111│000   6 ...   .A3  Id:1111</code></pre><p>Here is another example:</p><pre><code class="language-julia_repl">julia&gt; UnipotentClasses(coxgroup(:G,2))
UnipotentClasses(G₂)
1&lt;A₁&lt;Ã₁&lt;G₂(a₁)&lt;G₂
     u│D-R dBu B-C  C(u)        G₂(G₂₍₎)  .(G₂)
──────┼─────────────────────────────────────────
G₂    │ 22   0  22    q²         Id:φ₁‚₀       
G₂(a₁)│ 20   1  20 q⁴.S3 21:φ′₁‚₃ 3:φ₂‚₁ 111:Id
Ã₁    │ 01   2  .2 q³.A1         Id:φ₂‚₂       
A₁    │ 10   3  2. q⁵.A1        Id:φ″₁‚₃       
1     │ 00   6  ..   .G2         Id:φ₁‚₆       </code></pre><p>which illustrates that on class <code>G₂(a₁)</code> there are two local systems in the principal  series of  the Springer  correspondence, and  a further cuspidal local system. Also, from the &#39;B-C&#39; column, we see that that class is not in a  proper Levi,  in which  case the  Bala-Carter diagram coincides with the Dynkin-Richardson diagram.</p><p>The  characteristics 2 and  3 are not  good for &#39;G2&#39;.  To get the unipotent classes  and the Springer correspondence in bad characteristic, one gives a second argument to the function &#39;UnipotentClasses&#39;:</p><pre><code class="language-julia_repl">julia&gt; UnipotentClasses(coxgroup(:G,2),3)
UnipotentClasses(G₂)
1&lt;A₁,(Ã₁)₃&lt;Ã₁&lt;G₂(a₁)&lt;G₂
     u│dBu B-C  C(u) G₂(G₂₍₎) .(G₂) .(G₂)  .(G₂)
──────┼──────────────────────────────────────────
(Ã₁)₃ │  0  22 q².Z3   1:φ₁‚₀       ζ₃:Id ζ₃²:Id
G₂(a₁)│  1  20 q⁴.Z2   2:φ₂‚₁ 11:Id             
Ã₁    │  2  .2    q⁶  Id:φ₂‚₂                   
A₁    │  3  2. q⁵.A1 Id:φ″₁‚₃                   
1     │  3  ?? q⁵.A1 Id:φ′₁‚₃                   
G₂    │  6  ..   .G2  Id:φ₁‚₆       </code></pre><p>The  function &#39;ICCTable&#39; gives the  transition matrix between the functions <code>X_χ</code>  and <code>Y_ψ</code>.</p><pre><code class="language-julia-repl">julia&gt; uc=UnipotentClasses(coxgroup(:G,2));
julia&gt; t=ICCTable(uc)
Coefficients of X_φ on Y_ψ for G2
      │G₂ G₂(a₁)⁽²¹⁾ G₂(a₁) Ã₁ A₁  1
──────┼──────────────────────────────
Xφ₁‚₀ │ 1          0      1  1  1  1
Xφ′₁‚₃│ 0          1      0  1  0 q²
Xφ₂‚₁ │ 0          0      1  1  1 Φ₈
Xφ₂‚₂ │ 0          0      0  1  1 Φ₄
Xφ″₁‚₃│ 0          0      0  0  1  1
Xφ₁‚₆ │ 0          0      0  0  0  1</code></pre><p>Here  the row labels  and the column  labels show the  two ways of indexing local  systems: the  row labels  give the  character of the relative Weyl group and the column labels give the class and the name of the local system as  a character  of <code>A(u)</code>:  for instance,  &#39;G2(a1)&#39; is the trivial local system  of the  class &#39;G2(a1)&#39;,  while &#39;G2(a1)(21)&#39;  is the local system on that class corresponding to the 2-dimensional character of <code>A(u)=A_2</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Ucl.jl#L1-L235">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Ucl.UnipotentClasses" href="#Gapjm.Ucl.UnipotentClasses"><code>Gapjm.Ucl.UnipotentClasses</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>&#39;UnipotentClasses(&lt;W&gt;[,&lt;p&gt;])&#39;</p><p>&lt;W&gt;  should  be  a  &#39;CoxeterGroup&#39;  record  for a Weyl group or &#39;RootDatum&#39; describing a reductive algebraic group <code>𝐆</code>. The function returns a record containing   information   about   the   unipotent   classes  of  <code>𝐆</code>  in characteristic   &lt;p&gt;  (if   omitted,  &lt;p&gt;   is  assumed   to  be  any  good characteristic for <code>𝐆</code>). This contains the following fields:</p><p>&#39;group&#39;: a pointer to &lt;W&gt;</p><p>&#39;p&#39;: the characteristic of the field for which the unipotent classes were computed. It is &#39;0&#39; for any good characteristic.</p><p>&#39;orderClasses&#39;:  a list describing the Hasse diagram of the partial order induced   on   unipotent   classes   by   the  closure  relation.  That  is &#39;.orderclasses[i]&#39;  is the list of &#39;j&#39; such that <code>C̄_j⊋ C̄_i</code>  and  there  is  no  class  <code>C_k</code>  such  that <code>C̄_j⊋C̄_k⊋C̄_i</code>.</p><p>&#39;classes&#39;:  a  list  of  records  holding information for each unipotent class (see below).</p><p>&#39;springerSeries&#39;:  a list of records, each  of which describes a Springer series  of <code>𝐆</code>.</p><p>The  records  describing  individual  unipotent  classes have the following fields:</p><p>&#39;name&#39;: the name of the unipotent class.</p><p>&#39;parameter&#39;:  a parameter  describing the  class (for  example, a partition describing the Jordan form, for classical groups).</p><p>&#39;Au&#39;: the group <code>A(u)</code>.</p><p>&#39;dynkin&#39;:  present in good characteristic; contains the Dynkin-Richardson diagram,  given  as  a  list  of  0,1,2  describing  the coefficient on the corresponding simple root.</p><p>&#39;red&#39;:  the reductive part of <code>C_𝐆(u)</code>.</p><p>&#39;dimBu&#39;:  the dimension of the variety <code>𝓑_u</code>.</p><p>The  records for classes contain additional fields for certain groups: for instance,  the names given  to classes by  Mizuno in <code>E_6,  E_7, E_8</code> or by Shoji in <code>F_4</code>.</p><p>The  records  describing  individual  Springer  series  have  the following fields:</p><p>&#39;levi&#39;:the  indices of the reflections corresponding to the Levi subgroup <code>𝐋</code> where lives the cuspidal local system <code>ι</code> from which the Springer series is induced.</p><p>&#39;relgroup&#39;:  The  relative  Weyl  group <code>N_𝐆(𝐋,ι)/𝐋</code>. The first series is the principal series for which &#39;.levi=[]&#39; and &#39;.relgroup=W&#39;.</p><p>&#39;locsys&#39;:  a list  of length  &#39;NrConjugacyClasses(.relgroup)&#39;, holding in &#39;i&#39;-th  position a  pair describing  which local  system corresponds to the &#39;i&#39;-th  character of <code>N_𝐆(𝐋,ι)</code>.  The first element  of the pair is the index of the concerned unipotent class &#39;u&#39;, and the second is the index of the corresponding character of <code>A(u)</code>.</p><p>&#39;Z&#39;:  the central character associated  to the Springer series, specified by its value on the generators of the centre.</p><p>|    gap&gt; W:=CoxeterGroup(&quot;A&quot;,3,&quot;sc&quot;);;     gap&gt; uc:=UnipotentClasses(W);     UnipotentClasses( A3 )     gap&gt; uc.classes;     [ UnipotentClass(1111), UnipotentClass(211), UnipotentClass(22),       UnipotentClass(31), UnipotentClass(4) ]     gap&gt; PrintRec(uc.classes[3]);     rec(       name      := 22,       Au        := CoxeterGroup(&quot;A&quot;,1),       dimBu     := 2,       dimunip   := 4,       dimred    := 3,       parameter := [ 2, 2 ],       balacarter:= [ 1, 3 ],       dynkin    := [ 0, 2, 0 ],       red       := ReflectionSubgroup(CoxeterGroup(&quot;A&quot;,1), [ 1 ]),       AuAction  := A1,       operations:= UnipotentClassOps )     gap&gt; uc.orderClasses;     [ [ 2 ], [ 3 ], [ 4 ], [ 5 ], [  ] ]     gap&gt; uc.springerSeries;     [ rec(           relgroup := A3,           Z := [ 1 ],           levi := [  ],           locsys := [ [ 1, 1 ], [ 2, 1 ], [ 3, 2 ], [ 4, 1 ], [ 5, 1 ] ] )         , rec(           relgroup := A1,           Z := [ -1 ],           levi := [ 1, 3 ],           locsys := [ [ 3, 1 ], [ 5, 3 ] ] ), rec(           relgroup := .,           Z := [ E(4) ],           levi := [ 1, 2, 3 ],           locsys := [ [ 5, 2 ] ] ), rec(           relgroup := .,           Z := [ -E(4) ],           levi := [ 1, 2, 3 ],           locsys := [ [ 5, 4 ] ] ) ]|</p><p>The  &#39;Display&#39; and &#39;Format&#39; functions for  unipotent classes accept all the options  of &#39;FormatTable&#39;,  &#39;CharNames&#39;. Giving  the option &#39;mizuno&#39; (resp. &#39;shoji&#39;)  uses  the  names  given  by  Mizuno  (resp.  Shoji) for unipotent classes.  Moreover,  there  is  also  an  option  &#39;fourier&#39; which gives the correspondence  tensored  with  the  sign  character  of each relative Weyl group, which is the correspondence obtained via a Fourier-Deligne transform (here  we assume that  <code>p</code> is very  good, so that  there is a nondegenerate invariant  bilinear  form  on  the  Lie  algebra, and also one can identify nilpotent orbits with unipotent classes).</p><p>Here  is how  to display  only the  ordinary Springer correspondence of the unipotent classes of &#39;E6&#39; using the notations of Mizuno for the classes and those of Frame for the characters of the Weyl group and of Spaltenstein for the  characters of &#39;G2&#39; (this is convenient  for checking our data with the original paper of Spaltenstein):</p><p>|    gap&gt; uc:=UnipotentClasses(CoxeterGroup(&quot;E&quot;,6));;     gap&gt; Display(uc,rec(columns:=[1..5],mizuno:=true,frame:=true,     &gt; spaltenstein:=true));     1&lt;A1&lt;2A1&lt;3A1&lt;A2&lt;A2+A1&lt;A2+2A1&lt;2A2+A1&lt;A3+A1&lt;D4(a1)&lt;D4&lt;D5(a1)&lt;A5+A1&lt;D5&lt;E6     (a1)&lt;E6     A2+A1&lt;2A2&lt;2A2+A1     A2+2A1&lt;A3&lt;A3+A1     D4(a1)&lt;A4&lt;A4+A1&lt;A5&lt;A5+A1     A4+A1&lt;D5(a1)          u |   D-R dBu    B-C            C(u)                 E6()     _______________________________________________________________     E6     |222222   0 222222             q^6                   1p     E6(a1) |222022   1 222022             q^8                   6p     D5     |220202   2 22222.       q^9.(q-1)                  20p     A5+A1  |200202   3 200202         q^12.Z2         11:15p 2:30p     A5     |211012   4 2.2222         q^11.A1                  15q     D5(a1) |121011   4 22202.      q^13.(q-1)                  64p     A4+A1  |111011   5 2222.2      q^15.(q-1)                  60p     D4     |020200   6 .2222.         q^10.A2                  24p     A4     |220002   6 2222..   q^14.A1.(q-1)                  81p     D4(a1) |000200   7 .2202. q^18.(q-1)^2.S3 111:20s 3:80s 21:90s     A3+A1  |011010   8 22.22.   q^18.A1.(q-1)                  60s     2A2+A1 |100101   9 222.22         q^21.A1                  10s     A3     |120001  10 2.22..   q^15.B2.(q-1)                 81p&#39;     A2+2A1 |001010  11 222.2.   q^24.A1.(q-1)                 60p&#39;     2A2    |200002  12 2.2.22         q^16.G2                 24p&#39;     A2+A1  |110001  13 222...   q^23.A2.(q-1)                 64p&#39;     A2     |020000  15 2.2...    q^20.(A2xA2)       11:15p&#39; 2:30p&#39;     3A1    |000100  16 22..2.      q^27.A2xA1                 15q&#39;     2A1    |100001  20 22....   q^24.B3.(q-1)                 20p&#39;     A1     |010000  25 2.....         q^21.A5                  6p&#39;     1      |000000  36 ......              E6                  1p&#39;|</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Ucl.jl#L454-L609">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Ucl.ICCTable" href="#Gapjm.Ucl.ICCTable"><code>Gapjm.Ucl.ICCTable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% &#39;ICCTable(&lt;uc&gt;[,&lt;seriesNo&gt;[,&lt;q&gt;]])&#39;</p><p>This   function  gives  the  table   of  decompositions  of  the  functions <code>X_{u,φ}</code>   in   terms   of   the   functions  <code>Y_{u,φ}</code>.  Here <code>(u,φ)</code>   reductive  group  <code>𝐆</code>  and  <code>φ</code>  is  a  character  of  the group of components  <code>A(u)</code>; such a pair  describes a <code>𝐆</code>-equivariant local system on the class <code>C</code> of <code>u</code>. The function <code>Y_{u,φ}</code> is the characteristic function  of this  local system  and <code>X_{u,φ}</code>  is the characteristic function  of the  corresponding intersection  cohomology complex. The local systems  can  also  be  indexed  by  characters  of the relative Weyl group occurring  in  the  Springer  correspondence,  and since the coefficient of <code>X_χ</code>  on <code>Y_ψ</code> is <code>0</code> if <code>χ</code>  and <code>ψ</code> do not correspond to the same  relative Weyl group (are not in  the same Springer series), the table given  is for a given Springer series,  the series whose number is given by the  argument &#39;seriesNo&#39; (if omitted this defaults to &#39;seriesNo=1&#39; which is the principal series). The decomposition multiplicities are graded, and are given as polynomials in one variable (specified by the argument &lt;q&gt;; if not given &#39;Indeterminate(Rationals)&#39; is assumed).</p><pre><code class="language-julia-repl">julia&gt; ICCTable(uc)
Coefficients of X_φ on Y_ψ for A3
     │4 31 22 211 1111
─────┼─────────────────
X4   │1  1  1   1    1
X31  │0  1  1  Φ₂   Φ₃
X22  │0  0  1   1   Φ₄
X211 │0  0  0   1   Φ₃
X1111│0  0  0   0    1</code></pre><p>In  the  above  the  multiplicities  are  given  as  products of cyclotomic polynomials  to display  them more  compactly. However  the &#39;Format&#39; or the &#39;Display&#39;   of  such  a  table  can   be  controlled  more  precisely.</p><p>For  instance,  one  can  ask  to  not  display  the entries as products of cyclotomic polynomials:</p><p>|    gap&gt; Display(ICCTable(uc),rec(CycPol:=false));     Coefficients of X<em>phi on Y</em>psi for A3</p><pre><code class="language-none">      |4 31 22 211    1111
___________________________
X4    |1  1  1   1       1
X31   |0  1  1 q+1 q^2+q+1
X22   |0  0  1   1   q^2+1
X211  |0  0  0   1 q^2+q+1
X1111 |0  0  0   0       1|</code></pre><p>Since  &#39;Display&#39;  and  &#39;Format&#39;  use  the  function  &quot;FormatTable&quot;, all the options  of this function are  also available. We can  use this to restrict the  entries displayed to a given sublist of the rows and columns (here the indices correspond to the number in Chevie of the corresponding character of the relative Weyl group of the given Springer series):</p><p>|    gap&gt; W:=CoxeterGroup(&quot;F&quot;,4);;     gap&gt; uc:=UnipotentClasses(W);;     gap&gt; show:=[13,24,22,18,14,9,11,19];;     gap&gt; Display(ICCTable(uc),rec(rows:=show,columns:=show));     Coefficients of X<em>phi on Y</em>psi for F4</p><pre><code class="language-none">            |A1+~A1 A2 ~A2 A2+~A1 ~A2+A1 B2(11) B2 C3(a1)(11)
______________________________________________________________
Xphi{9,10}  |     1  0   0      0      0      0  0          0
Xphi{8,9}&#39;&#39; |     1  1   0      0      0      0  0          0
Xphi{8,9}&#39;  |     1  0   1      0      0      0  0          0
Xphi{4,7}&#39;&#39; |     1  1   0      1      0      0  0          0
Xphi{6,6}&#39;  |    P4  1   1      1      1      0  0          0
Xphi{4,8}   |   q^2  0   0      0      0      1  0          0
Xphi{9,6}&#39;&#39; |    P4 P4   0      1      0      0  1          0
Xphi{4,7}&#39;  |   q^2  0  P4      0      1      0  0          1|</code></pre><p>The function &#39;ICCTable&#39; returns a record with various pieces of information which can help further computations.</p><p>.scalar:  this contains the table of  multiplicities <code>P_{ψ,χ}</code> of the <code>X_ψ</code> on  the <code>Y_χ</code>. One should  pay attention that by  default, the table is not displayed  in the same order as the  stored |.scalar|, which is in order in Chevie  of  the  characters  in  the  relative  Weyl  group;  the  table is transposed,  then lines  and rows  are sorted  by |dimBu,class  no,index of character in A(u)| while displayed.</p><p>.group: The group &lt;W&gt;.</p><p>.relgroup: The relative Weyl group for the Springer series.</p><p>.series: The index of the Springer series given for &lt;W&gt;.</p><p>.dimBu: The list of <code>dim𝓑_u</code> for each local system <code>(u,φ)</code> in the series.</p><p>.L:  The matrix  of (unnormalized)  scalar products  of the functions <code>Y_ψ</code> with  themselves,  that  is  the  <code>(φ,ψ)</code>  entry  is  <code>∑_{g∈𝐆(𝔽_q)}  Y_φ(g) Ȳ_ψ(g)</code>.  This  is  thus  a  symmetric,  block-diagonal  matrix  where the diagonal  blocks correspond to geometric  unipotent conjugacy classes. This matrix  is  obtained  as  a  by-product  of  Lusztig&#39;s algorithm to compute <code>P_{ψ,χ}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Ucl.jl#L1018-L1116">source</a></section><h1><a class="nav-anchor" id="HasType.jl-Documentation-1" href="#HasType.jl-Documentation-1">HasType.jl Documentation</a></h1><h1><a class="nav-anchor" id="Symbols.jl-Documentation-1" href="#Symbols.jl-Documentation-1">Symbols.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Symbols" href="#Gapjm.Symbols"><code>Gapjm.Symbols</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>The  combinatorial objects  in this  module are  <em>partitions</em>, <em>β-sets</em> and <em>symbols</em>.</p><p>A partition is a decreasing list of strictly positive integers p₁≥p₂≥…pₙ&gt;0, represented as a <code>Vector</code> of <code>Int</code>.</p><p>A  <em>β-set</em> is  a set  of positive  integers, up  to the <em>shift</em> equivalence relation.  This  equivalence  relation  is  the  transitive  closure of the elementary  equivalence  of  [s₁,…,sₙ]  and [0,1+s₁,…,1+sₙ]. An equivalence class  has exactly one  member which does  not contain 0:  it is called the normalized  β-set. A β-set is represented as a strictly increasing <code>Vector</code> of <code>Int</code>.</p><p>To  a  partition  p₁≥p₂≥…pₙ&gt;0  is  associated  a  β-set,  whose  normalized representative   is  pₙ,pₙ₋₁+1,…,p₁+n-1.  Conversely,   to  each  β-set  is associated  a partition, the one giving by the above formula its normalized representative.</p><p>A  symbol is  a tuple  S=[S₁,…,Sₙ] of  β-sets, taken modulo the equivalence relation  generated by two elementary  equivalences: the simultaneous shift of  all β-sets, and the cyclic permutation  of the tuple (in the particular case  where n=2 it is thus an unordered pair of β-sets). This time there is a  unique normalized symbol where 0 is not in the intersection of the Sᵢ. A basic invariant attached to symbols is the <em>rank</em>, defined as</p><p><code>sum(sum,S)-div((sum(length,S)-1)*(sum(length,S)-length(S)+1),2*Length(S))</code></p><p>Another  function attached to symbols  is the <em>shape</em> &#39;map(length,S)&#39;; when n=2  one can  assume that  S₁ has  at least  the same  length as S₂ and the difference  of cardinals &#39;length(S[1])-length(S[2])&#39;,  called the <em>defect</em>, is then an invariant of the symbol.</p><p>Partitions  and pairs  of partitions  are parameters  for characters of the Weyl groups of classical types, and tuples of partitions are parameters for characters  of  imprimitive  complex  reflection  groups.  Symbols with two β-sets  are parameters for the  unipotent characters of classical Chevalley groups,   and  more  general  symbols  are  parameters  for  the  unipotent characters  of Spetses associated to complex reflection groups. The rank of the  symbol is the semi-simple rank of the corresponding Chevalley group or Spets.</p><p>Symbols of rank n and defect 0 parameterize characters of the Weyl group of type  Dₙ, and  symbols of  rank n  and defect  divisible by  4 parameterize unipotent characters of split orthogonal groups of dimension 2n. Symbols of rank n and defect congruent to 2 mod 4 parameterize unipotent characters of non-split orthogonal groups of dimension 2n. Symbols of rank n and defect 1 parameterize  characters of the Weyl group  of type Bₙ, and finally symbols of  rank n and  odd defect parameterize  unipotent characters of symplectic groups of dimension 2n or orthogonal groups of dimension 2n+1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Symbols.jl#L1-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Symbols.shiftβ" href="#Gapjm.Symbols.shiftβ"><code>Gapjm.Symbols.shiftβ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>shiftβ( β, n)</code> shift β-set β by n</p><pre><code class="language-julia-repl">julia&gt; shiftβ([4,5],3)
5-element Array{Int64,1}:
 0
 1
 2
 7
 8

julia&gt; shiftβ([0,1,4,5],-2)
2-element Array{Int64,1}:
 2
 3
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Symbols.jl#L60-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Symbols.βset" href="#Gapjm.Symbols.βset"><code>Gapjm.Symbols.βset</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>βset(p)</code> normalized β-set of a partition</p><pre><code class="language-julia-repl">julia&gt; βset([3,3,1])
3-element Array{Int64,1}:
 1
 4
 5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Symbols.jl#L86-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Symbols.partβ" href="#Gapjm.Symbols.partβ"><code>Gapjm.Symbols.partβ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>&#39;partβ(β)&#39; partition defined by β-set β</p><pre><code class="language-julia-repl">julia&gt; partβ([0,4,5])
2-element Array{Int64,1}:
 3
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Symbols.jl#L99-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Symbols.ranksymbol" href="#Gapjm.Symbols.ranksymbol"><code>Gapjm.Symbols.ranksymbol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>ranksymbol(S)</code> rank of symbol <code>S</code>.</p><pre><code class="language-julia-repl">julia&gt; ranksymbol([[1,2],[1,5,6]])
11</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Symbols.jl#L167-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Symbols.fegsymbol" href="#Gapjm.Symbols.fegsymbol"><code>Gapjm.Symbols.fegsymbol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>fegsymbol(S)</code> returns as a CycPol the fake degree given by symbol <code>S</code></p><pre><code class="language-julia-repl">julia&gt; fegsymbol([[1,5,6],[1,2]])
q¹⁶Φ₅Φ₇Φ₈Φ₉Φ₁₀Φ₁₁Φ₁₄Φ₁₆Φ₁₈Φ₂₀Φ₂₂</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Symbols.jl#L349-L356">source</a></section><h1><a class="nav-anchor" id="Util.jl-Documentation-1" href="#Util.jl-Documentation-1">Util.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Util" href="#Gapjm.Util"><code>Gapjm.Util</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>This  module contains  various utility  functions used  in the  rest of the code.  Maybe some  of them  exist in  some Julia  module I am not aware of; please tell me.</p><p>The code is divided in sections  according to semantics.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Util.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Util.groupby" href="#Gapjm.Util.groupby"><code>Gapjm.Util.groupby</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>group items of list l according to the corresponding values in list v</p><pre><code class="language-none">julia&gt; groupby([31,28,31,30,31,30,31,31,30,31,30,31],
       [:Jan,:Feb,:Mar,:Apr,:May,:Jun,:Jul,:Aug,:Sep,:Oct,:Nov,:Dec])
Dict{Int64,Array{Symbol,1}} with 3 entries:
  31 =&gt; Symbol[:Jan, :Mar, :May, :Jul, :Aug, :Oct, :Dec]
  28 =&gt; Symbol[:Feb]
  30 =&gt; Symbol[:Apr, :Jun, :Sep, :Nov]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Util.jl#L41-L51">source</a><div><div><p>group items of list l according to the values taken by function f on them</p><pre><code class="language-none">julia&gt; groupby(iseven,1:10)
Dict{Bool,Array{Int64,1}} with 2 entries:
  false =&gt; [1, 3, 5, 7, 9]
  true  =&gt; [2, 4, 6, 8, 10]</code></pre><p>Note:in this version l is required to be non-empty since I do not know how to access the return type of a function</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Util.jl#L60-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Util.constant" href="#Gapjm.Util.constant"><code>Gapjm.Util.constant</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>whether all elements in list a are equal</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Util.jl#L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Util.blocks" href="#Gapjm.Util.blocks"><code>Gapjm.Util.blocks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>blocks(M::Matrix)</p><p>M  should be a square matrix. Define  a graph G with vertices 1:size(M,1)   and  with an edge between i and j  if either M[i,j] or M[j,i] is not zero   or false. blocks returns a vector of vectors I such that I[1],I[2], etc..   are  the  vertices  in  each  connected  component  of G. In other words,   M[I[1],I[1]],M[I[2],I[2]],etc... are blocks of M.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Util.jl#L84-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Util.format" href="#Gapjm.Util.format"><code>Gapjm.Util.format</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>format(io, table; options )</p><p>General routine to format a table. Used for character tables.   Options:      row<em>labels          Labels for rows      column</em>labels       Labels for columns      rows<em>label          Label for column of rowLabels      separators          line numbers after which to put a separator      column</em>repartition  display in pieces of sizes these numbers of cols      rows                show only these rows      columns             show only these columns</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Util.jl#L148-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Util.prime_residues" href="#Gapjm.Util.prime_residues"><code>Gapjm.Util.prime_residues</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>the numbers less than n and prime to n </p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Util.jl#L233">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Util.phi" href="#Gapjm.Util.phi"><code>Gapjm.Util.phi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>the Euler function ϕ </p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Util.jl#L253">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.Util.primitiveroot" href="#Gapjm.Util.primitiveroot"><code>Gapjm.Util.primitiveroot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>primitiveroot(m::Integer) a primitive root mod. m,   that is it generates multiplicatively prime_residues(m).   It exists if m is of the form 4, 2p^a or p^a for p prime&gt;2.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/Util.jl#L259-L263">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>echelon!</code>. Check Documenter&#39;s build log for details.</p></div></div><h1><a class="nav-anchor" id="Cycpols.jl-Documentation-1" href="#Cycpols.jl-Documentation-1">Cycpols.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gapjm.CycPols" href="#Gapjm.CycPols"><code>Gapjm.CycPols</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Cyclotomic  numbers, and cyclotomic polynomials  over the rationals or some cyclotomic field, are important in reductive groups or Spetses. This module deals  with them: the type <code>CycPol</code>  represents the product of a polynomial with  a rational fraction in one variable with all poles or zeroes equal to 0  or  roots  of  unity.  The  advantages  of representing as <code>CycPol</code> such objects    are:   nice   display   (factorized),   less   storage,   faster multiplication,  division and evaluation. The drawback is that addition and subtraction are not implemented!</p><pre><code class="language-julia-repl">julia&gt; Pol(:q)
q

julia&gt; p=CycPol(q^25-q^24-2q^23-q^2+q+2)
(q-2)Φ₁Φ₂Φ₂₃

julia&gt; p(q) # a CycPol is a callable object, this call evaluates p at q
q²⁵-q²⁴-2q²³-q²+q+2

julia&gt; p*inv(CycPol(q^2+q+1))
(q-2)Φ₁Φ₂Φ₃⁻¹Φ₂₃
</code></pre><p>The variable name in a <code>CycPol</code> is set by default to the same as for <code>Pols</code>.</p><p><code>CycPol</code>s are internally a <code>struct</code> with fields:</p><p><code>.coeff</code>:  a coefficient, usually a cyclotomic number or a polynomial.</p><p><code>.valuation</code>: an <code>Int</code>.</p><p><code>.v</code>: a list of pairs <code>r=&gt;m</code> of a root of unity <code>r</code> and a multiplicity <code>m</code>. Here <code>r</code> is a <code>Root1</code>, internally a fraction <code>n//e</code> with <code>n&lt;e</code> representing <code>E(r)=E(e,n)</code>.</p><p>So <code>CycPol(c,val,v)</code> represents <code>c*q^val*prod((q-E(r))^m for (r,m) in v)</code>.</p><p>When   showing,  some  factors  of   the  cyclotomic  polynomial  <code>Φₙ</code>  are represented.  If <code>n</code>  has a  primitive root,  <code>ϕ′ₙ</code> is  the product  of the <code>(q-ζ)</code>  where <code>ζ</code> runs over the odd powers of a primitive root of <code>n</code>, and <code>ϕ″ₙ</code>  is the product for the even powers. Some other factors of cyclotomic polynomials are:</p><pre><code class="language-none">Φ′₈=q²-ζ₄
Φ″₈=q²+ζ₄
Φ‴₈=q²-√2q+1
Φ⁗₈=q²+√2q+1
Φ⁽⁵⁾₈=q²-√-2q-1
Φ⁽⁶⁾₈=q²+√-2q-1
Φ′₁₂=q²-ζ₄q-1
Φ″₁₂=q²+ζ₄q-1
Φ‴₁₂=q²+ζ₃²
Φ⁗₁₂=q²+ζ₃
Φ⁽⁵⁾₁₂=q²-√3q+1
Φ⁽⁶⁾₁₂=q²+√3q+1
Φ′₁₅=q⁴-q(1+√5)(q^2-q+1)/2+1
Φ″₁₅=q⁴-q(1-√5)(q^2-q+1)/2+1
Φ‴₁₅=q⁴+ζ₃²q³+ζ₃q²+q+ζ₃²
Φ⁗₁₅=q⁴+ζ₃q³+ζ₃²q²+q+ζ₃
Φ⁽⁵⁾₁₅=q²+ζ₃²(1+√5)q/2+ζ₃
Φ⁽⁶⁾₁₅=q²+ζ₃²(1-√5)q/2+ζ₃
Φ⁽⁷⁾₁₅=q²+ζ₃(1+√5)q/2+ζ₃
Φ⁽⁸⁾₁₅=q²+ζ₃(1-√5)q/2+ζ₃
Φ′₂₀=q⁴-(1+√5)/2q²+1
Φ″₂₀=q⁴-(1-√5)/2q²+1
Φ‴₂₀=q⁴+ζ₄q³-q²-ζ₄q+1
Φ⁗₂₀=q⁴-ζ₄q³-q²+ζ₄q+1
Φ′₂₄=q⁴+ζ₃²
Φ″₂₄=q⁴+ζ₃
Φ‴₂₄=q⁴-√2q³+q²-√2q+1
Φ⁗₂₄=q⁴+√2q³+q²+√2q+1
Φ⁽⁵⁾₂₄=q⁴-√6q³+3q²-√6q+1
Φ⁽⁶⁾₂₄=q⁴+√6q³+3q²+√6q+1
Φ⁽⁷⁾₂₄=q⁴+√-2q³-q²-√-2q+1
Φ⁽⁸⁾₂₄=q⁴-√-2q³-q²+√-2q+1
Φ⁽⁹⁾₂₄=q²+ζ₃²√-2q-ζ₃
Φ⁽¹⁰⁾₂₄=q²-ζ₃²√-2q-ζ₃
Φ⁽¹¹⁾₂₄=q²+ζ₃√-2q-ζ₃²
Φ⁽¹²⁾₂₄=q²-ζ₃√-2q-ζ₃²
Φ′₃₀=q⁴-q(1-√5)(q^2+q+1)/2+1
Φ″₃₀=q⁴-q(1+√5)(q^2+q+1)/2+1
Φ‴₃₀=q⁴-ζ₃q³+ζ₃²q²-q+ζ₃
Φ⁗₃₀=q⁴-ζ₃²q³+ζ₃q²-q+ζ₃²
Φ⁽⁵⁾₃₀=q²-ζ₃²(1-√5)q/2+ζ₃
Φ⁽⁶⁾₃₀=q²-ζ₃²(1+√5)q/2+ζ₃
Φ⁽⁷⁾₃₀=q²-ζ₃(1-√5)q/2+ζ₃²
Φ⁽⁸⁾₃₀=q²-ζ₃(1+√5)q/2+ζ₃²
Φ′₄₂=q⁶-ζ₃²q⁵+ζ₃q⁴-q³+ζ₃²q²-ζ₃q+1
Φ″₄₂=q⁶-ζ₃q⁵+ζ₃²q⁴-q³+ζ₃q²-ζ₃²q+1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/2fea3af8b738b6e8fe5df6e4d045056c1313f1b0/src/CycPols.jl#L1-L94">source</a></section><footer><hr/></footer></article></body></html>
