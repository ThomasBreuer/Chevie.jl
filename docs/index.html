<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gapjm Documentation · Gapjm.jl documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Gapjm.jl documentation</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Gapjm Documentation</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Permutations-1"><span>Permutations</span></a></li><li class="toplevel"><a class="tocitem" href="#Groups-1"><span>Groups</span></a></li><li class="toplevel"><a class="tocitem" href="#Permutation-groups-1"><span>Permutation groups</span></a></li><li class="toplevel"><a class="tocitem" href="#Cyclotomic-numbers-1"><span>Cyclotomic numbers</span></a></li><li class="toplevel"><a class="tocitem" href="#Univariate-Laurent-polynomials-1"><span>Univariate Laurent polynomials</span></a></li><li class="toplevel"><a class="tocitem" href="#Multivariate-Laurent-polynomials-1"><span>Multivariate Laurent polynomials</span></a></li><li class="toplevel"><a class="tocitem" href="#Coxeter-groups-1"><span>Coxeter groups</span></a></li><li class="toplevel"><a class="tocitem" href="#Finite-Coxeter-groups-and-Weyl-groups-1"><span>Finite Coxeter groups and Weyl groups</span></a></li><li class="toplevel"><a class="tocitem" href="#Finite-reflection-groups-1"><span>Finite reflection groups</span></a></li><li class="toplevel"><a class="tocitem" href="#Hecke-algebras-1"><span>Hecke algebras</span></a></li><li class="toplevel"><a class="tocitem" href="#Kazhdan-Lusztig-polynomials-and-bases-1"><span>Kazhdan-Lusztig polynomials and bases</span></a></li><li class="toplevel"><a class="tocitem" href="#Garside-monoids-and-groups,-braids.-1"><span>Garside monoids and groups, braids.</span></a></li><li class="toplevel"><a class="tocitem" href="#Classes-and-characters-of-reflection-groups-1"><span>Classes and characters of reflection groups</span></a></li><li class="toplevel"><a class="tocitem" href="#Reflection-cosets-1"><span>Reflection cosets</span></a></li><li class="toplevel"><a class="tocitem" href="#Unipotent-characters-1"><span>Unipotent characters</span></a></li><li class="toplevel"><a class="tocitem" href="#Unipotent-classes-of-reductive-groups-1"><span>Unipotent classes of reductive groups</span></a></li><li class="toplevel"><a class="tocitem" href="#Symbols-1"><span>Symbols</span></a></li><li class="toplevel"><a class="tocitem" href="#Signed-permutations-1"><span>Signed permutations</span></a></li><li class="toplevel"><a class="tocitem" href="#Utilities-1"><span>Utilities</span></a></li><li class="toplevel"><a class="tocitem" href="#Combinatorics-1"><span>Combinatorics</span></a></li><li class="toplevel"><a class="tocitem" href="#ModuleElts.jl-Documentation-1"><span>ModuleElts.jl Documentation</span></a></li><li class="toplevel"><a class="tocitem" href="#Cyclotomic-polynomials-1"><span>Cyclotomic polynomials</span></a></li><li class="toplevel"><a class="tocitem" href="#Posets-1"><span>Posets</span></a></li><li class="toplevel"><a class="tocitem" href="#Linear-algebra-on-any-field/ring-1"><span>Linear algebra on any field/ring</span></a></li><li class="toplevel"><a class="tocitem" href="#Eigenspaces-1"><span>Eigenspaces</span></a></li><li class="toplevel"><a class="tocitem" href="#Dictionary-from-GAP3/Chevie-1"><span>Dictionary from GAP3/Chevie</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Gapjm Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gapjm Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmichel7/Gapjm.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Gapjm-Documentation-1"><a class="docs-heading-anchor" href="#Gapjm-Documentation-1">Gapjm Documentation</a><a class="docs-heading-anchor-permalink" href="#Gapjm-Documentation-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm" href="#Gapjm"><code>Gapjm</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This  is  my  effort  porting  GAP  code  to Julia, specifically the Chevie package  of GAP3 plus the minimal other GAP functionality needed for Chevie to   work:  Cyclotomics,  Permutations,   Laurent  polynomials,  and  basic permutation group operations.</p><p>I am rather new to Julia, git and github so I am not even sure this package is  properly constituted; I did not try yet to register it. If you are more competent  that me and see anything to  be improved in this package, please write me or make a pull request.</p><p><strong>Installing</strong></p><p>To install this package, at the Julia command line:</p><ul><li>enter package mode with ]</li><li>do the command</li></ul><pre><code class="language-none">(v1.0) pkg&gt; add &quot;https://github.com/jmichel7/Gapjm.jl&quot;</code></pre><ul><li>exit package mode with backspace and then do </li></ul><pre><code class="language-none">julia&gt; using Gapjm</code></pre><p>and you are set up.</p><p>To update later to the latest version, do</p><pre><code class="language-none">(v1.0) pkg&gt; update &quot;https://github.com/jmichel7/Gapjm.jl&quot;</code></pre><p>The package currently contains:</p><ul><li>infrastructure</li></ul><p>Permutations,  cyclotomic  numbers,  Laurent  polynomials.  There  are also permutation  groups, for which I have  often replaced the proper algorithms of  GAP by naive but  easy to write methods  only suitable for small groups (sufficient  for the rest of the package but maybe not for your needs). The code  for infrastructure is often competitive  with GAP, despite being much shorter (often 100 lines of Julia replace 1000 lines of C); I am sure there are more optimisations possible. Any comments about the code and the design are welcome.</p><ul><li>ported from Chevie</li></ul><p>about 75% of Chevie functionality. The function <code>gap</code> can help you discover the  equivalent functionality  to a  Gap3 function:  it takes  a string and gives you Julia translations of functions in Gap3 which match this string:</p><pre><code class="language-julia-rep1">julia&gt; gap(&quot;words&quot;)
CoxeterWords(W[,l])      =&gt;  word.(Ref(W),elements(W[,l])
GarsideWords             =&gt;  elements
CharRepresentationWords  =&gt;  traces_words_mats</code></pre><p>Then you can call on-line help on the discovered functions.</p><p>This package is  often 10 times faster  than the equivalent GAP3 Chevie code (after the maddeningly long compilation time on first execution).</p><p>I tried that parts of my package can be used independently of the rest. For instance,  the modules <code>Combinat</code>,  <code>Groups</code>, <code>ModuleElts</code>, <code>Perms</code>, <code>Util</code> are  independent of  the rest  of the  package and  can be used stand-alone (after a trivial change forced by the exporting rules of Julia, see below).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Gapjm.jl#L1-L65">source</a></section></article><ul><li><a href="#Gapjm-Documentation-1">Gapjm Documentation</a></li><li><a href="#Permutations-1">Permutations</a></li><li><a href="#Groups-1">Groups</a></li><li><a href="#Permutation-groups-1">Permutation groups</a></li><li><a href="#Cyclotomic-numbers-1">Cyclotomic numbers</a></li><li><a href="#Univariate-Laurent-polynomials-1">Univariate Laurent polynomials</a></li><li><a href="#Multivariate-Laurent-polynomials-1">Multivariate Laurent polynomials</a></li><li><a href="#Coxeter-groups-1">Coxeter groups</a></li><li><a href="#Finite-Coxeter-groups-and-Weyl-groups-1">Finite Coxeter groups and Weyl groups</a></li><li><a href="#Finite-reflection-groups-1">Finite reflection groups</a></li><li><a href="#Hecke-algebras-1">Hecke algebras</a></li><li><a href="#Kazhdan-Lusztig-polynomials-and-bases-1">Kazhdan-Lusztig polynomials and bases</a></li><li><a href="#Garside-monoids-and-groups,-braids.-1">Garside monoids and groups, braids.</a></li><li><a href="#Classes-and-characters-of-reflection-groups-1">Classes and characters of reflection groups</a></li><li><a href="#Reflection-cosets-1">Reflection cosets</a></li><li><a href="#Unipotent-characters-1">Unipotent characters</a></li><li><a href="#Unipotent-classes-of-reductive-groups-1">Unipotent classes of reductive groups</a></li><li><a href="#Symbols-1">Symbols</a></li><li><a href="#Signed-permutations-1">Signed permutations</a></li><li><a href="#Utilities-1">Utilities</a></li><li><a href="#Combinatorics-1">Combinatorics</a></li><li><a href="#ModuleElts.jl-Documentation-1">ModuleElts.jl Documentation</a></li><li><a href="#Cyclotomic-polynomials-1">Cyclotomic polynomials</a></li><li><a href="#Posets-1">Posets</a></li><li><a href="#Linear-algebra-on-any-field/ring-1">Linear algebra on any field/ring</a></li><li><a href="#Eigenspaces-1">Eigenspaces</a></li><li><a href="#Dictionary-from-GAP3/Chevie-1">Dictionary from GAP3/Chevie</a></li></ul><h1 id="Permutations-1"><a class="docs-heading-anchor" href="#Permutations-1">Permutations</a><a class="docs-heading-anchor-permalink" href="#Permutations-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms" href="#Gapjm.Perms"><code>Gapjm.Perms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This module is a port of the GAP permutations type.</p><p>They  are permutations  of the  set <code>1:n</code>  represented as  a vector  of <code>n</code> integers  holding the images of <code>1:n</code>. The integer <code>n</code> is called the degree of  the permutation, even if it is not  moved. We follow the GAP design: it is  possible to multiply,  or to store  in the same  group, permutations of different  degrees; this  is implemented  by promoting  both to  the higher degree. Slightly different is the MAGMA design where any permutation has to belong  to  a  group  and  the  degree  is  determined  by that group; then multiplication of permutations within a given group is slightly faster, but it is more difficult to multiply permutations coming from different groups, like  a group  and one  of its  subgroups. The  degree is an implementation detail so usually it should not be used. One should rather use the function <code>largest_moved_point</code>.</p><p>The default constructor for a permutation uses the list of images of <code>1:n</code>, like  <code>Perm([2,3,1,5,4])</code>.  Often  it  is  more  convenient  to  use  cycle decompositions:    the   above   permutation    has   cycle   decomposition <code>(1,2,3)(4,5)</code>    thus   can   be    written   <code>Perm(1,2,3)*Perm(4,5)</code>   or <code>perm&quot;(1,2,3)(4,5)&quot;</code>  (this last form  can parse any  GAP permutation). The list  of images  of <code>1:n</code>  can be  gotten back  from the permutation by the function  <code>vec</code>;  note  that  since  equal  permutations may have different degrees, they may have different <code>vec</code>.</p><p>The  complete type of a permutation  is <code>Perm{T}</code> where <code>T&lt;:Integer</code>, where <code>Vector{T}</code>  is the type of the vector which holds the image of <code>1:n</code>. This can  be used to save space or  time. For instance <code>Perm{UInt8}</code> can be used for  Weyl groups of rank≤8 since they have at most 240 roots. If <code>T</code> is not specified  we take it to be <code>Int16</code> since this is a good compromise between speed, compactness and possible size of <code>n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a=Perm(1,2,3)
(1,2,3)

julia&gt; vec(a)
3-element Array{Int16,1}:
 2
 3
 1

julia&gt; a==Perm(vec(a))
true

julia&gt; b=Perm(1,2,3,4)
(1,2,3,4)

julia&gt; a*b     # product
(1,3,2,4)

julia&gt; inv(a)  # inverse
(1,3,2)

julia&gt; a/b     # quotient  a*inv(b)
(3,4)

julia&gt; a\b     # left quotient inv(a)*b
(1,4)

julia&gt; a^b     # conjugation inv(b)*a*b
(2,3,4)

julia&gt; b^2     # square
(1,3)(2,4)

julia&gt; 1^a     # image by a of point 1
2

julia&gt; one(a)
()

julia&gt; sign(a) # sigature of permutation
1

julia&gt; order(a)
3

julia&gt; largest_moved_point(a)
3

julia&gt; smallest_moved_point(a)
1

julia&gt; Perm{Int8}(a) # convert to Perm{Int8}
Perm{Int8}: (1,2,3)

julia&gt; Matrix(b)
4×4 Array{Bool,2}:
 0  1  0  0
 0  0  1  0
 0  0  0  1
 1  0  0  0

julia&gt; rand(Perm,10)
(1,8,4,2,9,7,5,10,3,6)
</code></pre><p><code>Perm</code>s have methods <code>copy</code>, <code>hash</code>, <code>==</code>, so they can be keys in hashes or elements  of sets; two permutations are equal  if they move the same points to  the same images. They have methods <code>cmp</code>, <code>isless</code> (lexicographic order on   moved  points)  so  they  can  be  sorted.  <code>Perm</code>s  are  scalars  for broadcasting.</p><p>other functions on <code>Perm</code>s are:  <code>cycles, cycletype, orbit, orbits, restricted</code>.  See individual documentations below.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L1-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.Perm" href="#Gapjm.Perms.Perm"><code>Gapjm.Perms.Perm</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct Perm</code></p><p>A  Perm represents a permutation  of the set <code>1:n</code>  and is implemented by a <code>struct Perm</code> with one field <code>d</code>, a vector holding the images of <code>1:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.Perm-Tuple{Vararg{Integer,N} where N}" href="#Gapjm.Perms.Perm-Tuple{Vararg{Integer,N} where N}"><code>Gapjm.Perms.Perm</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Perm{T}(x::Integer...)where T&lt;:Integer</code></p><p>returns  a cycle.  For example  <code>Perm{Int8}(1,2,3)</code> constructs the cycle    <code>(1,2,3)</code> as a <code>Perm{Int8}</code>. If omitted <code>{T}</code> is taken as to be <code>Int16</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L135-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.Perm-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#Gapjm.Perms.Perm-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>Gapjm.Perms.Perm</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Perm{T}(l::AbstractVector,l1::AbstractVector)</code></p><p>returns <code>p</code>, a <code>Perm{T}</code>, such that <code>l1^p==l</code> if such a <code>p</code> exists; returns <code>nothing</code> otherwise. If not given <code>{T}</code> is taken to be <code>{Int16}</code>. Needs the elements of <code>l</code> and <code>l1</code> to be sortable.</p><pre><code class="language-julia-repl">julia&gt; Perm([0,2,4],[4,0,2])
(1,3,2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L191-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.largest_moved_point" href="#Gapjm.Perms.largest_moved_point"><code>Gapjm.Perms.largest_moved_point</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>largest_moved_point(a::Perm)</code> is the largest integer moved by a</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.smallest_moved_point" href="#Gapjm.Perms.smallest_moved_point"><code>Gapjm.Perms.smallest_moved_point</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>smallest_moved_point(a::Perm)</code> is the smallest integer moved by a</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:^-Tuple{AbstractArray{T,1} where T,Perm}" href="#Base.:^-Tuple{AbstractArray{T,1} where T,Perm}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Base.:^(l::AbstractVector,p::Perm)</code> </p><p>returns <code>l</code> permuted by <code>p</code>, a vector <code>r</code> such that <code>r[i^p]==l[i]</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; [5,4,6,1,7,5]^Perm(1,3,5,6,4)
6-element Array{Int64,1}:
 1
 4
 5
 5
 6
 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L344-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.orbit-Tuple{Perm,Integer,Any}" href="#Gapjm.Groups.orbit-Tuple{Perm,Integer,Any}"><code>Gapjm.Groups.orbit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>orbit(a::Perm,i::Integer) returns the orbit of a on i</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L411-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.orbits-Tuple{Perm,Any}" href="#Gapjm.Groups.orbits-Tuple{Perm,Any}"><code>Gapjm.Groups.orbits</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>orbits(a::Perm,d::Vector=1:degree(a))</code> </p><p>returns the orbits of a on domain d</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; orbits(Perm(1,2)*Perm(4,5),1:5)
3-element Array{Array{Int16,1},1}:
 [1, 2]
 [3]
 [4, 5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L427-L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.order-Tuple{Perm}" href="#Gapjm.order-Tuple{Perm}"><code>Gapjm.order</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>order(a::Perm)</code> is the order of the permutation a</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L482-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.cycles" href="#Gapjm.Perms.cycles"><code>Gapjm.Perms.cycles</code></a> — <span class="docstring-category">Function</span></header><section><div><p>cycles(a::Perm) returns the non-trivial cycles of a</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cycles(Perm(1,2)*Perm(4,5))
2-element Array{Array{Int16,1},1}:
 [1, 2]
 [4, 5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L456-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.cycletype" href="#Gapjm.Perms.cycletype"><code>Gapjm.Perms.cycletype</code></a> — <span class="docstring-category">Function</span></header><section><div><p>cycletype(a::Perm) describes the partition of degree(a) associated to the   conjugacy class of a in the symmetric group, with ones removed. It is   represented as a Dict of cyclesize=&gt;multiplicity</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cycletype(Perm(1,2)*Perm(3,4))
1-element Array{Pair{Tuple{Int64,Int64},Int64},1}:
 (2, 1) =&gt; 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L487-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sign" href="#Base.sign"><code>Base.sign</code></a> — <span class="docstring-category">Function</span></header><section><div><p>sign(a::Perm) is the signature of  the permutation a</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Matrix-Tuple{Perm,Any}" href="#Base.Matrix-Tuple{Perm,Any}"><code>Base.Matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Matrix(a::Perm,n=degree(a))</code>  the  permutation  matrix  for  <code>a</code>  operating  on <code>n</code> points. If given, <code>n</code> should be larger than <code>largest_moved_point(a)</code>.</p><pre><code class="language-julia-repl">julia&gt; Matrix(Perm(2,3,4),5)
5×5 Array{Bool,2}:
 1  0  0  0  0
 0  0  1  0  0
 0  0  0  1  0
 0  1  0  0  0
 0  0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L262-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:^-Tuple{AbstractArray{T,2} where T,Perm}" href="#Base.:^-Tuple{AbstractArray{T,2} where T,Perm}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Base.:^(m::AbstractMatrix,p::Perm;dims=1)</p><p>Applies the permutation <code>p</code> on the lines, columns or both of the matrix <code>m</code> depending on the value of <code>dims</code></p><pre><code class="language-julia-repl">julia&gt; m=[3*i+j for i in 0:2,j in 1:3]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; p=Perm(1,2,3)
(1,2,3)

julia&gt; ^(m,p;dims=1)
3×3 Array{Int64,2}:
 7  8  9
 1  2  3
 4  5  6

julia&gt; ^(m,p;dims=2)
3×3 Array{Int64,2}:
 3  1  2
 6  4  5
 9  7  8

julia&gt; ^(m,p;dims=(1,2))
3×3 Array{Int64,2}:
 9  7  8
 3  1  2
 6  4  5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L367-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.restricted-Tuple{Perm,AbstractArray{#s5,1} where #s5&lt;:Integer}" href="#Gapjm.restricted-Tuple{Perm,AbstractArray{#s5,1} where #s5&lt;:Integer}"><code>Gapjm.restricted</code></a> — <span class="docstring-category">Method</span></header><section><div><p>restricted(a::Perm{T},l::AbstractVector{&lt;:Integer})</p><p>l should be a union of cycles of p; returns p restricted to l</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L540-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.reflength-Tuple{Perm}" href="#Gapjm.Perms.reflength-Tuple{Perm}"><code>Gapjm.Perms.reflength</code></a> — <span class="docstring-category">Method</span></header><section><div><p>reflength(a::Perm) minimum number of transpositions of which a is product</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L520">source</a></section></article><h1 id="Groups-1"><a class="docs-heading-anchor" href="#Groups-1">Groups</a><a class="docs-heading-anchor-permalink" href="#Groups-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups" href="#Gapjm.Groups"><code>Gapjm.Groups</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This module is a port of some GAP functionality on groups.</p><p>The only field of a Group G at the start is gens, the list of generators of G.  To  mimic  GAP  records  where  attributes/properties  of an object are computed  on demand when asked for, other attributes computed on demand are stored in the field .prop of the Group, which starts as Dict{Symbol,Any}()</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; G=Group([Perm(1,2),Perm(1,2,3)])
Group([perm&quot;(1,2)&quot;,perm&quot;(1,2,3)&quot;])

julia&gt; gens(G)
2-element Array{Perm{Int16},1}:
 (1,2)  
 (1,2,3)

julia&gt; nbgens(G)
2</code></pre><p>The group itself, applied to a sequence of integers, returns the element defined by the corresponding word in the generators</p><pre><code class="language-julia-repl">julia&gt; G(2,1,-2) # returns gens(G)[2]*gens(G)[1]*inv(gens(G)[2])
(1,3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Groups.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.orbit-Tuple{Array{T,1} where T,Any}" href="#Gapjm.Groups.orbit-Tuple{Array{T,1} where T,Any}"><code>Gapjm.Groups.orbit</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>orbit(gens::vector,p;action::Function=^)</code></p><p><code>orbit(G::Group,p;action::Function=^)</code></p><p>the  orbit of point  <code>p</code> under repeated  action of generators <code>gens</code>. Point <code>p</code>  should be hashable. The default action  of a group element is <code>^</code>. For example  if <code>g</code> is a permutation and <code>p</code>  an integer, <code>p^g</code> is the image of <code>p</code>  by <code>g</code>; if <code>h</code> and <code>g</code> are group elements, then <code>h^g</code> is the conjugate <code>inv(g)*h*g</code>.  If a group  is given instead  of generators, the orbit under <code>gens(G)</code> is returned.</p><pre><code class="language-julia-repl">julia&gt; orbit([Perm(1,2),Perm(2,3)],1) 
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; orbit([Perm(1,2),Perm(2,3)],[1,3];action=(v,g)-&gt;v.^g)
6-element Array{Array{Int64,1},1}:
 [1, 3]
 [2, 3]
 [1, 2]
 [3, 2]
 [2, 1]
 [3, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Groups.jl#L53-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.orbits-Tuple{Group,AbstractArray{T,1} where T}" href="#Gapjm.Groups.orbits-Tuple{Group,AbstractArray{T,1} where T}"><code>Gapjm.Groups.orbits</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>orbits(gens::Vector,v;action=^)</code></p><p><code>orbits(G,v;action=^)</code></p><p>the  orbits on <code>v</code> of reapted action  of <code>gens</code>; the elements of <code>v</code> should be  hashable. If a  group is given  instead of generators,  the orbit under <code>gens(G)</code> is returned.</p><pre><code class="language-julia-repl">julia&gt; G=Group([Perm(1,2),Perm(2,3)]);
julia&gt; orbits(G,1:4)
2-element Array{Array{Int64,1},1}:
 [1, 2, 3]
 [4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Groups.jl#L147-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.elements-Tuple{Group}" href="#Gapjm.elements-Tuple{Group}"><code>Gapjm.elements</code></a> — <span class="docstring-category">Method</span></header><section><div><p>elements(G::Group): the list of elements of G</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Groups.jl#L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.transversal" href="#Gapjm.Groups.transversal"><code>Gapjm.Groups.transversal</code></a> — <span class="docstring-category">Function</span></header><section><div><p>transversal(G::Group,p;action::Function=^)</p><p>returns  a Dict with entries x=&gt;g where x runs over orbit(G,p) and where g  is such that x=action(p,g)</p><pre><code class="language-julia-repl">julia&gt; G=Group([Perm(1,2),Perm(2,3)]);
julia&gt; transversal(G,1)
Dict{Int64,Perm{Int16}} with 3 entries:
  2 =&gt; (1,2)
  3 =&gt; (1,3,2)
  1 =&gt; ()</code></pre><p>orbit functions can take any action of G as keyword argument</p><pre><code class="language-julia-repl">julia&gt; transversal(G,[1,2],action=(x,y)-&gt;x.^y)
Dict{Array{Int64,1},Perm{Int16}} with 6 entries:
  [1, 3] =&gt; (2,3)
  [1, 2] =&gt; ()
  [2, 3] =&gt; (1,2,3)
  [3, 2] =&gt; (1,3)
  [2, 1] =&gt; (1,2)
  [3, 1] =&gt; (1,3,2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Groups.jl#L97-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.centralizer" href="#Gapjm.Groups.centralizer"><code>Gapjm.Groups.centralizer</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>centralizer(G,p;action=^)</code></p><p>computes the centralizer <code>C_G(p)</code></p><pre><code class="language-julia-repl">julia&gt; G=Group([Perm(1,2),Perm(1,2,3)]);
julia&gt; centralizer(G,1)
Group([perm&quot;(2,3)&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Groups.jl#L167-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.word-Tuple{Group,Any}" href="#Gapjm.word-Tuple{Group,Any}"><code>Gapjm.word</code></a> — <span class="docstring-category">Method</span></header><section><div><p>word(G::Group,w): a word in  gens(G) representing element w of G</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Groups.jl#L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{Group}" href="#Base.length-Tuple{Group}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p>length(G::Group): the number of elements of G</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Groups.jl#L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.class_reps-Tuple{Group}" href="#Gapjm.Groups.class_reps-Tuple{Group}"><code>Gapjm.Groups.class_reps</code></a> — <span class="docstring-category">Method</span></header><section><div><p>class_reps(G::Group): representatives of conjugacy classes of G</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Groups.jl#L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.minimal_words" href="#Gapjm.Groups.minimal_words"><code>Gapjm.Groups.minimal_words</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">`minimal_words(G)`</code></pre><p>returns a Dict giving for each element of <code>G</code> a minimal positive word in    the generators representing it.</p><pre><code class="language-julia-repl">julia&gt; G=Group([Perm(1,2),Perm(1,2,3)]);
julia&gt; minimal_words(G)
Dict{Perm{Int16},Array{Int64,1}} with 6 entries:
  ()      =&gt; Int64[]
  (2,3)   =&gt; [2, 1]
  (1,3,2) =&gt; [1, 2, 1]
  (1,3)   =&gt; [1, 2]
  (1,2)   =&gt; [1]
  (1,2,3) =&gt; [2]</code></pre><p>This Dict is stored in <code>G.prop[:words]</code> so it is computed only once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Groups.jl#L188-L205">source</a></section></article><h1 id="Permutation-groups-1"><a class="docs-heading-anchor" href="#Permutation-groups-1">Permutation groups</a><a class="docs-heading-anchor-permalink" href="#Permutation-groups-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups" href="#Gapjm.PermGroups"><code>Gapjm.PermGroups</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This module is a port of some GAP functionality on permutation groups.</p><p>This code refers to Holt &quot;Handbook of computational group theory&quot; chapter 4 for basic algorithms.</p><p>A  PermGroup is  a group  where gens  are Perms,  which allows  for all the algorithms like base, centralizer chain, etc...</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; G=Group([Perm(i,i+1) for i in 1:2])
Group([perm&quot;(1,2)&quot;,perm&quot;(2,3)&quot;])

# PermGroups are iterators over their elements
julia&gt; collect(G)  
6-element Array{Perm{Int16},1}:
 (1,2)
 (1,3,2)
 ()
 (1,2,3)
 (1,3)
 (2,3)

# maximum degree of an element of G
julia&gt; degree(G)  
3

julia&gt; Perm(1,2) in G
true

julia&gt; Perm(1,2,4) in G
false

# Elements,  appartenance test and  other function are  computed on G using
# Schreier-Sims theory, that is computing the following

# a list of points that no element of G fixes
julia&gt; base(G) 
2-element Array{Int16,1}:
 1
 2

# the i-th element is the centralizer of base[1:i-1]
julia&gt; centralizers(G) 
2-element Array{PermGroup{Int16},1}:
 Group([perm&quot;(1,2)&quot;,perm&quot;(2,3)&quot;])
 Group([perm&quot;(2,3)&quot;])

# i-th element is transversal of centralizer[i] on base[i]
julia&gt; transversals(G)
2-element Array{Dict{Int16,Perm{Int16}},1}:
 Dict(2 =&gt; (1,2),3 =&gt; (1,3,2),1 =&gt; ())
 Dict(2 =&gt; (),3 =&gt; (2,3))</code></pre><p>finally, benchmarks on julia 1.0.1</p><pre><code class="language-benchmark">julia&gt; @btime length(collect(symmetric_group(8)))
  5.481 ms (270429 allocations: 12.40 MiB)

julia&gt; @btime minimal_words(symmetric_group(8));
  10.477 ms (122062 allocations: 15.22 MiB)</code></pre><p>Compare to GAP3 Elements(SymmetricGroup(8)); takes 3.8 ms</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermGroups.jl#L1-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups.base" href="#Gapjm.PermGroups.base"><code>Gapjm.PermGroups.base</code></a> — <span class="docstring-category">Function</span></header><section><div><p>A list of points stabilized by no element of G </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermGroups.jl#L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups.centralizers" href="#Gapjm.PermGroups.centralizers"><code>Gapjm.PermGroups.centralizers</code></a> — <span class="docstring-category">Function</span></header><section><div><p>centralizers: the i-th element is the centralizer of base[1:i-1]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermGroups.jl#L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups.transversals" href="#Gapjm.PermGroups.transversals"><code>Gapjm.PermGroups.transversals</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The  i-th element  is  a description of  the orbit of :centralizers[i] on   :base[i]  as a Dict where each point q is the key to a permutation p such   that :base[i]^p=q</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermGroups.jl#L200-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups.symmetric_group" href="#Gapjm.PermGroups.symmetric_group"><code>Gapjm.PermGroups.symmetric_group</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The symmetric group of degree n </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermGroups.jl#L114">source</a></section></article><h1 id="Cyclotomic-numbers-1"><a class="docs-heading-anchor" href="#Cyclotomic-numbers-1">Cyclotomic numbers</a><a class="docs-heading-anchor-permalink" href="#Cyclotomic-numbers-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Cycs" href="#Gapjm.Cycs"><code>Gapjm.Cycs</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Cyclotomic  numbers means complex numbers which are sums of rationals times roots of unity.</p><p>They  are a very important feature of GAP, since character values of finite groups are cyclotomics.</p><p>They  have a normal form given by writing them in the Zumbroich basis. This form  allows to find  the smallest Cyclotomic  field which contains a given number,   and  decide   in  particular   if  a   cyclotomic  is  zero.  Let ζₙ=exp(2iπ/n). The Zumbroich basis of ℚ (ζₙ) is a particular subset of size φ(n) of 1,ζₙ,ζₙ²,…,ζₙⁿ⁻¹ which forms a basis of ℚ (ζₙ).</p><p>I  started  this  file  by  porting  Christian  Stump&#39;s Sage code, which is simpler to understand than GAP&#39;s code. The reference for the algorithms is</p><p>T. Breuer, Integral bases for subfields of cyclotomic fields AAECC 8 (1997)</p><p>As  does GAP,  I lower  automatically numbers  after each computation; this makes  this  code  about  50%  slower  than  GAP since lower is not as much optimized.  GAP also converts a Cyclotomic which is rational to a Rational, a  Rational which is integral to an Int, a BigInt which is small to a small Int,  etc... This is tremendously useful but  needs a new type of number to be added to Julia, which I am not competent enough to try.</p><p>The main way to build a Cyclotomic number is to use the function <code>E(n,k=1)</code> which constructs ζₙᵏ.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; E(3)+E(4)
Cyc{Int64}: ζ₁₂⁴-ζ₁₂⁷-ζ₁₂¹¹

julia&gt; E(3,2)
Cyc{Int64}: ζ₃²

julia&gt; 1+E(3,2)
Cyc{Int64}: -ζ₃

julia&gt; a=E(4)-E(4)
Cyc{Int64}: 0

julia&gt; conductor(a) # a is lowered to ℚ (ζ_1)=ℚ 
1

julia&gt; typeof(convert(Int,a))
Int64

julia&gt; convert(Int,E(4))
ERROR: InexactError: convert(Int64, E(4))

julia&gt; c=inv(1+E(4)) # inverses need Rationals
Cyc{Rational{Int64}}: 1/2-ζ₄/2

julia&gt; typeof(c)
Cyc{Rational{Int64}}

julia&gt; typeof(1+E(4))
Cyc{Int64}

julia&gt; Cyc(1+im) # one can convert Gaussian integers or rationals
Cyc{Int64}: 1+ζ₄

julia&gt; 1//(1+E(4))
Cyc{Rational{Int64}}: 1/2-ζ₄/2

julia&gt; typeof(Cyc(1//2)) # another way of building a Cyc
Cyc{Rational{Int64}}

julia&gt; conj(1+E(4))
Cyc{Int64}: 1-ζ₄

julia&gt; c=E(9)   # an effect of the Zumbroich basis
Cyc{Int64}: -ζ₉⁴-ζ₉⁷

julia&gt; Root1(c) # but you can decide whether a Cyc is a root of unity
Root1: ζ₉

julia&gt; c=Complex(E(3))   # convert to float is probably not very useful
-0.4999999999999998 + 0.8660254037844387im</code></pre><p><code>Cyc</code>s have methods <code>copy, hash, ==, cmp, isless</code> (total order) so they can be keys in hashes or elements of sets.</p><p>For more information see the methods ER, Quadratic, galois. </p><p>Finally, a benchmark:</p><pre><code class="language-benchmark">julia&gt; function testmat(p) 
         ss=[[i,j] for i in 0:p-1 for j in i+1:p-1]
         [(E(p,i&#39;*reverse(j))-E(p,i&#39;*j))//p for i in ss,j in ss]
       end
testmat (generic function with 1 method)

julia&gt; @btime testmat(12)^2;
  459.521 ms (9640239 allocations: 554.47 MiB)</code></pre><p>The equivalent in GAP:</p><pre><code class="language-none">testmat:=function(p)local ss;ss:=Combinations([0..p-1],2);
  return List(ss,i-&gt;List(ss,j-&gt;(E(p)^(i*Reversed(j))-E(p)^(i*j))/p));
end; </code></pre><p>testmat(12)^2 takes 0.4s in GAP3, 0.3s in GAP4</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Cycs.jl#L1-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Cycs.galois" href="#Gapjm.Cycs.galois"><code>Gapjm.Cycs.galois</code></a> — <span class="docstring-category">Function</span></header><section><div><p>galois(c::Cyc,n::Int) applies to c the galois automorphism   of Q(ζ_conductor(c)) raising all roots of unity to the n-th power.   n should be prime to c.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; galois(1+E(4),-1) # galois(c,-1) is the same as conj(c)
Cyc{Int64}: 1-ζ₄

julia&gt; galois(ER(5),2)==-ER(5)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Cycs.jl#L576-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Cycs.ER" href="#Gapjm.Cycs.ER"><code>Gapjm.Cycs.ER</code></a> — <span class="docstring-category">Function</span></header><section><div><p>ER(n::Int) computes as a Cyc the square root of the integer n.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ER(-1)
Cyc{Int64}: ζ₄

julia&gt; ER(3)
Cyc{Int64}: √3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Cycs.jl#L622-L632">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Cycs.Quadratic" href="#Gapjm.Cycs.Quadratic"><code>Gapjm.Cycs.Quadratic</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Quadratic(c::Cyc)</code> </p><p>determines  if <code>c</code> lives  in a quadratic  extension of <code>ℚ</code>.  It returns a   <code>Quadratic</code>  object representing <code>c</code> as <code>(a  + b ER(root))//d</code> or nothing   if no such tuple exists</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Quadratic(1+E(3))
(1+√-3)/2

julia&gt; Quadratic(1+E(5))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Cycs.jl#L781-L796">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Cycs.Root1" href="#Gapjm.Cycs.Root1"><code>Gapjm.Cycs.Root1</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Root1(c)</code></p><p><code>c</code> should be a cyclotomic number (a <code>Cyc</code>), or a <code>Real</code>. <code>Root1</code> returns a <code>Root1</code> object containing the rational <code>e/n</code> with <code>0≤e&lt;n</code> (that is, <code>e/n∈ ℚ /ℤ</code>) if <code>c==E(n,e)</code>, and <code>nothing</code> if <code>c</code> is not a root of unity.</p><pre><code class="language-julia-repl">julia&gt; r=Root1(-E(9,2)-E(9,5))
Root1: ζ₉⁸

julia&gt; E(r)
Cyc{Int64}: -ζ₉²-ζ₉⁵

julia&gt; Root1(-E(9,4)-E(9,5))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Cycs.jl#L705-L721">source</a></section></article><h1 id="Univariate-Laurent-polynomials-1"><a class="docs-heading-anchor" href="#Univariate-Laurent-polynomials-1">Univariate Laurent polynomials</a><a class="docs-heading-anchor-permalink" href="#Univariate-Laurent-polynomials-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Pols" href="#Gapjm.Pols"><code>Gapjm.Pols</code></a> — <span class="docstring-category">Module</span></header><section><div><p>An implementation of univariate Laurent polynomials.  A Pol contains two fields: its vector of coefficients, and its valuation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Pol(:q) # define string used for printing and set variable q
Pol{Int64}: q

julia&gt; Pol([1,2],0) # coefficients should have no leading or trailing zeroes.
Pol{Int64}: 2q+1

julia&gt; p=Pol([1,2],-1)
Pol{Int64}: 2+q⁻¹

julia&gt; valuation(p)
-1

julia&gt; p=(q+1)^2
Pol{Int64}: q²+2q+1

julia&gt; degree(p)
2

julia&gt; p(1//2) # a Pol is a callable object, where the call evaluates the Pol
9//4

julia&gt; p[0], p[1], p[-1] # indexing gives the coefficients
(1, 2, 0)

julia&gt; divrem(q^3+1,q+2) # changes coefficients to field elements
(1.0q²-2.0q+4.0, -7.0)

julia&gt; divrem1(q^3+1,q+2) # keeps the ring, but needs leading coeff divides
(q²-2q+4, -7)

julia&gt; cyclotomic_polynomial(24) # the 24-th cyclotomic polynomial
Pol{Int64}: q⁸-q⁴+1
</code></pre><p>see also the individual documentation of divrem, divrem1, gcd.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Pols.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.divrem" href="#Base.divrem"><code>Base.divrem</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>divrem(a::Pol, b::Pol)</code></p><p>computes <code>(p,q)</code> such that <code>a=p*b+q</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Pols.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Pols.divrem1" href="#Gapjm.Pols.divrem1"><code>Gapjm.Pols.divrem1</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>divrem1(a::Pol, b::Pol)</code></p><p><code>divrem</code> when the leading coefficiant of <code>b</code> divides that of <code>a</code>:  does not change type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Pols.jl#L264-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.gcd" href="#Base.gcd"><code>Base.gcd</code></a> — <span class="docstring-category">Function</span></header><section><div><p>gcd(p::Pol, q::Pol) the  coefficients of  p and  q must  be elements  of a  field for gcd to be type-stable</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; gcd(q+1,q^2-1)
Pol{Float64}: 1.0q+1.0

julia&gt; gcd(q+1//1,q^2-1//1)
Pol{Rational{Int64}}: (1//1)q+1//1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Pols.jl#L302-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Pols.cyclotomic_polynomial" href="#Gapjm.Pols.cyclotomic_polynomial"><code>Gapjm.Pols.cyclotomic_polynomial</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>cyclotomic_polynomial(n)</code></p><p>returns the <code>n</code>-th cyclotomic polynomial.</p><pre><code class="language-julia-repl">julia&gt; cyclotomic_polynomial(5)
Pol{Int64}: q⁴+q³+q²+q+1</code></pre><p>The  computed  cyclotomic  polynomials  are  cached  in  the global <code>Dict ̀</code>Pols.cyclotomic<em>polynomial</em>dict`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Pols.jl#L335-L347">source</a></section></article><h1 id="Multivariate-Laurent-polynomials-1"><a class="docs-heading-anchor" href="#Multivariate-Laurent-polynomials-1">Multivariate Laurent polynomials</a><a class="docs-heading-anchor-permalink" href="#Multivariate-Laurent-polynomials-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Mvps" href="#Gapjm.Mvps"><code>Gapjm.Mvps</code></a> — <span class="docstring-category">Module</span></header><section><div><p>What   is  implemented  here  is  &quot;Puiseux  polynomials&quot;,  that  is  linear combinations  of monomials  of the  type <code>x₁^{a₁}…  xₙ^{aₙ}</code> where <code>xᵢ</code> are variables  and <code>aᵢ</code> are exponents which  can be arbitrary rational numbers. Some  functions  described  below  need  their  argument  to  involve  only variables  to integral  powers; we  will refer  to such objects as &quot;Laurent polynomials&quot;; some functions require further that variables are raised only to positive powers: we refer then to &quot;true polynomials&quot;.</p><p><code>@Mvp x₁,…,xₙ</code></p><p>declares   that  <code>xᵢ</code>are  indeterminates  suitable  to  build  multivariate polynomials.</p><pre><code class="language-julia-repl">julia&gt; @Mvp x,y

julia&gt; (x+y)^3
Mvp{Int64}: x³+3x²y+3xy²+y³</code></pre><p><code>Mvp(p)</code> converts  the <code>Pol</code>  <code>p</code> to  an  <code>Mvp</code>. </p><pre><code class="language-julia-repl">julia&gt; Pol(:q)
Pol{Int64}: q

julia&gt; Mvp(q^2+q)
Mvp{Int64}: q²+q</code></pre><p><code>Mvp(x::Number)</code>   returns  the  constant   multivariate  polynomial  whose constant term is <code>x</code>.</p><pre><code class="language-julia-repl">julia&gt; degree(Mvp(1))
0</code></pre><p>One can divide an <code>Mvp</code> by another when the division is exact (this is equivalent to <code>ExactDiv</code>, see below).</p><pre><code class="language-julia-repl">julia&gt; (x^2-y^2)//(x-y)
Mvp{Int64}: x+y</code></pre><p>Only monomials can be raised to a non-integral power; they can be raised to  a fractional  power of  denominator  &#39;b&#39; only  if &#39;GetRoot(x,b)&#39;  is defined  where &#39;x&#39;  is  their  leading coefficient.  For  an &#39;Mvp&#39;  &lt;m&gt;, the  function  &#39;GetRoot(m,n)&#39; is  equivalent  to  &#39;m^(1/n)&#39;. Raising  a non-monomial Laurent polynomial  to a negative power  returns a rational fraction.</p><p>|    gap&gt; (2<em>x)^(1/2);     ER(2)x^(1/2)     gap&gt; (evalf(2)</em>x)^(1/2);     1.4142135624x^(1/2)     gap&gt; GetRoot(evalf(2)*x,2);     1.4142135624x^(1/2)|</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Mvps.jl#L1-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Mvps.Mvp" href="#Gapjm.Mvps.Mvp"><code>Gapjm.Mvps.Mvp</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Value of an <code>Mvp</code></p><pre><code class="language-julia-repl">julia&gt; p=-2+7x^5*inv(y)
Mvp{Int64}: 7x⁵y⁻¹-2

julia&gt; p(x=2)
Mvp{Int64}: -2+224y⁻¹

julia&gt; p(y=1)
Mvp{Int64}: 7x⁵-2

julia&gt; p(x=2,y=1)
Mvp{Int64}: 222</code></pre><p>One should pay attention to the fact that the last value is not an integer, but  a constant <code>Mvp</code>  (for consistency). See  the function &#39;scal&#39; below for how to convert such constants to their base ring.</p><pre><code class="language-julia-repl">julia&gt; p(x=y)
Mvp{Int64}: 7y⁴-2

julia&gt; p(x=y,y=x)
Mvp{Int64}: 7x⁴-2</code></pre><pre><code class="language-none">gap&gt; Value(p,[&quot;x&quot;,y,&quot;y&quot;,x]);
-2+7x^-1y^5|</code></pre><p>Evaluating an  &#39;Mvp&#39; which is  a Puiseux  polynomial may cause  calls to &#39;GetRoot&#39;</p><p>|    gap&gt; p:=x^(1/2)*y^(1/3);     x^(1/2)y^(1/3)     gap&gt; Value(p,[&quot;x&quot;,y]);     y^(5/6)     gap&gt;  Value(p,[&quot;x&quot;,2]);     ER(2)y^(1/3)     gap&gt;  Value(p,[&quot;y&quot;,2]);     Error, : unable to compute 3-th root of 2      in     GetRoot( values[i], d[i] ) called from     f.operations.Value( f, x ) called from     Value( p, [ &quot;y&quot;, 2 ] ) called from     main loop     brk&gt;|</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Mvps.jl#L482-L530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Mvps.variables" href="#Gapjm.Mvps.variables"><code>Gapjm.Mvps.variables</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>variables(p::Mvp)</code></p><p>returns the list of variables of <code>p</code> as a sorted list of <code>Symbol</code>s.</p><pre><code class="language-julia-repl">julia&gt; variables(x+x^4+y)
2-element Array{Symbol,1}:
 :x
 :y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Mvps.jl#L397-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.coefficients" href="#Gapjm.coefficients"><code>Gapjm.coefficients</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>coefficients(p::Mvp, var::Symbol)</code> </p><p>returns as a Dict the list of coefficients of <code>p</code> with respect to <code>var</code>.</p><pre><code class="language-julia-repl">julia&gt; p=(x+y+inv(y))^4
Mvp{Int64}: x⁴+4x³y+4x³y⁻¹+6x²y²+12x²+6x²y⁻²+4xy³+12xy+12xy⁻¹+4xy⁻³+y⁴+4y²+6+4y⁻²+y⁻⁴

julia&gt; coefficients(p,:x)
Dict{Int64,Mvp{Int64}} with 5 entries:
  0 =&gt; y⁴+4y²+6+4y⁻²+y⁻⁴
  4 =&gt; 1
  2 =&gt; 6y²+12+6y⁻²
  3 =&gt; 4y+4y⁻¹
  1 =&gt; 4y³+12y+12y⁻¹+4y⁻³

julia&gt; coefficients(p,:y)
Dict{Int64,Mvp{Int64}} with 9 entries:
  0  =&gt; x⁴+12x²+6
  4  =&gt; 1
  -4 =&gt; 1
  -3 =&gt; 4x
  2  =&gt; 6x²+4
  -2 =&gt; 6x²+4
  -1 =&gt; 4x³+12x
  3  =&gt; 4x
  1  =&gt; 4x³+12x</code></pre><p>The  same caveat is  applicable to <code>coefficients</code>  as to values: the values are  always <code>Mvp</code>s.  To get  a list  of scalars  for univariate polynomials represented as <code>Mvp</code>s, one should use <code>scal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Mvps.jl#L347-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.valuation" href="#Gapjm.valuation"><code>Gapjm.valuation</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The <code>valuation</code> of an <code>Mvp</code> is the minimal degree of a monomial.</p><pre><code class="language-julia-repl">julia&gt; a=x^2+x*y
Mvp{Int64}: x²+xy

julia&gt; valuation(a)
2</code></pre><p>With  second argument a variable name, <code>valuation</code> returns the valuation of the polynomial in that variable.</p><pre><code class="language-julia-repl">julia&gt; valuation(a,:y)
0

julia&gt; valuation(a,:x)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Mvps.jl#L320-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.degree" href="#Gapjm.degree"><code>Gapjm.degree</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The <code>degree</code> of a monomial is the sum of  the exponent of the variables. The <code>degree</code> of an <code>Mvp</code> is the largest degree of a monomial.</p><pre><code class="language-julia-repl">julia&gt; a=x^2+x*y
Mvp{Int64}: x²+xy

julia&gt; degree(a)
2</code></pre><p>With  second argument a  variable name, <code>degree</code>  returns the degree of the polynomial in that variable.</p><pre><code class="language-julia-repl">julia&gt; degree(a,:y)
1

julia&gt; degree(a,:x)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Mvps.jl#L293-L316">source</a></section></article><h1 id="Coxeter-groups-1"><a class="docs-heading-anchor" href="#Coxeter-groups-1">Coxeter groups</a><a class="docs-heading-anchor-permalink" href="#Coxeter-groups-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups" href="#Gapjm.CoxGroups"><code>Gapjm.CoxGroups</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A  suitable  reference  for  the  general  theory of Coxeter groups is, for example, Bourbaki &quot;Lie Groups and Lie Algebras&quot; chapter 4.</p><p>A <em>Coxeter group</em> is a group which has the presentation <code>W=⟨S|(st)^m(s,t)=1</code>  for  <code>s,t∈  S⟩</code>  for  some  symmetric  integer matrix <code>m(s,t)</code>  called  the  <em>Coxeter  matrix</em>,  where  <code>m(s,t)&gt;1</code>  for <code>s≠t</code> and <code>m(s,s)=1</code>.  It is true (but a non-trivial theorem) that in a Coxeter group the  order of <code>st</code> is exactly <code>m(s,t)</code>, thus a Coxeter group is the same as a  <em>Coxeter system</em>, that is a pair <code>(W,S)</code> of a group <code>W</code> and a set <code>S</code> of involutions,  such that the group is  presented by relations describing the order  of the product of two elements of <code>S</code>. A Coxeter group has a natural representation, its <em>reflection representation</em>, on a real vector space <code>V</code> of  dimension <code>length(S)</code> (the <em>Coxeter rank</em>  of W), where each element of <code>S</code>  acts as a  reflection; the faithfulness  of this representation in the main  argument to prove  that the order  of <code>st</code> is  exactly <code>m(s,t)</code>. Thus Coxeter groups are real reflection groups. The converse need not be true if the  set of reflecting  hyperplanes has bad  topological properties, but it turns out that finite Coxeter groups are the same as finite real reflection groups.  The possible Coxeter matrices for  finite Coxeter groups have been completely  classified; the corresponding finite groups play a deep role in several areas of mathematics.</p><p>Coxeter  groups  have  a  nice  solution  to the word problem. The <em>length</em> <code>l(w)</code>  of an element  <code>w∈ W</code> is  the minimum number  of elements of <code>S</code> of which it is a product (since the elements of <code>S</code> are involutions, we do not need inverses). An expression of <code>w</code> of minimal length is called a <em>reduced word</em>  for <code>w</code>. The main property of  reduced words is the <em>exchange lemma</em> which  states that if <code>s₁…sₖ</code> is a  reduced word for <code>w</code> (thus<code>k=l(w)</code>) and <code>s∈  S</code> is such that <code>l(sw)≤l(w)</code> then one  of the <code>sᵢ</code> in the word for <code>w</code> can be deleted to obtain a reduced word for <code>sw</code>. Thus given <code>s∈ S</code> and <code>w∈ W</code>,  either <code>l(sw)=l(w)+1</code> or  <code>l(sw)=l(w)-1</code> and we  say in this last case that  <code>s</code> belongs to  the <em>left descent  set</em> of <code>w</code>.  The computation of a reduced word for an element, and other word problems, are easily done if we know  the left descent sets. For the Coxeter groups that we implement, this left  descent set  can be  easily determined  (see e.g. &#39;CoxSym&#39; below), so this suggests how to deal with Coxeter groups.</p><p>The type <code>CoxeterGroup</code> is an abstact type; an actual struct which implements it must define a function</p><p><code>isleftdescent(W,w,i)</code> which tells whether the       <code>i</code>-th element of <code>S</code> is in the left descending set of <code>w</code>.</p><p>the other functions needed in an instance of a Coxeter group are</p><ul><li><code>gens(W)</code> which returns the set <code>S</code> (the list of <em>Coxeter generators</em>)</li><li><code>nref(W)</code> which  returns the  number of  reflections of  <code>W</code>, if  <code>W</code> is  finite or <code>nothing</code> if <code>W</code> is infinite</li></ul><p>It  should be  noted that  a Coxeter group can be <em>any</em> kind of group implementing the above functions.</p><p>A  common occurrence in code for Coxeter groups is a loop like:</p><p><code>findfirst(x-&gt;isleftdescent(W,w,x),eachindex(gens(W)))</code></p><p>if you provide a function <code>firstleftdescent(W,w)</code> it will be called instead of the above loop.</p><p>Because  of the  easy solution  of the  word problem  in Coxeter  groups, a convenient  way  to  represent  their  elements  is as words in the Coxeter generators.  They are represented as lists of labels for the generators. By default  these labels are  given as the  index of a  generator in <code>S</code>, so a Coxeter  word is just  a list of  integers in <code>1:length(S)</code>. For reflection subgroups, the labels are indices of the reflections in the parent group.</p><p>The functions &#39;word&#39; and &#39;W(...)&#39; will do the conversion between Coxeter words and elements of the group.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; W=CoxSym(4)
𝔖 ₄

julia&gt; p=W(1,3,2,1,3)
Perm{UInt8}: (1,4)

julia&gt; word(W,p)
5-element Array{Int64,1}:
 1
 2
 3
 2
 1
</code></pre><p>We  notice that the word we started with and the one that we ended up with, are not the same, though they represent the same element of <code>W</code>. The reason is  that the function &#39;word&#39; computes a lexicographically smallest word for <code>w</code>.  Below  are  some  other  possible  computations with the same Coxeter group:</p><pre><code class="language-julia-repl">julia&gt; word(W,longest(W))  # the (unique) longest element in W
6-element Array{Int64,1}:
 1
 2
 1
 3
 2
 1

julia&gt; w0=longest(W)
Perm{UInt8}: (1,4)(2,3)
julia&gt; length(W,w0)
6
julia&gt; map(i-&gt;word(W,reflection(W,i)),1:nref(W))
6-element Array{Array{Int64,1},1}:
 [1]
 [2]
 [3]
 [1, 2, 1]
 [2, 3, 2]
 [1, 2, 3, 2, 1]
julia&gt; [length(elements(W,i)) for i in 0:nref(W)]
7-element Array{Int64,1}:
 1
 3
 5
 6
 5
 3
 1
</code></pre><p>The above line tells us that there is 1 element of length 0, there are 6 of length 3, …</p><p>For  most basic functions the convention is that the input is an element of the  group, rather than  a Coxeter word.  The reason is  that for a Coxeter group  which  is  a  permutation  group,  using the low level functions for permutations  is usually  much faster  than manipulating lists representing reduced expressions.</p><p>This  file contains mostly a port of  the basic functions on Coxeter groups in  Chevie. The only Coxeter group  constructor implemented here is CoxSym. The file Weyl.jl defines coxgroup.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L1-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.isleftdescent" href="#Gapjm.CoxGroups.isleftdescent"><code>Gapjm.CoxGroups.isleftdescent</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>isleftdescent(W,w,i)</code></p><p>returns  <code>true</code>  if  and  only  if  the <code>i</code>-th generating reflection of the Coxeter  group <code>W</code> is  in the left  descent set of  the element <code>w</code> of <code>W</code>, that is iff <code>length(W,W(i)*w)&lt;length(W,w)</code>.</p><pre><code class="language-julia-repl">julia&gt; W=CoxSym(3)
𝔖 ₃

julia&gt; isleftdescent(W,Perm(1,2),1)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L782-L796">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.firstleftdescent" href="#Gapjm.CoxGroups.firstleftdescent"><code>Gapjm.CoxGroups.firstleftdescent</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>firstleftdescent(W,w)</code></p><p>returns the index in <code>gens(W)</code> of the first element of the left descent set of <code>w</code> –- that is, the first <code>i</code> such that if <code>s=W(i)</code> then `l(sw)&lt;l(w).</p><pre><code class="language-julia-repl">julia&gt; W=CoxSym(3)
𝔖 ₃

julia&gt; firstleftdescent(W,Perm(2,3))
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L151-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.leftdescents" href="#Gapjm.CoxGroups.leftdescents"><code>Gapjm.CoxGroups.leftdescents</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>leftdescents(W,w)</code></p><p>The  left descents of the element <code>w</code> of the Coxeter group <code>W</code>, that is the set of <code>i</code> such that <code>length(W,W(i)*w)&lt;length(W,w)</code>.</p><pre><code class="language-julia-repl">julia&gt; W=CoxSym(3)
𝔖 ₃

julia&gt; leftdescents(W,Perm(1,3))
2-element Array{Int64,1}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L169-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermGroups.reduced" href="#Gapjm.PermGroups.reduced"><code>Gapjm.PermGroups.reduced</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reduced(W,w)</code></p><p>The unique element in the coset W.w which stabilises the positive roots of W</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; H=reflection_subgroup(W,[2,6])
G₂₍₂₆₎=Ã₁×A₁

julia&gt; word.(Ref(W),Set(reduced.(Ref(H),elements(W))))
3-element Array{Array{Int64,1},1}:
 []
 [1, 2]
 [1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L294-L311">source</a></section><section><div><p><code>reduced(H,W)</code></p><p>The elements in W which are H-reduced</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; H=reflection_subgroup(W,[2,6])
G₂₍₂₆₎=Ã₁×A₁

julia&gt; [word(W,w) for S in reduced(H,W) for w in S]
3-element Array{Array{Int64,1},1}:
 []
 [1]
 [1, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L320-L337">source</a></section><section><div><p>reduced(H,W,S)   The elements in W which are H-reduced of length i from the set S of length i-1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L349-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.word-Tuple{CoxeterGroup,Any}" href="#Gapjm.word-Tuple{CoxeterGroup,Any}"><code>Gapjm.word</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>word(W::CoxeterGroup,w)</code></p><p>returns  a reduced word in the standard generators of the Coxeter group <code>W</code> for  the  element  <code>w</code>  (represented  as  the  vector  of the corresponding generator indices).</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; w=perm&quot;(1,11)(3,10)(4,9)(5,7)(6,12)&quot;
(1,11)(3,10)(4,9)(5,7)(6,12)

julia&gt; w in W
true

julia&gt; word(W,w)
5-element Array{Int64,1}:
 1
 2
 3
 2
 1</code></pre><p>The  result  of   <code>word</code>  is  the  lexicographically  smallest reduced word for~<code>w</code> (for the ordering of the Coxeter generators given by <code>gens(W)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L191-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{CoxeterGroup,Any}" href="#Base.length-Tuple{CoxeterGroup,Any}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>length(W::CoxeterGroup ,w)</code></p><p>returns the length of a reduced expression in the Coxeter generators of the element <code>w</code> of <code>W</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:F,4)
F₄

julia&gt; p=W(1,2,3,4,2)
(1,44,38,25,20,14)(2,5,40,47,48,35)(3,7,13,21,19,15)(4,6,12,28,30,36)(8,34,41,32,10,17)(9,18)(11,26,29,16,23,24)(27,31,37,45,43,39)(33,42)

julia&gt; length(W,p)
5

julia&gt; word(W,p)
5-element Array{Int64,1}:
 1
 2
 3
 2
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L229-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.elements-Tuple{CoxeterGroup}" href="#Gapjm.elements-Tuple{CoxeterGroup}"><code>Gapjm.elements</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>elements(W::CoxeterGroup[,l])</code></p><p>With  one argument this works only if  <code>W</code> is finite; the returned elements are  sorted  by  increasing  Coxeter  length.  If the second argument is an integer  <code>l</code>, the elements  of Coxeter length  <code>l</code> are returned.</p><pre><code class="language-julia_repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; e=elements(W,6)
1-element Array{Perm{Int16},1}:
 (1,7)(2,8)(3,9)(4,10)(5,11)(6,12)

julia&gt; e[1]==longest(W)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L366-L384">source</a></section><section><div><p>elements(G::Group): the list of elements of G</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Groups.jl#L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.words-Tuple{CoxeterGroup}" href="#Gapjm.words-Tuple{CoxeterGroup}"><code>Gapjm.words</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>words(W::CoxeterGroup[,l])</code></p><p>With  one argument this works only if <code>W</code> is finite; it returns the reduced Coxeter  words  of  elements  of  <code>W</code>  by  increasing length. If the second argument  is an integer <code>l</code>, only the  elements of length <code>l</code> are returned; this works for infinite Coxeter groups.</p><pre><code class="language-julia_repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; e=elements(W,6)
1-element Array{Perm{Int16},1}:
 (1,7)(2,8)(3,9)(4,10)(5,11)(6,12)

julia&gt; e[1]==longest(W)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L439-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.bruhatless" href="#Gapjm.CoxGroups.bruhatless"><code>Gapjm.CoxGroups.bruhatless</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>bruhatless(W, x, y)</code></p><p>whether <code>x≤y</code> in the Bruhat order, for <code>x,y∈ W</code>. We have <code>x≤y</code> if a reduced expression  for <code>x</code> can be extracted from  one for <code>w</code>). See cite[(5.9) and (5.10)]{Hum90} for properties of the Bruhat order.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:H,3)
H₃

julia&gt; w=W(1,2,1,3);

julia&gt; b=filter(x-&gt;bruhatless(W,x,w),elements(W));

julia&gt; word.(Ref(W),b)
12-element Array{Array{Int64,1},1}:
 []
 [3]
 [2]
 [1]
 [2, 3]
 [1, 3]
 [2, 1]
 [1, 2]
 [2, 1, 3]
 [1, 2, 3]
 [1, 2, 1]
 [1, 2, 1, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L463-L493">source</a></section><section><div><p><code>bruhatless(W, y)</code></p><p>returns  a vector  whose <code>i</code>-th  element is  the vector  of elements of <code>W</code> smaller for the Bruhat order than <code>w</code> and of Coxeter length <code>i-1</code>. Thus the first  element  of  the  returned  list  contains  only  <code>one(W)</code>  and  the <code>length(W,w)</code>-th element contains only <code>w</code>.</p><pre><code class="language-julia-repl">julia&gt; W=CoxSym(3)
𝔖 ₃

julia&gt; bruhatless(W,Perm(1,3))
4-element Array{Array{Perm{UInt8},1},1}:
 [()]
 [(1,2), (2,3)]
 [(1,2,3), (1,3,2)]
 [(1,3)]</code></pre><p>see also the method <code>Poset</code> for Coxeter groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L510-L531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.CoxSym" href="#Gapjm.CoxGroups.CoxSym"><code>Gapjm.CoxGroups.CoxSym</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Coxsym(n)</code> The symmetric group on <code>n</code> letters as a Coxeter group</p><pre><code class="language-julia-repl">julia&gt; W=CoxSym(3)
𝔖 ₃

julia&gt; e=elements(W)
6-element Array{Perm{UInt8},1}:
 ()     
 (2,3)  
 (1,2)  
 (1,2,3)
 (1,3,2)
 (1,3)  

julia&gt; length.(Ref(W),e)
6-element Array{Int64,1}:
 0
 1
 1
 2
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L730-L754">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection_subgroup-Tuple{CoxSym,AbstractArray{Int64,1}}" href="#Gapjm.PermRoot.reflection_subgroup-Tuple{CoxSym,AbstractArray{Int64,1}}"><code>Gapjm.PermRoot.reflection_subgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflection_subgroup(W::CoxSym,I)</code></p><p>Only parabolics defined are <code>I=1:m</code> for <code>m≤n</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L820-L824">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.longest" href="#Gapjm.CoxGroups.longest"><code>Gapjm.CoxGroups.longest</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>longest(W)</code></p><p>If  <code>W</code> is  finite, returns  the unique  element of  maximal length  of the Coxeter group <code>W</code>. May loop infinitely otherwise.</p><pre><code class="language-julia-repl">julia&gt; longest(CoxSym(4))
Perm{UInt8}: (1,4)(2,3)</code></pre><p><code>longest(W,I)</code></p><p>returns  the longest element of the  parabolic subgroup of <code>W</code> generated by the generating reflections of indices in <code>I</code>.</p><pre><code class="language-julia-repl">julia&gt; longest(CoxSym(4))
Perm{UInt8}: (1,4)(2,3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L261-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.nref" href="#Gapjm.CoxGroups.nref"><code>Gapjm.CoxGroups.nref</code></a> — <span class="docstring-category">Function</span></header><section><div><p>number of reflections of W</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L650">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.braid_relations" href="#Gapjm.CoxGroups.braid_relations"><code>Gapjm.CoxGroups.braid_relations</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>braid_relations(W)</code></p><p>this  function returns the  relations which present  the braid group of the reflection group <code>W</code>. These are homogeneous (both sides of the same length) relations  between generators in bijection  with the generating reflections of  <code>W</code>. A presentation  of <code>W</code> is  obtained by adding relations specifying the order of the generators.</p><pre><code class="language-julia-repl">julia&gt; W=ComplexReflectionGroup(29)
G₂₉

julia&gt; braid_relations(W)
7-element Array{Array{Array{Int64,1},1},1}:
 [[1, 2, 1], [2, 1, 2]]
 [[2, 4, 2], [4, 2, 4]]
 [[3, 4, 3], [4, 3, 4]]
 [[2, 3, 2, 3], [3, 2, 3, 2]]
 [[1, 3], [3, 1]]
 [[1, 4], [4, 1]]
 [[4, 3, 2, 4, 3, 2], [3, 2, 4, 3, 2, 4]]</code></pre><p>each  relation  is  represented  as  a  pair  of lists, specifying that the product  of the  generators according  to the  indices on  the left side is equal  to the product according to the  indices on the right side. See also <code>Diagram</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L680-L708">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.coxmat" href="#Gapjm.CoxGroups.coxmat"><code>Gapjm.CoxGroups.coxmat</code></a> — <span class="docstring-category">Function</span></header><section><div><p>coxmat(m::AbstractMatrix)</p><p>returns  the  Coxeter  matrix  of  the  Coxeter group defined by the cartan matrix <code>m</code></p><pre><code class="language-julia-repl">julia&gt; C=cartan(:H,3)
3×3 Array{Cyc{Int64},2}:
       2  ζ₅²+ζ₅³   0
 ζ₅²+ζ₅³        2  -1
       0       -1   2

julia&gt; coxmat(C)
3×3 Array{Int64,2}:
 1  5  2
 5  1  3
 2  3  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L623-L642">source</a></section><section><div><p><code>coxmat(W)</code></p><p>returns the Coxeter matrix of the Coxeter group <code>W</code>, that is the matrix <code>m</code> whose  entry <code>m[i,j]</code> contains the order of <code>W(i)*W(j)</code> where <code>W(i)</code> is the <code>i</code>-th  Coxeter generator of  <code>W</code>. An infinite  order is represented by the entry <code>0</code>.</p><pre><code class="language-julia-repl">julia&gt; W=CoxSym(4)
𝔖 ₄

julia&gt; coxmat(W)
3×3 Array{Int64,2}:
 1  3  2
 3  1  3
 2  3  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L659-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.standard_parabolic_class" href="#Gapjm.CoxGroups.standard_parabolic_class"><code>Gapjm.CoxGroups.standard_parabolic_class</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>standard_parabolic_class(W,I)</code></p><p><code>I</code>  should be a  subset of <code>eachindex(gens(W))</code>.  The function returns the list of such subsets conjugate to the given subset.</p><pre><code class="language-julia-repl">julia&gt; CoxGroups.standard_parabolic_class(coxgroup(:E,8),[7,8])
7-element Array{Array{Int64,1},1}:
 [7, 8]
 [6, 7]
 [5, 6]
 [4, 5]
 [2, 4]
 [3, 4]
 [1, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L591-L608">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.gencox" href="#Gapjm.CoxGroups.gencox"><code>Gapjm.CoxGroups.gencox</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>gencox(m)</code></p><p><code>m</code>  should be a square  matrix of real cyclotomic  numbers. It returns the Coxeter  group  whose  Cartan  matrix  is  <code>m</code>.  This  is  a  matrix  group constructed  as  follows.  Let  <code>V</code>  be  a  real  vector space of dimension <code>size(m,1)</code>,  and  let  <code>⟨,⟩</code>  be  the  bilinear  form defined by <code>⟨eᵢ,eⱼ⟩= m[i,j]</code>  where <code>eᵢ</code> is the  canonical basis of <code>V</code>.  Then the result is the matrix group generated by the reflections <code>sᵢ(x)=x-2⟨x,eᵢ⟩eᵢ</code>.</p><pre><code class="language-julia-repl">julia&gt; W=CoxGroups.gencox([2 -2;-2 2])
Gapjm.CoxGroups.GenCox{Int64}([[-1 0; 2 1], [1 2; 0 -1]], Dict{Symbol,Any}())</code></pre><p>Above is a way to construct the affine Weyl group  <code>̃A₁</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L855-L871">source</a></section></article><h1 id="Finite-Coxeter-groups-and-Weyl-groups-1"><a class="docs-heading-anchor" href="#Finite-Coxeter-groups-and-Weyl-groups-1">Finite Coxeter groups and Weyl groups</a><a class="docs-heading-anchor-permalink" href="#Finite-Coxeter-groups-and-Weyl-groups-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl" href="#Gapjm.Weyl"><code>Gapjm.Weyl</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Let  <code>V</code> be a  real vector space.  Finite Coxeter groups  coincide with the finite  subgroups of  <code>GL(V)</code> which  can be  generated y reflections. <em>Weyl groups</em>  are  the  finite  Coxeter  groups  which  can  be defined over the rational   numbers.  We  implement  finite   Coxter  groups  as  groups  of permutations  of  a  root  system.  Root  systems play an important role in mathematics as they classify semi-simple Lie algebras and algebraic groups.</p><p>Let  us give precise definitions. Let <code>V</code>  be a real vector space, <code>Vⱽ</code> its dual  and let <code>(,)</code>  be the natural  pairing between <code>Vⱽ</code>  and <code>V</code>. A <em>root system</em>  is a finite set  of vectors <code>R</code> which  generate <code>V</code> (the <em>roots</em>), together  with  a  map  <code>r↦  rⱽ</code>  from  <code>R</code>  to  a subset <code>Rⱽ</code> of <code>Vⱽ</code> (the <em>coroots</em>) such that:</p><ul><li>For any <code>r∈  R</code>, we have  <code>(rⱽ,r)=2</code> so that  the formula <code>x↦ x-(rⱽ,x)r</code></li></ul><p>defines a reflection <code>sᵣ:V→ V</code> with root <code>r</code> and coroot <code>rⱽ</code>.</p><ul><li>The reflection <code>sᵣ</code> stabilizes <code>R</code>.</li></ul><p>We  will only  consider <em>reduced</em>  root systems,  i.e., such  that the only elements  of <code>R</code> colinear with <code>r∈ R</code> are <code>r</code> and <code>-r</code>; for Weyl groups, we also ask that the root system be <em>crystallographic</em>, that is <code>(rⱽ,s)</code> is an integer, for any <code>s∈ R,rⱽ∈ Rⱽ</code>.</p><p>The  subgroup <code>W=W(R)</code> of  <code>GL(V)</code> generated by  the reflections <code>sᵣ</code> is a finite  Coxeter group; when <code>R</code> is crystallographic, the representation <code>V</code> of  <code>W</code>  is  defined  over  the  rational  numbers.  All finite-dimensional (complex)  representations of a  finite Coxeter group  can be realized over the  same field  as <code>V</code>.  Weyl groups  can be  characterized amongst finite Coxeter  groups by the fact that all numbers <code>m(s,t)</code> in the Coxeter matrix are in <code>{2,3,4,6}</code>.</p><p>If  we identify  <code>V</code> with  <code>Vⱽ</code> by  choosing a  <code>W</code>-invariant bilinear form <code>(.;.)</code>;  then we have <code>rⱽ=2r/(r;r)</code>. A root system <code>R</code> is <em>irreducible</em> if it is not the union of two orthogonal subsets. If <code>R</code> is reducible then the corresponding  Coxeter group  is the  direct product  of the Coxeter groups associated with the irreducible components of <code>R</code>.</p><p>The  irreducible  crystallographic  root  systems  are  classified  by  the following  list of  <em>Dynkin diagrams</em>,  which, in  addition to  the Coxeter matrix,  encode also the relative length of the roots. We show the labeling of the nodes given by the function &#39;Diagram&#39; described below.</p><pre><code class="language-none">A_n O—O—O—…—O   B_n O⇐O—O—…—O  C_n O⇒O—O—…—O  D_n  O 2
    1 2 3 … n       1 2 3 … n      1 2 3 … n       ￨
                                                 O—O—…—O
                                                 1 3 … n

G₂ O⇛O  F₄ O—O⇒O—O    E₆   O 2   E₇   O 2     E₈    O 2
   1  2     1 2  3 4       ￨          ￨             ￨
                       O—O—O—O—O  O—O—O—O—O—O   O—O—O—O—O—O—O
                       1 3 4 5 6  1 3 4 5 6 7   1 3 4 5 6 7 8</code></pre><p>These diagrams encode the presentation of the Coxeter group <code>W</code> as follows: the vertices represent the generating reflections; an edge is drawn between <code>s</code>  and <code>t</code> if the order <code>m(s,t)</code> of <code>st</code> is greater than <code>2</code>; the edge is single  if  <code>m(s,t)=3</code>,  double  if  <code>m(s,t)=4</code>,  triple if <code>m(s,t)=6</code>. The arrows  indicate the relative root lengths when <code>W</code> has more than one orbit on  <code>R</code>, as explained below; we  get the <em>Coxeter Diagram</em>, which describes the  underlying Weyl group, if  we ignore the arrows:  we see that the root systems <code>B_n</code> and <code>C_n</code> correspond to the same Coxeter group.</p><p>Here  are  the  diagrams  for  the  finite  Coxeter  groups which  are  not crystallographic:</p><pre><code class="language-none">       e        5         5
I₂(e) O—O   H₃ O—O—O  H₄ O—O—O—O
      1 2      1 2 3     1 2 3 4 </code></pre><p>Let us now describe how the root systems are encoded in these diagrams. Let <code>R</code>  be a root system in <code>V</code>. Then we can choose a linear form on <code>V</code> which vanishes  on no element of <code>R</code>. According to  the sign of the value of this linear  form on a root  <code>r ∈ R</code> we  call <code>r</code> <em>positive</em> or <em>negative</em>. Then there  exists a unique subset <code>Π</code> of  the positive roots, called the set of <em>simple  roots</em>, such that  any positive root  is a linear combination with non-negative  coefficients of  roots in  <code>Π</code>. Any  two sets of simple roots (corresponding  to  different  choices  of  linear  forms  as above) can be transformed into each other by a unique element of <code>W(R)</code>. Hence, since the pairing  between <code>V</code> and <code>Vⱽ</code>  is <code>W</code>-invariant, if <code>Π</code>  is a set of simple roots  and if  we define  the <em>Cartan  matrix</em> as  being the  <code>n</code> times <code>n</code> matrix   <code>C={rⱽ(s)}ᵣₛ</code>,  for  <code>r,s∈Π</code>  this   matrix  is  unique  up  to simultaneous  permutation of rows and columns.  It is precisely this matrix which is encoded in a Dynkin diagram, as follows.</p><p>The  indices for the rows of <code>C</code> label the nodes of the diagram. The edges, for  <code>r ≠ s</code>,  are given as  follows. If <code>Cᵣₛ</code>  and <code>Cₛᵣ</code> are integers such that  <code>|Cᵣₛ|≥|Cₛᵣ|=1</code> the vertices  are connected by  <code>|Cᵣₛ|</code> lines, and if <code>|Cᵣₛ|&gt;1</code> then we put an additional arrow on the lines pointing towards the node  with label <code>s</code>. In other cases,  we simply put a single line equipped with the unique integer <code>pᵣₛ≥1</code> such that <code>CᵣₛCₛᵣ=cos^2 (π/pₛᵣ)</code>.</p><p>Conversely,  the whole root  system can be  recovered from the simple roots and  the corresponding coroots. The  reflections in <code>W(R)</code> corresponding to the  simple roots are called  <em>simple</em> reflections or <em>Coxeter generators</em>. They are precisely the generators for which the Coxeter diagram encodes the defining  relations of <code>W(R)</code>. Each root is  in the orbit of a simple root, so  that <code>R</code> is obtained  as the orbit of  the simple roots under the group generated  by  the  simple  reflections.  The  restriction  of  the  simple reflections  to the span of <code>R</code> is  determined by the Cartan matrix, so <code>R</code> is determined by the Cartan matrix and the set of simple roots.</p><p>The  Cartan  matrix  corresponding  to  one  of  the above irreducible root systems  (with the specified labeling) is  returned by the command &#39;cartan&#39; which  takes as input  a <code>Symbol</code> giving  the type (that  is &#39;:A&#39;, &#39;:B&#39;, …, &#39;:I&#39;)  and a positive <code>Int</code> giving the  rank (plus an <code>Int</code> giving the bond for  type <code>:I</code>).  This function  returns a  matrix with  entries in <code>ℤ</code> for crystallographic  types, and a  matrix of <code>Cyc</code>  for the other types. Given two  Cartan matrices <code>c1</code> and <code>c2</code>,  their matrix direct sum (corresponding to  the  orthogonal  direct  sum  of  the  root systems) can be produced by <code>cat(c1,c2,dims=[1,2])</code>.</p><p>The  function &#39;rootdatum&#39; takes as input a  list of simple roots and a list of the corresponding coroots and produces a <code>struct</code> containing information about  the root system <code>R</code> and about <code>W(R)</code>. If we label the positive roots by  &#39;1:N&#39;, and the negative roots  by &#39;N+1:2N&#39;, then each simple reflection is  represented by the permutation of &#39;1:2N&#39; which it induces on the roots. If  only one argument is given, the Cartan matrix of the root system, it is taken  as the list  of coroots and  the list of  roots is assumed to be the canonical basis of <code>V</code>.</p><p>If one only wants to work with Cartan matrices with a labeling as specified by  the  above  list,  the  function  call  can  be  simplified. Instead of &#39;rootdatum(cartan(:D,4))&#39; the following is also possible.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; cartan(W)
4×4 Array{Int64,2}:
  2   0  -1   0
  0   2  -1   0
 -1  -1   2  -1
  0   0  -1   2</code></pre><p>Also,  the Weyl group struct associated to a direct sum of irreducible root systems can be obtained as a product</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,2)*coxgroup(:B,2)
A₂×B₂

julia&gt; cartan(W)
4×4 Array{Int64,2}:
  2  -1   0   0
 -1   2   0   0
  0   0   2  -2
  0   0  -1   2</code></pre><p>The  same <code>struct</code>  is constructed  by applying  &#39;coxgroup&#39; to  the matrix &#39;cat(cartan(:A,2), cartan(:B,2),dims=[1,2])&#39;.</p><p>The elements of a Weyl group are permutations of the roots:</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; p=W(1,3,2,1,3)
(1,14,13,2)(3,17,8,18)(4,12)(5,20,6,15)(7,10,11,9)(16,24)(19,22,23,21)

julia&gt; word(W,p)
5-element Array{Int64,1}:
 1
 3
 1
 2
 3
</code></pre><p>finally, a benchmark on julia 1.0.2</p><pre><code class="language-benchmark">julia&gt; @btime length(elements(coxgroup(:E,7)))
  531.385 ms (5945569 allocations: 1.08 GiB)</code></pre><p>GAP3 for the same computation takes 2.2s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L1-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.cartan" href="#Gapjm.PermRoot.cartan"><code>Gapjm.PermRoot.cartan</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>cartan(m::AbstractMatrix)</code></p><p>The  argument is a Coxeter matrix for a Coxeter group <code>W</code> and the result is a  Cartan Matrix  for the  standard reflection  representation of  <code>W</code>. Its diagonal   terms  are  <code>2</code>  and  the  coefficient  between  two  generating reflections   <code>s</code>  and  <code>t</code>  is   <code>-2cos(π/m[s,t])</code>  (where  by  convention <code>π/m[s,t]==0</code>  if  <code>m[s,t]==infty</code>,  which  is  represented here by setting &#39;m[s,t]=0&#39;).  The matrix  <code>m</code> is  symmetric, and  the result  is symmetric, meaning  that all roots  in the constructed  reflection representation have same length.</p><pre><code class="language-julia-repl">julia&gt; cartan([1 3;3 1])
2×2 Array{Cyc{Int64},2}:
  2  -1
 -1   2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L193-L211">source</a></section><section><div><p><code>cartan(type, rank [,bond])</code></p><p>return  the Cartan matrix for a finite  Coxeter group described by type and rank.  The recognized types are <code>:A, :B,  :Bsym, :C, :D, :E, :F, :Fsym, :G, :Gsym, :I, :H</code>. For type <code>:I</code> a third argument must be given describing the bond between the two generators. The <code>sym</code> types correspond to root systems where all roots have the same length.</p><pre><code class="language-julia-repl">julia&gt; cartan(:F,4)
4×4 Array{Int64,2}:
  2  -1   0   0
 -1   2  -1   0
  0  -2   2  -1
  0   0  -1   2

julia&gt; cartan(:I,2,5)
2×2 Array{Cyc{Int64},2}:
       2  ζ₅²+ζ₅³
 ζ₅²+ζ₅³        2

julia&gt; cartan(:Bsym,2)
2×2 Array{Cyc{Int64},2}:
   2  -√2
 -√2    2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L214-L241">source</a></section><section><div><p><code>cartan(W::Group)</code></p><p>Let  <code>s₁,…,sₙ</code> be a  list of reflections  with associated root vectors <code>rᵢ</code> and  coroots <code>cᵢ</code>.  Then the  matrix <code>Cᵢ,ⱼ</code>  of the  <code>cᵢ(rⱼ)</code> is called the <em>Cartan  matrix</em> of the  list of reflections.  It is uniquely determined by the reflections up to conjugating by  a diagonal matrix.</p><p>If  <code>s₁,…,sₙ</code> are the generators of a  reflection group <code>W</code>, the matrix <code>C</code> up  to conjugation by a  diagonal matrix is an  invariant of the reflection representation   of   <code>W</code>.   It   actually   completely   determines   this representation if the <code>rᵢ</code> are linearly independent (which is e.g. the case if  <code>C</code> is  invertible), since  in the  <code>rᵢ</code> basis  the matrix for the <code>sᵢ</code> differs  from the identity only on the <code>i</code>-th line, where the corresponding line of <code>C</code> has been subtracted. This function returns the Cartan matrix of the reflection group <code>W</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; cartan(W)
3×3 Array{Int64,2}:
  2  -1   0
 -1   2  -1
  0  -1   2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L345-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.two_tree" href="#Gapjm.Weyl.two_tree"><code>Gapjm.Weyl.two_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">two_tree(m)</code></pre><p>Given  a square  matrix m  with zeroes  (or falses,  for a boolean matrix)  symmetric  with respect to the diagonal, let  G be the graph with vertices  axes(m)[1] and an edge between i and j iff !iszero(m[i,j]).  If G  is a line this function returns it as a Vector{Int}.   If  G  is  a  tree  with  one  vertex  c of valence 3 the function returns  (c,b1,b2,b3)  where b1,b2,b3 are  the branches from  this vertex sorted by  increasing length.  Otherwise the function returns <code>nothing</code></p><pre><code class="language-julia-repl">julia&gt; Weyl.two_tree(cartan(:A,4))
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; Weyl.two_tree(cartan(:E,8))
(4, [2], [3, 1], [5, 6, 7, 8])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L315-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection_subgroup" href="#Gapjm.PermRoot.reflection_subgroup"><code>Gapjm.PermRoot.reflection_subgroup</code></a> — <span class="docstring-category">Function</span></header><section><div><p>reflection_subgroup(W,I) The subgroup of W generated by reflections(W)[I]</p><p>A   theorem  discovered  by  Deodhar  cite{Deo89}  and  Dyer  cite{Dye90} independently  is that a subgroup <code>H</code> of a Coxeter system <code>(W,S)</code> generated by  reflections has  a canonical  Coxeter generating  set, formed of the <code>t ∈Ref(H)</code>  such <code>l(tt&#39;)&gt;l(t)</code> for any <code>t&#39;∈  Ref(H)</code> different from <code>t</code>. This is used by &#39;reflection_subgroup&#39; to determine the Coxeter system of <code>H</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; Diagram(W)
O⇛ O
1  2

julia&gt; H=reflection_subgroup(W,[2,6])
G₂₍₂₆₎=Ã₁×A₁

julia&gt; Diagram(H)
O
1
O
2</code></pre><p>The  notation <code>G₂₍₂₆₎</code> means  that &#39;W.G.roots[2:6]&#39; form  a system of simple roots for <code>H</code>.</p><p>A  reflection subgroup has specific properties  the most important of which is  &#39;inclusion&#39; which gives the positions of the roots of H in the roots of W. The inverse (partial) map is &#39;restriction&#39;.</p><pre><code class="language-julia-repl">julia&gt; inclusion(H)
4-element Array{Int64,1}:
  2
  6
  8
 12

julia&gt; restriction(H)
12-element Array{Int64,1}:
 0
 1
 0
 0
 0
 2
 0
 3
 0
 0
 0
 4</code></pre><p>If  H is a standard parabolic subgroup of a Coxeter group W then the length function on H (with respect to its set of generators) is the restriction of the  length function on  W. This need  not no longer  be true for arbitrary reflection subgroups of W:</p><pre><code class="language-julia-repl">julia&gt; word(W,H(2))
5-element Array{Int64,1}:
 1
 2
 1
 2
 1</code></pre><p>In  this package, finite  reflection groups are  represented as permutation groups  on a set of roots. Consequently,  a reflection subgroup <code>H⊆ W</code> is a permutation  subgroup, thus its elements are represented as permutations of the roots of the parent group.</p><pre><code class="language-julia-repl">julia&gt; elH=word.(Ref(H),elements(H))
4-element Array{Array{Int64,1},1}:
 []    
 [2]   
 [1]   
 [1, 2]

julia&gt; elW=word.(Ref(W),elements(H))
4-element Array{Array{Int64,1},1}:
 []                
 [1, 2, 1, 2, 1]   
 [2]               
 [1, 2, 1, 2, 1, 2]

julia&gt; map(w-&gt;H(w...),elH)==map(w-&gt;W(w...),elW)
true
</code></pre><p>Another  basic result about reflection subgroups  of Coxeter groups is that each  coset of  H in  W contains  a unique  element of  minimal length, see <code>reduced</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L864-L965">source</a></section><section><div><p><code>reflection_subgroup(W::CoxSym,I)</code></p><p>Only parabolics defined are <code>I=1:m</code> for <code>m≤n</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CoxGroups.jl#L820-L824">source</a></section><section><div><p>Only parabolics defined are I=1:m for m≤n</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/SPerms.jl#L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.coxgroup" href="#Gapjm.Weyl.coxgroup"><code>Gapjm.Weyl.coxgroup</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>coxgroup(type,rank[,bond])</code></p><p>This is equivalent to &#39;coxgroup(cartan(type,rank[,bond]))`.</p><p>The  resulting object, that we will  call a <em>Coxeter datum</em>, has additional entries and functions describing various information on the root system and Coxeter group that we describe below.</p><p><code>nref(W)</code>:   the number of positive roots</p><p><code>.rootdec</code>: the root vectors, given as linear combinations of simple roots. The  first  &#39;nref(W)&#39;  roots  are  positive,  the  next  &#39;nref(W)&#39;  are the corresponding negative roots. Moreover, the first &#39;semisimpleRank(W)&#39; roots are the simple roots. The positive roots are ordered by increasing height.</p><p>&#39;coroots(W.G)&#39;:     the same   information    for  the  coroots.    The coroot        corresponding  to a given  root is in  the same relative position in        the list of coroots as the root in the list of roots.</p><p>&#39;rootLengths&#39;:   the vector of length of roots the simple roots.        The  shortest roots in an irreducible subsystem are given the length        1. The others then have length 2 (or 3 in type  G_2).  The matrix of        the &lt;W&gt;-invariant bilinear form is given by        &#39;map(i-&gt;W.rootLengths[i]*W.cartan[i],1:semisimplerank(W)])/2&#39;.</p><p>&#39;orbitRepresentative&#39;:   this is a list of  same length as &#39;roots&#39;, which        for  each  root,  gives  the  smallest  index  of a root in the same        &lt;W&gt;-orbit.</p><p>&#39;orbitRepresentativeElements&#39;:   a list of  same length as &#39;roots&#39;, which        for  the  i-th  root, gives an element  &lt;w&gt; of &lt;W&gt; of minimal length        such that &#39;i=orbitRepresentative[i]^w&#39;.</p><p><code>W.G.matgens</code>:    the  matrices  (in  row  convention  –-  that is the matrices        operate  <em>from the right</em>) of the  simple reflections of the Coxeter group.</p><p><code>gens(W)</code>:   the generators as permutations of the root vectors.  They        are given in the same order as the first <code>semisimplerank(W)</code> roots.</p><pre><code class="language-julia_repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; cartan(W)
3×3 Array{Int64,2}:
  2  -1   0
 -1   2  -1
  0  -1   2

julia&gt; W.rootdec
12-element Array{Array{Int64,1},1}:
 [1, 0, 0]   
 [0, 1, 0]   
 [0, 0, 1]   
 [1, 1, 0]   
 [0, 1, 1]   
 [1, 1, 1]   
 [-1, 0, 0]  
 [0, -1, 0]  
 [0, 0, -1]  
 [-1, -1, 0] 
 [0, -1, -1] 
 [-1, -1, -1]

julia&gt; W.G.matgens
3-element Array{Array{Int64,2},1}:
 [-1 0 0; 1 1 0; 0 0 1]
 [1 1 0; 0 -1 0; 0 1 1]
 [1 0 0; 0 1 1; 0 0 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L654-L725">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.rootdatum" href="#Gapjm.Weyl.rootdatum"><code>Gapjm.Weyl.rootdatum</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Adjoint root datum from cartan mat</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L728">source</a></section><section><div><p>root datum from 2 matrices: roots on basis of X(T), coroots on basis of Y(T)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L731">source</a></section><section><div><p>root datum from type </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Cosets.jl#L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.describe_involution" href="#Gapjm.Weyl.describe_involution"><code>Gapjm.Weyl.describe_involution</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>describe_involution(W,w)</code></p><p>Given  an involution <code>w</code> of a Coxeter group <code>W</code>, by a theorem of Richardson cite{rich82} there is a unique parabolic subgroup <code>P</code> of <code>W</code> such that that <code>w</code>  is the  longest element  of <code>P</code>,  and is  central in <code>P</code>. The function returns <code>I</code> such that <code>P=reflection_subgroup(W,I)</code>, so that <code>w=longest(reflection_subgroup(W,I))</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; w=longest(W)
(1,5)(2,4)(3,6)

julia&gt; describe_involution(W,w)
1-element Array{Int64,1}:
 3

julia&gt; w==longest(reflection_subgroup(W,[3]))
true</code></pre><p>For now does not work for abscox groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L562-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.standard_parabolic" href="#Gapjm.Weyl.standard_parabolic"><code>Gapjm.Weyl.standard_parabolic</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>standard_parabolic(W,H)</code></p><p>Given a parabolic subgroup H or its simple roots returns w such that H^w is a standard parabolic subgroup of W</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L533-L538">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.inversions" href="#Gapjm.Weyl.inversions"><code>Gapjm.Weyl.inversions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>inversions(W,w)</code></p><p>Returns  the inversions of the element <code>w</code> of the finite Coxeter group <code>W</code>, that  is, the list of the  indices of roots of <code>W</code>  sent by <code>w</code> to negative roots.  The element <code>w</code> can also be  a word <code>s₁…sₙ</code> (a vector of integers), in  which  case  the  function  returns  inversions  in  the  order  of the reflections <code>W(s₁), W(s₁,s₂,s₁), …, W(s₁,s₂,…,sₙ,sₙ₋₁,…,s₁)</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; inversions(W,W(1,2,1))
3-element Array{Int64,1}:
 1
 2
 4

julia&gt; inversions(W,[1,2,1])
3-element Array{Int16,1}:
 1
 4
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L464-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.with_inversions" href="#Gapjm.Weyl.with_inversions"><code>Gapjm.Weyl.with_inversions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>with_inversions(W,N)</code></p><p><code>W</code>  should be  a finite  Coxeter group  and <code>N</code>  a subset  of <code>1:nref(W)</code>. Returns  the  element  <code>w</code>  of  <code>W</code> such that <code>N==inversions(W,w)</code>. Returns <code>nothing</code> if no such element exists.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; map(N-&gt;with_inversions(W,N),combinations(1:nref(W)))
8-element Array{Union{Nothing, Perm{Int16}},1}:
 ()
 (1,4)(2,3)(5,6)
 (1,3)(2,5)(4,6)
 nothing
 nothing
 (1,6,2)(3,5,4)
 (1,2,6)(3,4,5)
 (1,5)(2,4)(3,6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L497-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.torus" href="#Gapjm.Weyl.torus"><code>Gapjm.Weyl.torus</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>torus(rank)</code></p><p>This  function returns the object corresponding to the notion of a torus of dimension  <code>rank</code>, a Coxeter  group of semisimple  rank 0 and given <code>rank</code>. This  corresponds to a split torus; the extension to Coxeter cosets is more useful.</p><pre><code class="language-julia-repl">julia&gt; torus(3)
.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L749-L761">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.SubTorus" href="#Gapjm.Weyl.SubTorus"><code>Gapjm.Weyl.SubTorus</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SubTorus(W,Y::Matrix)</code></p><p>The  function  returns  the  subtorus  𝐒  of  the  maximal torus <code>𝐓</code> of the reductive  group represented by the Weyl group  <code>W</code> such that <code>Y(𝐒)</code> is the (pure)  sublattice of  <code>Y(𝐓)</code> generated  by the  (integral) vectors  <code>Y</code>. A basis  of <code>Y(𝐒)</code>  adapted to  <code>Y(𝐓)</code> is  computed and  stored in  the field &#39;S.generators&#39;  of the returned  SubTorus struct. Here,  adapted means that there  is a  set of  integral vectors,  stored in &#39;S.complement&#39;, such that &#39;M=vcat(S.generators,S.complement)&#39;  is  a  basis  of  <code>Y(𝐓)</code> (equivalently <code>M∈GL(Z^{rank(W)})</code>.  An  error  is  raised  if  <code>Y</code> does not define a pure sublattice.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,4)
A₄

julia&gt; SubTorus(W,[1 2 3 4;2 3 4 1;3 4 1 1])
SubTorus(A₄,[[1, 0, 3, -13], [0, 1, 2, 7], [0, 0, 4, -3]])

julia&gt; SubTorus(W,[1 2 3 4;2 3 4 1;3 4 1 2])
ERROR: not a pure sublattice
Stacktrace:
 [1] error(::String) at ./error.jl:33
 [2] Gapjm.Weyl.SubTorus(::FiniteCoxeterGroup{Perm{Int16},Int64}, ::Array{Int64,2}) at /home/jmichel/julia/Gapjm.jl/src/Weyl.jl:1082
 [3] top-level scope at REPL[25]:1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L1061-L1088">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.fundamental_group" href="#Gapjm.Weyl.fundamental_group"><code>Gapjm.Weyl.fundamental_group</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>fundamental_group(W)</code></p><p>This  function returns the fundamental group of the algebraic group defined by  the Coxeter  group struct  <code>W</code>. This  group is  returned as  a group of diagram  automorphisms of the corresponding affine Weyl group, that is as a group  of permutations of  the set of  simple roots enriched  by the lowest root  of  each  irreducible  component.  The  definition  we  take  of  the fundamental  group of a (not necessarily semisimple) reductive group is (P∩ Y(𝐓))/Q where P is the coweight lattice (the dual lattice in Y(𝐓)⊗ ℚ of the root lattice) and Q is the coroot latice. The bijection between elements of P/Q   and   diagram   automorphisms   is   explained   in  the  context  of non-irreducible groups for example in cite[S 3.B]{Bon05}.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; fundamental_group(W)
Group([perm&quot;(1,2,3,12)&quot;])

julia&gt; W=rootdatum(:sl,4)
A₃

julia&gt; fundamental_group(W)
Group([])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L1269-L1296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.relative_group" href="#Gapjm.Weyl.relative_group"><code>Gapjm.Weyl.relative_group</code></a> — <span class="docstring-category">Function</span></header><section><div><p>relative_group(W::FiniteCoxeterGroup,J)</p><p><code>J</code> should be a if <em>distinguished</em> subset of <code>S==eachindex(gens(W))</code>, that is if for s∈ S-J we  set v(s,J)=w<em>0^{J∪ s}w</em>0^J then J  is stable  by all v(s,J). Then R=N<em>W(W</em>J)/W<em>J  is a Coxeter group with  Coxeter system the v(s,J). The program  return  R  in  its  reflection  representation  on X(ZL</em>J/ZG). (according to Lusztig&#39;s &quot;Coxeter Orbits...&quot;, the images of the roots of W in X(ZL_J/ZG) form a root system).</p><p>R.prop has the fields: :relativeIndices=setdiff(S,J) :parentMap:=the list of v(s,J) :MappingFromNormalizer maps J-reduced elements of N<em>W(W</em>J) to elements of R</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L1313-L1330">source</a></section></article><h1 id="Finite-reflection-groups-1"><a class="docs-heading-anchor" href="#Finite-reflection-groups-1">Finite reflection groups</a><a class="docs-heading-anchor-permalink" href="#Finite-reflection-groups-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot" href="#Gapjm.PermRoot"><code>Gapjm.PermRoot</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Let  <code>V</code> be a vector space over a subfield <code>K</code> of the complex numbers; here it  usually means  a <code>Rational</code>  or a  <code>Cyc</code>. A  <em>complex reflection</em> is an element  <code>s∈ GL(V)</code> of finite order whose  fixed point set is an hyperplane (we  will in the  following just call  it a <em>reflection</em>  to abbreviate; in some  literature the term reflection  is only employed when  the order is 2 and  the  more  general  case  is  called  a  <em>pseudo-reflection</em>).  Thus a reflection  has a unique  eigenvalue not equal  to <code>1</code>, which  is a root of unity.  If  <code>K</code>  is  a  subfield  of  the  real numbers, this eigenvalue is necessarily equal to <code>-1</code>.</p><p>A  reflection group <code>W</code> is a group  generated by a finite number of complex reflections.</p><p>Since  when <code>W</code> contains  a reflection <code>s</code>  it contains its  powers, <code>W</code> is always  generated  by  reflections  <code>s</code>  with non-trivial eigenvalue <code>E(d)</code> where  <code>d</code> is the order of <code>s</code>; we may in addition assume that <code>s</code> is not a power  of another reflection with larger order. Such a reflection is called <em>distinguished</em>;  it is  a canonical  generator of  the cyclic  subgroup it generates.  The  generators  of  reflection  groups we construct are always distinguished  reflections. In a real  reflection group all reflections are distinguished.</p><p>Reflection groups for us are groups <code>W</code> with the following methods defined</p><p><code>gens(W)</code>: the reflections which generate <code>W</code></p><p><code>reflections(W)</code>: a list of distinguished reflections, given as elements of <code>W</code>, which starts with gens(W).</p><p>Note  that <code>W</code>  does <em>not</em>  need to  be a  matrix group. The meaning of the above  fields is just that <code>W</code> has a representation (called the <em>reflection representation</em>  of <code>W</code>) where  <code>reflections(W)</code> act as  reflections. It is much  more efficient  to compute  with permutation  groups than with matrix groups,  when possible.  Information sufficient  to determine  a particular reflection  representation  is  stored  for  such  groups  (see <code>roots</code> and <code>coroots</code>). Note that when <code>W</code> is finite, the distinguished reflections are in bijection with the reflecting hyperplanes.</p><p>Let  <code>W</code>  be  a  finite  reflection  group  on  the vector space <code>V</code> over a subfield  <code>K</code> of the  complex numbers. An  efficient representation that we use  for computing with such group is, is a permutation representation on a <code>W</code>-invariant  set of root and coroot  vectors for reflections of <code>W</code>; that is,  a  set  <code>R</code>  of  pairs  <code>(r,rᵛ)∈  V×Vᵛ</code> invariant by <code>W</code> and such each distinguished  reflection  in  <code>W</code>  is  defined  by  some  pair in <code>R</code> (see <code>reflection</code>). There may be several pairs for each reflection, differing by roots  of unity. This generalizes the usual construction for Coxeter groups (the  case <code>K=ℝ</code>) where to each reflection of <code>W</code> is associated two roots, a  positive and a negative one.  For irreducible complex reflection groups, there are at least as many roots on a given line as the order of the center of <code>W</code>.</p><p>The  finite  irreducible  complex  reflection  groups  have been completely classified   by  Shepard  and  Todd.   They  contain  one  infinite  family <code>G(de,e,r)</code> depending on 3 parameters, and 34 exceptional groups which have been  given by Shephard and Todd names which range from <code>G₄</code> to <code>G₃₇</code>. They cover the exceptional Coxeter groups, e.g., <code>coxgroup(:E,8)</code> is the same as <code>G₃₇</code>.</p><p>We provide functions to build any finite reflection group, either by giving a  list of  roots and  corrots defining  the generating  reflections, or in terms  of the classification. The  output is a permutation  group on set of roots  (see <code>ComplexReflectionGroup</code>  and <code>PermRootGroup</code>).  In the context e.g.  of  Weyl  groups,  one  wants  to describe the particular root system chosen  in term of the  traditional classification of crystallographic root systems. This is done via calls to the function <code>coxgroup</code> (see the chapter on  finite Coxeter  groups). There  is not  yet a  general theory on how to construct  a nice set of  roots for a non-real  reflection group; the roots chosen  here  where  obtained  case-by-case;  however, they satisfy several important properties:</p><ul><li><p>The  generating  reflections  satisfy  braid relations which  present the braid group associated to <code>W</code> (see <code>Diagram</code>).</p></li><li><p>The <em>field of definition</em> of <code>W</code> is the field <code>K</code> generated by the traces of the elements of <code>W</code> acting on <code>V</code>.</p></li></ul><p>It  is a theorem that  <code>W</code> may be realized  as a reflection group over <code>K</code>. For  almost  all  irreducible  complex  reflection  groups,  the generating matrices  for <code>W</code>  we give  have coefficients  in <code>K</code>.  Further, the set of matrices  for all  elements of  <code>W</code> is  globally invariant under the Galois group  of <code>K/ℚ</code>, thus the Galois  action induces automorphisms of <code>W</code>. The exceptions are <code>G₂₂, G₂₇</code> where the matrices are in a degree two extension of   <code>K</code>  (this  is  needed  to   have  a  globally  invariant  model,  see [MarinMichel10]) and some dihedral groups as well as <code>H_3</code> and <code>H_4</code>, where the  matrices given (the usual  Coxeter reflection representation over <code>K</code>) are not globally invariant.</p><p>It turns out that all representations of a complex reflection group <code>W</code> are defined  over the  field of  definition of  <code>W</code> (cf.  [Ben76] and D.~Bessis thesis).  This has been known for a long  time in the case <code>K=ℚ</code>, the case of Weyl groups: their representations are defined over the rationals.</p><ul><li>The Cartan matrix (see &quot;CartanMat&quot;) for the generating roots (those which  correspond  to the generating reflections) has  entries in the ring <code>ℤₖ</code>  of integers of <code>K</code>, and the roots (resp. coroots) are linear combination  with coefficients in <code>ℤₖ</code> of a linearly independent subset of them.</li></ul><p>The finite reflection groups have thus the following additional fields:</p><p><code>roots</code>:  a  set  of  complex  roots  in  <code>V</code>,  given  as a list of lists        (vectors), on which <code>W</code> has a faithful permutation representation.</p><pre><code class="language-none">   `coroots`: the  coroots for `gens(W)`.</code></pre><p>Here  we  describe  functions  available  for  finite reflection groups <code>W</code> represented  as permutation groups on a  set of roots. These functions make use  of the classification of <code>W</code> whenever it is known, but work even if it is not known.</p><p>Let <code>SV</code> be the symmetric algebra of <code>V</code>. The invariants of <code>W</code> in <code>SV</code> are called  the  <em>polynomial  invariants</em>  of  <code>W</code>.  They  are  generated  as a polynomial   ring   by   <code>dim   V</code>  homogeneous  algebraically  independent polynomials  <code>f₁,…,f_{dim  V}</code>.  The  polynomials  <code>fᵢ</code>  are not uniquely determined  but  their  degrees  are.  The  <code>fᵢ</code>  are  called  the  <em>basic invariants</em>  of <code>W</code>, and their degrees the <em>reflection degrees</em> of <code>W</code>. Let <code>I</code> be the ideal generated by the homogeneous invariants of positive degree in  <code>SV</code>. Then <code>SV/I</code> is isomorphic to the regular representation of <code>W</code> as a  <code>W</code>-module. It  is thus  a graded  (by the  degree of  elements of <code>SV</code>) version  of the regular  representation of <code>W</code>.  The polynomial which gives the  graded multiplicity  of a  character <code>φ</code>  of <code>W</code>  in the graded module <code>SV/I</code> is called the <em>fake degree</em> of <code>φ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L1-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection" href="#Gapjm.PermRoot.reflection"><code>Gapjm.PermRoot.reflection</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reflection(W,i)</code></p><p>reflection for <code>i</code>-th root of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L338-L342">source</a></section><section><div><p><code>reflection(root, coroot)::Matrix</code> the reflection of given root and coroot</p><p>A  (complex) reflection in <code>GL(V)</code>, the linear group of a vector space over a subfield of the complex numbers, is a map <code>s</code> of finite order whose fixed points  are  a  hyperplane  <code>H</code>  (the  <em>reflecting  hyperplane</em> of <code>s</code>); an eigenvector  <code>r</code> for  the non-trivial  eigenvalue <code>ζ</code>  (a root of unity) is called  a <em>root</em> of <code>s</code>. If we choose a linear form <code>rᵛ</code> (called a <em>coroot</em> of <code>s</code>) defining <code>H</code> such that <code>rᵛ(r)=1-ζ</code> then the linear map <code>s</code> is given by <code>x↦x-rᵛ(x)r</code>.</p><p>A  way of specifying a  reflection is by giving  a root and a coroot, which are  uniquely determined by the reflection up to multiplication of the root by  a  scalar  and  of  the  coroot  by  the  inverse  scalar. The function <code>reflection</code>  gives  the  matrix  of  the  corresponding  reflection in the standard  basis of <code>V</code>, where the <code>root</code> and the <code>coroot</code> are vectors given in  the standard  bases of  <code>V</code> and  <code>Vᵛ</code>, so  that <code>rᵛ(r)</code>  is obtained as <code>permutedims(root)*coroot</code>.</p><pre><code class="language-none">julia&gt; r=reflection([1,0,0],[2,-1,0])
3×3 Array{Int64,2}:
 -1  0  0
  1  1  0
  0  0  1

julia&gt; r==matX(coxgroup(:A,3),1)
true

julia&gt; r*[2,-1,0]
3-element Array{Int64,1}:
 -2
  1
  0

julia&gt; [1 0 0]*r
1×3 Array{Int64,2}:
 -1  0  0</code></pre><p>As  we see in the last lines, in our package the matrices operate an <code>V</code> as row vectors and on <code>Vᵛ</code> as column vectors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L1100-L1141">source</a></section><section><div><p><code>reflection(s::Matrix [,r::AbstractVector])</code></p><p>Here  <code>s</code> is  a square  matrix, and  if given  <code>r</code> is  a vector of the same length  as <code>size(s)[1]</code>. The function determines if  <code>s</code> is the matrix of a reflection  (resp. if <code>r</code> is  given if it is  the matrix of a reflection of root  <code>r</code>; the point of  giving <code>r</code> is to  specify exactly the desired root and  coroot, which  otherwise are  determined only  up to  a scalar and its inverse).  The returned result is <code>false</code> if <code>s</code> is not a reflection (resp. not  a  reflection  with  root  <code>r</code>),  and  otherwise is a record with four fields:</p><p><code>.root</code>:   the root of the reflection <code>s</code> (equal to <code>r</code> if given)</p><p><code>.coroot</code>:  the coroot of <code>s</code></p><p><code>.eigenvalue</code>:  the non-trivial eigenvalue of <code>s</code></p><p><code>.isOrthogonal</code>:   a  boolean  which is  <code>true</code> if  and  only if  <code>s</code> is   orthogonal  with respect to  the usual scalar  product (then the root and   eigenvalue are sufficient to determine <code>s</code>)</p><pre><code class="language-julia-repl">julia&gt; reflection([-1 0 0;1 1 0;0 0 1])
(root = [2, 0, 0], coroot = Rational{Int64}[1//1, -1//2, 0//1], eig = -1, isOrthogonal = false)

julia&gt; reflection([-1 0 0;1 1 0;0 0 1],[1,0,0])
(root = [1, 0, 0], coroot = Rational{Int64}[2//1, -1//1, 0//1], eig = -1, isOrthogonal = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L1312-L1341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.cartan-Tuple{PermRootGroup}" href="#Gapjm.PermRoot.cartan-Tuple{PermRootGroup}"><code>Gapjm.PermRoot.cartan</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>cartan(W::Group)</code></p><p>Let  <code>s₁,…,sₙ</code> be a  list of reflections  with associated root vectors <code>rᵢ</code> and  coroots <code>cᵢ</code>.  Then the  matrix <code>Cᵢ,ⱼ</code>  of the  <code>cᵢ(rⱼ)</code> is called the <em>Cartan  matrix</em> of the  list of reflections.  It is uniquely determined by the reflections up to conjugating by  a diagonal matrix.</p><p>If  <code>s₁,…,sₙ</code> are the generators of a  reflection group <code>W</code>, the matrix <code>C</code> up  to conjugation by a  diagonal matrix is an  invariant of the reflection representation   of   <code>W</code>.   It   actually   completely   determines   this representation if the <code>rᵢ</code> are linearly independent (which is e.g. the case if  <code>C</code> is  invertible), since  in the  <code>rᵢ</code> basis  the matrix for the <code>sᵢ</code> differs  from the identity only on the <code>i</code>-th line, where the corresponding line of <code>C</code> has been subtracted. This function returns the Cartan matrix of the reflection group <code>W</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; cartan(W)
3×3 Array{Int64,2}:
  2  -1   0
 -1   2  -1
  0  -1   2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L345-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.hyperplane_orbits" href="#Gapjm.PermRoot.hyperplane_orbits"><code>Gapjm.PermRoot.hyperplane_orbits</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>hyperplane_orbits(W)</code></p><p>returns  a  list  of  named  tuples,  one  for each hyperplane orbit of the reflection  group <code>W</code>. If <code>o</code> is the named tuple for such an orbit, and <code>s</code> is  the first  element of  <code>gens(W)</code> whose  hyperplane is  in the orbit, it contains the following fields</p><p><code>o.s</code>:     index of <code>s</code> in <code>gens(W)</code></p><p><code>o.cl_s</code>:  <code>map(i-&gt;position_class(W,s^i),1:o.order-1)</code></p><p><code>o.order</code>: order of s</p><p><code>.N_s</code>:    Size of orbit</p><p><code>.det_s</code>:  for i in <code>1:o.order-1</code>, position in CharTable of <code>(det_s)^i</code></p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; hyperplane_orbits(W)
2-element Array{NamedTuple{(:s, :cl_s, :order, :N_s, :det_s),Tuple{Int64,Array{Int64,1},Int64,Int64,Array{Int64,1}}},1}:
 (s = 2, cl_s = [4], order = 2, N_s = 2, det_s = [1])
 (s = 1, cl_s = [2], order = 2, N_s = 2, det_s = [3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L580-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.rank" href="#Gapjm.PermRoot.rank"><code>Gapjm.PermRoot.rank</code></a> — <span class="docstring-category">Function</span></header><section><div><p>rank(W::Group)</p><p>This  function  returns  the  <em>rank</em>  of  a  reflection group, which is the dimension of the space where it acts.</p><pre><code class="language-julia-repl">julia&gt; rank(ComplexReflectionGroup(31))
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L382-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.semisimplerank" href="#Gapjm.PermRoot.semisimplerank"><code>Gapjm.PermRoot.semisimplerank</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>semisimpleRank(W)</code></p><p>This  function returns the  <em>semisimple rank</em> of  the reflection group <code>W</code>, which  is the dimension of the space  where it effectively acts. If <code>W</code>is a reflection  group acting on <code>V</code>, and <code>V₁</code>  is the subspace generated by the roots  of  the  reflections  of  <code>W</code>,  then  the  dimension  of <code>V₁</code> is the semisimple rank. <code>W</code> is called <em>essential</em> if <code>V₁=V</code>.</p><pre><code class="language-julia-repl">julia&gt; W=reflection_subgroup(coxgroup(:A,3),[1,3])
A₃₍₁₃₎=A₁×A₁

julia&gt; semisimplerank(W)
2

julia&gt; rank(W)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L861-L880">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.degrees-Tuple{Group}" href="#Gapjm.degrees-Tuple{Group}"><code>Gapjm.degrees</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>degrees(W)</code></p><p>returns  a list  holding the  degrees of  <code>W</code> as  a reflection group on the vector  space <code>V</code> on which  it acts. These are  the degrees <code>d₁,…,dₙ</code> where <code>n</code>  is the dimension of  <code>V</code> of the basic  invariants of <code>W</code> in <code>SV</code>. They reflect various properties of <code>W</code>; in particular, their product is the size of <code>W</code>.</p><pre><code class="language-julia-repl">julia&gt; W=ComplexReflectionGroup(30)
H₄

julia&gt; degrees(W)
4-element Array{Int64,1}:
  2
 12
 20
 30

julia&gt; length(W)
14400</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/ComplexR.jl#L74-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.ComplexR.codegrees" href="#Gapjm.ComplexR.codegrees"><code>Gapjm.ComplexR.codegrees</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>codegrees(W)</code></p><p>returns  a list holding the  codegrees of <code>W</code> as  a reflection group on the vector  space <code>V</code>  on which  it acts.  These are  one less than the degrees <code>d^*_1,ldots,d^*_(dim V)</code> of the basic derivations of <code>W</code> on <code>SV⊗ V^vee</code>.</p><pre><code class="language-julia-repl">julia&gt; W=ComplexReflectionGroup(4)
G₄

julia&gt; codegrees(W)
2-element Array{Int64,1}:
 0
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/ComplexR.jl#L211-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.bipartite_decomposition" href="#Gapjm.PermRoot.bipartite_decomposition"><code>Gapjm.PermRoot.bipartite_decomposition</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>bipartite_decomposition(W)</code></p><p>Returns  a bipartite decomposition <code>[L,R]</code> of the indices of the generators of  the  reflection  group  <code>W</code>,  such  that <code>reflection_subgroup(W,L)</code> and <code>reflection_subgroup(W,R)</code> are abelian subgroups, and <code>W=reflection_subgroup(W,   vcat(L,R))</code>.   Gives   an   error  if  no  such decomposition is possible.</p><pre><code class="language-julia-repl">julia&gt; bipartite_decomposition(coxgroup(:E,8))
([1, 4, 6, 8], [3, 2, 5, 7])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L636-L650">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.catalan" href="#Gapjm.PermRoot.catalan"><code>Gapjm.PermRoot.catalan</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Catalan(n) <code>n</code>-th Catalan Number</p><pre><code class="language-julia-repl">julia&gt; catalan(8)
1430</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L1245-L1252">source</a></section><section><div><p><code>Catalan(W)</code></p><p>returns the Catalan Number of the irreducible complex reflection group <code>W</code>. For well-generated groups, this number is equal to the number of simples in the  dual  Braid  monoid.  For  other  groups  it was defined by Gordon and Griffeth  (cite{gg12}).  For  Weyl  groups,  it  also counts the number of antichains of roots.</p><pre><code class="language-julia-repl">julia&gt; catalan(coxgroup(:A,7))
1430</code></pre><p><code>Catalan(W,i)</code></p><p>returns   the  <code>i</code>-th  Fuss-Catalan  Number   of  the  irreducible  complex reflection  group <code>W</code>. For  well-generated groups, this  number is equal to the  number of chains  <code>s₁,…,sᵢ</code> of simples  in the dual  monoid where <code>sⱼ</code> divides  <code>sⱼ₊₁</code>. For these groups, it is also equal to <code>∏ⱼ(ih+dⱼ)/dⱼ</code> where the  product runs over the reflection degrees  of <code>W</code>, and where <code>h</code> is the Coxeter  number of <code>W</code>. For non-well generated groups, the definition is in cite{gg12}.</p><pre><code class="language-julia-repl">julia&gt; catalan(ComplexReflectionGroup(7),2)
16//1</code></pre><p><code>Catalan(W,q)</code>, resp. <code>Catalan(W,i,q)</code></p><p>where  <code>q</code>  is  a  variable  (like  <code>Pol(:q)</code>  or  an  &#39;Mvp&#39;)  returns  the <code>q</code>-Catalan number (resp. the <code>i</code>-th <code>q</code>-Fuss Catalan number) of <code>W</code>. Again the definitions in general are in cite{gg12}.</p><pre><code class="language-julia-repl">julia&gt; catalan(ComplexReflectionGroup(7),2,q)
Pol{Int64}: q⁷²+2q⁶⁰+3q⁴⁸+4q³⁶+3q²⁴+2q¹²+1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L1256-L1295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.matX" href="#Gapjm.PermRoot.matX"><code>Gapjm.PermRoot.matX</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>MatX(W,w)</code></p><p>Let  <code>W</code> be a  finite reflection group  on the space  <code>V</code> and let  <code>w</code> be a permutation  of the roots of <code>W</code>. The function <code>MatX</code> returns the matrix of <code>w</code>  acting on  <code>V</code>. This  is the  linear transformation  of <code>V</code> which acts trivially  on the orthogonal of  the coroots and has  same effect as <code>w</code> on the simple roots. The function makes sense more generally for an element of the normalizer of <code>W</code> in the whole permutation group of the roots.</p><pre><code class="language-julia-repl">julia&gt; W=reflection_subgroup(rootdatum(&quot;E7sc&quot;),1:6)
E₇₍₁₂₃₄₅₆₎=E₆

julia&gt; matX(W,longest(W))
7×7 Array{Int64,2}:
  0   0   0   0   0  -1  2
  0  -1   0   0   0   0  2
  0   0   0   0  -1   0  3
  0   0   0  -1   0   0  4
  0   0  -1   0   0   0  3
 -1   0   0   0   0   0  2
  0   0   0   0   0   0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L1150-L1174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.PermX" href="#Gapjm.PermRoot.PermX"><code>Gapjm.PermRoot.PermX</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>PermX(W,M::AbstractMatrix)</code></p><p>Let  <code>M</code> be  a linear  transformation of  reflection representation  of <code>W</code> which  preserves the set  of roots of  <code>parent(W)</code>, and normalizes <code>W</code> (for the  action of  matrices on  the right).  <code>PermX</code> returns the corresponding permutation  of the roots of <code>parent(W)</code>;  it returns <code>nothing</code> if <code>M</code> does not normalize the set of roots.</p><pre><code class="language-julia-repl">julia&gt; W=reflection_subgroup(rootdatum(&quot;E7sc&quot;),1:6)
E₇₍₁₂₃₄₅₆₎=E₆

julia&gt; PermX(W,matX(W,longest(W)))==longest(W)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L897-L913">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflections" href="#Gapjm.PermRoot.reflections"><code>Gapjm.PermRoot.reflections</code></a> — <span class="docstring-category">Function</span></header><section><div><p>list of same length as W.roots giving corresponding reflections</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.refleigen" href="#Gapjm.PermRoot.refleigen"><code>Gapjm.PermRoot.refleigen</code></a> — <span class="docstring-category">Function</span></header><section><div><p>&#39;refleigen(W)&#39;</p><p>Let  <code>W</code>  be  a  reflection  group  on the vector space <code>V</code>. <code>refleigen(W)</code> returns  the  list  for  each  conjugacy  classes  of the eigenvalues of an element of that class acting on <code>V</code>, as a list of <code>Root1</code>.</p><pre><code class="language-julia-repl">julia&gt; refleigen(coxgroup(:B,2))
5-element Array{Array{Root1,1},1}:
 [1, 1]
 [1, -1]
 [-1, -1]
 [1, -1]
 [ζ₄, ζ₄³]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L715-L731">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflchar" href="#Gapjm.PermRoot.reflchar"><code>Gapjm.PermRoot.reflchar</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reflchar(W,w)</code></p><p>Returns  the trace  of the  element <code>w</code>  of the  reflection group <code>W</code> as an endomorphism of the vector space <code>V</code> on which <code>W</code> acts. This is the same as <code>trace(matX(W,w))</code>.</p><p>julia-repl``` julia&gt; W=coxgroup(:B,3) B₃</p><p>julia&gt; reflchar(W,longest(W)) -3 julia-repl```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L679-L693">source</a></section><section><div><p><code>reflchar(W)</code></p><p>Returns  the reflection character of the  reflection group <code>W</code>. This is the same  as <code>map(c-&gt;reflchar(W,c),class-reps(W))</code>. When <code>W</code> is irreducible, it is also <code>CharTable(W).irr[charinfo(W)[:extRefl][2]]</code>.</p><pre><code class="language-julia-repl">julia&gt; reflchar(coxgroup(:A,3))
5-element Array{Int64,1}:
  3
  1
 -1
  0
 -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L696-L712">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.simple_conjugating_element" href="#Gapjm.PermRoot.simple_conjugating_element"><code>Gapjm.PermRoot.simple_conjugating_element</code></a> — <span class="docstring-category">Function</span></header><section><div><p>for each root element conjugative representative to root</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.simple_representatives" href="#Gapjm.PermRoot.simple_representatives"><code>Gapjm.PermRoot.simple_representatives</code></a> — <span class="docstring-category">Function</span></header><section><div><p>for each root index of simple representative</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Weyl.jl#L828">source</a></section><section><div><p>return for each root the index of the first simple root conjugate to it</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.invariant_form" href="#Gapjm.PermRoot.invariant_form"><code>Gapjm.PermRoot.invariant_form</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>invariant_form(W)</code></p><p>This  function returns the matrix <code>F</code>  of an Hermitian form invariant under the action of the reflection group <code>W</code>. That is, if <code>M</code> is the matrix of an element of <code>W</code>, then <code>M*F*M&#39;=F</code>.</p><pre><code class="language-julia-repl">julia&gt; W=ComplexReflectionGroup(4)
G₄

julia&gt; invariant_form(W)
2×2 Array{Cyc{Rational{Int64}},2}:
 1  0
 0  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L1361-L1377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.generic_order" href="#Gapjm.PermRoot.generic_order"><code>Gapjm.PermRoot.generic_order</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>generic_order(W,q)</code></p><p>returns  the &quot;compact&quot; generic order of <code>W</code> as a polynomial in <code>q</code>. This is <code>q^(Nₕ)Πᵢ(q^(dᵢ)-1)</code>  where <code>dᵢ</code>  are the  reflection degrees  and <code>Nₕ</code> the number  of reflecting hyperplanes. For a Weyl group, it is the order of the associated  semisimple  finite  reductive  group  over  the  field with <code>q</code> elements.</p><pre><code class="language-julia-repl">julia&gt; Pol(:q)
Pol{Int64}: q

julia&gt; PermRoot.generic_order(ComplexReflectionGroup(4),q)
Pol{Int64}: q¹⁴-q¹⁰-q⁸+q⁴</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L1409-L1425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.torus_order" href="#Gapjm.PermRoot.torus_order"><code>Gapjm.PermRoot.torus_order</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>torus_order(W,i,q)</code></p><p>returns  as a  polynomial in  <code>q</code> the  toric order  of the <code>i</code>-th conjugacy class  of <code>W</code>. This is the characteristic  polynomial of an element of that class  on  the  reflection  representation  of  <code>W</code>.  It is the same as the generic  order of the reflection subcoset  of <code>W</code> determined by the trivial subgroup and a representative of the <code>i</code>-th conjugacy class.</p><pre><code class="language-julia-repr">julia&gt; W=ComplexReflectionGroup(4);Pol(:q);

julia&gt; torus_order.(Ref(W),1:HasType.NrConjugacyClasses(W),q)
7-element Array{Pol{Cyc{Int64}},1}:
 q²-2q+1
 q²+2q+1
 q²+1
 q²-ζ₃q+ζ₃²
 q²+ζ₃q+ζ₃²
 q²+ζ₃²q+ζ₃
 q²-ζ₃²q+ζ₃</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L773-L795">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.parabolic_representatives" href="#Gapjm.PermRoot.parabolic_representatives"><code>Gapjm.PermRoot.parabolic_representatives</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>parabolic_representatives(W)</code></p><p>Returns   a   list   of   indices of roots of <code>W</code>   describing representatives  of orbits of parabolic subgroups under conjugation by <code>W</code>. For Coxeter groups, each orbit has a representative whose indices is a subset of <code>eachindex(gens(W))</code>. This may not be the case in general.</p><p>julia&gt; parabolic_representatives(coxgroup(:A,4)) 7-element Array{Array{Int64,1},1}:  []  [1]  [1, 2]  [1, 3]  [1, 2, 3]  [1, 2, 4]  [1, 2, 3, 4] gap&gt; ParabolicRepresentatives(ComplexReflectionGroup(3,3,3)); [ [  ], [ 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 20 ], [ 2, 3 ], [ 1, 2, 3 ] ]</p><p><code>parabolic_representatives(W,r)</code></p><p>If  a second  argument &lt;r&gt;  is given,  returns only  representatives of the parabolic subgroups of semisimple rank &lt;r&gt;. julia&gt; parabolic_representatives(coxgroup(:A,4),2) 2-element Array{Array{Int64,1},1}:  [1, 2]  [1, 3] gap&gt; ParabolicRepresentatives(ComplexReflectionGroup(3,3,3),2); [ [ 1, 2 ], [ 1, 3 ], [ 1, 20 ], [ 2, 3 ] ]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/PermRoot.jl#L940-L970">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.ComplexR.ComplexReflectionGroup" href="#Gapjm.ComplexR.ComplexReflectionGroup"><code>Gapjm.ComplexR.ComplexReflectionGroup</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>ComplexReflectionGroup(STnumber)</code></p><p><code>ComplexReflectionGroup(p,q,r)</code></p><p>The  first form of <code>ComplexReflectionGroup</code>  returns the complex reflection group which has Shephard-Todd number <code>STnumber</code>, see cite{ST54}. The second form returns the imprimitive complex reflection group <code>G(p,q,r)</code>.</p><pre><code class="language-julia-repl">julia&gt; G=ComplexReflectionGroup(4)
G₄

julia&gt; degrees(G)
2-element Array{Int64,1}:
 4
 6

julia&gt; length(G)
24

julia&gt; fakedegrees(G,Pol(:q))
7-element Array{Pol{Int64},1}:
 1       
 q⁴      
 q⁸      
 q⁷+q⁵   
 q⁵+q³   
 q³+q    
 q⁶+q⁴+q²

julia&gt; ComplexReflectionGroup(2,1,6)
B₆</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/ComplexR.jl#L6-L40">source</a></section></article><h1 id="Hecke-algebras-1"><a class="docs-heading-anchor" href="#Hecke-algebras-1">Hecke algebras</a><a class="docs-heading-anchor-permalink" href="#Hecke-algebras-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras" href="#Gapjm.HeckeAlgebras"><code>Gapjm.HeckeAlgebras</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This   module  ports   Chevie  functionality   for  Iwahori-Hecke  algebras associated to Coxeter groups.</p><p>Let  (W,S) be a Coxeter  system where <code>mₛₜ</code> is  the order of <code>st</code> for <code>s,t∈ S</code>. Let <code>R</code> be a commutative ring with 1 and for <code>s∈ S</code> let <code>uₛ₀,uₛ₁∈ R</code> be elements which depend ony on the conjugacy class of <code>s</code> in <code>W</code> (this is the same  as requiring that <code>uₛᵢ=uₜᵢ</code> whenever <code>mₛₜ</code> is odd). The Iwahori-Hecke algebra of <code>W</code> over <code>R</code> with parameters <code>uₛᵢ</code> is a deformation of the group algebra  of <code>W</code> over <code>R</code> defined as  follows: it is the unitary associative <code>R</code>-algebra generated by elements <code>Tₛ, s∈ S</code> subject to the relations:</p><p><span>$(Tₛ-uₛ₀)(Tₛ-uₛ₁)=0$</span> for all <code>s∈ S</code> (the quadratic relations)</p><p><span>$TₛTₜTₛ…= TₜTₛTₜ…$</span> with <code>mₛₜ</code> factors on each side (the braid relations)</p><p>If  <code>uₛ₀=1</code> and  <code>uₛ₁=-1</code> for  all <code>s</code>  then the quadratic relations become <code>Tₛ²=1</code> and the deformation of the group algebra is trivial.</p><p>Since  the generators <code>Tₛ</code> satisfy the  braid relations, the algebra <code>H</code> is in  fact a quotient of the group algebra of the braid group associated with <code>W</code>.  It follows that, if <code>w=s_1⋯ s_m</code>  is a reduced expression of <code>w ∈ W</code> then  the  product  <code>Tₛ_1⋯ Tₛ_m</code>  depends  only  on <code>w</code>. We will therefore denote by <code>T_w</code>. We have <code>T_1=1</code>.</p><p>If  one of <code>uₛ₀</code> or <code>uₛ₁</code> is invertible  in <code>R</code>, for example <code>uₛ₁</code>, then by changing  the generators  to <code>T′ₛ=-Tₛ/uₛ₁</code>,  and setting <code>qₛ=-uₛ₀/uₛ₁</code>, the braid  relations do no change  (since when <code>mₛₜ</code> is  odd we have <code>uₛᵢ=uₜᵢ</code>) but  the quadratic relations become  <code>(T′ₛ-qₛ)(T′ₛ+1)=0</code>. This last form is the  most common  form considered  in the  literature. Another common form, considered  in  the  context  of  Kazhdan-Lusztig  theory, is <code>uₛ₀=√qₛ</code> and <code>uₛ₁=-√qₛ⁻¹</code>.  The general form of parameters provided is a special case of general cyclotomic Hecke algebras, and can be useful in many contexts.</p><p>For  some  algebras  the  character  table,  and in general Kazhdan-Lusztig bases,  require a square root of <code>-uₛ₀uₛ₁</code>.  We provide a way to specify it with  the  field  <code>.rootpara</code>  which  can  be  given  when constructing the algebra. If not given a root is automatically extracted when needed (and we know  how to compute it) by the function <code>RootParameter</code>. Note however that sometimes  an  explicit  choice  of  root  is  necessary  which  cannot  be automatically determined.</p><p>There  is a universal choice  for <code>R</code> and <code>uₛᵢ</code>:  Let <code>uₛᵢ:s∈ S,i∈[0,1]</code> be indeterminates   such  that  <code>uₛᵢ=uₜᵢ</code>  whenever  <code>mₛₜ</code>  is  odd,  and  let <code>A=ℤ[uₛᵢ]</code> be the corresponding polynomial ring. Then the Hecke algebra <code>H</code> of  <code>W</code> over a  with parameters <code>uₛᵢ</code>  is called the <em>generic Iwahori-Hecke algebra</em>  of  with  <code>W</code>.  Any  other  algebra  with parameters <code>vₛᵢ</code> can be obtained  by specialization from  <code>H</code>: There is  a unique ring homomorphism <code>f:A  → R</code> such that <code>f(uₛᵢ)=vₛᵢ</code>  for all <code>i</code>. Then we  can view <code>R</code> as an <code>A</code>-module via <code>f</code> and we can identify the other algebra to <span>$R⊗ _A H$</span>.</p><p>The  elements <code>{T_w∣w∈ W}</code> actually form an  <code>R</code>-basis of <code>H</code> if one of the <code>uₛᵢ</code>  is invertible for all <code>s</code>. The  structure constants in that basis is obtained  as  follows.  To  multiply  <code>T_v</code>  by  <code>T_w</code>,  choose  a  reduced expression for <code>v</code>, say <code>v=s_1 ⋯ s_k</code> and apply inductively the formula:</p><p><span>$T_sT_w=T_{sw}$</span>               if <code>l(sw)=l(w)+1</code></p><p><span>$T_sT_w=-uₛ₀uₛ₁T_{sw}+(uₛ₀+uₛ₁)T_w$</span> if <code>l(sw)=l(w)-1</code>.</p><p>If all <code>s</code> we have <code>uₛ₀=q</code>, <code>uₛ₁=-1</code> then we call the corresponding algebra the one-parameter or Spetsial Iwahori-Hecke algebra associated with <code>W</code>; it can  be obtained with the  simplified call &#39;hecke(W,q)&#39;. Certain invariants of  the irreducible characters of  this algebra play a  special role in the representation  theory of the underlying  finite Coxeter groups, namely the <code>a</code>- and <code>A</code>-invariants. For basic properties of Iwahori-Hecke algebras and their  relevance to the representation theory of finite groups of Lie type, see for example Curtis and Reiner 1987, Sections~67 and 68.</p><p>In  the  following  example,  we  compute  the multiplication table for the <code>0</code>-Iwahori–Hecke algebra associated with the Coxeter group of type <code>A_2</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; H=hecke(W,0)             # One-parameter algebra with `q=0`
hecke(A₂,0)

julia&gt; T=Tbasis(H);             # Create the `T` basis

julia&gt; el=words(W)
6-element Array{Array{Int8,1},1}:
 []       
 [2]      
 [1]      
 [2, 1]   
 [1, 2]   
 [1, 2, 1]

julia&gt; T.(el)*permutedims(T.(el))        # multiplication table
6×6 Array{HeckeTElt{Perm{Int16},Int64,FiniteCoxeterGroup{Perm{Int16},Int64}},2}:
 T.    T₂     T₁     T₂₁    T₁₂    T₁₂₁ 
 T₂    -T₂    T₂₁    -T₂₁   T₁₂₁   -T₁₂₁
 T₁    T₁₂    -T₁    T₁₂₁   -T₁₂   -T₁₂₁
 T₂₁   T₁₂₁   -T₂₁   -T₁₂₁  -T₁₂₁  T₁₂₁ 
 T₁₂   -T₁₂   T₁₂₁   -T₁₂₁  -T₁₂₁  T₁₂₁ 
 T₁₂₁  -T₁₂₁  -T₁₂₁  T₁₂₁   T₁₂₁   -T₁₂₁
</code></pre><p>Thus,  we work  with algebras  with arbitrary  parameters. We will see that this also works on the level of characters and representations.</p><p>finally, benchmarks on julia 1.0.2</p><pre><code class="language-benchmark">julia&gt; function test_w0(n)
         W=coxgroup(:A,n)
         Tbasis(hecke(W,Pol([1],1)))(longest(W))^2
       end
test_w0 (generic function with 1 method)

julia&gt; @btime test_w0(7);
  132.737 ms (1788153 allocations: 157.37 MiB)</code></pre><p>Compare to GAP3 where the following function takes 0.92s</p><pre><code class="language-none">test_w0:=function(n)local W,T,H;
  W:=CoxeterGroup(&quot;A&quot;,n);H:=Hecke(W,X(Rationals));T:=Basis(H,&quot;T&quot;);
  T(LongestCoxeterWord(W))^2;
end;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/HeckeAlgebras.jl#L1-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.hecke" href="#Gapjm.HeckeAlgebras.hecke"><code>Gapjm.HeckeAlgebras.hecke</code></a> — <span class="docstring-category">Function</span></header><section><div><p>hecke( W [, parameter][,rootpara=r]) return a Hecke algebra for W</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; Pol(:q)
Pol{Int64}: q

julia&gt; H=hecke(W,q)
hecke(B₂,q)

julia&gt; H.para
2-element Array{Array{Pol{Int64},1},1}:
 [q, -1]
 [q, -1]

julia&gt; H=hecke(W,q^2,rootpara=q)
hecke(B₂,q²,rootpara=q)

julia&gt; H.para,rootpara(H)
(Array{Pol{Int64},1}[[q², -1], [q², -1]], Pol{Int64}[q, q])

julia&gt; H=hecke(W,[q^2,q^4],rootpara=[q,q^2])
hecke(B₂,Pol{Int64}[q², q⁴],rootpara=Pol{Int64}[q, q²])

julia&gt; H.para,rootpara(H)
(Array{Pol{Int64},1}[[q², -1], [q⁴, -1]], Pol{Int64}[q, q²])

julia&gt; H=hecke(W,9,rootpara=3)
hecke(B₂,9,rootpara=3)

julia&gt; H.para,rootpara(H)
([[9, -1], [9, -1]], [3, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/HeckeAlgebras.jl#L134-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.central_monomials" href="#Gapjm.HeckeAlgebras.central_monomials"><code>Gapjm.HeckeAlgebras.central_monomials</code></a> — <span class="docstring-category">Function</span></header><section><div><p>central_monomials(H)   Let  <code>H</code> be an Hecke  algebra for the reflection  group <code>W</code>. The function   returns  the  scalars  by  which  the  image  in  <code>H</code>  of  π  acts on the   irreducible  representations of  the Iwahori-Hecke  algebra. When  <code>W</code> is   irreducible, π is the generator of the center of the pure braid group. In   general,  it  is  the  product  of  such  elements  for  each irreducible   component. When <code>W</code> is an irreducible Coxeter group, π is the lift to the   braid group of the square of the longest element of <code>W</code>.</p><pre><code class="language-julia-repl">julia&gt; H=hecke(coxgroup(:H,3),Pol(:q))
hecke(H₃,q)

julia&gt; central_monomials(H)
10-element Array{Pol{Cyc{Int64}},1}:
 1  
 q³⁰
 q¹²
 q¹⁸
 q¹⁰
 q¹⁰
 q²⁰
 q²⁰
 q¹⁵
 q¹⁵</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/HeckeAlgebras.jl#L278-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.class_polynomials" href="#Gapjm.HeckeAlgebras.class_polynomials"><code>Gapjm.HeckeAlgebras.class_polynomials</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>class_polynomials(h)</code></p><p>returns the class polynomials of the Hecke element <code>h</code> of the Hecke algebra <code>H=h.H</code>  with respect  to representatives  <code>reps</code> of  minimal length in the conjugacy  classes  of  the  Coxeter  group  <code>W=H.W</code>.  Such  minimal length representatives  are given by  the function <code>classinfo(W)[:classtext]</code>. The vector  <code>p</code> of these polynomials has the property that if <code>X</code> is the matrix of  the values of  the irreducible characters  of <code>H</code> on  <code>T_w</code> (for <code>w</code> in <code>reps</code>),  then the product <code>X*p</code>  is the list of  values of the irreducible characters on <code>h</code>.</p><pre><code class="language-julia-repl">julia&gt; W=CoxSym(4)
𝔖 ₄

julia&gt; H=hecke(W,Pol(:q))
hecke(𝔖 ₄,q)

julia&gt; h=Tbasis(H)(longest(W))
T₁₂₁₃₂₁

julia&gt; p=class_polynomials(h)
5-element Array{Pol{Int64},1}:
 0        
 0        
 q²       
 q³-2q²+q 
 q³-q²+q-1</code></pre><p>The class polynomials were introduced in  cite{GP93}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/HeckeAlgebras.jl#L433-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.char_values" href="#Gapjm.HeckeAlgebras.char_values"><code>Gapjm.HeckeAlgebras.char_values</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>char_values(h)</code></p><p><code>h</code>  is an  element of  an Iwahori-Hecke  algebra <code>H</code>  (in any  basis). The function  returns the  values of  the irreducible  characters of <code>H</code> on <code>h</code> (the   method  used  is  to  convert  to   the  <code>T</code>  basis,  and  then  use <code>class_polynomials</code>).</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; H=hecke(W,q^2;rootpara=q)
hecke(B₂,q²,rootpara=q)

julia&gt; char_values(Cpbasis(H)(1,2,1))
5-element Array{Pol{Int64},1}:
 -q-q⁻¹        
 q+q⁻¹         
 0             
 q³+2q+2q⁻¹+q⁻³
 0             </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/HeckeAlgebras.jl#L518-L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.schur_elements" href="#Gapjm.HeckeAlgebras.schur_elements"><code>Gapjm.HeckeAlgebras.schur_elements</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>schur_elements(H)</code></p><p>returns the list of Schur elements for the (cyclotomic) Hecke algebra <code>H</code></p><pre><code class="language-julia-repl">julia&gt; H=hecke(ComplexReflectionGroup(4),Pol(:q))
hecke(G₄,Pol{Cyc{Int64}}[q, ζ₃, ζ₃²])

julia&gt; s=schur_elements(H)
7-element Array{Pol{Cyc{Rational{Int64}}},1}:
 q⁸+2q⁷+3q⁶+4q⁵+4q⁴+4q³+3q²+2q+1              
 2√-3+(6+4√-3)q⁻¹+12q⁻²+(6-4√-3)q⁻³+(-2√-3)q⁻⁴
 -2√-3+(6-4√-3)q⁻¹+12q⁻²+(6+4√-3)q⁻³+(2√-3)q⁻⁴
 2+2q⁻¹+4q⁻²+2q⁻³+2q⁻⁴                        
 (-2ζ₃-ζ₃²)q³+(3-√-3)q²+3q+3+√-3+(-ζ₃-2ζ₃²)q⁻¹
 (-ζ₃-2ζ₃²)q³+(3+√-3)q²+3q+3-√-3+(-2ζ₃-ζ₃²)q⁻¹
 q²+2q+2+2q⁻¹+q⁻²                             

julia&gt; CycPol.(s)
7-element Array{CycPol{Cyc{Rational{Int64}}},1}:
 Φ₂²Φ₃Φ₄Φ₆             
 (2√-3)q⁻⁴Φ₂²Φ′₃Φ′₆    
 (-2√-3)q⁻⁴Φ₂²Φ″₃Φ″₆   
 2q⁻⁴Φ₃Φ₄              
 (-2ζ₃-ζ₃²)q⁻¹Φ₂²Φ′₃Φ″₆
 (-ζ₃-2ζ₃²)q⁻¹Φ₂²Φ″₃Φ′₆
 q⁻²Φ₂²Φ₄              </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/HeckeAlgebras.jl#L544-L573">source</a></section></article><h1 id="Kazhdan-Lusztig-polynomials-and-bases-1"><a class="docs-heading-anchor" href="#Kazhdan-Lusztig-polynomials-and-bases-1">Kazhdan-Lusztig polynomials and bases</a><a class="docs-heading-anchor-permalink" href="#Kazhdan-Lusztig-polynomials-and-bases-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.KL" href="#Gapjm.KL"><code>Gapjm.KL</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This  module ports Chevie functionality for Kazhdan-Lusztig polynomials and bases.</p><p>Let  <code>ℋ</code> be  the Iwahori-Hecke algebra  of a Coxeter  system <code>(W,S)</code>, with quadratic  relations <code>(Tₛ-uₛ₀)(Tₛ-uₛ₁)=0</code>  for <code>s∈  S</code>. If  <code>-uₛ₀uₛ₁</code> has a square  root  <code>wₛ</code>,  we  can  scale  the  basis  <code>Tₛ</code>  to  get  a new basis <code>tₛ=-Tₛ/wₛ</code>    with   quadratic    relations   <code>(tₛ-vₛ)(tₛ+vₛ⁻¹)=0</code>   where <code>vₛ=wₛ/uₛ₁</code>.   The  most  general  case   when  Kazhdan-Lusztig  bases  and polynomials  can be defined is when the parameters <code>vₛ</code> belong to a totally ordered  abelian group <code>Γ</code>  for multiplication, see  Lus83. We set <code>Γ⁺= {γ∈ Γ∣γ&gt;0}</code> and <code>Γ⁻={γ⁻¹∣γ∈ Γ⁺}={γ∈ Γ∣γ&lt;0}</code>.</p><p>Thus  we assume <code>ℋ</code> defined over the ring <code>ℤ[Γ]</code>, the group algebra of <code>Γ</code> over  <code>ℤ</code>, and the quadratic  relations of <code>ℋ</code>  associate to each <code>s∈ S</code> a <code>vₛ∈  Γ⁺</code> such that  <code>(tₛ-vₛ)(tₛ+vₛ⁻¹)=0</code>. We also  set <code>qₛ=vₛ²</code> and define the  basis <code>Tₛ=vₛtₛ</code> with quadratic relations <code>(Tₛ-qₛ)(Tₛ+1)=0</code>; for <code>w∈ W</code> with reduced expression <code>w=s₁…sₙ</code> we define <code>q_w∈ Γ⁺</code> by <code>q_w^½=v_{s₁}…v_{sₙ}</code> and let <code>q_w=(q_w^½)²</code>.</p><p>We  define the bar involution on <code>ℋ</code>  by linearity: on <code>ℤ[Γ]</code> we define it by  <span>$\overline{∑_{γ∈ Γ}a_γγ}= ∑_{γ∈ Γ} a_γ γ⁻¹$</span> and we extend it to <code>ℋ</code> by  <span>$\overline  Tₛ=Tₛ⁻¹$</span>.  Then  the  Kazhdan-Lusztig  basis <code>C′_w</code> is defined  as  the  only  basis  of  <code>ℋ</code>  stable  by the bar involution and congruent to <span>$t_w$</span> modulo <span>$∑_{w∈ W}Γ⁻ t_w$</span>.</p><p>The  basis <code>C′_w</code> can be computed  as follows. We define elements <span>$R_{x,y}$</span> of  <code>ℤ[Γ]</code> by  <span>$T_y⁻¹=∑_x \overline{R_{x,y⁻¹}}  q_x⁻¹T_x$</span>. We  then define inductively  the Kazhdan-Lusztig  polynomials (in  this general  context we should  say the  Kazhdan-Lusztig elements  of <code>ℤ[Γ]</code>,  which belong  to the subalgebra  of <code>ℤ[Γ]</code> generated by  the <code>qₛ</code>) by <span>$P_{x,w}=τ_{≤(q_w/q_x)^½} (∑_{x&lt;y≤w}R_{x,y}P_{y,w})$</span>  where <code>τ</code>  is the  truncation: <span>$τ_≤\nu ∑_{γ∈ Γ} a_γγ= ∑_{γ≤\nu}a_γγ$</span>; the induction is thus on decreasing <code>x</code> for the Bruhat order  and  starts  at  <span>$P_{w,w}=1$</span>.  We  have  then  <span>$C′_w=∑_y q_w^{-1/2} P_{y,w}T_y$</span>.</p><p>The  Chevie code  for the  Kazhdan-Lusztig bases  <code>C</code>, <code>D</code> and their primed versions, has been initially written by Andrew Mathas around 1994, who also contributed  to  the  design  of  the programs dealing with Kazhdan-Lusztig bases. He also implemented some other bases, such as the Murphy basis which can  be  found  in  the  Chevie  contributions  directory. The code for the unequal  parameters  case  has  been  written  around  1999  by F.Digne and J.Michel. The other Kazhdan-Lusztig bases are computed in terms of the <code>C′</code> basis.</p><p>When  the <code>ℤ[Γ]</code> is a  Laurent polynomial ring the  bar operation is taking the  inverse of  the variables,  and truncation  is keeping terms of degree smaller or equal to that of <code>ν</code>. It is possible to use arbitrary groups <code>Γ</code> as   long   as   methods   <code>bar</code>:<span>$∑_{γ∈   Γ}   a_γγ↦  ∑_{γ∈  Γ}  a_γγ⁻¹$</span>, <code>positive_part</code>  : <span>$∑_{γ∈  Γ} a_γγ↦  ∑_{γ≥ 1}  a_γγ$</span> and <code>negative_part</code>: <span>$∑_{γ∈  Γ}  a_γγ  ↦  ∑_{γ≤  1}  a_γγ$</span>  have been defined on <code>ℤ[Γ]</code>. These operations   will   be   used   internally   by  the  programs  to  compute Kazhdan-Lusztig bases.</p><p>finally, benchmarks on julia 1.0.2</p><pre><code class="language-benchmark">julia&gt; function test_kl(W)
         q=Pol([1],1); H=hecke(W,q^2,rootpara=q)
         C=Cpbasis(H); T=Tbasis(H)
         [T(C(w)) for w in elements(W)]
       end
test_kl (generic function with 1 method)

julia&gt; @btime test_kl(coxgroup(:F,4));
2.265 s (22516606 allocations: 1.81 GiB)</code></pre><p>Compare to GAP3 where the following function takes 11s for F4</p><pre><code class="language-none">test_kl:=function(W)local q,H,T,C;
  q:=X(Rationals);H:=Hecke(W,q^2,q);
  T:=Basis(H,&quot;T&quot;);C:=Basis(H,&quot;C&#39;&quot;);
  List(Elements(W),e-&gt;T(C(e)));
end;</code></pre><p>Another benchmark:</p><pre><code class="language-benchmark">function test_kl2(W)
  el=elements(W)
  [KLPol(W,x,y) for x in el, y in el]
end

test_kl2 (generic function with 1 method)

julia&gt;@btime test_kl2(coxgroup(:F,4));
  8s (97455915 allocations: 6.79 GiB)</code></pre><p>Compare to GAP3 where the following function takes 42s for F4</p><pre><code class="language-none">test_kl2:=function(W)local el;
  el:=Elements(W);
  List(el,x-&gt;List(el,y-&gt;KazhdanLusztigPolynomial(W,x,y)));
end;</code></pre><p>We provide also functionality to study the Kazhdan-Lusztig left cells (for the equal-parameter Hecke algebra).</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:H,3)
H₃

julia&gt; c=LeftCells(W)
22-element Array{LeftCell{FiniteCoxeterGroup{Perm{Int16},Cyc{Int64}}},1}:
 LeftCell&lt;H₃: duflo= character=φ₁‚₀&gt;
 LeftCell&lt;H₃: duflo=123 character=φ₁‚₁₅&gt;
 LeftCell&lt;H₃: duflo=(15) character=φ₅‚₅&gt;
 LeftCell&lt;H₃: duflo=(10) character=φ₅‚₅&gt;
 LeftCell&lt;H₃: duflo=(14) character=φ₅‚₅&gt;
 LeftCell&lt;H₃: duflo=7 character=φ₅‚₅&gt;
 LeftCell&lt;H₃: duflo=(12) character=φ₅‚₅&gt;
 LeftCell&lt;H₃: duflo=(9,12) character=φ₅‚₂&gt;
 LeftCell&lt;H₃: duflo=(5,11) character=φ₅‚₂&gt;
 LeftCell&lt;H₃: duflo=13 character=φ₅‚₂&gt;
 ⋮
 LeftCell&lt;H₃: duflo=(8,13) character=φ₃‚₆+φ₃‚₈&gt;
 LeftCell&lt;H₃: duflo=(1,15) character=φ₃‚₆+φ₃‚₈&gt;
 LeftCell&lt;H₃: duflo=3 character=φ₃‚₁+φ₃‚₃&gt;
 LeftCell&lt;H₃: duflo=2 character=φ₃‚₁+φ₃‚₃&gt;
 LeftCell&lt;H₃: duflo=1 character=φ₃‚₁+φ₃‚₃&gt;
 LeftCell&lt;H₃: duflo=6 character=φ₄‚₃+φ₄‚₄&gt;
 LeftCell&lt;H₃: duflo=(13) character=φ₄‚₃+φ₄‚₄&gt;
 LeftCell&lt;H₃: duflo=(11) character=φ₄‚₃+φ₄‚₄&gt;
 LeftCell&lt;H₃: duflo=9 character=φ₄‚₃+φ₄‚₄&gt;</code></pre><p>see  also  the  functions  <code>elements</code>,  <code>character</code>,  <code>representation</code>  and <code>WGraph</code>  for left  cells. The  operations <code>length</code>,  <code>in</code> (which  refer to <code>elements</code>)  and <code>==</code> (which  compares Duflo involutions)  are also defined for  left cells. When  <code>Character(c)</code> has been  computed, then <code>c.prop[:a]</code> also  has been bound which holds the common value of Lusztig&#39;s <code>a</code>-function for the elements of <code>c</code> and The irreducible constituents of <code>character(c)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/KL.jl#L22-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.KL.KLPol" href="#Gapjm.KL.KLPol"><code>Gapjm.KL.KLPol</code></a> — <span class="docstring-category">Function</span></header><section><div><p>KLPol(W,y,w) returns the Kazhdan-Lusztig polynomial P_{y,w} of W</p><p>To  compute Kazhdan-Lusztig polynomials in  the one-parameter case it seems that  the best  approach still  is by  using the  recursion formula  in the original  article KL79. One can first run  a number of standard checks on a given  pair  of  elements  to  see  if the computation of the corresponding polynomial  can be reduced to a similar computation for elements of smaller length. One such check involves the notion of critical pairs (cf. Alv87): a pair  of elements <code>w₁,w₂∈  W</code> such that  <code>w₁≤w₂</code> is <em>critical</em>  if <code>ℒ(w₂) ⊆ ℒ(w₁)</code>  and <code>ℛ (w₂)⊆ ℛ (w₁)</code>, where <code>ℒ</code>  and <code>ℛ</code> denote the left and right descent  set, respectively.  Now if  <code>y≤w ∈  W</code> are arbitrary elements then there   always  exists  a  critical  pair   <code>z≤w</code>  with  <code>y≤z≤w</code>  and  then <code>P_{y,w}=P_{z,w}</code>.  Given two elements <code>y</code> and <code>w</code>, such a critical pair is found by the function &#39;critical_pair&#39;. Whenever the polynomial corresponding to a critical pair is computed then this pair and the polynomial are stored in the property <code>:klpol</code> of the underlying Coxeter group.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:B,3)
B₃

julia&gt; map(i-&gt;map(x-&gt;KLPol(W,one(W),x),elements(W,i)),1:W.N)
9-element Array{Array{Pol{Int64},1},1}:
 [1, 1, 1]
 [1, 1, 1, 1, 1]
 [1, 1, 1, 1, 1, 1, 1]
 [1, 1, 1, x+1, 1, 1, 1, 1]
 [x+1, 1, 1, x+1, x+1, 1, x+1, 1]
 [1, x+1, 1, x+1, x+1, x²+1, 1]
 [x+1, x+1, x²+x+1, 1, 1]
 [x²+1, x+1, 1]
 [1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/KL.jl#L223-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.Tbasis" href="#Gapjm.HeckeAlgebras.Tbasis"><code>Gapjm.HeckeAlgebras.Tbasis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:B,3)
B₃

julia&gt; Pol(:v);H=hecke(W,v^2,rootpara=v)
hecke(B₃,v²,rootpara=v)

julia&gt; C=Cpbasis(H);

julia&gt; T=Tbasis(H);

julia&gt; T(C(1,2))
v⁻²T.+v⁻²T₂+v⁻²T₁+v⁻²T₁₂</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/KL.jl#L384-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.KL.character" href="#Gapjm.KL.character"><code>Gapjm.KL.character</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>character(c)</code></p><p>Returns  a list <code>l</code>  such that the  character of <code>c.group</code>  afforded by the left cell <code>c</code> is <code>sum(CharTable(c.group).irr[l])</code>.</p><pre><code class="language-julia-repl">julia&gt; c=LeftCells(coxgroup(:G,2))[3]
LeftCell&lt;G₂: duflo=2 character=φ₂‚₁+φ′₁‚₃+φ₂‚₂&gt;

julia&gt; character(c)
3-element Array{Int64,1}:
 3
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/KL.jl#L429-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.representation-Tuple{LeftCell,Any}" href="#Gapjm.Chars.representation-Tuple{LeftCell,Any}"><code>Gapjm.Chars.representation</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>representation(c::LeftCell,H)</code></p><p>returns  a list of  matrices giving the  representation of <code>H</code>  on the left cell <code>c</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:H,3)
H₃

julia&gt; c=LeftCells(W)[3]
LeftCell&lt;H₃: duflo=(15) character=φ₅‚₅&gt;

julia&gt; Pol(:q);H=hecke(W,q^2;rootpara=q)
hecke(H₃,q²,rootpara=q)

julia&gt; representation(c,H)
3-element Array{Array{Pol{Int64},2},1}:
 [-1 0 … q 0; 0 -1 … q q; … ; 0 0 … q² 0; 0 0 … 0 q²]
 [-1 0 … 0 0; 0 q² … 0 0; … ; 0 q … -1 0; 0 q … 0 -1]
 [q² 0 … 0 0; 0 -1 … q 0; … ; 0 0 … q² 0; 0 0 … q -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/KL.jl#L552-L574">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.KL.LeftCells" href="#Gapjm.KL.LeftCells"><code>Gapjm.KL.LeftCells</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>LeftCells(W[,i])</code> left cells of <code>W</code> [in <code>i</code>-th 2-sided cell]   for the 1-parameter Hecke algebra <code>hecke(W,q)</code></p><p>The program uses precomputed data(see cite{GH14}) for exceptional types and for  type <code>:A</code>, so  is quite fast  for these types  (it takes 13 seconds to compute  the 101796 left cells for type  <code>E₈</code>). For other types, left cells are  computed from  first principles,  thus computing  many Kazhdan-Lusztig polynomials.  It takes 60  seconds to compute  the left cells  of <code>D₆</code>, for example.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; LeftCells(W)
4-element Array{LeftCell{FiniteCoxeterGroup{Perm{Int16},Int64}},1}:
 LeftCell&lt;G₂: duflo= character=φ₁‚₀&gt;
 LeftCell&lt;G₂: duflo=12 character=φ₁‚₆&gt;
 LeftCell&lt;G₂: duflo=2 character=φ₂‚₁+φ′₁‚₃+φ₂‚₂&gt;
 LeftCell&lt;G₂: duflo=1 character=φ₂‚₁+φ″₁‚₃+φ₂‚₂&gt;</code></pre><p>Printing such a record displays the character afforded by the left cell and its  Duflo involution; the Duflo involution <code>r</code>  is printed as a subset <code>I</code> of    <code>1:W.N</code>   such    that   <code>r=longest(reflection_subgroup(W,I))</code>,   see <code>describe_involution</code>.</p><p>If  a second argument <code>i</code> is given, the program returns only the left cells which  are in the <code>i</code>-th two-sided cell,  that is whose character is in the <code>i</code>-th family of <code>W</code> (see &quot;Families of unipotent characters&quot;).</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2);
julia&gt; LeftCells(W,1)
2-element Array{LeftCell{FiniteCoxeterGroup{Perm{Int16},Int64}},1}:
 LeftCell&lt;G₂: duflo=2 character=φ₂‚₁+φ′₁‚₃+φ₂‚₂&gt;
 LeftCell&lt;G₂: duflo=1 character=φ₂‚₁+φ″₁‚₃+φ₂‚₂&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/KL.jl#L702-L742">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.KL.LeftCell" href="#Gapjm.KL.LeftCell"><code>Gapjm.KL.LeftCell</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>LeftCell(W,w)</code></p><p>returns  a  record  describing  the  left  cell  of  <code>W</code>  for  <code>hecke(W,q)</code> containing element <code>w</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:E,8)
E₈

julia&gt; LeftCell(W,W((1:8)...))
LeftCell&lt;E₈: duflo=(42,43) character=φ₃₅‚₂&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/KL.jl#L792-L805">source</a></section></article><h1 id="Garside-monoids-and-groups,-braids.-1"><a class="docs-heading-anchor" href="#Garside-monoids-and-groups,-braids.-1">Garside monoids and groups, braids.</a><a class="docs-heading-anchor-permalink" href="#Garside-monoids-and-groups,-braids.-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside" href="#Gapjm.Garside"><code>Gapjm.Garside</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Garside  monoids are a general class  of monoids whose most famous examples are  the braid  and dual  braid monoids.  The implementation  of these last monoids is in the framework of a general implementation of Garside monoids.</p><p>To   define  them  we  first  need   to  introduce  some  vocabulary  about divisibility  in monoids. A <em>left divisor</em> of  <code>x</code> is a <code>d</code> such that there exists  <code>y</code> with <code>x=dy</code> (and then we say  that <code>x</code> is a <em>right multiple</em> of <code>d</code>).  We say that a monoid <code>M</code>  is left cancellable if an equality <code>dx=dy</code> implies  <code>x=y</code>. We define symmetrically  right divisors, left multiples and right cancellability. We say that <code>x</code> is an <em>atom</em> if it has no proper left divisor (that is a <code>d</code> such that <code>x=dy</code> with <code>y≠1</code>) apart from <code>1</code>. A <em>left gcd</em>  of <code>x</code> and <code>y</code> is a common left  divisor <code>d</code> of <code>x</code> and <code>y</code> such that any  other common left divisor is a left divisor of <code>d</code>. Similarly a <em>right lcm</em>  of <code>x</code> and  <code>y</code> is a  common multiple which  is a left divisor of any other common multiple.</p><p>We  call <em>Garside</em> a monoid <code>M</code> which:</p><ul><li>is left and right cancellable.</li><li>is generated by its atoms,  which are finite in number.</li><li>admits left and  right  gcds  and  lcms.</li><li>is such that any element has only finitely many left (or right) divisors.</li><li>admits a <em>Garside element</em>, which is an element <code>Δ</code> whose set of left and right divisors coincide and generate <code>M</code>.</li></ul><p>Garside  elements are not  unique, but there  is a unique  minimal one (for divisibility);  we assume a  Garside element <code>Δ</code>  has been chosen. Then the divisors  of <code>Δ</code> are called  the <em>simples</em> of <code>M</code>.  A Garside monoid embeds into  its group of fractions, which is  called a <em>Garside group</em> (a Garside group  may have  several distinct  Garside structures,  as we  will see for Braid groups of finite Coxeter groups).</p><p>We  also implement <em>locally Garside</em> monoids,  which are monoids where lcms do  not always exist, but exist when any common multiple exists; the set of simples  is then not defined using a  Garside element, but by the condition that  they contain the atoms and are  closed under lcms and taking divisors (see  [BDM01]); since it is not ensured by the existence of <code>Δ</code>, one has to add  the condition that  any element is  divisible by finitely many simples (but  the number of simples can be infinite). The main example is the braid monoid of an infinite Coxeter group. It is not known if these monoids embed in  their group of fractions (though that has been proved for braid monoids of Coxeter groups by Paris [Paris01]) and thus computing in the monoid does not help for computing in the group (only the monoid is implemented here).</p><p>What allows computing with Garside and locally Garside monoids, and Garside groups,  is the fact  that they admit  normal forms –-  these normal forms where exhibited for braid monoids of Coxeter groups by Deligne [Del72], who extended previous work of Brieskorn, Saito [BS72] and Garside [Gar69]:</p><p>(i) Let  <code>M</code> be a locally Garside monoid and let <code>b∈ M</code>. Then there is a unique maximal left simple divisor <code>α(b)</code> of <code>b</code>, called the <em>head</em> of <code>b</code> –- any other simple dividing <code>b</code> on the left divides <code>α(b)</code> on the left.</p><p>(ii) Assume  <code>M</code> is a Garside monoid, <code>Δ</code> is  its Garside element and <code>G</code> is its group  of fractions. Then,  given any element  <code>x∈ G</code>, there  is some power <code>Δⁱ</code> such that <code>Δⁱ x∈ M</code>.</p><p>A consequence of (i) is that any element has a canonical decomposition as a product of simples, called its left-greedy normal form. If we define <code>ω(x)</code> by  <code>x=α(x)ω(x)</code>, then the normal form of <code>x</code> is <code>α(x)α(ω(x))α(ω^2(x))…</code> We use  the normal form to represent elements  of <code>M</code>, and when <code>M</code> is Garside (ii)  to represent elements  of <code>G</code>: given  <code>x∈ G</code> we  compute the smallest power  <code>i</code>  such  that  <code>Δⁱ  x∈  M</code>,  and  we  represent  <code>x</code> by the couple <code>(i,Δ⁻ⁱx)</code>.  We are thus reduced to the case where <code>x∈ M</code>, not divisible by <code>Δ</code>,  where we represent  <code>x</code> by the  sequence of simples which constitutes its normal form. We now describe Artin-Tits braid monoids. Let <code>(W,S)</code> be a Coxeter system, that is <code>W</code> has presentation</p><p><code>⟨s∈ S∣s^2=1, sts⋯ =tst⋯   (mₛₜ factors on each side) for s,t∈ S⟩</code></p><p>for  some Coxeter matrix <code>mₛₜ</code> for <code>s,t∈ S</code>. The braid group <code>B</code> associated to <code>(W,S)</code> is the group defined by the presentation</p><p><code>⟨𝐬∈ 𝐒∣ 𝐬𝐭𝐬⋯ =𝐭𝐬𝐭⋯  (mₛₜ factors on each side) for 𝐬,𝐭∈ 𝐒⟩</code></p><p>The <em>positive</em> braid monoid <code>B⁺</code> associated to <code>W</code> is the monoid defined by the  presentation above –- it identifies to the submonoid of <code>B</code> generated by  <code>𝐒</code> by  the result  of Paris  mentioned above.  This monoid  is locally Garside,  with set of simples  in bijection with elements  of <code>W</code> and atoms the elements of <code>𝐒</code>; we will denote by <code>𝐖</code> the set of simples, and by <code>𝐰 ↦ w</code>  the bijection between simples and elements  of <code>W</code>. The group <code>W</code> has a length  defined  in  terms  of  reduced expressions. Similarly, having only homogeneous relations, <code>B⁺</code> has a natural length function. Then <code>𝐖</code> can be characterized  as the subset of the elements  of <code>B⁺</code> of the same length as their image in <code>W</code>.</p><p>If  <code>W</code> is finite, then <code>B⁺</code> is Garside with Garside element the element of <code>𝐖</code> whose image is the longest element  of <code>W</code>. A finite Coxeter group is also  a reflection group in  a real vector space,  thus in its complexified <code>V</code>,  and <code>B</code> has also a topological definition as the fundamental group of the  space <code>Vʳᵉᵍ/W</code>, where <code>Vʳᵉᵍ</code>  is the set of  elements of <code>V</code> which are fixed  by no  non-identity element  of <code>S</code>;  however, we  will not use this here.</p><p>Given a Coxeter group <code>W</code>,</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,4)
A₄

julia&gt; B=BraidMonoid(W)
BraidMonoid(A₄)</code></pre><p>constructs  the  associated  braid  monoid,  and  then  as  a  function &#39;B&#39; constructs  elements of the braid monoid (or group when <code>W</code> is finite) from a list of generators.</p><pre><code class="language-julia-repl">julia&gt; w=B(1,2,3,4)
1234

julia&gt; w^3
121321432.343

julia&gt; word(W,α(w^3))
9-element Array{Int64,1}:
 1
 2
 1
 3
 2
 1
 4
 3
 2

julia&gt; w^4
δ.232432

julia&gt; inv(w)
(1234)⁻¹</code></pre><p>As  seen in the fourth  line above, the function  &#39;α(b)&#39; returns the simple <code>α(b)∈ 𝐖</code> as an element of <code>W</code>.</p><p>How  an element of  a Garside group  is printed is  controlled by IOcontext &#39;:greedy&#39;.  By default, elements are printed  as fractions <code>a⁻¹b</code> where <code>a</code> and  <code>b</code> have no left common divisor. Each  of <code>a</code> and <code>b</code> is printed using its left-greedy normal form, that is a maximal power of the Garside element followed  the rest.  One can  print the  entire element  in the left-greedy normal  from by setting the &#39;:greedy&#39; IOContext; with the same <code>w</code> as above we have:</p><pre><code class="language-julia-repl">julia&gt; repr(w^-1,context=IOContext(stdout,:greedy=&gt;true,:limit=&gt;true))
&quot;δ⁻¹.232432&quot;</code></pre><p>Finally,  <code>repr</code> gives   <code>w</code>  back   in  a   form  which   after  assigning &#39;B=BraidMonoid(W)&#39; can be input back into Julia:</p><pre><code class="language-julia-repl">julia&gt; repr(w)
&quot;B(1,2,3,4)&quot;

julia&gt; repr(w^3)
&quot;B(1,2,1,3,2,1,4,3,2,3,4,3)&quot;

julia&gt; repr(w^-1)
&quot;B(-4,-3,-2,-1)&quot;</code></pre><p>In  general elements of  a Garside monoid  are displayed thus  as a list of their constituting atoms.</p><p>We  now describe the dual braid monoid.  For that, we first give a possible approach  to construct Garside monoids. Given a  group <code>W</code> and a set <code>S</code> of generators  of <code>W</code> as a monoid, we  define the length <code>l(w)</code> as the minimum number of elements of <code>S</code> needed to write <code>w</code>. We then define left divisors of   <code>x</code>  as  the  <code>d</code>   such  that  there  exists   <code>y</code>  with  <code>x=dy</code>  and <code>l(d)+l(y)=l(x)</code>.  We say that <code>w∈ W</code> is  balanced if its set of left and right  divisors coincide,  is a  lattice (where  upper and lower bounds are lcms and gcds) and generates <code>W</code>. Then we have:</p><p>suppose <code>w</code> is balanced and let <code>[1,w]</code> be its set of divisors (an interval for  the partial order  defined by divisibility).  Then the monoid <code>M</code> with generators  <code>[1,w]</code> and relations  <code>xy=z</code> whenever <code>xy=z</code>  holds in <code>W</code> and <code>l(x)+l(y)=l(z)</code>  is Garside,  with simples  <code>[1,w]</code> and  atoms <code>S</code>.  It is called the interval monoid defined by the interval <code>[1,w]</code>.</p><p>The  Artin-Tits braid monoid  is an interval  monoid by taking  for <code>S</code> the Coxeter generators, in which case <code>l</code> is the Coxeter length, and taking for <code>w</code>  the longest element of <code>W</code>. The dual monoid, constructed by Birman, Ko and  Lee  for  type  <code>A</code>  and  by  Bessis  for  all  well-generated complex reflection  groups, is obtained in  a similar way, by  taking this time for <code>S</code>  the set of all reflections, and for <code>w</code> a Coxeter element; then <code>l</code> is the  reflection length  &#39;reflength&#39; (for  well-generated complex reflection groups  whihc are not real <code>S</code> contains only those reflections which divide <code>w</code>  for the  reflection length);  for the  dual monoid  the simples are of cardinality  the  generalized  Catalan  numbers.  An  interval  monoid  has naturally  an inverse morphism from <code>M</code>  to <code>W</code>, called &#39;EltBraid&#39; which is the  quotient map from the  interval monoid to <code>W</code>  which sends back simple braids to <code>[1,w]</code>. #A  last notable  notion is  <em>reversible</em> monoids.  Since in Chevie we store #only  left normal forms, it is easy to compute left lcms and gcds, but hard #to  compute right ones.  But this becomes  easy to do  if the monoid has an #operation  &#39;reverse&#39;, which has the property that  &#39;a&#39; is a left divisor of #&#39;b&#39;  if and only if  &#39;reverse(a)&#39; is a right  divisor of &#39;reverse(b)&#39;. This #holds  for Artin-Tits  and dual  braid monoids;  Artin-Tits monoids  have a #reverse  operation which consists of reversing a word, written as a list of #atoms.  The dual monoid  also has a  reverse operation defined  in the same #way,  but this operation changes  monoid: it goes from  the dual monoid for #the  Coxeter element <code>w</code> to the dual  monoid for the Coxeter element <code>w⁻¹</code>. #The  operations &#39;RightLcm&#39; and  &#39;RightGcd&#39;, as well  quite a few algorithms #have faster implementations if the monoid has a reverse operation.</p><p>This module implements functions to solve the conjugacy problem and compute centralizers  in Garside groups, following the work of Franco, Gebhardt and Gonzalez-Meneses.</p><p>Two  elements <code>w</code> and <code>w&#39;</code> of a monoid  <code>M</code> are <em>conjugate</em> in <code>M</code> if there exists  <code>x∈ M</code> such that <code>wx=xw&#39;</code>; if  <code>M</code> satisfies the Öre conditions, it has  a  group  of  fractions  where  this  becomes  <code>x⁻¹wx=w&#39;</code>,  the  usual definition  of conjugacy. A special case  which is even closer to conjugacy in  the group is if there exists <code>y∈  M</code> such that <code>w=xy</code> and <code>w&#39;=yx</code>. This relation  is not transitive in general,  but we call <em>cyclic conjugacy</em> the transitive closure of this relation, a restricted form of conjugacy.</p><p>The  next  observation  is  that  if  <code>w,w&#39;</code>  are conjugate in the group of fractions  of the Garside monoid <code>M</code> then  they are conjugate in <code>M</code>, since if  <code>wx=xw&#39;</code> then  there is  a power  <code>Δⁱ</code> which  is central and such that <code>xΔⁱ∈ M</code>. Then <code>wxΔⁱ=xΔⁱ w&#39;</code> is a conjugation in <code>M</code>.</p><p>The  crucial observation for solving the  conjugacy problem is to introduce <code>inf(w):=sup{i such  that  Δⁱ   divides  w}</code>  and <code>sup(w):=inf{i such  that  w  divides Δⁱ}</code>, and to notice  that the number of  conjugates of <code>w</code> with  same <code>inf</code> and <code>sup</code> as <code>w</code>  is finite. Further, a  theorem of Birman shows  that the maximum <code>inf</code> and  minimum <code>sup</code> in a conjugacy class can be achieved simultaneously; the elements  achieving this are called the super summit set of <code>w</code>. Thus a way to  determine if two elements are conjugate  is to find a representative of both  of them in  their super summit  set, and then  solve conjugacy within that  set. This can also be used  to compute the centralizer of an element: if  we consider  the super  summit set  as the  objects of a category whose morphisms are the conjugations by simple elements, the centralizer is given by the endomorphisms of the given object.</p><p>We illustrate this on an example:</p><pre><code class="language-julia-repl">julia&gt; b=B(2,1,4,1,4)
214.14

julia&gt; c=B(1,4,1,4,3)
14.143

julia&gt; d=representative_operation(b,c)
(1)⁻¹21321432

julia&gt; b^d
14.143

julia&gt; centralizer_generators(b)
3-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 21.1         
 321432.213243
 4

julia&gt; C=conjcat(b;ss=:ss)
category with 10 objects and 32 generating maps

julia&gt; C.obj
10-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 1214.4
 214.14
 124.24
 1343.1
 14.124
 143.13
 24.214
 134.14
 13.134
 14.143</code></pre><p>There  is a faster  solution to the  conjugacy problem given in [gebgon10]: for  each <code>b∈ M</code>, they define a  particular simple left divisor of <code>b</code>, its <em>preferred  prefix</em>  such  that  the  operation  <em>sliding</em> which cyclically conjugates  <code>b</code> by  its preferred  prefix, is  eventually periodic, and the period  is contained in the super summit set  of <code>x</code>. We say that <code>x</code> is in its  sliding circuit if some  iterated sliding of <code>x</code>  is equal to <code>x</code>. The set  of sliding  circuits in  a given  conjugacy class  is smaller than the super  summit  set,  thus  allows  to  solve  the conjugacy problem faster. Continuing from the above example,</p><pre><code class="language-julia-repl">julia&gt; word(W,preferred_prefix(b))
2-element Array{Int64,1}:
 2
 1

julia&gt; b^B(preferred_prefix(b))
1214.4

julia&gt; b1=b^B(preferred_prefix(b))
1214.4

julia&gt; C=conjcat(b)
category with 2 objects and 6 generating maps

julia&gt; C.obj
2-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 1214.4
 1343.1</code></pre><p>Finally,  we have implemented  Hao Zheng&#39;s algorithm  to extract roots in a Garside monoid:</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; B=BraidMonoid(W)
BraidMonoid(A₃)

julia&gt; pi=B(B.delta)^2
δ²

julia&gt; root(pi,2)
δ

julia&gt; root(pi,3)
1232

julia&gt; root(pi,4)
132</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Garside.jl#L1-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.left_divisors" href="#Gapjm.Garside.left_divisors"><code>Gapjm.Garside.left_divisors</code></a> — <span class="docstring-category">Function</span></header><section><div><p>left_divisors( M, s)</p><p>all  the left divisors of the simple element <code>s</code> of the Garside monoid <code>M</code>, as  a vector  of vectors,  where the  i+1-th vector  holds the  divisors of length i in the atoms.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; B=BraidMonoid(W)
BraidMonoid(A₃)

julia&gt; map(x-&gt;B.(x),Garside.left_divisors(B,W(1,3,2)))
4-element Array{Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1},1}:
 [.]   
 [1, 3]
 [13]  
 [132] 

julia&gt; B=DualBraidMonoid(W)
DualBraidMonoid(A₃,c=[1, 3, 2])

julia&gt; map(x-&gt;B.(x),Garside.left_divisors(B,W(1,3,2)))
4-element Array{Array{Gapjm.Garside.GarsideElm{Perm{Int16},DualBraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1},1}:
 [.]                     
 [1, 2, 3, 4, 5, 6]      
 [12, 13, 15, 25, 34, 45]
 [δ]                     </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Garside.jl#L440-L471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.leftgcd" href="#Gapjm.Garside.leftgcd"><code>Gapjm.Garside.leftgcd</code></a> — <span class="docstring-category">Function</span></header><section><div><p>elts must be simples</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Garside.jl#L341-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.α" href="#Gapjm.Garside.α"><code>Gapjm.Garside.α</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>α(b)</code></p><p><code>b</code> should be an element of a Garside monoid.  <code>α</code> returns the first simple in the normal form of <code>b</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; b=BraidMonoid(W)(2,1,2,1,1)
121.1.1

julia&gt; word(W,α(b))
3-element Array{Int64,1}:
 1
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Garside.jl#L721-L740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.DualBraidMonoid" href="#Gapjm.Garside.DualBraidMonoid"><code>Gapjm.Garside.DualBraidMonoid</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Let  <code>W</code> be a well generated complex  reflection group and <code>c</code> be a Coxeter element  of <code>W</code> (if <code>W</code> is a Coxeter group and no <code>c</code> is given a particular one  is chosen  by making  the product  of elements  in a  partition of the Coxeter  diagram in two sets where  elements in each commute pairwise). The result  is the dual braid  monoid determined by <code>W</code>  and <code>c</code>: let <code>w</code> be an element  of <code>W</code> or a sequence  <code>s₁,…,sₙ</code> of integers indices of reflections of <code>W</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; B=DualBraidMonoid(W)
DualBraidMonoid(A₃,c=[1, 3, 2])

julia&gt; B(2,1,2,1,1)
12.1.1.1

julia&gt; B(-1,-2,-3,1,1)
(25.1)⁻¹1.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Garside.jl#L607-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.fraction" href="#Gapjm.Garside.fraction"><code>Gapjm.Garside.fraction</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fraction(b) returns a tuple <code>(x,y)</code>  of two  elements with  no non-trivial  common left divisor and such that <code>b=inv(x)*y</code>.</p><pre><code class="language-julia-repl">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A₃)

julia&gt; b=B( 2, 1, -3, 1, 1)
(23)⁻¹321.1.1

julia&gt; fraction(b)
(23, 321.1.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Garside.jl#L697-L712">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.word-Tuple{Gapjm.Garside.GarsideElm}" href="#Gapjm.word-Tuple{Gapjm.Garside.GarsideElm}"><code>Gapjm.word</code></a> — <span class="docstring-category">Method</span></header><section><div><p>word(b::GarsideElm) returns  a description  of <code>b</code>  as a  list of  the atoms  of which  it is a product.  If <code>b</code> is in the Garside group  but not the Garside monoid, it is represented  in  fraction  normal  form  where  as a special convention the inverses  of  the  atoms  are  represented  by  negating  the corresponding integer.</p><pre><code class="language-julia-repl">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A₃)

julia&gt; b=B(2,1,2,1,1)*inv(B(2,2))
(21)⁻¹1.12.21

julia&gt; word(b)
7-element Array{Int64,1}:
 -1
 -2
  1
  1
  2
  2
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Garside.jl#L750-L775">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.image" href="#Gapjm.Garside.image"><code>Gapjm.Garside.image</code></a> — <span class="docstring-category">Function</span></header><section><div><p>&#39;image(b)&#39;</p><p>This  function is defined only if &lt;b&gt;  is an element of an interval monoid, for instance a braid. It returns the image of &lt;b&gt; in the group of which the monoid  is an interval  monoid. For instance  it gives the  projection of a braid in an Artin monoid back to the Coxeter group.</p><p>gap&gt;  W := CoxeterGroupSymmetricGroup( 4 );; gap&gt;  b := Braid( W )(2, 1, 2, 1, 1); 121.1.1 gap&gt; p := EltBraid( b ); (1,3) gap&gt; CoxeterWord( W, p ); [ 1, 2, 1 ]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Garside.jl#L874-L889">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.representative_operation" href="#Gapjm.Groups.representative_operation"><code>Gapjm.Groups.representative_operation</code></a> — <span class="docstring-category">Function</span></header><section><div><p>representative_operation(b,b1[,F];ss=:sc)</p><p><code>b</code>  and <code>b1</code> should  be elements of  the same Garside  group. The function returns  <code>a</code> such that <code>b^a=b1</code> if such exists, and <code>nothing</code> otherwise. If an  argument <code>ss</code>  is given,  the computation  is done in the corresponding category  –- see &quot;conjcat&quot;.  If an argument  <code>F</code> is given  it should be an automorphism  of the braid monoid, like the Frobenius of a reflection coset attached  to <code>b.M.W</code>;  the computation  is then  done in  the corresponding <code>F</code>-conjugacy category.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; B=BraidMonoid(W)
BraidMonoid(D₄)

julia&gt; b=B(2,3,1,2,4,3);b1=B(1,4,3,2,2,2)
1432.2.2

julia&gt; representative_operation(b,b1)
(134312.23)⁻¹

julia&gt; c=representative_operation(b,b1;ss=:cyc)
232.2

julia&gt; b^c
1432.2.2

julia&gt; WF=spets(W,Perm(1,2,4))
³D₄

julia&gt; F=Frobenius(WF);

julia&gt; c=B(3,4,3,3,2,4)
343.324

julia&gt; representative_operation(b,c,F)
2312

julia&gt; ^(b,B(2,3,1,2),F)
343.324</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Garside.jl#L1156-L1200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.centralizer_generators" href="#Gapjm.Garside.centralizer_generators"><code>Gapjm.Garside.centralizer_generators</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>centralizer_generators(b[,F];ss=:sc)</code></p><p>a  list of generators of the centralizer of <code>b</code>. The computation is done by computing  the  endomorphisms  of  the  object  <code>b</code>  in the category of its sliding  circuits. If an argument <code>ss</code> is given, the computation is done in the corresponding category –- see <code>conjcat</code>.</p><p>If  an argument  <code>F</code> is  given it  should be  an automorphism  of the braid monoid,  like the Frobenius of a reflection coset attached to <code>b.M.W</code>; then the <code>F</code>-centralizer is computed.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; B=BraidMonoid(W)
BraidMonoid(D₄)

julia&gt; w=B(4,4,4)
4.4.4

julia&gt; cc=centralizer_generators(w)
8-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 (31432)⁻¹231432
 1              
 (2)⁻¹34.432    
 (1)⁻¹34.431    
 34.43          
 4              
 (32431)⁻¹132431
 2              

julia&gt; shrink(cc)
5-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 4            
 2            
 1            
 34.43        
 (3243)⁻¹13243

julia&gt; centralizer_generators(w;ss=:cyc)
Set{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}}} with 1 element:
  4

julia&gt; F=Frobenius(spets(W,Perm(1,2,4)));

julia&gt; centralizer_generators(w,F)
2-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 124      
 312343123</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Garside.jl#L1231-L1283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.conjcat" href="#Gapjm.Garside.conjcat"><code>Gapjm.Garside.conjcat</code></a> — <span class="docstring-category">Function</span></header><section><div><p>&#39;conjcat(b[,F];ss=:sc)&#39;</p><p>returns  the conjugacy category  of the summit  set of <code>b</code>  of the required type.  By default,  computes the  category of  sliding circuits  of <code>b</code>. If <code>ss==:ss</code>,  computes  the  super  summit  set.  If <code>ss==:cyc</code>, computes the cyclic  conjugacy category. Finally, if <code>ss==:inf</code> computes the category of all conjugate elements with same <code>Inf</code> as <code>b</code>.</p><p>If  an argument  <code>F</code> is  given it  should be  the Frobenius of a Reflection coset attached to <code>b.M.W</code>. Then the <code>F</code>-conjugacy category is returned.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,4)
A₄

julia&gt; w=BraidMonoid(W)(4,3,3,2,1)
43.321

julia&gt; conjcat(w)
category with 2 objects and 4 generating maps

julia&gt; conjcat(w).obj
2-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 32143
 21324

julia&gt; conjcat(w;ss=:ss).obj
4-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 32143
 13243
 21432
 21324</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Garside.jl#L1116-L1150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.endomorphisms" href="#Gapjm.Garside.endomorphisms"><code>Gapjm.Garside.endomorphisms</code></a> — <span class="docstring-category">Function</span></header><section><div><p>endomorphisms(C,o)  for category C, returns generators of the endomorphisms of C.obj[o]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Garside.jl#L962-L965">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.shrink" href="#Gapjm.Garside.shrink"><code>Gapjm.Garside.shrink</code></a> — <span class="docstring-category">Function</span></header><section><div><p>shrink(l)</p><p>The  list <code>l</code> is a  list of  elements of  the same Garside group <code>G</code>. This function  tries to find  another set of  generators of the  subgroup of <code>G</code> generated by the elements of <code>l</code>, of smaller total length (the length being counted  as returned by the function  <code>word</code>).</p><pre><code class="language-julia-repl">julia&gt; B=BraidMonoid(CoxSym(3))
BraidMonoid(𝔖 ₃)

julia&gt; b=[B(1)^3,B(2)^3,B(-2,-1,-1,2,2,2,2,1,1,2),B(1,1,1,2)]
4-element Array{Gapjm.Garside.GarsideElm{Perm{UInt8},BraidMonoid{Perm{UInt8},CoxSym{UInt8}}},1}:
 1.1.1              
 2.2.2              
 (1.12)⁻¹2.2.2.21.12
 1.1.12             

julia&gt; shrink(b)
2-element Array{Gapjm.Garside.GarsideElm{Perm{UInt8},BraidMonoid{Perm{UInt8},CoxSym{UInt8}}},1}:
 2  
 1  </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Garside.jl#L1404-L1428">source</a></section></article><h1 id="Classes-and-characters-of-reflection-groups-1"><a class="docs-heading-anchor" href="#Classes-and-characters-of-reflection-groups-1">Classes and characters of reflection groups</a><a class="docs-heading-anchor-permalink" href="#Classes-and-characters-of-reflection-groups-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars" href="#Gapjm.Chars"><code>Gapjm.Chars</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The  <code>CharTable</code> of a finite complex reflection group <code>W</code> is computed using the  decomposition of <code>W</code> in irreducible  groups (see <code>refltype</code>). For each irreducible  group the character  table is either  computed using recursive formulas  for the infinite series,  or read into the  system from a library file  for the  exceptional types.  Thus, character  tables can  be obtained quickly  even for very large groups  (e.g., E₈). Similar remarks apply for conjugacy classes.</p><p>The  conjugacy  classes  and  irreducible  characters of irreducible finite complex reflection groups have canonical labelings by certain combinatorial objects;  these labelings are used in the  tables we give. For the classes, these  are partitions or partition tuples  for the infinite series, or, for exceptional  Coxeter  groups,  Carter&#39;s  admissible  diagrams [@Car72]; for other  primitive  complex  reflection  groups  we  just  use  words  in the generators  to specify  the classes.  For the  characters, these  are again partitions  or partition tuples for the infinite series, and for the others they  are pairs  of two  integers <code>(d,e)</code>  where <code>d</code>  is the  degree of the character  and  <code>e</code>  is  the  smallest  symmetric  power  of the reflection representation  containing  the  given  character  as  a  constituent  (the <code>b</code>-invariant  of the character). This information is obtained by using the functions <code>classinfo</code> and <code>charinfo</code>. When you display the character table, the canonical labelings for classes and characters are those displayed.</p><p>A  typical example  is <code>coxgroup(:A,n)</code>,  the symmetric  group <code>𝔖ₙ₊₁</code> where classes and characters are parameterized by partitions of <code>n+1</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; CharTable(W)
CharTable(H(G(1,1,4)))
    │1111 211 22 31  4
────┼──────────────────
1111│   1  -1  1  1 -1
211 │   3  -1 -1  .  1
22  │   2   .  2 -1  .
31  │   3   1 -1  . -1
4   │   1   1  1  1  1

julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; ct=CharTable(W)
CharTable(W(G2))
     │A₀ Ã₁ A₁ G₂ A₂ A₁+Ã₁
─────┼─────────────────────
φ₁‚₀ │ 1  1  1  1  1     1
φ₁‚₆ │ 1 -1 -1  1  1     1
φ′₁‚₃│ 1  1 -1 -1  1    -1
φ″₁‚₃│ 1 -1  1 -1  1    -1
φ₂‚₁ │ 2  .  .  1 -1    -2
φ₂‚₂ │ 2  .  . -1 -1     2

julia&gt; ct.charnames
6-element Array{String,1}:
 &quot;\phi_{1,0}&quot;  
 &quot;\phi_{1,6}&quot;  
 &quot;\phi_{1,3}&#39;&quot; 
 &quot;\phi_{1,3}&#39;&#39;&quot;
 &quot;\phi_{2,1}&quot;  
 &quot;\phi_{2,2}&quot;  

julia&gt; ct.classnames
6-element Array{String,1}:
 &quot;A_0&quot;            
 &quot;\tilde A_1&quot;    
 &quot;A_1&quot;            
 &quot;G_2&quot;            
 &quot;A_2&quot;            
 &quot;A_1+\tilde A_1&quot;</code></pre><p>Recall  that our groups acts a reflection group on the vector space <code>V</code>, so have  fake degrees  (see &quot;fakeDegree&quot;).  The valuation  and degree of these give  two  integers  <code>b,B</code>  for  each  irreducible  character  of  <code>W</code> (see <code>charinf(W)[:b]</code>  and  <code>charinfo(W)[:B]</code>).  For  finite Coxeter groups, the valuation  and degree of  the generic degrees  of the one-parameter generic Hecke  algebra  give  two  more  integers  <code>a,A</code> (see <code>charinfo(W)[:a]</code> and <code>charinfo(W)[:A]</code>,  and [@Car85, Ch.11] for  more details). These will also be  used in the operations of truncated inductions explained in the chapter &quot;Reflection subgroups&quot;.</p><p>Iwahori-Hecke  algebras and  cyclotomic Hecke  algebras also have character tables, see the corresponding chapters.</p><p>We  now describe for each type our conventions for labeling the classes and characters.</p><p>Type  <code>Aₙ</code> (<code>n≥0</code>). In this  case we have  <code>W ≅ 𝔖ₙ₊₁</code>. The classes and characters  are labeled by partitions of <code>n+1</code>. The partition corresponding to  a class describes  the cycle type  for the elements  in that class; the representative   in  &#39;.classtext&#39;   is  the   concatenation  of  the  words corresponding  to each part, and to a part <code>i</code> is associated the product of <code>i-1</code>  consecutive generators (starting one  higher that the last generator used  for the previous  parts). The partition  corresponding to a character describes  the type of  the Young subgroup  such that the trivial character induced  from this  subgroup contains  that character with multiplicity <code>1</code> and such that every other character occurring in this induced character has a  higher <code>a</code>-value. Thus, the sign  character corresponds to the partition <code>(1ⁿ⁺¹)</code>  and  the  trivial  character  to  the  partition  <code>(n+1)</code>. The character of the reflection representation of <code>W</code> is labeled by <code>(n,1)</code>.</p><p>Type  <code>Bₙ</code> (<code>n≥2</code>). In this  case <code>W=W(Bₙ)</code> is  isomorphic to the wreath product  of the cyclic  group of order  <code>2</code> with the  symmetric group <code>𝔖ₙ</code>. Hence  the classes and characters are  parameterized by pairs of partitions such  that the total sum of their  parts equals <code>n</code>. The pair corresponding to  a class describes the signed cycle type for the elements in that class, as  in [@Car72]. We use the convention that  if <code>(λ,μ)</code> is such a pair then <code>λ</code>  corresponds  to  the  positive  and  <code>μ</code> to the negative cycles. Thus, <code>(1ⁿ,-)</code>  and <code>(-,1ⁿ)</code> label the trivial class and the class containing the longest  element, respectively.  The pair  corresponding to  an irreducible character is determined via Clifford theory, as follows.</p><p>We  have a semidirect product decomposition <code>W(Bₙ)=N ⋊ 𝔖ₙ</code> where <code>N</code> is the standard  <code>n</code>-dimensional  <code>𝔽₂ⁿ</code>-vector  space.  For  <code>a,b  ≥  0</code> such that <code>n=a+b</code> let <code>η_{a,b}</code> be the irreducible character of <code>N</code> which takes value <code>1</code>  on the first <code>a</code> standard basis vectors and value <code>-1</code> on the next <code>b</code> standard  basis vectors of <code>N</code>. Then  the inertia subgroup of <code>η_{a,b}</code> has the  form <code>T_{a,b}=N.(𝔖_a × 𝔖_b)</code> and  we can extend <code>η_{a,b}</code> trivially to an  irreducible  character  <code>η̃_{a,b}</code>  of  <code>T_{a,b}</code>.  Let  <code>α</code> and <code>β</code> be partitions  of <code>a</code> and <code>b</code>, respectively. We take the tensor product of the corresponding  irreducible characters of <code>𝔖_a</code> and <code>𝔖_b</code> and regard this as an  irreducible  character  of  <code>T_{a,b}</code>.  Multiplying this character with <code>η̃_{a,b}</code>  and  inducing  to  <code>W(Bₙ)</code>  yields an irreducible character <code>χ= χ_{(α,β)}</code>  of <code>W(Bₙ)</code>. This defines the correspondence between irreducible characters and pairs of partitions as above.</p><p>For example, the pair <code>((n),-)</code> labels the trivial character and <code>(-,(1ⁿ))</code> labels  the  sign  character.  The  character  of  the  natural  reflection representation is labeled by <code>((n-1),(1))</code>.</p><p>Type  <code>Dₙ</code> (<code>n≥4</code>). In this case <code>W=W(Dₙ)</code> can be embedded as a subgroup of index  <code>2</code> into the Coxeter  group <code>W(Bₙ)</code>. The intersection  of a class of <code>W(Bₙ)</code> with <code>W(Dₙ)</code> is either empty or a single class in <code>W(Dₙ)</code> or splits up  into two classes in  <code>W(Dₙ)</code>. This also leads  to a parameterization of the  classes of <code>W(Dₙ)</code> by pairs of  partitions <code>(λ,μ)</code> as before but where the  number of parts of <code>μ</code> is even and where there are two classes of this type  if <code>μ</code> is empty and all parts of  <code>λ</code> are even. In the latter case we denote  the two classes in <code>W(Dₙ)</code> by <code>(λ,+)</code> and <code>(λ,-)</code>, where we use the convention  that  the  class  labeled  by <code>(λ,+)</code> contains a representative which  can be written  as a word  in <code>{s₁,s₃,…,sₙ}</code> and  <code>(λ,-)</code> contains a representative which can be written as a word in <code>{s₂,s₃, …,sₙ}</code>.</p><p>By  Clifford theory the restriction of  an irreducible character of <code>W(Bₙ)</code> to  <code>W(Dₙ)</code>  is  either  irreducible  or  splits  up  into  two irreducible components.  Let <code>(α,β)</code> be  a pair of  partitions with total  sum of parts equal to <code>n</code>. If <code>α!=β</code> then the restrictions of the irreducible characters of  <code>W(Bₙ)</code> labeled  by <code>(α,β)</code>  and <code>(β,α)</code>  are irreducible and equal. If <code>α=β</code>  then the restriction of the character labeled by <code>(α,α)</code> splits into two  irreducible components  which we  denote by  <code>(α,+)</code> and <code>(α,-)</code>. Note that  this can only happen if <code>n</code> is  even. In order to fix the notation we use  a result of  [@Ste89] which describes  the value of  the difference of these  two  characters  on  a  class  of  the  form <code>(λ,+)</code> in terms of the character  values  of  the  symmetric  group  <code>𝔖_{n/2}</code>.  Recall that it is implicit  in the notation <code>(λ,+)</code> that all  parts of <code>λ</code> are even. Let <code>λ&#39;</code> be  the partition of <code>n/2</code> obtained by  dividing each part by <code>2</code>. Then the value  of <code>χ_{(α,-)}-χ_{(α,+)}</code> on an element in the class <code>(λ,+)</code> is given by  <code>2^{k(λ)}</code> times  the value  of the  irreducible character of <code>𝔖_{n/2}</code> labeled  by <code>α</code> on the class of  cycle type <code>λ&#39;</code>. (Here, <code>k(λ)</code> denotes the number of non-zero parts of <code>λ</code>.)</p><p>The  labels for the trivial, the  sign and the natural reflection character are the same as for <code>W(Bₙ)</code>, since these characters are restrictions of the corresponding characters of <code>W(Bₙ)</code>.</p><p>The groups <code>G(d,1,n)</code>. They  are isomorphic to the wreath product of the cyclic group of order <code>d</code> with  the  symmetric  group  <code>𝔖ₙ</code>.  Hence  the  classes  and characters are parameterized  by <code>d</code>-tuples of partitions such that the total sum of their parts  equals <code>n</code>. The words chosen  as representatives of the classes are, when <code>d&gt;2</code>, computed in a slightly different way than for <code>Bₙ</code>, in order to agree  with the words on which Ram  and Halverson compute the characters of the  Hecke algebra. First the parts of the <code>d</code> partitions are merged in one big  partition and sorted in  increasing order. Then, to  a part <code>i</code> coming from  the <code>j</code>-th partition is  associated the word <code>(l+1…1… l+1)ʲ⁻¹l+2…l+i</code> where <code>l</code> is the highest generator used to express the previous part.</p><p>The  <code>d</code>-tuple corresponding to an  irreducible character is determined via Clifford  theory in  a similar  way than  for the  <code>Bₙ</code> case.  The identity character  has the first  partition with one  part equal <code>n</code>  and the other ones  empty. The character of the  reflection representations has the first two  partitions with one part  equal respectively to <code>n-1</code>  and to <code>1</code>, and the other partitions empty.</p><p>The groups <code>G(de,e,n)</code>. They  are normal  subgroups of  index <code>e</code>  in <code>G(de,1,n)</code>.  The quotient is cyclic,  generated by the image <code>g</code>  of the first generator of <code>G(de,1,n)</code>. The  classes are parameterized as the  classes of <code>G(de,e,n)</code> with an extra information for a component of a class which splits.</p><p>According  to  [@Hu85],  a  class  <code>C</code>  of  <code>G(de,1,n)</code>  parameterized by a <code>de</code>-partition  <code>(S₀,…,S_{de-1})</code> is  in <code>G(de,e,n)</code>  if <code>e</code>  divides <code>∑ᵢ i ∑_{p∈  Sᵢ}p</code>. It splits in <code>d</code> classes for the largest <code>d</code> dividing <code>e</code> and all  parts of all <code>Sᵢ</code> and  such that <code>Sᵢ</code> is empty  if <code>d</code> does not divide <code>i</code>.  If <code>w</code> is in <code>C</code> then &#39;gⁱ w g⁻ⁱ&#39; for &#39;i in 0:d-1&#39; are representatives of  the  classes  of  <code>G(de,e,n)</code>  which  meet  <code>C</code>.  They are described by appending the integer <code>i</code> to the label for <code>C</code>.</p><p>The  characters are described by Clifford theory. We make <code>g</code> act on labels for  characters of <code>G(de,1,n)</code>  . The action  of <code>g</code> permutes circularly by <code>d</code>  the partitions in the <code>de</code>-tuple.  A character has same restriction to <code>G(de,e,n)</code>  as its transform by <code>g</code>.  The number of irreducible components of its restriction is equal to the order <code>k</code> of its stabilizer under powers of  <code>g</code>.  We  encode  a  character  of  <code>G(de,e,n)</code>  by first, choosing the smallest  for lexicographical order label  of a character whose restriction contains  it; then this label is periodic with a motive repeated <code>k</code> times; we  represent the  character by  one of  these motives,  to which we append <code>E(k)ⁱ</code> for &#39;i in 0:k-1&#39; to describe which component of the restriction we choose.</p><p>Types  <code>G₂</code> and <code>F₄</code>. The matrices  of character values and the orderings and  labelings of  the irreducible  characters are  exactly the  same as in [@Car85,  p.412/413]: in type <code>G₂</code> the character <code>φ₁,₃&#39;</code> takes the value -1 on  the reflection associated  to the long  simple root; in  type <code>F₄</code>, the characters  <code>φ₁,₁₂&#39;</code>, <code>φ₂,₄&#39;</code>, <code>φ₄,₇&#39;</code>, <code>φ₈,₉&#39;</code> and <code>φ₉,₆&#39;</code> occur in the induced  of the  identity from  the <code>A₂</code>  corresponding to the short simple roots;  the  pairs  (<code>φ₂,₁₆&#39;</code>,  <code>φ₂,₄″</code>)  and  (<code>φ₈,₃&#39;</code>, <code>φ₈,₉″</code>) are related by tensoring by sign; and finally <code>φ₆,₆″</code> is the exterior square of  the reflection representation. Note, however, that we put the long root at the left of the Dynkin diagrams to be in accordance with the conventions in [@Lus85, (4.8) and (4.10)].</p><p>The  classes  are  labeled  by  Carter&#39;s  admissible  diagrams  [@Car72]. A character is labeled by a pair <code>(d,b)</code> where <code>d</code> denotes the degree and <code>b</code> the  corresponding <code>b</code>-invariant. If there  are several characters with the same pair <code>(d,b)</code> we attach a prime to them, as in [@Car85].</p><p>Types  <code>E₆,E₇,E₈</code>. The character tables are obtained by specialization of those  of the Hecke algebra. The classes are labeled by Carter&#39;s admissible diagrams  [@Car72]. A  character is  labeled by  the pair <code>(d,b)</code> where <code>d</code> denotes  the degree and  <code>b</code> is the  corresponding <code>b</code>-invariant. For these types, this gives a unique labeling of the characters.</p><p>Non-crystallographic  types <code>I₂(m)</code>, <code>H₃</code>, <code>H₄</code>. In these cases we do not have  canonical  labelings  for  the  classes.  We  label  them  by reduced expressions.</p><p>Each  character for  type <code>H₃</code>  is uniquely  determined by the pair <code>(d,b)</code> where  <code>d</code> is the degree and  <code>b</code> the corresponding <code>b</code>-invariant. For type <code>H₄</code>  there are just  two characters (those  of degree <code>30</code>)  for which the corresponding  pairs are  the same.  These two  characters are nevertheless distinguished  by  their  fake  degrees:  the  character <code>φ₃₀,₁₀&#39;</code> has fake degree  <code>q¹⁰+q¹²+</code> higher terms, while <code>φ₃₀,₁₀″</code> has fake degree <code>q¹⁰+q¹⁴+</code> higher  terms. The characters in the table for type <code>H₄</code> are ordered in the same way as in [@AL82].</p><p>Finally,  the characters  of degree <code>2</code>  for type  <code>I₂(m)</code> are  ordered as follows.  The matrix representations affording the characters of degree <code>2</code> are given by: <code>ρ_j : s₁s₂ ↦ (\begin{array}{cc}E(m)^j&amp;0\0&amp;E(m)^{-j}\end{array}),  s₁↦(\begin{array}{cc}0&amp;1\1&amp;0\end{array}),</code> where  <code>1 ≤ j ≤  ⌊(m-1)/2⌋</code>. The reflection representation is  <code>ρ₁</code>. The  characters in  the table  are ordered by listing first the characters of degree 1 and then <code>ρ₁,ρ₂,…</code>.</p><p>Primitive complex reflection groups <code>G₄</code> to <code>G₃₄</code>. The  groups <code>G₂₃=H₃</code>, <code>G₂₈=F₄</code>, <code>G₃₀=H₄</code> are exceptional Coxeter groups and have  been  explained  above.  Similarly  for  the  other groups labels for characters  consist primarily  of the  pair <code>(d,b)</code>  where <code>d</code>  denotes the degree  and <code>b</code> is the corresponding  <code>b</code>-invariant. This is sufficient for <code>G₄</code>,  <code>G₁₂</code>, <code>G₂₂</code> and <code>G₂₄</code>. For other  groups there are pairs or triples of  characters which  have the  same <code>(d,b)</code>  value. We  disambiguate these according  to  the  conventions  of  [@Mal00]  for <code>G₂₇, G₂₉, G₃₁, G₃₃</code> and <code>G₃₄</code>:</p><ul><li>For <code>G₂₇</code>:</li></ul><p>The  fake degree  of <code>φ₃,₅&#39;</code>  (resp. <code>φ₃,₂₀&#39;</code>,  <code>φ₈,₉″</code>) has smaller degree that  of  <code>φ₃,₅″</code>  (resp.  <code>φ₃,₂₀″</code>,  <code>φ₈,₉&#39;</code>). The characters <code>φ₅,₁₅&#39;</code> and <code>φ₅,₆&#39;</code> occur with multiplicity 1 in the induced from the trivial character of  the parabolic subgroup  of type <code>A₂</code>  generated by the  first and third generator  (it is  asserted mistakenly  in [@Mal00]  that <code>φ₅,₆″</code>  does not occur in this induced; it occurs with multiplicity 2).</p><ul><li>For <code>G₂₉</code>:</li></ul><p>The  character  <code>φ₆,₁₀‴</code>  is  the  exterior  square  of <code>φ₄,₁</code>; its complex conjugate  is <code>φ₆,₁₀⁗</code>. The  character <code>φ₁₅,₄″</code> occurs  in <code>φ₄,₁⊗φ₄,₃</code>; the character  <code>φ₁₅,₁₂″</code>  is  tensored  by  the  sign  character from <code>φ₁₅,₄″</code>. Finally  <code>φ₆,₁₀&#39;</code> occurs in  the induced from  the trivial character of the standard parabolic subgroup of type <code>A₃</code> generated by the first, second and fourth generators.</p><ul><li>For <code>G₃₁</code>:</li></ul><p>The  characters <code>φ₁₅,₈&#39;</code>, <code>φ₁₅,₂₀&#39;</code> and <code>φ₄₅,₈″</code> occur in <code>φ₄,₁⊗φ₂₀,₇</code>; the character   <code>φ₂₀,₁₃&#39;</code>  is  complex  conjugate  of  <code>φ₂₀,₇</code>;  the  character <code>φ₄₅,₁₂&#39;</code>  is tensored by sign of <code>φ₄₅,₈&#39;</code>. The two terms of maximal degree of  the fakedegree of <code>φ₃₀,₁₀&#39;</code> are  <code>q⁵⁰+q⁴⁶</code> while for <code>φ₃₀,₁₀″</code> they are <code>q⁵⁰+2q⁴⁶</code>.</p><ul><li>For <code>G₃₃</code>:</li></ul><p>The  terms of  maximal degree  of the  fakedegree of <code>φ₁₀,₈&#39;</code> are <code>q²⁸+q²⁶</code> while  for <code>φ₁₀,₈&#39;</code> they are <code>q²⁸+q²⁴</code>. The  terms of maximal degree of the fakedegree   of  <code>φ₄₀,₅&#39;</code>  are  <code>q³¹+q²⁹</code>   while  for  <code>φ₄₀,₅″</code>  they  are <code>q³¹+2q²⁹</code>.  The character  <code>φ₁₀,₁₇&#39;</code> is  tensored by  sign of <code>φ₁₀,₈&#39;</code> and <code>φ₄₀,₁₄&#39;</code> is tensored by sign of <code>φ₄₀,₅&#39;</code>.</p><ul><li>For <code>G₃₄</code>:</li></ul><p>The  character <code>φ₂₀,₃₃&#39;</code> occurs in <code>φ₆,₁⊗φ₁₅,₁₄</code>. The character <code>φ₇₀,₉&#39;</code> is rational.  The character  <code>φ₇₀,₉″</code> occurs  in <code>φ₆,₁⊗φ₁₅,₁₄</code>.  The character <code>φ₇₀,₄₅&#39;</code>   is  rational.The   character  <code>φ₇₀,₄₅″</code>   is  tensored  by  the determinant  character of  <code>φ₇₀,₉″</code>. The  character <code>φ₅₆₀,₁₈&#39;</code> is rational. The character <code>φ₅₆₀,₁₈‴</code> occurs in <code>φ₆,₁⊗φ₃₃₆,₁₇</code>. The character <code>φ₂₈₀,₁₂&#39;</code> occurs    in   <code>φ₆,₁⊗φ₃₃₆,₁₇</code>.   The   character   <code>φ₂₈₀,₃₀″</code>   occurs   in <code>φ₆,₁⊗φ₃₃₆,₁₇</code>.  The  character  <code>φ₅₄₀,₂₁&#39;</code>  occurs  in <code>φ₆,₁⊗φ₁₀₅,₂₀</code>. The character  <code>φ₁₀₅,₈&#39;</code> is  complex conjugate  of <code>φ₁₀₅,₄</code>,  and <code>φ₈₄₀,₁₃&#39;</code> is complex  conjugate  of  <code>φ₈₄₀,₁₁</code>.  The  character  <code>φ₈₄₀,₂₃&#39;</code>  is  complex conjugate  of  <code>φ₈₄₀,₁₉</code>.  Finally  <code>φ₁₂₀,₂₁&#39;</code>  occurs  in induced from the trivial character of the standard parabolic subgroup of type <code>A₅</code> generated by the generators of <code>G₃₄</code> with the third one omitted.</p><p>For  the groups <code>G₅</code> and <code>G₇</code> we  adopt the following conventions. For <code>G₅</code> they are compatible with those of [@MR03] and [@BMM14].</p><ul><li>For <code>G₅</code>:</li></ul><p>We  let <code>W=ComplexReflectionGroup(5)</code>,  so the  generators are  <code>W(1)</code> and <code>W(2)</code>.</p><p>The  character <code>φ₁,₄&#39;</code> (resp. <code>φ₁,₁₂&#39;</code>, <code>φ₂,₃&#39;</code>) takes the value <code>1</code> (resp. <code>ζ₃</code>,  <code>-ζ₃</code>)  on  <code>W(1)</code>.  The  character  <code>φ₁,₈″</code> is complex conjugate to <code>φ₁,₁₆</code>,  and the character  <code>φ₁,₈&#39;</code> is complex  conjugate to <code>φ₁,₄&#39;</code> . The character  <code>φ₂,₅″</code> is complex  conjugate to <code>φ₂,₁</code>;  <code>φ₂,₅&#39;</code> take the value <code>-1</code> on <code>W(1)</code>. The character <code>φ₂,₇&#39;</code> is complex conjugate to <code>φ₂,₅&#39;</code>.</p><ul><li>For <code>G₇</code>:</li></ul><p>We  let <code>W=ComplexReflectionGroup(7)</code>,  so the  generators are <code>W(1)</code>, <code>W(2)</code> and <code>W(3)</code>.</p><p>The  characters  <code>φ₁,₄&#39;</code>  and  <code>φ₁,₁₀&#39;</code>  take  the value <code>1</code> on <code>W(2)</code>. The character  <code>φ₁,₈″</code> is complex  conjugate to <code>φ₁,₁₆</code>  and <code>φ₁,₈&#39;</code> is complex conjugate  to <code>φ₁,₄&#39;</code>. The characters <code>φ₁,₁₂&#39;</code>  and <code>φ₁,₁₈&#39;</code> take the value <code>ζ₃</code>  on <code>W(2)</code>. The character <code>φ₁,₁₄″</code> is complex conjugate to <code>φ₁,₂₂</code> and <code>φ₁,₁₄&#39;</code>  is complex conjugate to <code>φ₁,₁₀&#39;</code>. The character <code>φ₂,₃&#39;</code> takes the value  <code>-ζ₃</code> on  <code>W(2)</code> and  <code>φ₂,₁₃&#39;</code> takes  the value  <code>-1</code> on <code>W(2)</code>. The characters  <code>φ₂,₁₁″</code>, <code>φ₂,₅″</code>, <code>φ₂,₇‴</code> and  <code>φ₂,₁</code> are Galois conjugate, as well  as  the  characters  <code>φ₂,₇&#39;</code>,  <code>φ₂,₁₃&#39;</code>,  <code>φ₂,₁₁&#39;</code>  and  <code>φ₂,₅&#39;</code>. The character  <code>φ₂,₉&#39;</code> is complex  conjugate to <code>φ₂,₁₅</code>  and <code>φ₂,₉‴</code> is complex conjugate to <code>φ₂,₃&#39;</code>.</p><p>Finally,  for the remaining groups <code>G₆, G₈</code>  to <code>G₁₁, G₁₃</code> to <code>G₂₁</code>, <code>G₂₅</code>, <code>G₂₆</code>,  <code>G₃₂</code> and <code>G₃₃</code> there are only  pairs of characters with same value <code>(d,b)</code>.  We give labels uniformly to these characters by applying in order the following rules :</p><ul><li><p>If the two characters have  different fake degrees, label <code>φ_{d,b}&#39;</code> the  one  whose  fake  degree  is  minimal  for  the  lexicographic  order of  polynomials (starting with the highest term).</p></li><li><p>For the not yet labeled pairs, if only one of the two characters has the  property   that  in  its   Galois  orbit  at   least  one  character  is  distinguished by its <code>(d,b)</code>-invariant, label it <code>φ_{d,b}&#39;</code>.</p></li><li><p>For the not yet labeled pairs,  if the minimum of the <code>(d,b)</code>-value (for  the  lexicographic  order  <code>(d,b)</code>)  in  the  Galois  orbits  of the two  character  is different, label <code>φ_{d,b}&#39;</code> the character with the minimal  minimum.</p></li><li><p>We define now a new invariant  for characters: consider all the pairs of  irreducible   characters  <code>χ</code>  and  <code>ψ</code>  uniquely  determined  by  their  <code>(d,b)</code>-invariant such that <code>φ</code> occurs with non-zero multiplicity <code>m</code> in  <code>χ⊗ψ</code>.  We define  <code>t(φ)</code> to  be the  minimal (for  lexicographic order)  possible list <code>(d(χ),b(χ),d(ψ),b(ψ),m)</code>.</p></li></ul><p>For  the not  yet labeled  pairs, if  the t-invariants are different, label <code>φ_{d,b}&#39;</code> the character with the minimal <code>t</code>-invariant.</p><p>After  applying  the  last  rule  all  the  pairs  will be labelled for the considered  groups. The labelling obtained  is compatible for <code>G₂₅</code>, <code>G₂₆</code>, <code>G₃₂</code>  and <code>G₃₃</code> with that of [@Mal00]  and for <code>G₈</code> with that described in [@MR03].</p><p>We  should  emphasize  that  for  all  groups  with  a  few exceptions, the parameters  for characters do  not depend on  any non-canonical choice. The exceptions  are <code>G(de,e,n)</code> with <code>e&gt;1</code>, and <code>G₅</code>, <code>G₇</code>, <code>G₂₇</code>, <code>G₂₈</code>, <code>G₂₉</code> and  <code>G₃₄</code>, groups  which admit  outer automorphisms  preserving the set of reflections,  so choices  of a  particular value  on a particular generator must be made for characters which are not invariant by these automorphisms.</p><p>Labels  for the classes. For the exceptional complex reflection groups, the labels  for the classes represent the  decomposition of a representative of the  class as a product of generators, with the additional conventions that &#39;z&#39;  represents the generator  of the center  and for well-generated groups &#39;c&#39;  represents a Coxeter element  (a product of the  generators which is a regular element for the highest reflection degree).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Chars.jl#L1-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.CharTable" href="#Gapjm.Chars.CharTable"><code>Gapjm.Chars.CharTable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>CharTable is a structure to hold character tables of groups and Hecke  algebras</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Chars.jl#L785-L788">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.charinfo" href="#Gapjm.Chars.charinfo"><code>Gapjm.Chars.charinfo</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>charinfo(W)</code></p><p>returns   information  about  the  irreducible  characters  of  the  finite reflection group <code>W</code>. The result is a Dict with the following entries:</p><p><code>:charparams</code>:  contains  parameters  for  the  irreducible  characters  as described in the introduction. The parameters are tuples with one component for  each irreducible  component of  <code>W</code> (as  given by  <code>refltype</code>). For an irreducible   component  which  is  an  imprimitive  reflection  group  the component  of the <code>charparam</code> is a tuple of partitions (partitions for type <code>:A</code>,  double partitions  for type  <code>:B</code>), and  for a primitive irreducible group it is a pair <code>(d,e)</code> where <code>d</code> is the degree of the character and <code>e</code> is  the  smallest  symmetric  power  of  the  character  of  the reflection representation  which  contains  the  given  character  as  a component. In addition,  there is an ordinal number if more than one character shares the first two invariants.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:G,2))[:charparams]
6-element Array{Array{Array{Int64,1},1},1}:
 [[1, 0]]   
 [[1, 6]]   
 [[1, 3, 1]]
 [[1, 3, 2]]
 [[2, 1]]   
 [[2, 2]]   </code></pre><p><code>:charnames</code>:  strings describing the  irreducible characters, computed from the <code>charparams</code>. This is the same as <code>charnames(W)</code>.</p><p><code>:positionId</code>:  the position of the trivial character in the character table of <code>W</code>.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:D,4))[:positionId]
13</code></pre><p><code>:positionDet</code>:  Contains the position  of the determinant  character in the character   table  of  <code>W</code>. For Coxeter groups this is the sign character.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:D,4))[:positionDet]
4</code></pre><p><code>:extRefl</code>: Only present if <code>W</code> is irreducible, in which case the reflection representation  of <code>W</code> and all its exterior powers are irreducible. It then contains   the  position   of  the   exterior  powers   of  the  reflection representation in the character table.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:D,4))[:extRefl]
5-element Array{Int64,1}:
 13
 11
  5
  3
  4</code></pre><p><code>:b</code>:   contains  a  list  holding  the  <code>b</code>-function  for  all  irreducible characters  of <code>W</code>, that is,  for each character <code>χ</code>,  the valuation of the fake  degree of <code>χ</code>. The ordering of the result corresponds to the ordering of  the  characters  in  <code>CharTable(W)</code>.  The  advantage  of  this function compared  to calling <code>fakeDegrees</code> is that one  does not have to provide an indeterminate,  and that  it may  be much  faster to  compute than the fake degrees.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:D,4))[:b]
13-element Array{Int64,1}:
  6
  6
  7
 12
  4
  3
  6
  2
  2
  4
  1
  2
  0</code></pre><p><code>:B</code>:   contains  a  list  holding  the  <code>B</code>-function  for  all  irreducible characters  of <code>W</code>, that is, for each character <code>χ</code>, the degree of the fake degree  of <code>χ</code>. The ordering  of the result corresponds  to the ordering of the  characters in <code>CharTable(W)</code>. The  advantage of this function compared to  calling  <code>fakeDegrees</code>  is  that  one  does  not  have  to  provide  an indeterminate,  and that  it may  be much  faster to  compute than the fake degrees.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:D,4))[:B]
13-element Array{Int64,1}:
 10
 10
 11
 12
  8
  9
 10
  6
  6
  8
  5
  6
  0</code></pre><p><code>:a</code>:  Only  filled  for  Spetsial  groups.  Contains  a  list  holding  the <code>a</code>-function  for  all  irreducible  characters  of  the  Coxeter  group or Spetsial  reflection  group  <code>W</code>,  that  is,  for  each  character <code>χ</code>, the valuation  of the generic degree of <code>χ</code> (in the one-parameter Hecke algebra <code>hecke(W,Pol(:q))</code>  corresponding  to  <code>W</code>).  The  ordering  of  the result corresponds to the ordering of the characters in <code>CharTable(W)</code>.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:D,4))[:a]
13-element Array{Int64,1}:
  6
  6
  7
 12
  3
  3
  6
  2
  2
  3
  1
  2
  0</code></pre><p><code>:A</code>:  Only  filled  for  Spetsial  groups.  Contains  a  list  holding  the <code>A</code>-function  for  all  irreducible  characters  of  the  Coxeter  group or Spetsial  reflection group <code>W</code>, that is, for each character <code>χ</code>, the degree of   the  generic  degree  of  <code>χ</code>  (in  the  one-parameter  Hecke  algebra <code>hecke(W,Pol(:q))</code>  corresponding  to  <code>W</code>).  The  ordering  of  the result corresponds to the ordering of the characters in <code>CharTable(W)</code>.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:D,4))[:A]
13-element Array{Int64,1}:
 10
 10
 11
 12
  9
  9
 10
  6
  6
  9
  5
  6
  0</code></pre><p><code>:opdam</code>:  Contains the permutation of  the characters obtained by composing the  Opdam  involution  with  complex  conjugation. This permutation has an interpretation as a Galois action on the characters of <code>H=hecke(W,Pol(:x))</code>:  if <code>H</code> splits  by taking <code>v</code>  an <code>e</code>-th root of <code>x</code>, <code>.opdam</code> records the permutation effected by the Galois action <code>v-&gt;E(e)*v</code>.</p><pre><code class="language-julia-repl">julia&gt; charinfo(ComplexReflectionGroup(22))[:opdam]
(3,5)(4,6)(11,13)(12,14)(17,18)</code></pre><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:A,2))
Dict{Symbol,Any} with 9 entries:
  :a           =&gt; [3, 1, 0]
  :b           =&gt; [3, 1, 0]
  :positionId  =&gt; 3
  :charnames   =&gt; [&quot;111&quot;, &quot;21&quot;, &quot;3&quot;]
  :A           =&gt; [3, 2, 0]
  :B           =&gt; [3, 2, 0]
  :extRefl     =&gt; [3, 2, 1]
  :charparams  =&gt; [[[1, 1, 1]], [[2, 1]], [[3]]]
  :positionDet =&gt; 1</code></pre><p>For  irreducible groups, the returned  record contains sometimes additional information:</p><p>for  <code>F₄</code>: the entry <code>:kondo</code> gives the  labeling of the characters given by Kondo, also used in [@Lus85, (4.10)].</p><p>for  <code>E₆, E₇, E₈</code>: the  entry <code>:frame</code> gives the  labeling of the characters given by Frame, also used in [@Lus85, (4.11), (4.12), and (4.13)].</p><p>for  <code>G₂</code>: the  entry <code>:spaltenstein</code>  gives the  labeling of the characters given by Spaltenstein.</p><pre><code class="language-julia-repl">julia&gt; charinfo(coxgroup(:G,2))[:spaltenstein]
6-element Array{String,1}:
 &quot;1&quot;             
 &quot;\varepsilon&quot;  
 &quot;\varepsilon_l&quot;
 &quot;\varepsilon_c&quot;
 &quot;\theta&#39;&quot;      
 &quot;\theta&#39;&#39;&quot;     </code></pre><p>for  <code>G(de,e,2)</code>  even  <code>e</code>  and  <code>d&gt;1</code>:  the  entry  <code>:malle</code>  gives  the parameters for the characters used by Malle in [@Mal96].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Chars.jl#L466-L681">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.classinfo" href="#Gapjm.Chars.classinfo"><code>Gapjm.Chars.classinfo</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>classinfo(W)</code></p><p>returns  information about the  conjugacy classes of  the finite reflection group <code>W</code>. The result is a Dict with three entries:</p><p><code>:classtext</code>:  contains words in  the generators describing representatives of  each  conjugacy  class.  Each  word  is  a  list  of integers where the generator  <code>sᵢ</code>  is  represented  by  the  integer  <code>i</code>. For finite Coxeter groups, it is the same as <code>map(x-&gt;word(W,representative(x)),conjugacyclasses(W))</code>,   and   each  such representative  is of minimal length in its  conjugacy class and is a &quot;very good&quot; element in the sense of [@GM97].</p><p><code>:classparams</code>:  The  elements  of  this  list  are  tuples  which have one component  for each irreducible component of  <code>W</code>. These components for the infinite  series,  contain  partitions  or  partition tuples describing the class  (see  the  introduction).  For  the  exceptional Coxeter groups they contain Carter&#39;s admissible diagrams, see [@Car72]. For exceptional complex reflection  groups  they  contain  in  general  the  same information as in classtext.</p><p><code>:classnames</code>:  Contains strings describing the conjugacy classes, made out of the information in <code>:classparams</code>.</p><pre><code class="language-julia-repl">julia&gt; classinfo(coxgroup(:A,2))
Dict{Symbol,Any} with 5 entries:
  :classes     =&gt; [1, 3, 2]
  :orders      =&gt; [1, 2, 3]
  :classtext   =&gt; [[], [1], [1, 2]]
  :classnames  =&gt; [&quot;111&quot;, &quot;21&quot;, &quot;3&quot;]
  :classparams =&gt; [[1, 1, 1], [2, 1], [3]]</code></pre><p>See also the introduction of this section.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Chars.jl#L724-L760">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.fakedegree" href="#Gapjm.Chars.fakedegree"><code>Gapjm.Chars.fakedegree</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>fakedegree(W, φ, q)</code></p><p>returns  the  fake degree  of  the  character  of parameter  φ  (see :CharParams)  of  the  reflection  group <code>W</code>,  evaluated  at  <code>q</code>  (see &quot;fakeDegrees&quot; for a definition of the fake degrees).</p><pre><code class="language-julia-repl">julia&gt; Chars.fakedegree(coxgroup(:A,2),[[2,1]],Pol(:q))
Pol{Cyc{Int64}}: q²+q</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Chars.jl#L395-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.fakedegrees" href="#Gapjm.Chars.fakedegrees"><code>Gapjm.Chars.fakedegrees</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>fakedegrees(W , q)</code></p><p>returns  a list holding the fake degrees of the reflection group <code>W</code> on the vector  space <code>V</code>, evaluated at <code>q</code>. These are the graded multiplicities of the  irreducible characters of <code>W</code> in the quotient <code>SV/I</code> where <code>SV</code> is the symmetric  algebra of <code>V</code> and <code>I</code> is the ideal generated by the homogeneous invariants  of  positive  degree  in  <code>SV</code>.  The  ordering  of  the  result corresponds to the ordering of the characters in &#39;CharTable(W)&#39;.</p><pre><code class="language-julia-repl">julia&gt; fakedegrees(coxgroup(:A,2),Pol(:q))
3-element Array{Pol,1}:
 q³  
 q²+q
 1   </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Chars.jl#L418-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.representation" href="#Gapjm.Chars.representation"><code>Gapjm.Chars.representation</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>representation(c::LeftCell,H)</code></p><p>returns  a list of  matrices giving the  representation of <code>H</code>  on the left cell <code>c</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:H,3)
H₃

julia&gt; c=LeftCells(W)[3]
LeftCell&lt;H₃: duflo=(15) character=φ₅‚₅&gt;

julia&gt; Pol(:q);H=hecke(W,q^2;rootpara=q)
hecke(H₃,q²,rootpara=q)

julia&gt; representation(c,H)
3-element Array{Array{Pol{Int64},2},1}:
 [-1 0 … q 0; 0 -1 … q q; … ; 0 0 … q² 0; 0 0 … 0 q²]
 [-1 0 … 0 0; 0 q² … 0 0; … ; 0 q … -1 0; 0 q … 0 -1]
 [q² 0 … 0 0; 0 -1 … q 0; … ; 0 0 … q² 0; 0 0 … q -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/KL.jl#L552-L574">source</a></section><section><div><p><code>representation(W,i)</code></p><p>returns a list holding, for the <code>i</code>-th irreducible character of the complex reflection  group  <code>W</code>,  a  list  of  matrices  images  of  the  generating reflections  of <code>W</code>  in a  model of  the corresponding representation. This function  is based on the classification,  and is not yet fully implemented for   <code>G₃₄</code>;  88  representations  are  missing  out  of  169,  that  is  4 representations of dim. 105, 3 of dim. 315, 6 of dim. 420, 4 of dim.840 and those  of dim. 120, 140, 189, 280, 384,  504, 540, 560, 630, 720, 729, 756, 896, 945, 1260 and 1280.</p><pre><code class="language-julia-repl">julia&gt; representation(ComplexReflectionGroup(24),3)
3-element Array{Array{Cyc{Rational{Int64}},2},1}:
 [1 0 0; -1 -1 0; -1 0 -1]
 [-1 0 -1; 0 -1 (1-√-7)/2; 0 0 1]
 [-1 -1 0; 0 1 0; 0 (1+√-7)/2 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Chars.jl#L872-L891">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.representations" href="#Gapjm.Chars.representations"><code>Gapjm.Chars.representations</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>representations(W)</code></p><p>returns the representations of <code>W</code> (see <code>representation</code>).</p><pre><code class="language-julia-repl">julia&gt; representations(coxgroup(:B,2))
5-element Array{Array{Array{Int64,2},1},1}:
 [[1], [-1]]                
 [[1 0; -1 -1], [1 2; 0 -1]]
 [[-1], [-1]]               
 [[1], [1]]                 
 [[-1], [1]]                </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Chars.jl#L908-L922">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.InductionTable" href="#Gapjm.Chars.InductionTable"><code>Gapjm.Chars.InductionTable</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>InductionTable(u,g)</code></p><p>returns   an  object  describing  the   decomposition  of  the  irreducible characters  of the subgroup  <code>u</code> induced to  the group <code>g</code>.  In the default show method, the rows correspond to the characters of the parent group, and the  columns  to  those  of  the  subgroup.  The  return object has a field <code>scalar</code>  which is a <code>Matrix{Int}</code> containing  the induction table, and the other  fields contain labeling information  taken from the character tables of <code>u</code> and <code>g</code> when it exists.</p><pre><code class="language-julia-rep1">julia&gt; g=Group([Perm(1,2),Perm(2,3),Perm(3,4)])
Group([(1,2),(2,3),(3,4)])

julia&gt; u=Group( [ Perm(1,2), Perm(3,4) ])
Group([(1,2),(3,4)])

julia&gt; InductionTable(u,g)
Induction Table from Group([perm&quot;(1,2)&quot;,perm&quot;(3,4)&quot;]) to Group([perm&quot;(1,2)&quot;,perm&quot;(2,3)&quot;,perm&quot;(3,4)&quot;])
   │X.1 X.2 X.3 X.4
───┼────────────────
X.1│  .   1   .   .
X.2│  .   1   1   1
X.3│  1   1   .   .
X.4│  1   .   1   1
X.5│  1   .   .   .</code></pre><pre><code class="language-julia-repl">julia&gt; g=coxgroup(:G,2)
G₂

julia&gt; u=reflection_subgroup(g,[1,6])
G₂₍₁₅₎=A₂

julia&gt; InductionTable(u,g)
Induction Table from G₂₍₁₅₎=A₂ to G₂
     │111 21 3
─────┼─────────
φ₁‚₀ │  .  . 1
φ₁‚₆ │  1  . .
φ′₁‚₃│  1  . .
φ″₁‚₃│  .  . 1
φ₂‚₁ │  .  1 .
φ₂‚₂ │  .  1 .</code></pre><p>the rshow method allows to transmit attributes to the format method</p><pre><code class="language-julia-rep1">julia&gt; rshow(t;rows=[5],cols=[3,2])
Induction Table
    │2,11 11,2
────┼──────────
φ₂‚₁│   1    1</code></pre><p>It is also possible to TeX induction tables</p><p><strong>This function also works for Spets (Reflection Cosets)</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Chars.jl#L1122-L1183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.WGraphToRepresentation" href="#Gapjm.Chars.WGraphToRepresentation"><code>Gapjm.Chars.WGraphToRepresentation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">          Functions for W-graphs</code></pre><p>(Jean Michel june/december 2003 from  code/data of Geck, Marin, Alvis, Naruse, Howlett,Yin)    WGraphToRepresentation(semisimpleRank,graph,v) or WGraphToRepresentation(H,graph) Chevie stores some representations of some equal-parameter Hecke algebras as  <code>W</code>-graphs. For a Coxeter system <code>(W,S)</code>  a <code>W</code>-graph is defined by a set  of vertices  <code>C</code>; to  <code>x∈ C</code>  is attached  <code>I(x)⊂ S</code>  and to <code>(x,y)∈  C^2</code>  is  attached  an  `<code>edge&#39;&#39;</code>μ(x,y)<code>in  the field of definition  of</code>W<code>;  this defines  a representation  of the Hecke algebra with single rootparameter</code>v<code>on a space with basis</code>e<em>y</em>{y∈ C}` by:</p><p>T<em>s(e</em>y)=cases{-e<em>y&amp;                            if <code>s∈ I(y)</code><br/>             v^2 e</em>y+∑<em>{x∣s∈ I(x)} vμ(x,y)e</em>x&amp;otherwise}</p><p>The W-graphs  are stored in a  compact format to save  space. They are represented  as a  pair.  -The  first element is a list describing C; its elements are either a set I(x),  or an integer n  specifying to repeat the  previous element n more times. -The  second element is a list which  specifies mu. We first describe the mu-list  for symmetric  W-graphs (when  μ(x,y)=μ(y,x)). There  is one element  of the  mu-list for  each non-zero  value m  taken by μ, which consists of a pair whose first element is m and whose second element is a list  of  lists;  if  l  is  one  of  these  lists  each pair [l[1],l[i]] represents  an  edge  (x=l[1],y=l[i])  such that μ(x,y)=μ(y,x)=m. For non-symmetric  W-graphs, the first element of each pair in the mu-list is a  pair [m1,m2] and each edge [x,y] obtained from the lists in the second element has to be interpreted as mu(x,y)=m1 and mu(y,x)=m2.</p><p>The next function given a W-graph gr for some Hecke algebra of rank rk with rootparameter v constructs the rk matrices it specifies</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Chars.jl#L925-L958">source</a></section></article><h1 id="Reflection-cosets-1"><a class="docs-heading-anchor" href="#Reflection-cosets-1">Reflection cosets</a><a class="docs-heading-anchor-permalink" href="#Reflection-cosets-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Cosets" href="#Gapjm.Cosets"><code>Gapjm.Cosets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Let  <code>R</code> be a  root system in  the real vector  space <code>V</code>. We say that <code>F₀∈ GL(V)</code>  is an  <em>automorphism of  <code>R</code></em> if  it permutes  <code>R</code> and is of finite order  (finite  order  is  automatic  if  <code>R</code> generates <code>V</code>). It follows by cite[chap.  VI, S1.1, lemme 1]{Bou68} that  the dual <code>F₀*∈ GL(V*)</code> permutes the  coroots  <code>R*⊂  V*</code>;  thus  <code>F₀</code>  normalizes  the  reflection group <code>W</code> associated  to <code>R</code>, that is <code>w↦ F₀wF₀⁻¹</code> is an automorphism of <code>W</code>. Thus we get a reflection coset <code>WF₀</code>, which we call a <em>Coxeter coset</em>.</p><p>The  motivation for introducing Coxeter  cosets comes from automorphisms of algebraic  reductive groups, giving rise to non-split reductive groups over finite fields. Let <code>𝐆</code> be a connected reductive algebraic group <code>𝐆</code> over an algebraic  closure <code>𝔽̄_q</code> of a finite field <code>𝔽_q</code>, defined over <code>𝔽_q</code>; this corresponds  to a  Frobenius endomorphism  <code>F</code> so  that the finite group of rational  points <code>𝐆(𝔽_q)</code> identifies to the  subgroup <code>𝐆^F</code> of fixed points under <code>F</code>.</p><p>Let <code>𝐓</code> be a maximal torus of <code>𝐆</code>, and <code>Φ</code> (resp. <code>Φ*</code>) be the roots (resp. coroots)  of <code>𝐆</code> with respect  to <code>𝐓</code> in the  character group <code>X(𝐓)</code> (resp. the  group of one-parameter subgroups <code>Y(𝐓)</code>). Then <code>𝐆</code> is determined up to isomorphism  by <code>(X(𝐓),Φ,Y(𝐓),Φ*)</code>; this corresponds  to give a root system in   the  vector  space  <code>V=ℚ ⊗ X(𝐓)</code>   and  a  rational  reflection  group <code>W=N_𝐆(𝐓)/𝐓</code> acting on it.</p><p>If  <code>𝐓</code> is <code>F</code>-stable the Frobenius endomorphism <code>F</code> acts also naturally on <code>X(T)</code>  and defines thus  an endomorphism of  <code>V</code>, which is  of the form <code>q F₀</code>, where <code>F₀∈ GL(V)</code> is of finite order and normalizes <code>W</code>. We get thus a Coxeter  coset <code>WF₀⊂GL(V)</code>.  The data  <code>(X(𝐓), Φ,  Y(𝐓), Φ*,  F₀)</code>, and the integer   <code>q</code>  completely  determine  up   to  isomorphism  the  associated <em>reductive finite group</em> <code>𝐆^F</code>. Thus these data is a way of representing in the  essential  information  which  determines  a  finite  reductive group. Indeed, all properties of Chevalley groups can be computed from that datum: symbols  representing characters, conjugacy classes,  and finally the whole character table of <code>𝐆^F</code>.</p><p>It  turns out that  many interesting objects  attached to this datum depend only on <code>(V,W, F₀)</code>: the order of the maximal tori, the <em>fake degrees</em>, the order  of <code>𝐆^F</code>, symbols representing unipotent characters, Deligne-Lusztig induction  in  terms  of  <em>almost  characters</em>, the Fourier matrix relating characters  and almost  characters, etc…  (see, e.g.,  cite{BMM93}). It is thus  possible to extend their  construction to non-crystallographic groups (or  even to more general complex  reflection groups, see &quot;Spets&quot;); this is why  we did  not include  a root  system in  the definition of a reflection coset. However, unipotent conjugacy classes for instance depend on the root system.</p><p>We assume now that <code>𝐓</code> is contained in an <code>F</code>-stable Borel subgroup of <code>𝐆</code>. This  defines an order  on the roots,  and there is  a unique element <code>ϕ∈ W F₀</code>,  the  <em>reduced  element</em>  of  the  coset,  which  preserves the set of positive  roots.  It  thus  defines  a  <em>diagram  automorphism</em>, that is an automorphism  of the Coxeter system <code>(W,S)</code>.  This element is stored in the component  &#39;.phi&#39; of the coset record. It may be defined without mentioning the  roots,  as  follows:  <code>(W,F₀(S))</code>  is  another  Coxeter  system,  thus conjugate to <code>S</code> by a unique element of <code>W</code>, thus there is a unique element <code>ϕ∈ WF₀</code> which stabilizes <code>S</code> (a proof follows from cite[Theoreme 1, chap. V,  S  3]{Bou68}).  We  consider  thus  cosets  of the form <code>Wϕ</code> where <code>ϕ</code> stabilizes  <code>S</code>. The coset  <code>W ϕ</code> is  completely defined by the permutation &#39;.phi&#39;  when <code>𝐆</code> is semi-simple –- equivalently when <code>Φ</code> generates <code>V</code>; in this case we just need to specify &#39;phi&#39; to define the coset.</p><p>There is a slight generalisation of the above setup, covering in particular the  case of the Ree  and Suzuki groups. We  consider <code>𝐆^F</code> where <code>F</code> not a Frobenius  endomorphism, but  an isogeny  such that  some power  <code>F^n</code> is a Frobenius endomorphism. Then <code>F</code> still defines an endomorphism of <code>V</code> which normalizes  <code>W</code>; we define a real number <code>q</code> such that <code>F^n</code> is attached to an  <code>𝔽_{qⁿ}</code>-structure. Then we still have <code>F=q F₀</code> where <code>F₀</code> is of finite order  but <code>q</code> is no more an integer.  Thus <code>F₀∈ GL(V⊗ ℝ)</code> but <code>F₀∉ GL(V)</code>. For  instance, for the  Ree and Suzuki  groups, <code>F₀</code> is  an automorphism of order  <code>2</code> of <code>W</code>, which is of type <code>G₂</code>, <code>B₂</code> or <code>F₄</code>, and <code>q=√2</code> for <code>B₂</code> and  <code>F₄</code> and <code>q=√3</code>  for <code>G₂</code> This  can be constructed  starting from root systems  for <code>G₂</code>, <code>B₂</code> or  <code>F₄</code> where all the  roots have the same length. This kind of root system is <em>not</em> crystallographic. Such non-crystallographic  root systems exist for all finite Coxeter groups such as  the dihedral groups, <code>H₃</code> and <code>H₄</code>. We will call here <em>Weyl cosets</em> the cosets  corresponding to rational forms  of algebraic groups, which include thus some non-rational roots systems for <code>B₂</code>, <code>G₂</code> and <code>F₄</code>.</p><p>Conjugacy  classes and irreducible characters of Coxeter cosets are defined as  for  general  reflection  cosets.  For  irreducible  characters of Weyl cosets,  we choose (following Lusztig) for each <code>ϕ</code>-stable character of <code>W</code> a  particular extension to a character of  <code>W⋊ ⟨ϕ⟩</code>, which we will call the <em>preferred extension</em>. The <em>character table</em> of the coset <code>Wϕ</code> is the table of  the restrictions to  <code>Wϕ</code> of the  preferred extensions. The question of finding the conjugacy classes and character table of a Coxeter coset can be reduced to the case of irreducible root systems <code>R</code>.</p><ul><li><p>The automorphism <code>ϕ</code> permutes the irreducible components of <code>W</code>, and <code>Wϕ</code>  is a direct  product of cosets  where <code>ϕ</code> permutes cyclically the irreducible components of <code>W</code>. The preferred extension is defined to be the  direct  product  of  the  preferred  extension  in  each  of these situations.</p></li><li><p>Assume now that <code>Wϕ</code> is a  descent of scalars, that is the decomposition in irreducible components <code>W=W₁× ⋯ × Wₖ</code> is cyclically permuted by <code>ϕ</code>. Then there are natural bijections from the <code>ϕ</code>-conjugacy classes of <code>W</code> to  the <code>ϕᵏ</code>-conjugacy classes  of <code>W₁</code> as  well as from the <code>ϕ</code>-stable characters  of <code>W</code> to the <code>ϕᵏ</code>-stable  characters of <code>W₁</code>, which reduce the  definition of preferred  extensions on <code>Wϕ</code>  to the definition for <code>W₁ϕᵏ</code>.</p></li><li><p>Assume now  that <code>W</code>  is the  Coxeter group  of an  irreducible root system.   <code>ϕ</code>  permutes  the  simple   roots,  hence  induces  a  graph automorphism  on  the  corresponding  Dynkin  diagram.  If  <code>ϕ=1</code>  then conjugacy  classes and  characters coincide  with those  of the Coxeter group <code>W</code>.</p></li></ul><p>The  nontrivial cases for crystallographic roots  systems are (the order of <code>ϕ</code>  is written as left exponent to  the type): <code>²Aₙ</code>, <code>²Dₙ</code>, <code>³D₄</code>, <code>²E₆</code>. For  non-crystallographic root  systems where  all the  roots have the same length the additional cases <code>²B₂</code>, <code>²G₂</code>, <code>²F₄</code> and <code>²I₂(k)</code> arise.</p><ul><li><p>In  case  <code>³D₄</code>  the  group  <code>W⋊ ⟨ϕ⟩</code>  can be embedded into the Coxeter  group of type <code>F₄</code>, which induces a labeling for the conjugacy classes of the coset. The preferred extension is chosen as the (single) extension with rational values.</p></li><li><p>In case  <code>²Dₙ</code> the  group <code>W⋊ ⟨ϕ⟩</code>  is isomorphic  to a Coxeter group of type <code>Bₙ</code>. This induces a canonical labeling for the conjugacy classes  of the coset and allows to define the preferred extension in a combinatorial  way  using  the  labels  (pairs  of  partitions) for the characters of the Coxeter group of type <code>Bₙ</code>.</p></li><li><p>In the remaining crystallographic cases <code>ϕ</code> identifies to <code>-w₀</code> where <code>w₀</code>  is the longest element of <code>W</code>.  So, there is a canonical labeling of  the conjugacy classes and characters of  the coset by those of <code>W</code>. The  preferred extensions  are defined  by describing  the signs of the character values on <code>-w₀</code>.</p></li></ul><p>The  most general  construction of  a Coxeter  coset is  by starting from a Coxeter   datum   specified   by   the   matrices   of   &#39;simpleRoots&#39;  and &#39;simpleCoroots&#39;,  and  giving  in  addition  the  matrix &#39;F0Mat&#39; of the map <code>F₀:V→ V</code> (see the commands  &#39;CoxeterCoset&#39; and &#39;CoxeterSubCoset&#39;). As for Coxeter  groups,  the  elements  of  <code>Wϕ</code>  are  uniquely  determined by the permutation  they  induce  on  the  set  of  roots  <code>R</code>.  We consider these permutations as &#39;Elements&#39; of the Coxeter coset.</p><p>Coxeter  cosets are implemented by a struct which points to a Coxeter datum record  and  has  additional  fields  holding &#39;F0Mat&#39; and the corresponding element  &#39;phi&#39;. Functions on the coset (for example, &#39;classinfo&#39;) are about properties  of  the  group  coset  <code>W  ϕ</code>  ;  however, most definitions for elements of untwisted Coxeter groups apply without change to elements in <code>W ϕ</code>:  e.g., if we define the length of  an element <code>wϕ∈ Wϕ</code> as the number of positive  roots it sends to negative ones, it  is the same as the length of <code>w</code>,  i.e., <code>ϕ</code> is of length <code>0</code>, since <code>ϕ</code> has been chosen to preserve the set of positive roots. Similarly, the &#39;Coxeter word&#39; describing <code>wϕ</code> is the same as the one for <code>w</code>, etc…</p><p>We associate to a Coxeter coset <code>Wϕ</code> a <em>twisted Dynkin diagram</em>, consisting of  the Dynkin diagram of <code>W</code> and  the graph automorphism induced by <code>ϕ</code> on this  diagram (this specifies the  group <code>W⋊ ⟨F⟩</code>, mentioned above, up to  isomorphism). See the  functions &#39;ReflectionType&#39;, &#39;ReflectionName&#39; and &#39;Diagram&#39; for Coxeter cosets.</p><p>Below  is an example showing first how to <em>not</em> define, then how to define, the Weyl coset for a Suzuki group:</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; spets(W,Perm(1,2))
ERROR: matrix F must preserve the roots
Stacktrace:
 [1] error(::String) at ./error.jl:33
 [2] spets(::Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}, ::Array{Int64,2}) at /home/jmichel/julia/Gapjm/src/Cosets.jl:241 (repeats 2 times)
 [3] top-level scope at REPL[19]:1

julia&gt; W=coxgroup(:Bsym,2)
Bsym₂

julia&gt; spets(W,Perm(1,2))
²Bsym₂

julia&gt; CharTable(W)
CharTable(H(G(2,1,2)))
   │11. 1.1 .11 2. .2
───┼──────────────────
11.│  1   1   1 -1 -1
1.1│  2   .  -2  .  .
.11│  1  -1   1 -1  1
2. │  1   1   1  1  1
.2 │  1  -1   1  1 -1</code></pre><p>A <em>subcoset</em> <code>Hwϕ</code> of <code>Wϕ</code> is given by a reflection subgroup <code>H</code> of <code>W</code> and an  element <code>w</code> of <code>W</code>  such that <code>wϕ</code> induces  an automorphism of the root system of <code>H</code>. For algebraic groups, this corresponds to a rational form of a  reductive subgroup of maximal rank.  For example, if <code>Wϕ</code> corresponds to the  algebraic group <code>𝐆</code> and  <code>H</code> is the trivial  subgroup, the coset <code>Hwϕ</code> corresponds to a maximal torus <code>𝐓_w</code> of type <code>w</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:Bsym,2)
Bsym₂

julia&gt; WF=spets(W,Perm(1,2))
²Bsym₂

julia&gt; subspets(WF,Int[],W(1))
.Φ‴₈</code></pre><p>A subgroup <code>H</code> which is a parabolic subgroup corresponds to a rational form of  a Levi  subgroup of  <code>𝐆</code>. The  command &#39;twistings&#39;  gives all rational forms of such a Levi.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; twistings(W,[1])
2-element Array{Gapjm.Cosets.FCC{Int16,FiniteCoxeterSubGroup{Perm{Int16},Int64}},1}:
 Ã₁Φ₁
 Ã₁Φ₂

julia&gt; twistings(W,[2])
2-element Array{Gapjm.Cosets.FCC{Int16,FiniteCoxeterSubGroup{Perm{Int16},Int64}},1}:
 A₁Φ₂
 A₁Φ₁</code></pre><p>Notice how we distinguish between subgroups generated by short roots and by long  roots. A general  <code>H</code> corresponds to  a reductive subgroup of maximal rank.  Here we consider the subgroup generated  by the long roots in <code>B₂</code>, which  corresponds to a  subgroup of type  <code>SL₂× SL₂</code> in <code>SP₄</code>, and show its possible rational forms.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; twistings(W,[2,4])
2-element Array{Gapjm.Cosets.FCC{Int16,FiniteCoxeterSubGroup{Perm{Int16},Int64}},1}:
 (A₁A₁)
 A₁×A₁ </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Cosets.jl#L1-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.degrees-Tuple{Spets}" href="#Gapjm.degrees-Tuple{Spets}"><code>Gapjm.degrees</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>degrees(WF::Spets)</code></p><p>Let  <code>W</code> be  the group  of the  reflection coset  <code>WF</code>, and  let <code>V</code> be the vector  space  of  dimension  &#39;rank(W)&#39;  on  which <code>W</code> acts as a reflection group.  Let  <code>f₁,…,fₙ</code>  be  the  basic  invariants  of <code>W</code> on the symmetric algebra  <code>SV</code> of <code>V</code>;  they can be  chosen so they  are eigenvectors of the matrix  <code>WF.F</code>. The corresponding  eigenvalues are called  the <em>factors</em> of <code>F</code> acting on <code>V</code>; they characterize the coset –- they are equal to 1 only for  the trivial  coset. The  <em>generalized degrees</em>  of <code>WF</code>  are the pairs formed of the reflection degrees and the corresponding factor.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:E,6)
E₆

julia&gt; WF=spets(W)
E₆

julia&gt; phi=W(6,5,4,2,3,1,4,3,5,4,2,6,5,4,3,1);

julia&gt; HF=subspets(WF,2:5,phi)
³D₄Φ₃

julia&gt; Diagram(HF)
ϕ acts as (1,2,4) on the component below
  O 2
  ￨
O—O—O
1 3 4

julia&gt; degrees(HF)
6-element Array{Tuple{Int64,Cyc{Int64}},1}:
 (1, ζ₃) 
 (1, ζ₃²)
 (2, 1)  
 (4, ζ₃) 
 (6, 1)  
 (4, ζ₃²)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/ComplexR.jl#L104-L144">source</a></section></article><h1 id="Unipotent-characters-1"><a class="docs-heading-anchor" href="#Unipotent-characters-1">Unipotent characters</a><a class="docs-heading-anchor-permalink" href="#Unipotent-characters-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch" href="#Gapjm.Uch"><code>Gapjm.Uch</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Let  <code>𝐆</code> be a connected reductive group defined over the algebraic closure of  a finite field <code>𝔽_q</code>, with corresponding Frobenius automorphism <code>F</code>, or more  generally  let  <code>F</code>  be  an  isogeny  of  <code>𝐆</code> such that a power is a Frobenius (this covers the Suzuki and Ree groups).</p><p>If  <code>𝐓</code>  is  an  <code>F</code>-stable  maximal  torus  of  <code>𝐆</code>,  and  <code>𝐁</code> is a (not necessarily  <code>F</code>-stable)  Borel  subgroup  containing  <code>𝐓</code>,  we  define the <em>Deligne-Lusztig</em>  variety <code>X_𝐁={g𝐁 ∈ 𝐆 /𝐁 ∣ g𝐁 ∩ F(g𝐁 )≠∅ }</code>. This variety has  a  natural  action  of  <code>𝐆  ^F</code>  on  the  left,  so  the corresponding <em>Deligne-Lusztig  virtual  module</em>  <code>∑ᵢ  (-1)ⁱ  Hⁱ_c(X_𝐁,ℚ̄  _ℓ)</code> also. The character of this virtual module is the <em>Deligne-Lusztig</em> character <code>R_𝐓 ^𝐆 (1)</code>; the notation reflects the fact that one can prove that this character does  not  depend  on  the  choice  of  <code>𝐁</code>.  Actually,  this  character is parameterized by an <code>F</code>-conjugacy class of <code>W</code>: if <code>𝐓₀⊂𝐁₀</code> is an <code>F</code>-stable pair,  there is an unique <code>w∈ W=N_𝐆 (𝐓₀)/𝐓₀</code> such that the triple <code>(𝐓,𝐁,F)</code> is  <code>𝐆</code>-conjugate to <code>(𝐓₀,𝐁₀,wF)</code>. In this case we denote <code>R_w</code> for <code>R_𝐓^𝐆 (1)</code>; it depends only on the <code>F</code>-class of <code>w</code>.</p><p>The  <em>unipotent characters</em> of  <code>𝐆 ^F</code> are  the irreducible constituents of the <code>R_w</code>. In a similar way that the unipotent classes are a building block for  describing the conjugacy  classes of a  reductive group, the unipotent characters  are  a  building  block  for  the  irreducible  characters of a reductive  group.  They  can  be  parameterized  by combinatorial data that Lusztig  has attached just to the coset <code>Wφ</code>, where <code>φ</code> is the finite order automorphism  of  <code>X(𝐓₀)</code>  such  that  <code>F=qφ</code>.  Thus, from the viewpoint of Chevie, they are objects combinatorially attached to a Coxeter coset.</p><p>A  subset  of  the  unipotent  characters, the <em>principal series</em> unipotent characters,   can  be  described  in  an   elementary  way.  They  are  the constituents  of <code>R₁</code>, or equivalently the characters of the virtual module defined  by the cohomology of <code>X_{𝐁 ₀}</code>,  which is the discrete variety <code>(𝐆 /𝐁₀)^F</code>;  the virtual  module reduces  to the  actual module <code>ℚ̄ _ℓ[(𝐆 /𝐁₀) ^F]</code>.   Thus  the   Deligne-Lusztig  induction   <code>R_𝐓₀^𝐆  (1)</code>  reduces  to Harish-Chandra  induction,  defined  as  follows:  let  <code>𝐏  =𝐔  ⋊ 𝐋</code> be an <code>F</code>-stable  Levi decomposition of an <code>F</code>-stable parabolic subgroup of <code>𝐆</code>. Then  the <em>Harish-Chandra</em> induced <code>R_𝐋^𝐆</code> of  a character <code>χ</code> of <code>𝐋^F</code> is the  character <code>Ind_{𝐏^F}^{𝐆 ^F}χ̃</code>, where <code>χ̃</code> is the lift to <code>𝐏^F</code> of <code>χ</code> via  the quotient <code>𝐏^F/𝐔 ^F=𝐋^F</code>;  Harish-Chandra induction is a particular case  of <em>Lusztig induction</em>,  which is defined  when <code>𝐏</code> is not <code>F</code>-stable using  the variety <code>X_𝐔  ={ g𝐔 ∈𝐆  /𝐔 ∣ g𝐔  ∩ F(g𝐔 )≠∅}</code>,  and gives for an <code>𝐋^F</code>-module  a  virtual  <code>𝐆  ^F</code>-module.  Like  ordinary  induction, these functors  have adjoint  functors going  from representations  of <code>𝐆  ^F</code> to representations   (resp.   virtual   representations)   of   <code>𝐋^F</code>   called Harish-Chandra restriction (resp. Lusztig restriction).</p><p>The  commuting  algebra  of  <code>𝐆^F</code>-endomorphisms  of  <code>R_{𝐓₀}^𝐆(1)</code>  is  an Iwahori-Hecke  algebra for <code>W^φ</code>, with parameters  which are some powers of <code>q</code>;  they  are  all  equal  to  <code>q</code>  when  <code>W^φ=W</code>.  Thus principal series unipotent characters correspond to characters of <code>W^φ</code>.</p><p>To  understand the  decomposition of  Deligne-Lusztig characters,  and thus unipotent  characters,  is  is  useful  to  introduce  another set of class functions  which are parameterized  by irreducible characters  of the coset <code>Wφ</code>.  If  <code>χ</code>  is  such  a  character,  we  define  the associated <em>almost character</em> by: <code>Rᵪ=|W|⁻¹∑_{w∈ W}χ(wφ) R_w</code>. The reason to the name is that these  class  function  are  close  to irreducible characters: they satisfy <code>⟨Rᵪ, R_ψ⟩_{𝐆^F}=δ_{χ,ψ}</code>;  for  the  linear  and  unitary group they are actually  unipotent characters (up to sign in the latter case). They are in general  sum (with  rational coefficients)  of a  small number of unipotent characters  in  the  same  <em>Lusztig  family</em>  (see  &quot;Families  of unipotent characters&quot;).  The degree of <code>Rᵪ</code> is a polynomial in <code>q</code> equal to the fake degree  of  the  character  <code>χ</code>  of  <code>Wφ</code>  (see  &quot;Functions  for Reflection cosets&quot;).</p><p>We  now describe the parameterization of unipotent characters when <code>W^φ=W</code>, thus  when the coset <code>Wφ</code> identifies with <code>W</code> (the situation is similar but a  bit more difficult to describe  in general). The (rectangular) matrix of scalar  products  <code>⟨ρ, Rᵪ⟩_{𝐆 ^F}</code>,  when  characters of <code>W</code> and unipotent characters  are arranged in the right  order, is block-diagonal with rather small blocks which are called <em>Lusztig families</em>.</p><p>For  the characters of <code>W</code> a family <code>𝓕</code> corresponds to a block of the Hecke algebra  over a ring called the Rouquier  ring. To <code>𝓕</code> Lusztig associates a small  group <code>Γ</code> (not bigger  than <code>(ℤ/2)^n</code>, or <code>𝔖ᵢ</code>  for <code>i≤5</code>) such that the  unipotent  characters  in  the  family  are parameterized by the pairs <code>(x,θ)</code>  taken up to  <code>Γ</code>-conjugacy, where <code>x∈Γ</code>  and <code>θ</code> is an irreducible character  of  <code>C_Γ(x)</code>.  Further,  the  elements  of  <code>𝓕</code>  themselves  are parameterized  by a  subset of  such pairs,  and Lusztig  defines a pairing between  such pairs which computes the scalar product <code>⟨ρ, Rᵪ⟩_{𝐆^F}</code>. For more details see &quot;DrinfeldDouble&quot;.</p><p>A  second parameterization  of unipotent  character is  via <em>Harish-Chandra series</em>.  A character is called <em>cuspidal</em> if all its proper Harish-Chandra restrictions  vanish. There are few  cuspidal unipotent characters (none in linear   groups,  and  at   most  one  in   other  classical  groups).  The <code>𝐆^F</code>-endomorphism  algebra of an  Harish-Chandra induced <code>R_{𝐋^F}^{𝐆^F}λ</code>, where <code>λ</code> is a cuspidal unipotent character turns out to be a Hecke algebra associated to the group <code>W_{𝐆^F}(𝐋^F):=N_{𝐆^F}(𝐋)/𝐋</code>, which turns out to be a  Coxeter group.  Thus another  parameterization is  by triples <code>(𝐋,λ,φ)</code>, where  <code>λ</code>  is  a  cuspidal  unipotent  character  of  <code>𝐋^F</code>  and <code>φ</code> is an irreducible   character  of  the   <em>relative  group</em>  <code>W_{𝐆^F}(𝐋^F)</code>.  Such characters  are said to  belong to the  Harish-Chandra series determined by <code>(𝐋,λ)</code>.</p><p>A  final  piece  of  information  attached  to  unipotent characters is the <em>eigenvalues  of Frobenius</em>. Let <code>F^δ</code> be the smallest power of the isogeny <code>F</code> which is a split Frobenius (that is, <code>F^δ</code> is a Frobenius and <code>φ^δ=1</code>). Then  <code>F^δ</code> acts  naturally on  Deligne-Lusztig varieties  and thus  on the corresponding  virtual modules, and  commutes to the  action of <code>𝐆^F</code>; thus for  a given  unipotent character  <code>ρ</code>, a  submodule of  the virtual module which  affords <code>ρ</code>  affords a  single eigenvalue  <code>μ</code> of  <code>F^δ</code>. Results of Lusztig  and  Digne-Michel  show  that  this  eigenvalue  is  of  the  form <code>q^{aδ}λ_ρ</code> where <code>2a∈ℤ</code> and <code>λ_ρ</code> is a root of unity which depends only on <code>ρ</code>  and not the considered module. This  <code>λ_ρ</code> is called the eigenvalue of Frobenius  attached  to  <code>ρ</code>.  Unipotent  characters  in the Harish-Chandra series of a pair <code>(𝐋,λ)</code> have the same eigenvalue of Frobenius as <code>λ</code>.</p><p>Chevie   contains  tables  of  all   this  information,   and  can  compute Harish-Chandra  and Lusztig  induction of  unipotent characters  and almost characters. We illustrate the information on some examples:</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; uc=UnipotentCharacters(W)
UnipotentCharacters(G₂)
      γ│   Deg(γ)  Feg Fr(γ)    label
───────┼──────────────────────────────
φ₁‚₀   │        1    1     1         
φ₁‚₆   │       q⁶   q⁶     1         
φ′₁‚₃  │  qΦ₃Φ₆/3   q³     1    (1,ρ)
φ″₁‚₃  │  qΦ₃Φ₆/3   q³     1   (g₃,1)
φ₂‚₁   │ qΦ₂²Φ₃/6  qΦ₈     1    (1,1)
φ₂‚₂   │ qΦ₂²Φ₆/2 q²Φ₄     1   (g₂,1)
G₂[-1] │ qΦ₁²Φ₃/2    0    -1   (g₂,ε)
G₂[1]  │ qΦ₁²Φ₆/6    0     1    (1,ε)
G₂[ζ₃] │qΦ₁²Φ₂²/3    0    ζ₃  (g₃,ζ₃)
G₂[ζ₃²]│qΦ₁²Φ₂²/3    0   ζ₃² (g₃,ζ₃²)</code></pre><p>The first column gives the name of the unipotent character; the first 6 are in  the  principal  series  so  are  named  according  to the corresponding characters  of <code>W</code>. The last 4 are cuspidal, and named by the corresponding eigenvalue  of  Frobenius,  which  is  displayed  in  the fourth column. In general   the   names   of   the   unipotent  characters  come  from  their parameterization  by  Harish-Chandra  series;  in  addition,  for classical groups, they are associated to <em>symbols</em>.</p><p>The first two characters are each in a family by themselves. The last eight are  in a family associated to the group <code>Γ=𝔖_3</code>: the last column shows the parameters  <code>(x,θ)</code>. The  second column  shows the  degree of the unipotent characters, which is transformed by the Lusztig Fourier matrix of the third column,  which gives the  degree of the  corresponding almost character, or equivalently the fake degree of the corresponding character of <code>W</code>.</p><p>One  can get  more information  on the  Lusztig Fourier  matrix of  the big family by asking</p><pre><code class="language-julia-repl">julia&gt; uc.families[1]
Family(D(S₃):[5, 6, 4, 3, 8, 7, 9, 10])
   label│eigen                                               
────────┼─────────────────────────────────────────────────────
(1,1)   │    1 1//6  1//2  1//3  1//3  1//6  1//2  1//3  1//3
(g₂,1)  │    1 1//2  1//2  0//1  0//1 -1//2 -1//2  0//1  0//1
(g₃,1)  │    1 1//3  0//1  2//3 -1//3  1//3  0//1 -1//3 -1//3
(1,ρ)   │    1 1//3  0//1 -1//3  2//3  1//3  0//1 -1//3 -1//3
(1,ε)   │    1 1//6 -1//2  1//3  1//3  1//6 -1//2  1//3  1//3
(g₂,ε)  │   -1 1//2 -1//2  0//1  0//1 -1//2  1//2  0//1  0//1
(g₃,ζ₃) │   ζ₃ 1//3  0//1 -1//3 -1//3  1//3  0//1  2//3 -1//3
(g₃,ζ₃²)│  ζ₃² 1//3  0//1 -1//3 -1//3  1//3  0//1 -1//3  2//3</code></pre><p>One  can  do  computations  with  individual  unipotent characters. Here we construct  the Coxeter torus, and then the identity character of this torus as a unipotent character.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; T=spets(reflection_subgroup(W,Int[]),W(1,2))
.Φ₆

julia&gt; u=UniChar(T,1)
[.Φ₆]:&lt;.&gt;</code></pre><p>Then  here  are  two  ways  to  construct  the  Deligne-Lusztig  character associated to the Coxeter torus:</p><pre><code class="language-julia-repl">julia&gt; LusztigInduce(W,u)
[G₂]:&lt;φ₁‚₀&gt;+&lt;φ₁‚₆&gt;-&lt;φ₂‚₁&gt;+&lt;G₂[-1]&gt;+&lt;G₂[ζ₃]&gt;+&lt;G₂[ζ₃²]&gt;

julia&gt; v=DLChar(W,[1,2])
[G₂]:&lt;φ₁‚₀&gt;+&lt;φ₁‚₆&gt;-&lt;φ₂‚₁&gt;+&lt;G₂[-1]&gt;+&lt;G₂[ζ₃]&gt;+&lt;G₂[ζ₃²]&gt;

julia&gt; degree(v)
Pol{Cyc{Rational{Int64}}}: q⁶+q⁵-q⁴-2q³-q²+q+1

julia&gt; v*v
Cyc{Rational{Int64}}: 6</code></pre><p>The  last two lines ask for the degree  of <code>v</code>, then for the scalar product of <code>v</code> with itself.</p><p>Finally  we mention  that Chevie  can also  provide unipotent characters of Spetses, as defined in [@BMM14]. An example:</p><pre><code class="language-julia-repl">julia&gt; UnipotentCharacters(ComplexReflectionGroup(4))
UnipotentCharacters(G₄)
    γ│               Deg(γ)    Feg Fr(γ)   label
─────┼───────────────────────────────────────────
φ₁‚₀ │                    1      1     1        
φ₁‚₄ │   (-√-3)q⁴Φ″₃Φ₄Φ″₆/6     q⁴     1  1∧-ζ₃²
φ₁‚₈ │    (√-3)q⁴Φ′₃Φ₄Φ′₆/6     q⁸     1  -1∧ζ₃²
φ₂‚₅ │            q⁴Φ₂²Φ₆/2   q⁵Φ₄     1   1∧ζ₃²
φ₂‚₃ │(-ζ₃-2ζ₃²)qΦ″₃Φ₄Φ′₆/3   q³Φ₄     1   1∧ζ₃²
φ₂‚₁ │(-2ζ₃-ζ₃²)qΦ′₃Φ₄Φ″₆/3    qΦ₄     1    1∧ζ₃
φ₃‚₂ │               q²Φ₃Φ₆ q²Φ₃Φ₆     1        
Z₃:2 │      (-√-3)qΦ₁Φ₂Φ₄/3      0   ζ₃²  ζ₃∧ζ₃²
Z₃:11│     (-√-3)q⁴Φ₁Φ₂Φ₄/3      0   ζ₃²  ζ₃∧-ζ₃
G₄   │           -q⁴Φ₁²Φ₃/2      0    -1 -ζ₃²∧-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Uch.jl#L1-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.UnipotentCharacters" href="#Gapjm.Uch.UnipotentCharacters"><code>Gapjm.Uch.UnipotentCharacters</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>UnipotentCharacters(W)</code></p><p><code>W</code>  should be a Coxeter group, a  Coxeter Coset or a Spetses. The function gives  back a record containing  information about the unipotent characters of the associated algebraic group (or Spetses). This contains the following fields:</p><p><code>:group</code>: a pointer to <code>W</code></p><p><code>:charNames</code>:  the list of names of the unipotent characters.</p><p><code>:charSymbols</code>: the list of symbols associated to unipotent characters, for classical groups.</p><p><code>:harishChandra</code>:  information  about  Harish-Chandra  series  of  unipotent characters.  This is itself a list of records, one for each pair <code>(𝐋,λ)</code> of a  Levi  of  an  <code>F</code>-stable  parabolic  subgroup  and  a cuspidal unipotent character of <code>𝐋^F</code>. These records themselves have the following fields:</p><p><code>:levi</code>: a list &#39;l&#39; such that <code>𝐋</code> corresponds to &#39;ReflectionSubgroup(W,l)&#39;.</p><p><code>:cuspidalName</code>: the name of the unipotent cuspidal character <code>lambda</code>.</p><p><code>:eigenvalue</code>: the eigenvalue of Frobenius for <code>λ</code>.</p><p><code>:relativeType</code>: the reflection type of <code>W_𝐆 (𝐋)</code>;</p><p><code>:parameterExponents</code>:  the  <code>𝐆 ^F</code>-endomorphism  algebra  of <code>R_𝐋^𝐆 (λ)</code> is a Hecke algebra for <code>W_𝐆 (𝐋)</code> with some parameters of the form <code>q^{a_s}</code>. This holds the list of exponents <code>a_s</code>.</p><p><code>:charNumbers</code>:  the  indices  of  the  unipotent  characters indexed by the irreducible characters of <code>W_𝐆 (𝐋)</code>.</p><p><code>:families</code>:  information  about  Lusztig  families of unipotent characters. This  is itself a list  of records, one for  each family. These records are described in the section about families below.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:Bsym,2)
Bsym₂

julia&gt; WF=spets(W,Perm(1,2))
²Bsym₂

julia&gt; uc=UnipotentCharacters(WF)
UnipotentCharacters(²Bsym₂)
       γ│   Deg(γ)   Feg Fr(γ) label
────────┼────────────────────────────
2       │        1     1     1      
11      │       q⁴    q⁴     1      
²B₂[1,3]│√2qΦ₁Φ₂/2 qΦ₁Φ₂   ζ₈³     1
²B₂[1,5]│√2qΦ₁Φ₂/2     0   ζ₈⁵     2

julia&gt; uc.families
3-element Array{Family,1}:
 Family(C₁:[1]) 
 Family(C₁:[2]) 
 Family(???:3:4)

julia&gt; uc.families[3]
Family(???:3:4)
label│eigen    1     2
─────┼─────────────────
1    │  ζ₈³ √2/2 -√2/2
2    │  -ζ₈ √2/2  √2/2</code></pre><p><code>:charnames</code>:  returns  the  names  of  the  unipotent characters. Using the version  with an additional  option record as  the second argument, one can control the display in various ways.</p><pre><code class="language-julia-repl">julia&gt; uc=UnipotentCharacters(coxgroup(:G,2));

julia&gt; charnames(uc;limit=true)
10-element Array{String,1}:
 &quot;φ₁‚₀&quot;   
 &quot;φ₁‚₆&quot;   
 &quot;φ′₁‚₃&quot;  
 &quot;φ″₁‚₃&quot;  
 &quot;φ₂‚₁&quot;   
 &quot;φ₂‚₂&quot;   
 &quot;G₂[-1]&quot; 
 &quot;G₂[1]&quot;  
 &quot;G₂[ζ₃]&quot; 
 &quot;G₂[ζ₃²]&quot;

julia&gt; charnames(uc;TeX=true)
10-element Array{String,1}:
 &quot;\phi_{1,0}&quot;    
 &quot;\phi_{1,6}&quot;    
 &quot;\phi_{1,3}&#39;&quot;   
 &quot;\phi_{1,3}&#39;&#39;&quot;  
 &quot;\phi_{2,1}&quot;    
 &quot;\phi_{2,2}&quot;    
 &quot;G_2[-1]&quot;        
 &quot;G_2[1]&quot;         
 &quot;G_2[\zeta_3]&quot;  
 &quot;G_2[\zeta_3^2]&quot;</code></pre><p><code>:Display</code>:  One can control the display  of unipotent characters in various ways.  In the record controlling &#39;Display&#39;, a field &#39;items&#39; specifies which columns are displayed. The possible values are</p><p><code>:n0</code>:  The index of the character in the list of unipotent characters.</p><p><code>:Name</code>:   The name of the unipotent character.</p><p><code>:Degree</code>:  The degree of the unipotent character.</p><p><code>:FakeDegree</code>: The degree of the corresponding almost character.</p><p><code>:Eigenvalue</code>:  The eigenvalue of Frobenius attached to the unipotent character.</p><p><code>:Symbol</code>: for classical groups, the symbol attached to the unipotent character.</p><p><code>:Family</code>: The parameter the character has in its Lusztig family.</p><p><code>:Signs</code>: The signs attached to the character in the Fourier transform.</p><p>The default value is  &#39;items:=[:Name,:Degree,:FakeDegree,:Eigenvalue,:Family]`</p><p>This  can be changed by setting the variable &#39;UnipotentCharactersOps.items` which holds this default value. In addition if the field &#39;byFamily&#39; is set, the  characters are displayed  family by family  instead of in index order. Finally,  the field &#39;chars&#39; can be  set, indicating which characters are to be displayed in which order.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; uc=UnipotentCharacters(W)
UnipotentCharacters(B₂)
  γ│Deg(γ) Feg Fr(γ) label
───┼───────────────────────
11.│ qΦ₄/2  q²     1   +,-
1.1│qΦ₂²/2 qΦ₄     1   +,+
.11│    q⁴  q⁴     1      
2. │     1   1     1      
.2 │ qΦ₄/2  q²     1   -,+
B₂ │qΦ₁²/2   0    -1   -,-</code></pre><pre><code class="language-none">gap&gt; Display(uc,rec(byFamily:=true));
Unipotent characters for B2
Name |  Degree FakeDegree Eigenvalue Label
___________________________________________
*.11 |     q^4        q^4          1
___________________________________________
11.  |  1/2qP4        q^2          1   +,-
*1.1 |1/2qP2^2        qP4          1   +,+
.2   |  1/2qP4        q^2          1   -,+
B2   |1/2qP1^2          0         -1   -,-
___________________________________________
*2.  |&#39;|&#39;|       1          1          1
gap&gt; Display(uc,items=[:n0,:Name,:Symbol]));
Unipotent characters for B2
n0 |Name   Symbol
__________________
1  | 11.   (12,0)
2  | 1.1   (02,1)
3  | .11 (012,12)
4  |  2.     (2,)
5  |  .2   (01,2)
6  |  B2   (012,)|</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Uch.jl#L322-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.degrees-Tuple{UnipotentCharacters,Any}" href="#Gapjm.degrees-Tuple{UnipotentCharacters,Any}"><code>Gapjm.degrees</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>degrees(uc::UnipotentCharacters,q=Pol([1],1))</code></p><p>Returns  the  list  of  degrees  of  the unipotent characters of the finite reductive group (or Spetses) with Weyl group (or Spetsial reflection group) <code>W</code>, evaluated at <code>q</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; uc=UnipotentCharacters(W);

julia&gt; degrees(uc)
10-element Array{Pol{Rational{Int64}},1}:
 1//1                                         
 (1//1)q⁶                                     
 (1//3)q⁵+(1//3)q³+(1//3)q                    
 (1//3)q⁵+(1//3)q³+(1//3)q                    
 (1//6)q⁵+(1//2)q⁴+(2//3)q³+(1//2)q²+(1//6)q  
 (1//2)q⁵+(1//2)q⁴+(1//2)q²+(1//2)q           
 (1//2)q⁵+(-1//2)q⁴+(-1//2)q²+(1//2)q         
 (1//6)q⁵+(-1//2)q⁴+(2//3)q³+(-1//2)q²+(1//6)q
 (1//3)q⁵+(-2//3)q³+(1//3)q                   
 (1//3)q⁵+(-2//3)q³+(1//3)q                   </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Uch.jl#L689-L715">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.UniChar" href="#Gapjm.Uch.UniChar"><code>Gapjm.Uch.UniChar</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>UniChar(W,l)</code></p><p>Constructs  an object representing the unipotent character specified by <code>l</code> of  the algebraic  group associated  to the  Coxeter group or Coxeter coset specified  by <code>W</code>. There are 3 possibilities  for <code>l</code>: if it is an integer, the  <code>l</code>-th unipotent character of <code>W</code> is  returned. If it is a string, the unipotent  character of <code>W</code> whose name is <code>l</code> is returned. Finally, <code>l</code> can be  a  list  of  length  the  number  of unipotent characters of <code>W</code>, which specifies the coefficient to give to each.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; UniChar(W,7)
[G₂]:&lt;G₂[-1]&gt;

julia&gt; UniChar(W,&quot;G2[E3]&quot;)
[G₂]:&lt;G₂[ζ₃]&gt;

julia&gt; UniChar(W,[1,0,0,-1,0,0,2,0,0,1])
[G₂]:&lt;φ₁‚₀&gt;-&lt;φ″₁‚₃&gt;+2&lt;G₂[-1]&gt;+&lt;G₂[ζ₃²]&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Uch.jl#L800-L824">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.DLChar" href="#Gapjm.Uch.DLChar"><code>Gapjm.Uch.DLChar</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>DLChar(W,w)</code></p><p>This  function returns  the Deligne-Lusztig  character <code>R_𝐓  ^𝐆 (1)</code> of the algebraic  group <code>𝐆</code> associated to the Coxeter group or Coxeter coset <code>W</code>. The  torus  <code>𝐓</code>  can  be  specified  in  3  ways:  if <code>w</code> is an integer, it represents the <code>w</code>-th conjugacy class (or <code>phi</code>-conjugacy class for a coset <code>Wϕ</code>)  of <code>W</code>. Otherwise  <code>w</code> can be  a word or  an element of  <code>W</code>, and it represents the class (or <code>ϕ</code>-class) of <code>w</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; DLChar(W,3)
[G₂]:&lt;φ₁‚₀&gt;-&lt;φ₁‚₆&gt;-&lt;φ′₁‚₃&gt;+&lt;φ″₁‚₃&gt;

julia&gt; DLChar(W,W(1))
[G₂]:&lt;φ₁‚₀&gt;-&lt;φ₁‚₆&gt;-&lt;φ′₁‚₃&gt;+&lt;φ″₁‚₃&gt;

julia&gt; DLChar(W,[1])
[G₂]:&lt;φ₁‚₀&gt;-&lt;φ₁‚₆&gt;-&lt;φ′₁‚₃&gt;+&lt;φ″₁‚₃&gt;

julia&gt; DLChar(W,[1,2])
[G₂]:&lt;φ₁‚₀&gt;+&lt;φ₁‚₆&gt;-&lt;φ₂‚₁&gt;+&lt;G₂[-1]&gt;+&lt;G₂[ζ₃]&gt;+&lt;G₂[ζ₃²]&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Uch.jl#L957-L983">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.AlmostChar" href="#Gapjm.Uch.AlmostChar"><code>Gapjm.Uch.AlmostChar</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>AlmostChar(W,i)</code></p><p>This  function  returns  the  <code>i</code>-th  almost  unipotent  character  of  the algebraic  group 𝐆 associated to the Coxeter group or Coxeter coset <code>W</code>. If <code>φ</code> is the <code>i</code>-th irreducible character of <code>W</code>, the <code>i</code>-th almost character is  <code>R_φ=W⁻¹∑_w∈  W  φ(w)  R_𝐓_w^𝐆  (1)</code>  where  <code>𝐓_w</code> is the maximal torus associated  to the conjugacy class (or  <code>ϕ</code>-conjugacy class for a coset) of <code>w</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; AlmostChar(W,3)
[B₂]:&lt;.11&gt;

julia&gt; AlmostChar(W,1)
[B₂]:1/2&lt;11.&gt;+1/2&lt;1.1&gt;-1/2&lt;.2&gt;-1/2&lt;B₂&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Uch.jl#L990-L1010">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.DLLefschetz" href="#Gapjm.Uch.DLLefschetz"><code>Gapjm.Uch.DLLefschetz</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>DLLefschetz(h)</code></p><p>Here <code>h</code> is an element of a Hecke algebra associated to a Coxeter group &lt;W&gt; which  itself  is  associated  to  an  algebraic  group <code>𝐆</code>. By results of Digne-Michel,  for <code>g∈  𝐆 ^F</code>,  the number  of fixed  points of <code>Fᵐ</code> on the Deligne-Lusztig variety associated to the element <code>wϕ</code> of the Coxeter coset <code>Wϕ</code>, have for <code>m</code> sufficiently divisible, the form <code>∑_φ φ_(qᵐ)(T_wϕ)R_φ(g)</code> where  <code>φ</code> runs over the irreducible characters of <code>Wϕ</code>, where <code>R_φ</code> is the corresponding  almost character, and where <code>φ_(qᵐ)</code> is a character value of the  Hecke algebra <code>ℋ (Wϕ,qᵐ)</code> of <code>Wϕ</code> with parameter <code>qᵐ</code>. This expression is  called the <em>Lefschetz character</em> of  the Deligne-Lusztig variety. If we consider <code>qᵐ</code> as an indeterminate <code>x</code>, it can be seen as a sum of unipotent characters  with coefficients character values of the generic Hecke algebra <code>ℋ (Wϕ,x)</code>.</p><p>The  function &#39;DLLefschetz&#39; takes  as argument a  Hecke element and returns the  corresponding Lefschetz character. This is defined on the whole of the Hecke  algebra by linearity.  The Lefschetz character  of various varieties related   to   Deligne-Lusztig   varieties,   like   their  completions  or desingularisation,  can be  obtained by  taking the  Lefschetz character at various elements of the Hecke algebra.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; H=hecke(W,Pol(:q))
hecke(A₂,q)

julia&gt; T=Tbasis(H);

julia&gt; DLLefschetz(T(1,2))
[A₂]:&lt;111&gt;-q&lt;21&gt;+q²&lt;3&gt;

julia&gt; DLLefschetz((T(1)+T())*(T(2)+T()))
[A₂]:q&lt;21&gt;+(q²+2q+1)&lt;3&gt;</code></pre><p>The   last  line  shows  the   Lefschetz  character  of  the  Samelson-Bott desingularisation of the Coxeter element Deligne-Lusztig variety.</p><p>We now show an example with a coset (corresponding to the unitary group).</p><p>gap&gt; H:=Hecke(CoxeterCoset(W,(1,2)),q^2); Hecke(2A2,q^2) gap&gt; T:=Basis(H,&quot;T&quot;); function ( arg ) ... end gap&gt; DeligneLusztigLefschetz(T(1)); [2A2]=-&lt;11&gt;-q&lt;2A2&gt;+q^2&lt;2&gt;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Uch.jl#L1017-L1067">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.LusztigInduce" href="#Gapjm.Uch.LusztigInduce"><code>Gapjm.Uch.LusztigInduce</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>LusztigInduce(W,u)</code></p><p><code>u</code>  should be a unipotent character of a parabolic subcoset of the Coxeter coset  <code>W</code>. It represents  a unipotent character  <code>λ</code> of a  Levi <code>𝐋</code> of the algebraic  group  <code>𝐆</code>  attached  to  <code>W</code>.  The  program returns the Lusztig induced <code>R_𝐋^𝐆(λ)</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; WF=spets(W)
G₂

julia&gt; T=subspets(WF,Int[],W(1))
.Φ₁Φ₂

julia&gt; u=UniChar(T,1)
[.Φ₁Φ₂]:&lt;.&gt;

julia&gt; LusztigInduce(WF,u)
[G₂]:&lt;φ₁‚₀&gt;-&lt;φ₁‚₆&gt;-&lt;φ′₁‚₃&gt;+&lt;φ″₁‚₃&gt;

julia&gt; DLChar(W,W(1))
[G₂]:&lt;φ₁‚₀&gt;-&lt;φ₁‚₆&gt;-&lt;φ′₁‚₃&gt;+&lt;φ″₁‚₃&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Uch.jl#L879-L906">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Uch.LusztigRestrict" href="#Gapjm.Uch.LusztigRestrict"><code>Gapjm.Uch.LusztigRestrict</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>LusztigRestrict(R,u)</code></p><p><code>u</code>  should be a unipotent character of a parent Coxeter coset <code>W</code> of which <code>R</code> is a parabolic subcoset. It represents a unipotent character <code>γ</code> of the algebraic  group <code>𝐆</code> attached to <code>W</code>,  while <code>R</code> represents a Levi subgroup <code>L</code>. The program returns the Lusztig restriction <code>*R_𝐋^𝐆(γ)</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; WF=spets(W)
G₂

julia&gt; T=subspets(WF,Int[],W(1))
.Φ₁Φ₂

julia&gt; u=DLChar(W,W(1))
[G₂]:&lt;φ₁‚₀&gt;-&lt;φ₁‚₆&gt;-&lt;φ′₁‚₃&gt;+&lt;φ″₁‚₃&gt;

julia&gt; Uch.LusztigRestrict(T,u)
[.Φ₁Φ₂]:4&lt;.&gt;

julia&gt; T=subspets(WF,Int[],W(2))
.Φ₁Φ₂

julia&gt; Uch.LusztigRestrict(T,u)
[.Φ₁Φ₂]:0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Uch.jl#L912-L942">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Lusztig.LusztigInductionTable" href="#Gapjm.Lusztig.LusztigInductionTable"><code>Gapjm.Lusztig.LusztigInductionTable</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>LusztigInductionTable(R,W)</code></p><p><code>R</code>  should be a parabolic subgroup of the Coxeter group <code>W</code> or a parabolic subcoset  of  the  Coxeter  coset  <code>W</code>,  in  each  case representing a Levi subgroup  <code>𝐋</code> of  the algebraic  group <code>𝐆</code>  associated to <code>W</code>. The function returns  an  <code>InductionTable</code>  representing  the  Lusztig induction <code>R_𝐋^𝐆</code> between unipotent characters.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:B,3)
B₃

julia&gt; t=twistings(W,[1,3])
2-element Array{Gapjm.Cosets.FCC{Int16,FiniteCoxeterSubGroup{Perm{Int16},Int64}},1}:
 Ã₁×A₁Φ₁
 Ã₁×A₁Φ₂

julia&gt; LusztigInductionTable(t[2],W)
Lusztig Induction from Ã₁×A₁Φ₂ to B₃
     │11⊗ 11 11⊗ 2 2⊗ 11 2⊗ 2
─────┼────────────────────────
111. │     1    -1    -1    .
11.1 │    -1     .     1   -1
1.11 │     .     .    -1    .
.111 │    -1     .     .    .
21.  │     .     .     .    .
1.2  │     1    -1     .    1
2.1  │     .     1     .    .
.21  │     .     .     .    .
3.   │     .     .     .    1
.3   │     .     1     1   -1
B₂:2 │     .     .     1   -1
B₂:11│     1    -1     .    .</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Lusztig.jl#L212-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Families" href="#Gapjm.Families"><code>Gapjm.Families</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Families of unipotent characters</p><p>The  blocks of the (rectangular) matrix  <code>⟨Rᵪ,ρ⟩_{𝐆 ^F}</code> when <code>χ</code> runs over <code>Irr(W)</code>  and  <code>ρ</code>  runs  over  the  unipotent  characters,  are called the <em>Lusztig  families</em>. When  <code>𝐆</code>  is split  and <code>W</code>  is a Coxeter group they correspond  on the <code>Irr(W)</code> side to two-sided Kazhdan-Lusztig cells –- for split  Spetses they  correspond to  Rouquier blocks  of the  Spetsial Hecke algebra.  The matrix of scalar products <code>⟨Rᵪ,ρ⟩_{𝐆 ^F}</code> can be completed to a  square matrix <code>⟨A_{ρ&#39;},ρ⟩_{𝐆 ^F}</code> where <code>A_{ρ&#39;}</code> are the <em>characteristic functions of character sheaves</em> on <code>𝐆 ^F</code>; this square matrix is called the <em>Fourier matrix</em> of the family.</p><p>The  &#39;UnipotentCharacters&#39; record in Chevie contains a field &#39;.families&#39;, a list of family records containing information on each family, including the Fourier matrix. Here is an example.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; uc=UnipotentCharacters(W);

julia&gt; uc.families
3-element Array{Family,1}:
 Family(D(S₃):[5, 6, 4, 3, 8, 7, 9, 10])
 Family(C₁:[1])                         
 Family(C₁:[2])                         

julia&gt; uc.families[1]
Family(D(S₃):[5, 6, 4, 3, 8, 7, 9, 10])
   label│eigen                                               
────────┼─────────────────────────────────────────────────────
(1,1)   │    1 1//6  1//2  1//3  1//3  1//6  1//2  1//3  1//3
(g₂,1)  │    1 1//2  1//2  0//1  0//1 -1//2 -1//2  0//1  0//1
(g₃,1)  │    1 1//3  0//1  2//3 -1//3  1//3  0//1 -1//3 -1//3
(1,ρ)   │    1 1//3  0//1 -1//3  2//3  1//3  0//1 -1//3 -1//3
(1,ε)   │    1 1//6 -1//2  1//3  1//3  1//6 -1//2  1//3  1//3
(g₂,ε)  │   -1 1//2 -1//2  0//1  0//1 -1//2  1//2  0//1  0//1
(g₃,ζ₃) │   ζ₃ 1//3  0//1 -1//3 -1//3  1//3  0//1  2//3 -1//3
(g₃,ζ₃²)│  ζ₃² 1//3  0//1 -1//3 -1//3  1//3  0//1 -1//3  2//3

julia&gt; charnames(uc)[uc.families[1][:charNumbers]]
8-element Array{String,1}:
 &quot;phi2,1&quot;  
 &quot;phi2,2&quot;  
 &quot;phi1,3&#39;&#39;&quot;
 &quot;phi1,3&#39;&quot; 
 &quot;G2[1]&quot;   
 &quot;G2[-1]&quot;  
 &quot;G2[E3]&quot;  
 &quot;G2[E3^2]&quot;</code></pre><p>The Fourier matrix is obtained by &#39;fourier(f)&#39;; the field &#39;f[:charNumbers]&#39; holds  the indices of the unipotent characters  which are in the family. We obtain  the list of eigenvalues of Frobenius for these unipotent characters by  &#39;Eigenvalues(f)&#39;. The Fourier matrix  and vector of eigenvalues satisfy the  properties of <em>fusion data</em>, see  below. The field &#39;f[:charLabels]&#39; is what  is displayed  in the  column &#39;labels&#39;  when displaying the family. It contains  labels naturally attached to lines  of the Fourier matrix. In the case   of  reductive  groups,   the  family  is   always  attached  to  the &quot;Drinfeld_double&quot;  of a small  finite group and  the &#39;.charLabels&#39; come from this construction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Families.jl#L1-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Families.Family" href="#Gapjm.Families.Family"><code>Gapjm.Families.Family</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Family(f [, charNumbers [, opt]])</code></p><p>This function creates a new family in two possible ways.</p><p>In  the first case <code>f</code> is a string which denotes a family known to  CHEVIE. Examples are &quot;S3&quot;,   &quot;S4&quot;,   &quot;S5&quot;   which denote the family obtained as the Drinfeld  double of the symmetric group  on 3,4,5 elements, or &quot;C2&quot;   which denotes the Drinfeld double of the cyclic group of order 2.</p><p>In the second case <code>f</code> is already a struct Family.</p><p>The other (optional) arguments add information to the family defined by the first argument. If given, the second argument becomes <code>f[:charNumbers]</code>. If given,  the third argument  <code>opt</code> is a  <code>Dict</code> whose keys  are added to the resulting family.</p><p>If <code>opt</code> has a key <code>signs</code>, this should be a list of &#39;1&#39; and &#39;-1&#39;, and then the  Fourier matrix  is conjugated  by the  diagonal matrix of those signs. This  is used  in Spetses  to adjust  the matrix  to the choice of signs of unipotent degrees.</p><pre><code class="language-julia-repl">julia&gt; Family(&quot;C2&quot;)
Family(C₂:4)
 label│eigen                       
──────┼─────────────────────────────
(1,1) │    1 1//2  1//2  1//2  1//2
(g₂,1)│    1 1//2  1//2 -1//2 -1//2
(1,ε) │    1 1//2 -1//2  1//2 -1//2
(g₂,ε)│   -1 1//2 -1//2 -1//2  1//2

julia&gt; Family(&quot;C2&quot;,4:7,Dict(:signs=&gt;[1,-1,1,-1]))
Family(C₂:4:7)
 label│eigen signs                       
──────┼───────────────────────────────────
(1,1) │    1     1  1//2 -1//2 1//2 -1//2
(g₂,1)│    1    -1 -1//2  1//2 1//2 -1//2
(1,ε) │    1     1  1//2  1//2 1//2  1//2
(g₂,ε)│   -1    -1 -1//2 -1//2 1//2  1//2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Families.jl#L86-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Families.Drinfeld_double" href="#Gapjm.Families.Drinfeld_double"><code>Gapjm.Families.Drinfeld_double</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>Drinfeld_double(g[,opt])</code></p><p>Given  a (usually small) finite group  <code>Γ</code>, Lusztig has associated a family (a  Fourier matrix, a list of eigenvalues of Frobenius) which describes the representation ring of the Drinfeld double of the group algebra of <code>Γ</code>, and for   some  appropriate  small  groups  describes  a  family  of  unipotent characters. We do not explain the details of this construction, but explain how its final result building Lusztig&#39;s Fourier matrix, and a variant of it that we use in Spetses, from <code>Γ</code>.</p><p>The  elements of the family are in bijection  with the set <code>𝓜 (Γ)</code> of pairs <code>(x,χ)</code>  taken up to  <code>Γ</code>-conjugacy, where <code>x∈Γ</code>  and <code>χ</code> is an irreducible complex-valued   character  of  <code>C_Γ(x)</code>.  To  such  a  pair  <code>ρ=(x,χ)</code>  is associated  an eigenvalue of Frobenius defined by <code>ω_ρ:=χ(x)/χ(1)</code>. Lusztig then defines a Fourier matrix <code>S₀</code> whose coefficient is given, for <code>ρ=(x,χ)</code> and <code>ρ&#39;=(x&#39;, χ&#39;)</code>, by:</p><p><code>S₀_{ρ,ρ&#39;}:=#C_Γ(x)⁻¹ ∑_{ρ₁=(x₁,χ₁)}χ̄₁(x)χ(y₁)</code></p><p>where the sum is over all pairs <code>ρ₁∈𝓜 (Γ)</code> which are <code>Γ</code>-conjugate to <code>ρ&#39;</code> and  such that <code>y₁∈  C_Γ(x)</code>. This coefficient  also represents the scalar product <code>⟨ρ,ρ&#39;⟩_{𝐆^F}</code> of the corresponding unipotent characters.</p><p>A  way  to  understand  the  formula  for  <code>S₀_{ρ,ρ&#39;}</code> better is to consider another  basis of the complex  vector space with basis  <code>𝓜 (Γ)</code>, indexed by the  pairs  <code>(x,y)</code>  taken  up  to  <code>Γ</code>-conjugacy,  where  <code>x</code>  and <code>y</code> are commuting  elements  of  <code>Γ</code>.  This  basis  is  called  the basis of Mellin transforms, and given by:</p><p><code>(x,y)=∑_{χ∈ Irr(C_Γ(x))}χ(y)(x,χ)</code></p><p>In  the  basis  of  Mellin  transforms,  the  linear  map  <code>S₀</code> is given by <code>(x,y)↦(x⁻¹,y⁻¹)</code>  and  the  linear  transformation  <code>T</code> which sends <code>ρ</code> to <code>ω_ρρ</code>   becomes  <code>(x,y)↦(x,xy)</code>.   These  are   particular  cases  of  the permutation  representation of <code>GL_2(ℤ)</code> on  the basis of Mellin transforms where <code>(begin{array}{cc}a&amp;b;c&amp;d{array}) %begin{pmatrix}{cc}a&amp;b;c&amp;d{pmatrix}</code> acts by <code>(x,y)↦(x^ay^b,x^cy^d)</code>.</p><p>Fourier  matrices in finite reductive groups  are given by the above matrix <code>S₀</code>.  But for non-rational Spetses, we use  a different matrix <code>S</code> which in the  basis of Mellin transforms  is given by <code>(x,y)↦(y⁻¹,x)</code>. Equivalently, the  formula <code>S_{ρ,ρ&#39;}</code>  differs from  the formula  for <code>S₀_{ρ,ρ&#39;}</code>  in that there  is no complex conjugation of <code>χ₁</code>;  thus the matrix <code>S</code> is equal to <code>S₀</code>  multiplied on the right by the permutation matrix which corresponds to <code>(x,χ)↦(x,χ̄)</code>.  The advantage of the matrix <code>S</code>  over <code>S₀</code> is that the pair <code>S,T</code>  satisfies directly the axioms for a fusion algebra (see below); also the matrix <code>S</code> is symmetric, while <code>S₀</code> is Hermitian.</p><p>Thus there are two variants of &#39;Drinfeld_double`:</p><p><code>Drinfeld_double(g,lu=true)</code></p><p>returns  a family  containing Lusztig&#39;s  Fourier matrix  <code>S₀</code>, and  an extra field  &#39;.perm&#39;  containing  the  permutation  of  the  indices  induced  by <code>(x,χ)↦(x,χ̄)</code>,  which allows  to recover  <code>S</code>, as  well as  an extra field `:lusztig&#39;, set to &#39;true&#39;.</p><p><code>Drinfeld_double(g)</code></p><p>returns a family with the matrix <code>S</code>, which does not have fields &#39;.lusztig&#39; or &#39;.perm&#39;.</p><p>The family record &#39;f&#39; returned also has the fields:</p><p><code>:group</code>: the group <code>Γ</code>.</p><p><code>:charLabels</code>: a list of labels describing the pairs <code>(x,χ)</code>, and thus also specifying in which order they are taken.</p><p><code>:fourierMat</code>: the Fourier matrix (the matrix <code>S</code> or <code>S₀</code> depending on the call).</p><p><code>:eigenvalues</code>: the eigenvalues of Frobenius.</p><p><code>:xy</code>: a list of pairs &#39;[x,y]&#39; which are representatives of the <code>Γ</code>-orbits of pairs of commuting elements.</p><p><code>:mellinLabels</code>: a list of labels describing the pairs &#39;[x,y]&#39;.</p><p><code>:mellin</code>:  the base change matrix between  the basis <code>(x,χ)</code> and the basis of   Mellin  transforms,   so  that   |f.fourierMat^(f.mellin^-1)|  is  the permutation  matrix (for <code>(x,y)↦(y⁻¹,x)</code>  or <code>(x,y)↦(y⁻¹,x⁻¹)</code> depending on the call).</p><p><code>:special</code>: the index of the special element, which is <code>(x,χ)=(1,1)</code>.</p><pre><code class="language-julia-repl">julia&gt; Drinfeld_double(CoxSym(3))
Family(D(CoxSym(3)):8)
   label│eigen                                       
────────┼─────────────────────────────────────────────
(1,X.1) │    1  1/6  1/3 1/6 -3/2 -3/2  1/3  1/3  1/3
(1,X.2) │    1  1/3  2/3 1/3    0    0 -1/3 -1/3 -1/3
(1,1)   │    1  1/6  1/3 1/6  3/2  3/2  1/3  1/3  1/3
(2a,X.1)│   -1 -1/6    0 1/6  1/2 -1/2    0    0    0
(2a,1)  │    1 -1/6    0 1/6 -1/2  1/2    0    0    0
(3a,1)  │    1  1/3 -1/3 1/3    0    0  2/3 -1/3 -1/3
(3a,X.2)│  ζ₃²  1/3 -1/3 1/3    0    0 -1/3 -1/3  2/3
(3a,X.3)│   ζ₃  1/3 -1/3 1/3    0    0 -1/3  2/3 -1/3

julia&gt; Drinfeld_double(CoxSym(3);lu=true)
Family(LD(CoxSym(3)):8)
   label│eigen                                       
────────┼─────────────────────────────────────────────
(1,X.1) │    1  1/6  1/3 1/6 -3/2 -3/2  1/3  1/3  1/3
(1,X.2) │    1  1/3  2/3 1/3    0    0 -1/3 -1/3 -1/3
(1,1)   │    1  1/6  1/3 1/6  3/2  3/2  1/3  1/3  1/3
(2a,X.1)│   -1 -1/6    0 1/6  1/2 -1/2    0    0    0
(2a,1)  │    1 -1/6    0 1/6 -1/2  1/2    0    0    0
(3a,1)  │    1  1/3 -1/3 1/3    0    0  2/3 -1/3 -1/3
(3a,X.2)│  ζ₃²  1/3 -1/3 1/3    0    0 -1/3  2/3 -1/3
(3a,X.3)│   ζ₃  1/3 -1/3 1/3    0    0 -1/3 -1/3  2/3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Families.jl#L491-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Families.NrDrinfeld_double" href="#Gapjm.Families.NrDrinfeld_double"><code>Gapjm.Families.NrDrinfeld_double</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>NrDrinfeld_double(g)</code></p><p>This  function returns the number of elements that the family associated to the  Drinfeld double of the group <code>g</code> would have, without computing it. The evident advantage is the speed.</p><pre><code class="language-julia-repl">julia&gt; Families.NrDrinfeldDouble(ComplexReflectionGroup(5))
378</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Families.jl#L666-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Families.family_imprimitive" href="#Gapjm.Families.family_imprimitive"><code>Gapjm.Families.family_imprimitive</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>family_imprimitive(&lt;S&gt;)</code></p><p>&lt;S&gt; should be a symbol for a unipotent characters of an imprimitive complex reflection  group &#39;G(e,1,n)&#39; or &#39;G(e,e,n)&#39;. The function returns the family</p><pre><code class="language-julia-repl">julia&gt; HasType.Family(family_imprimitive([[0,1],[1],[0]]))
Family(0011:3)
label│eigen      1         2         3
─────┼─────────────────────────────────
1    │  ζ₃²  √-3/3    -√-3/3     √-3/3
2    │    1 -√-3/3 (3-√-3)/6 (3+√-3)/6
3    │    1  √-3/3 (3+√-3)/6 (3-√-3)/6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Families.jl#L680-L695">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Families.FamiliesClassical" href="#Gapjm.Families.FamiliesClassical"><code>Gapjm.Families.FamiliesClassical</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>FamiliesClassical(l)</code></p><p>The  list  <code>l</code>  should  be  a  list  of symbols as returned by the function <code>Symbols</code>,  which classify the unipotent characters of groups of type <code>:B</code>, <code>:C</code>  or <code>:D</code>. <code>FamiliesClassical</code> returns  the list of families determined by these symbols.</p><pre><code class="language-julia-repl">julia&gt; HasType.FamiliesClassical(HasType.BDSymbols(3,1))
6-element Array{Family,1}:
 Family(01123:[1, 3, 8])
 Family(3:[9])          
 Family(013:[5, 7, 10]) 
 Family(0112233:[4])    
 Family(112:[2])        
 Family(022:[6])</code></pre><p>The  above example shows the families of unipotent characters for the group <code>B_3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Families.jl#L795-L815">source</a></section></article><h1 id="Unipotent-classes-of-reductive-groups-1"><a class="docs-heading-anchor" href="#Unipotent-classes-of-reductive-groups-1">Unipotent classes of reductive groups</a><a class="docs-heading-anchor-permalink" href="#Unipotent-classes-of-reductive-groups-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Ucl" href="#Gapjm.Ucl"><code>Gapjm.Ucl</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This  module gives information  about the unipotent  conjugacy classes of a connected  reductive  group  over  an  algebraically  closed field <code>k</code>, and various  invariants attached to  them. The unipotent  classes depend on the characteristic of <code>k</code>; their classification differs when the characteristic is  not <em>good</em>  (that is,  when it  divides one  of the coefficients of the highest  root).  In  good  characteristic,  the  unipotent  classes  are in bijection with nilpotent orbits on the Lie algebra.</p><p>We  give  the  following  information  for  a unipotent element <code>u</code> of each class:</p><ul><li><p>the centralizer <code>C_𝐆 (u)</code>, that we describe by the reductive part of  <code>C_𝐆 (u)^0</code>,  by the group  of components <code>A(u):=C_𝐆 (u)/C_𝐆 (u)^0</code>,  and by the dimension of its radical.</p></li><li><p>in good characteristic, the  Dynkin-Richardson  diagram.</p></li><li><p>the Springer correspondence,  attaching characters of  the Weyl group or</p></li></ul><p>relative Weyl groups to each character of <code>A(u)</code>.</p><p>The  Dynkin-Richarson diagram is attached to a nilpotent element <code>e</code> of the Lie  algebra <code>𝔤</code>.  By the  Jacobson-Morozov theorem  there exists an <code>𝔰𝔩₂</code> subalgebra of <code>𝔤</code> containing <code>e</code> as the element |–-|–-| | 1 | 0 | | 0 | 0 | . Let <code>𝐒</code> be the torus </p><p>|–-|––-| | h | 0   | | 0 | h⁻¹ |  of <code>SL₂</code> and let <code>𝐓</code> be a maximal  torus containing <code>𝐒</code>, so that <code>𝐒</code>  is the image of a one-parameter subgroup <code>σ∈ Y(𝐓)</code>. Consider the root decomposition <code>𝔤=∑_{α∈Σ}𝔤_α</code> given by <code>𝐓</code>;  then <code>α↦⟨σ,α⟩</code> defines a linear form  on <code>Σ</code>, determined by its value on  simple roots. It is possible to choose  a system of simple roots <code>Π</code> so that  <code>⟨σ,α⟩≥ 0</code>  for <code>α∈Π</code>,  and then  <code>⟨σ,α⟩∈{0,1,2}</code> for  any <code>α∈Π</code>. The Dynkin  diagram  of  <code>Π</code>  decorated  by  these values <code>0,1,2</code> is called the Dynkin-Richardson  diagram of <code>e</code>, and in good characteristic is a complete invariant of its <code>𝔤</code>-orbit.</p><p>Let  <code>𝓑</code>  be  the  variety  of  all  Borel  subgroups  and let <code>𝓑ᵤ</code> be the subvariety  of Borel subgroups  containing the unipotent  element <code>u</code>. Then <code>dim C_𝐆(u)=rank𝐆+2dim𝓑ᵤ</code> and in good characteristic this dimension can be computed  from the Dynkin-Richardson diagram: the dimension of the class of <code>u</code> is the number of roots <code>α</code> such that <code>⟨σ,α⟩∉{0,1}</code>.</p><p>We   describe  now  the  Springer  correspondence.  Indecomposable  locally constant  <code>𝐆</code>-equivariant  sheaves  on  <code>C</code>,  called  <em>local  systems</em>, are parameterized  by irreducible characters of <code>A(u)</code>. The <em>ordinary</em> Springer correspondence  is a bijection  between irreducible characters  of the Weyl group  and a large subset  of the local systems  which contains all trivial local  systems (those parameterized by the  trivial character of <code>A(u)</code> for each  <code>u</code>).  More  generally,  the  <em>generalized</em>  Springer  correspondence associates  to each local  system a (unique  up to <code>𝐆</code>-conjugacy) <em>cuspidal pair</em>  of a Levi  subgroup <code>𝐋</code> of  <code>𝐆</code> and a  <code>cuspidal</code> local system on an unipotent  class of <code>𝐋</code>, such that the set of local systems associated to a given cuspidal pair is parameterized by the characters of the relative Weyl group <code>W_𝐆(𝐋):=N_𝐆(𝐋)/𝐋</code>. There are only few cuspidal pairs.</p><p>The  Springer correspondence gives information on the character values of a finite  reductive  groups  as  follows:  assume  that  <code>k</code> is the algebraic closure  of a finite field <code>𝔽_q</code> and  that <code>F</code> is the Frobenius attached to an <code>𝔽_q</code>-structure of <code>𝐆</code>. Let <code>C</code> be an <code>F</code>-stable unipotent class and let <code>u∈  C^F</code>; we call <code>C</code>  the <em>geometric class</em> of  <code>u</code> and the <code>𝐆^F</code>-classes inside  <code>C^F</code>  are  parameterized  by  the <code>F</code>-conjugacy classes of <code>A(u)</code>, denoted  <code>H^1(F,A(u))</code> (most of the time we can find <code>u</code> such that <code>F</code> acts trivially  on <code>A(u)</code> and <code>H^1(F,A(u))</code> is then just the conjugacy classes). To  an <code>F</code>-stable character <code>φ</code> of  <code>A(u)</code> we associate the <em>characteristic function</em>  of  the  corresponding  local  system (actually associated to an extension  <code>φ̃</code> of <code>φ</code>  to <code>A(u).F</code>); it  is a class  function <code>Y_{u,φ}</code> on <code>𝐆^F</code>  which can be  normalized so that:  <code>Y_{u,φ}(u₁)=φ̃(cF)</code> if <code>u₁</code> is geometrically  conjugate to <code>u</code> and its <code>𝐆^F</code>-class is parameterized by the <code>F</code>-conjugacy class <code>cF</code> of <code>A(u)</code>, otherwise <code>Y_{u,φ}(u₁)=0</code>. If the pair <code>u,φ</code>  corresponds via the Springer correspondence  to the character <code>χ</code> of <code>W_𝐆(𝐋)</code>,  then <code>Y_{u,φ}</code> is also denoted <code>Yᵪ</code>. There is another important class of functions indexed by local systems: to a local system on class <code>C</code> is  attached  an  intersection  cohomology  complex,  which is a complex of sheaves  supported on  the closure  <code>C̄</code>. To  such a  complex of sheaves is associated  its  <em>characteristic  function</em>,  a  class  function  of  <code>𝐆^F</code> obtained  by taking  the alternating  trace of  the Frobenius acting on the stalks  of the cohomology sheaves. If  <code>Y_ψ</code> is the characteristic function of  a  local  system,  the  characteristic  function  of  the corresponding intersection  cohomology  complex  is  denoted  by  <code>X_ψ</code>. This function is supported  on <code>C̄</code>, and Lusztig has  shown that <code>X_ψ=∑ᵩ P_{ψ,χ} Yᵪ</code> where <code>P_{ψ,χ}</code>  are integer polynomials  in <code>q</code> and  <code>Yᵪ</code> are attached to local systems on classes lying in <code>C̄</code>.</p><p>Lusztig  and Shoji have given an algorithm to compute the matrix <code>P_{ψ,χ}</code>, which  is  implemented  in  Chevie.  The  relationship  with  characters of <code>𝐆(𝔽_q)</code>,  taking to simplify the ordinary Springer correspondence, is that the  restriction to the unipotent elements of the almost character <code>R_χ</code> is equal  to <code>q^{bᵪ} Xᵪ</code>, where <code>bᵪ</code> is <code>dim  𝓑ᵤ</code> for an element <code>u</code> of the class  <code>C</code> such  that the  support of  <code>χ</code> is  <code>C̄</code>. The restriction of the Deligne-Lusztig  characters <code>R_w</code> to  the unipotents are  called the <em>Green functions</em>  and can also be computed by Chevie. The values of all unipotent characters  on  unipotent  elements  can  also  be computed in principle by applying Lusztig&#39;s Fourier transform matrix (see the section on the Fourier matrix)  but  there  is  a  difficulty  in  that  the  <code>Xᵪ</code>  must be first multiplied  by some roots  of unity which  are not known  in all cases (and when  known may  depend on  the congruence  class of  <code>q</code> modulo some small primes).</p><p>We illustrate these computations on some examples:</p><pre><code class="language-julia-repl">julia&gt; UnipotentClasses(rootdatum(:sl,4))
UnipotentClasses(A₃)
1111&lt;211&lt;22&lt;31&lt;4
   u│D-R dBu B-C     C(u) A₃(A₃₍₎) A₁(A₃₍₁₃₎=A₁×A₁)/-1 .(A₃)/ζ₄ .(A₃)/-ζ₄
────┼─────────────────────────────────────────────────────────────────────
4   │222   0 222    q³.Z₄      1:4                -1:2    ζ₄:Id    -ζ₄:Id
31  │202   1 22.      q⁴.    Id:31                                       
22  │020   2 2.2 q⁴.A₁.Z₂     2:22               11:11                   
211 │101   3 2..    q⁵.A₁   Id:211                                       
1111│000   6 ...      .A₃  Id:1111</code></pre><p>The  first column in the table gives the name of the unipotent class, which here  is  a  partition  describing  the  Jordan  form. The partial order on unipotent  classes given by Zariski closure  is given before the table. The column   &#39;D-R&#39;,   displayed   only   in   good  characteristic,  gives  the Dynkin-Richardson  diagram  for  each  class;  the  column  &#39;dBu&#39; gives the dimension  of the  variety <code>𝓑ᵤ</code>.  The column  &#39;B-C&#39; gives  the Bala-Carter classification  of <code>u</code>, that is in the case  of <code>sl₄</code> it displays <code>u</code> as a regular  unipotent  in  a  Levi  subgroup  by  giving the Dynkin-Richardson diagram  of a regular  unipotent (all 2&#39;s)  at entries corresponding to the Levi  and &#39;.&#39; at  entries which do  not correspond to  the Levi. The column &#39;C(u)&#39;  describes  the  group  <code>C_𝐆(u)</code>:  a  power <code>q^d</code> describes that the unipotent  radical  of  <code>C_𝐆(u)</code>  has  dimension  <code>d</code>  (thus <code>q^d</code> rational points);  then follows a  description of the  reductive part of the neutral component  of  <code>C_𝐆(u)</code>,  given  by  the  name  of  its root datum. Then if <code>C_𝐆(u)</code> is not connected, the description of <code>A(u)</code> is given using another vocabulary:  a cyclic group  of order 4  is given as  &#39;Z4&#39;, and a symmetric group on 3 points would be given as &#39;S3&#39;.</p><p>For instance, the first class &#39;4&#39; has <code>C_𝐆(u)^0</code> unipotent of dimension <code>3</code> and  <code>A(u)</code> equal to &#39;Z4&#39;, the cyclic group  of order 4. The class &#39;22&#39; has <code>C_G(u)</code>  with unipotent radical  of dimension <code>4</code>,  reductive part of type &#39;A1&#39;  and <code>A(u)</code> is  &#39;Z2&#39;, that is  the cyclic group  of order 2. The other classes  have <code>C_𝐆(u)</code> connected. For the  class &#39;31&#39; the reductive part of <code>C_G(u)</code> is a torus of rank 1.</p><p>Then  there is one column for each <em>Springer series</em>, giving for each class the pairs &#39;a:b&#39; where &#39;a&#39; is the name of the character of <code>A(u)</code> describing the  local system  involved and  &#39;b&#39; is  the name  of the  character of the (relative)  Weyl group corresponding by the Springer correspondence. At the top  of the column is  written the name of  the relative Weyl group, and in brackets  the name  of the  Levi affording  a cuspidal  local system; next, separated  by a |/| is a description of the central character associated to the  Springer series  (omitted if  this central  character is trivial): all local  systems  in  a  given  Springer  series have same restriction to the center of <code>𝐆</code>. To find what the picture becomes for another algebraic group in  the  same  isogeny  class,  for  instance the adjoint group, one simply discards the Springer series whose central character becomes trivial on the center  of <code>𝐆</code>; and  each group <code>A(u)</code>  has to be  quotiented by the common kernel  of  the  remaining  characters.  Here  is the table for the adjoint group:</p><pre><code class="language-julia-repl">julia&gt; UnipotentClasses(coxgroup(:A,3))
UnipotentClasses(A₃)
1111&lt;211&lt;22&lt;31&lt;4
   u│D-R dBu B-C  C(u) A₃(A₃₍₎)
────┼───────────────────────────
4   │222   0 222    q³     Id:4
31  │202   1 22.   q⁴.    Id:31
22  │020   2 2.2 q⁴.A₁    Id:22
211 │101   3 2.. q⁵.A₁   Id:211
1111│000   6 ...   .A₃  Id:1111</code></pre><p>Here is another example:</p><pre><code class="language-julia-repl">julia&gt; UnipotentClasses(coxgroup(:G,2))
UnipotentClasses(G₂)
1&lt;A₁&lt;Ã₁&lt;G₂(a₁)&lt;G₂
     u│D-R dBu B-C  C(u)        G₂(G₂₍₎)  .(G₂)
──────┼─────────────────────────────────────────
G₂    │ 22   0  22    q²         Id:φ₁‚₀       
G₂(a₁)│ 20   1  20 q⁴.S₃ 21:φ′₁‚₃ 3:φ₂‚₁ 111:Id
Ã₁    │ 01   2  .2 q³.A₁         Id:φ₂‚₂       
A₁    │ 10   3  2. q⁵.A₁        Id:φ″₁‚₃       
1     │ 00   6  ..   .G₂         Id:φ₁‚₆</code></pre><p>which illustrates that on class <code>G₂(a₁)</code> there are two local systems in the principal  series of  the Springer  correspondence, and  a further cuspidal local system. Also, from the &#39;B-C&#39; column, we see that that class is not in a  proper Levi,  in which  case the  Bala-Carter diagram coincides with the Dynkin-Richardson diagram.</p><p>The  characteristics 2 and  3 are not  good for &#39;G2&#39;.  To get the unipotent classes  and the Springer correspondence in bad characteristic, one gives a second argument to the function &#39;UnipotentClasses&#39;:</p><pre><code class="language-julia-repl">julia&gt; UnipotentClasses(coxgroup(:G,2),3)
UnipotentClasses(G₂)
1&lt;A₁,(Ã₁)₃&lt;Ã₁&lt;G₂(a₁)&lt;G₂
     u│dBu B-C  C(u) G₂(G₂₍₎) .(G₂) .(G₂)  .(G₂)
──────┼──────────────────────────────────────────
G₂    │  0  22 q².Z₃   1:φ₁‚₀       ζ₃:Id ζ₃²:Id
G₂(a₁)│  1  20 q⁴.Z₂   2:φ₂‚₁ 11:Id             
Ã₁    │  2  .2    q⁶  Id:φ₂‚₂                   
A₁    │  3  2. q⁵.A₁ Id:φ″₁‚₃                   
(Ã₁)₃ │  3  ?? q⁵.A₁ Id:φ′₁‚₃                   
1     │  6  ..   .G₂  Id:φ₁‚₆  </code></pre><p>The  function &#39;ICCTable&#39; gives the  transition matrix between the functions <code>Xᵪ</code>  and <code>Y_ψ</code>.</p><pre><code class="language-julia-repl">julia&gt; uc=UnipotentClasses(coxgroup(:G,2));
julia&gt; t=ICCTable(uc)
Coefficients of Xᵩ on Y_ψ for G₂
      │G₂ G₂(a₁)⁽²¹⁾ G₂(a₁) Ã₁ A₁  1
──────┼──────────────────────────────
Xφ₁‚₀ │ 1          0      1  1  1  1
Xφ′₁‚₃│ 0          1      0  1  0 q²
Xφ₂‚₁ │ 0          0      1  1  1 Φ₈
Xφ₂‚₂ │ 0          0      0  1  1 Φ₄
Xφ″₁‚₃│ 0          0      0  0  1  1
Xφ₁‚₆ │ 0          0      0  0  0  1</code></pre><p>Here  the row labels  and the column  labels show the  two ways of indexing local  systems: the  row labels  give the  character of the relative Weyl group and the column labels give the class and the name of the local system as  a character  of <code>A(u)</code>:  for instance,  &#39;G2(a1)&#39; is the trivial local system  of the  class &#39;G2(a1)&#39;,  while &#39;G2(a1)(21)&#39;  is the local system on that class corresponding to the 2-dimensional character of <code>A(u)=A₂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Ucl.jl#L1-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Ucl.UnipotentClasses" href="#Gapjm.Ucl.UnipotentClasses"><code>Gapjm.Ucl.UnipotentClasses</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>UnipotentClasses(W[,p])</code></p><p><code>W</code>  should  be  a  <code>CoxeterGroup</code>  record  for a Weyl group or <code>RootDatum</code> describing a reductive algebraic group <code>𝐆</code>. The function returns a record containing   information   about   the   unipotent   classes  of  <code>𝐆</code>  in characteristic   <code>p</code>  (if   omitted,  <code>p</code>   is  assumed   to  be  any  good characteristic for <code>𝐆</code>). This contains the following fields:</p><p><code>group</code>: a pointer to <code>W</code></p><p><code>p</code>: the characteristic of the field for which the unipotent classes were computed. It is <code>0</code> for any good characteristic.</p><p><code>orderClasses</code>:  a list describing the Hasse diagram of the partial order induced   on   unipotent   classes   by   the  closure  relation.  That  is <code>.orderclasses[i]</code>  is the list of <code>j</code> such that <code>C̄ⱼ⊋ C̄ᵢ</code>  and  there  is  no  class  <code>Cₖ</code>  such  that <code>C̄ⱼ⊋ C̄ₖ⊋ C̄ᵢ</code>.</p><p><code>classes</code>:  a  list  of  records  holding information for each unipotent class (see below).</p><p><code>springerSeries</code>:  a list of records, each  of which describes a Springer series  of <code>𝐆</code>.</p><p>The  records  describing  individual  unipotent  classes have the following fields:</p><p><code>name</code>: the name of the unipotent class.</p><p><code>parameter</code>:  a parameter  describing the  class (for  example, a partition describing the Jordan form, for classical groups).</p><p><code>Au</code>: the group <code>A(u)</code>.</p><p><code>dynkin</code>:  present in good characteristic; contains the Dynkin-Richardson diagram,  given  as  a  list  of  0,1,2  describing  the coefficient on the corresponding simple root.</p><p><code>red</code>:  the reductive part of <code>C_𝐆(u)</code>.</p><p><code>dimBu</code>:  the dimension of the variety <code>𝓑ᵤ</code>.</p><p>The  records for classes contain additional  fields for certain groups: for instance,  the names given to classes by Mizuno in <code>E₆, E₇, E₈</code> or by Shoji in <code>F₄</code>.</p><p>The  records  describing  individual  Springer  series  have  the following fields:</p><p><code>levi</code>:the  indices of the  reflections corresponding to  the Levi subgroup <code>𝐋</code>  where  lives  the  cuspidal  local  system <code>ι</code> from which the Springer series is induced.</p><p><code>relgroup</code>:  The  relative  Weyl  group <code>N_𝐆(𝐋,ι)/𝐋</code>. The first series is the principal series for which <code>.levi=[]</code> and <code>.relgroup=W</code>.</p><p><code>locsys</code>:  a  list  of  length  <code>NrConjugacyClasses(.relgroup)</code>, holding in <code>i</code>-th  position a  pair describing  which local  system corresponds to the <code>i</code>-th  character of <code>N_𝐆(𝐋,ι)</code>. The first element of the pair is the index of  the concerned unipotent class  <code>u</code>, and the second  is the index of the corresponding character of <code>A(u)</code>.</p><p><code>Z</code>:  the central character associated  to the Springer series, specified by its value on the generators of the centre.</p><pre><code class="language-julia-repl">julia&gt; W=rootdatum(:sl,4)
A₃

julia&gt; uc=UnipotentClasses(W);

julia&gt; uc.classes
5-element Array{Gapjm.Ucl.UnipotentClass,1}:
 UnipotentClass(1111)
 UnipotentClass(211) 
 UnipotentClass(22)  
 UnipotentClass(31)  
 UnipotentClass(4)   </code></pre><p>The  <code>show</code>  function  for  unipotent  classes  accepts  all the options of <code>formatTable</code>  and  of  <code>charnames</code>.  Giving  the  option  <code>mizuno</code>  (resp. <code>shoji</code>)  uses  the  names  given  by  Mizuno  (resp.  Shoji) for unipotent classes.  Moreover,  there  is  also  an  option  <code>fourier</code> which gives the correspondence  tensored  with  the  sign  character  of each relative Weyl group, which is the correspondence obtained via a Fourier-Deligne transform (here  we assume that  <code>p</code> is very  good, so that  there is a nondegenerate invariant  bilinear  form  on  the  Lie  algebra, and also one can identify nilpotent orbits with unipotent classes).</p><p>Here is how to display the non-cuspidal part of the Springer correspondence of  the unipotent  classes of  <code>E₆</code> using  the notations  of Mizuno for the classes  and those  of Frame  for the  characters of  the Weyl group and of Spaltenstein  for the characters  of <code>G₂</code> (this  is convenient for checking our data with the original paper of Spaltenstein):</p><pre><code class="language-julia-rep1">julia&gt; uc=UnipotentClasses(rootdatum(:Esc,6));

julia&gt; rshow(uc;cols=[5,6,7],spaltenstein=true,frame=true,mizuno=true,
      order=false)
UnipotentClasses(E₆)
     u│            E₆(E₆₍₎) G₂(E₆₍₁₃₅₆₎=A₂×A₂)/ζ₃ G₂(E₆₍₁₃₅₆₎=A₂×A₂)/ζ₃²
──────┼──────────────────────────────────────────────────────────────────
E₆    │                1:1ₚ                  ζ₃:1                  ζ₃²:1
E₆(a₁)│                1:6ₚ                ζ₃:ε_c                ζ₃²:ε_c
D₅    │              Id:20ₚ                                             
A₅+A₁ │        -1:15ₚ 1:30ₚ                 ζ₃:θ′                 ζ₃²:θ′
A₅    │              1:15_q                 ζ₃:θ″                 ζ₃²:θ″
D₅(a₁)│              Id:64ₚ                                             
A₄+A₁ │              Id:60ₚ                                             
D₄    │              Id:24ₚ                                             
A₄    │              Id:81ₚ                                             
D₄(a₁)│111:20ₛ 3:80ₛ 21:90ₛ                                             
A₃+A₁ │              Id:60ₛ                                             
2A₂+A₁│               1:10ₛ                 ζ₃:εₗ                 ζ₃²:εₗ
A₃    │             Id:81ₚ′                                             
A₂+2A₁│             Id:60ₚ′                                             
2A₂   │              1:24ₚ′                  ζ₃:ε                  ζ₃²:ε
A₂+A₁ │             Id:64ₚ′                                             
A₂    │      11:15ₚ′ 2:30ₚ′                                             
3A₁   │            Id:15_q′                                             
2A₁   │             Id:20ₚ′                                             
A₁    │              Id:6ₚ′                                             
1     │              Id:1ₚ′                                             </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Ucl.jl#L488-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Ucl.ICCTable" href="#Gapjm.Ucl.ICCTable"><code>Gapjm.Ucl.ICCTable</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ICCTable(uc[,seriesNo[,q]])</code></p><p>This  function gives the table of decompositions of the functions <code>X_{u,φ}</code> in  terms of the functions  <code>Y_{u,φ}</code>. Here <code>u</code> is  an unipotent element of the  reductive group <code>𝐆</code> and <code>φ</code> is  a character of the group of components <code>A(u)</code>;  such a pair describes a  <code>𝐆</code>-equivariant local system on the class <code>C</code>  of <code>u</code>. The function <code>Y_{u,φ}</code>  is the characteristic function of this local   system  and  <code>X_{u,φ}</code>  is   the  characteristic  function  of  the corresponding  intersection cohomology  complex on  <code>C̄</code>. The local systems can  also be indexed by characters of  the relative Weyl group occurring in the Springer correspondence, and since the coefficient of <code>Xᵪ</code> on <code>Y_ψ</code> is <code>0</code>  if <code>χ</code> and <code>ψ</code> do not correspond  to the same relative Weyl group (are not  in the same Springer series), the  table given is for a given Springer series,  the series  whose number  is given  by the argument &#39;seriesNo&#39; (if omitted  this defaults to &#39;seriesNo=1&#39; which  is the principal series). The decomposition  multiplicities are graded,  and are given  as polynomials in one  variable (specified by the argument  <code>q</code>; if not given <code>Pol([1],1)</code> is assumed).</p><pre><code class="language-julia-repl">julia&gt; t=ICCTable(uc)
Coefficients of Xᵩ on Y_ψ for A₃
     │4 31 22 211 1111
─────┼─────────────────
X4   │1  1  1   1    1
X31  │0  1  1  Φ₂   Φ₃
X22  │0  0  1   1   Φ₄
X211 │0  0  0   1   Φ₃
X1111│0  0  0   0    1</code></pre><p>In  the  above  the  multiplicities  are  given  as  products of cyclotomic polynomials  to display them more compactly. However the &#39;format&#39; of such a table can be controlled more precisely.</p><p>For  instance,  one  can  ask  to  not  display  the entries as products of cyclotomic polynomials:</p><pre><code class="language-julia-rep1">julia&gt; rshow(t;cycpol=false)
Coefficients of X_φ on Y_ψ for A3
     │4 31 22 211   1111
─────┼───────────────────
X4   │1  1  1   1      1
X31  │0  1  1 q+1 q²+q+1
X22  │0  0  1   1   q²+1
X211 │0  0  0   1 q²+q+1
X1111│0  0  0   0      1</code></pre><p>Since  &#39;format&#39;  uses  the  function  <code>format</code> for tables, all the options  of this function are  also available. We can  use this to restrict the  entries displayed to a given sublist of the rows and columns (here the indices correspond to the number in Chevie of the corresponding character of the relative Weyl group of the given Springer series):</p><pre><code class="language-julia-rep1">julia&gt; uc=UnipotentClasses(coxgroup(:F,4));
julia&gt; t=ICCTable(uc);
julia&gt; sh=[13,24,22,18,14,9,11,19];
julia&gt; show(IOContext(stdout,:rows=&gt;sh,:cols=&gt;sh,:limit=&gt;true),t);
Coefficients of X_φ on Y_ψ for F₄
      │A₁+Ã₁ A₂ Ã₂ A₂+Ã₁ Ã₂+A₁ B₂⁽¹¹⁾ B₂ C₃(a₁)⁽¹¹⁾
──────┼─────────────────────────────────────────────
Xφ₉‚₁₀│    1  0  0     0     0      0  0          0
Xφ″₈‚₉│    1  1  0     0     0      0  0          0
Xφ′₈‚₉│    1  0  1     0     0      0  0          0
Xφ″₄‚₇│    1  1  0     1     0      0  0          0
Xφ′₆‚₆│   Φ₄  1  1     1     1      0  0          0
Xφ₄‚₈ │   q²  0  0     0     0      1  0          0
Xφ″₉‚₆│   Φ₄ Φ₄  0     1     0      0  1          0
Xφ′₄‚₇│   q²  0 Φ₄     0     1      0  0          1</code></pre><p>The function &#39;ICCTable&#39; returns a Dict with various pieces of information which can help further computations.</p><p><code>:scalar</code>: this contains the table of multiplicities <code>P_{ψ,χ}</code> of the <code>X_ψ</code> on  the <code>Yᵪ</code>. One should  pay attention that by  default, the table is not displayed  in the same order as the  stored |.scalar|, which is in order in Chevie  of  the  characters  in  the  relative  Weyl  group;  the  table is transposed,  then lines  and rows  are sorted  by |dimBu,class  no,index of character in A(u)| while displayed.</p><p><code>:group</code>: The group &lt;W&gt;.</p><p><code>:relgroup</code>: The relative Weyl group for the Springer series.</p><p><code>:series</code>: The index of the Springer series given for &lt;W&gt;.</p><p><code>:dimBu</code>: The list of <code>dim𝓑ᵤ</code> for each local system <code>(u,φ)</code> in the series.</p><p><code>:L</code>:  The matrix of (unnormalized) scalar  products of the functions <code>Y_ψ</code> with  themselves,  that  is  the  <code>(φ,ψ)</code>  entry  is  <code>∑_{g∈𝐆(𝔽_q)}  Yᵩ(g) Ȳ_ψ(g)</code>.  This  is  thus  a  symmetric,  block-diagonal  matrix  where the diagonal  blocks correspond to geometric  unipotent conjugacy classes. This matrix  is  obtained  as  a  by-product  of  Lusztig&#39;s algorithm to compute <code>P_{ψ,χ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Ucl.jl#L896-L994">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Ucl.induced_linear_form" href="#Gapjm.Ucl.induced_linear_form"><code>Gapjm.Ucl.induced_linear_form</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>induced_linear_form(W, K, h)</code></p><p>This routine can be used to find the Richardson-Dynkin diagram of the class in  the algebraic group <code>𝐆</code>  which contains a given  unipotent class of a reductive subgroup of maximum rank <code>𝐒</code> of <code>𝐆</code>.</p><p>It  takes a linear  form on the  roots of <code>K</code>,  defined by its value on the simple  roots (these values  can define a  Dynkin-Richardson diagram); then extends  this linear form to the roots of <code>𝐆</code> by <code>0</code> on the orthogonal of the  roots of <code>K</code>; and finally conjugates  the resulting form by an element of the Weyl group so that it takes positive values on the simple roots.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:F,4)
F₄

julia&gt; H=reflection_subgroup(W,[1,3])
F₄₍₁₃₎=A₁×Ã₁

julia&gt; Ucl.induced_linear_form(W,H,[2,2])
4-element Array{Int64,1}:
 0
 1
 0
 0

julia&gt; uc=UnipotentClasses(W);

julia&gt; uc.classes[4].prop
Dict{Symbol,Any} with 7 entries:
  :dynkin     =&gt; [0, 1, 0, 0]
  :dimred     =&gt; 6
  :red        =&gt; A₁×A₁
  :Au         =&gt; .
  :balacarter =&gt; [1, 3]
  :dimunip    =&gt; 18
  :AuAction   =&gt; Extended(coxgroup(:A,1)*coxgroup(:A,1),[[1 0; 0 1]])

julia&gt; uc.classes[4]
UnipotentClass(A₁+Ã₁)</code></pre><p>The  example above shows that the class containing the regular class of the Levi subgroup of type <code>A₁× Ã₁</code> is the class |A1+~A1|.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Ucl.jl#L287-L332">source</a></section></article><h1 id="Symbols-1"><a class="docs-heading-anchor" href="#Symbols-1">Symbols</a><a class="docs-heading-anchor-permalink" href="#Symbols-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols" href="#Gapjm.Symbols"><code>Gapjm.Symbols</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The  combinatorial objects  in this  module are  <em>partitions</em>, <em>β-sets</em> and <em>symbols</em>.</p><p>A partition is a decreasing list of strictly positive integers p₁≥p₂≥…pₙ&gt;0, represented as a <code>Vector</code> of <code>Int</code>.</p><p>A  <em>β-set</em> is  a set  of positive  integers, up  to the <em>shift</em> equivalence relation.  This  equivalence  relation  is  the  transitive  closure of the elementary  equivalence  of  [s₁,…,sₙ]  and [0,1+s₁,…,1+sₙ]. An equivalence class  has exactly one  member which does  not contain 0:  it is called the normalized  β-set. A β-set is represented as a strictly increasing <code>Vector</code> of <code>Int</code>.</p><p>To  a  partition  p₁≥p₂≥…pₙ&gt;0  is  associated  a  β-set,  whose  normalized representative   is  pₙ,pₙ₋₁+1,…,p₁+n-1.  Conversely,   to  each  β-set  is associated  a partition, the one giving by the above formula its normalized representative.</p><p>An   <code>n</code>-symbol  is  a  tuple  S=[S₁,…,Sₙ]  of  β-sets,  taken  modulo  the equivalence   relation  generated  by   two  elementary  equivalences:  the simultaneous  shift of all β-sets, and  the cyclic permutation of the tuple (in  the particular case where n=2 it is thus an unordered pair of β-sets). This  time  there  is  a  unique  normalized  symbol  where 0 is not in the intersection of the Sᵢ. The <em>content</em> of <code>S</code> is <code>sum(length(S))</code>; it is not an invariant of the symbol, but the <em>rank</em> is, defined for an <code>n</code>-symbol of content <code>c</code> as <code>sum(sum,S)-div((c-1)*(c-n+1),2*n)</code>.</p><p>Another  function attached to symbols  is the <em>shape</em> &#39;map(length,S)&#39;; when n=2  one can  assume that  S₁ has  at least  the same  length as S₂ and the difference  of cardinals &#39;length(S[1])-length(S[2])&#39;,  called the <em>defect</em>, is then an invariant of the symbol.</p><p>Partitions  and pairs  of partitions  are parameters  for characters of the Weyl groups of classical types, and tuples of partitions are parameters for characters  of  imprimitive  complex  reflection  groups.  Symbols with two β-sets  are parameters for the  unipotent characters of classical Chevalley groups,   and  more  general  symbols  are  parameters  for  the  unipotent characters  of Spetses associated to complex reflection groups. The rank of the  symbol is the semi-simple rank of the corresponding Chevalley group or Spets.</p><p>Symbols of rank n and defect 0 parameterize characters of the Weyl group of type  Dₙ, and  symbols of  rank n  and defect  divisible by  4 parameterize unipotent characters of split orthogonal groups of dimension 2n. Symbols of rank n and defect congruent to 2 mod 4 parameterize unipotent characters of non-split orthogonal groups of dimension 2n. Symbols of rank n and defect 1 parameterize  characters of the Weyl group  of type Bₙ, and finally symbols of  rank n and  odd defect parameterize  unipotent characters of symplectic groups of dimension 2n or orthogonal groups of dimension 2n+1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Symbols.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.shiftβ" href="#Gapjm.Symbols.shiftβ"><code>Gapjm.Symbols.shiftβ</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>shiftβ( β, n)</code> shift β-set β by n</p><pre><code class="language-julia-repl">julia&gt; shiftβ([4,5],3)
5-element Array{Int64,1}:
 0
 1
 2
 7
 8

julia&gt; shiftβ([0,1,4,5],-2)
2-element Array{Int64,1}:
 2
 3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Symbols.jl#L101-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.βset" href="#Gapjm.Symbols.βset"><code>Gapjm.Symbols.βset</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>βset(p)</code> normalized β-set of a partition</p><pre><code class="language-julia-repl">julia&gt; βset([3,3,1])
3-element Array{Int64,1}:
 1
 4
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Symbols.jl#L127-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.partβ" href="#Gapjm.Symbols.partβ"><code>Gapjm.Symbols.partβ</code></a> — <span class="docstring-category">Function</span></header><section><div><p>&#39;partβ(β)&#39; partition defined by β-set β</p><pre><code class="language-julia-repl">julia&gt; partβ([0,4,5])
2-element Array{Int64,1}:
 3
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Symbols.jl#L140-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.ranksymbol" href="#Gapjm.Symbols.ranksymbol"><code>Gapjm.Symbols.ranksymbol</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>ranksymbol(S)</code> rank of symbol <code>S</code>.</p><pre><code class="language-julia-repl">julia&gt; ranksymbol([[1,2],[1,5,6]])
11</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Symbols.jl#L208-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.defectsymbol" href="#Gapjm.Symbols.defectsymbol"><code>Gapjm.Symbols.defectsymbol</code></a> — <span class="docstring-category">Function</span></header><section><div><p>`defectsymbol(s)&#39;</p><p>Let  <code>s=[S,T]</code> be  a symbol  given as  a pair  of lists  (see the whelp for <code>?Symbols</code>).   &#39;defectsymbol&#39;  returns   the  defect   of  <code>s</code>,   equal  to <code>length(S)-length(T)</code>.</p><pre><code class="language-julia-repl">julia&gt; defectsymbol([[1,2],[1,5,6]])
-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Symbols.jl#L267-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.fegsymbol" href="#Gapjm.Symbols.fegsymbol"><code>Gapjm.Symbols.fegsymbol</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>fegsymbol(S)</code> </p><p>Let  <code>s=[S₁,…,Sₙ]</code> be  a symbol  given as  a list  of lists.  This function returns as a CycPol the fake degree of the character of symbol <code>S</code>.</p><pre><code class="language-julia-repl">julia&gt; fegsymbol([[1,5,6],[1,2]])
q¹⁶Φ₅Φ₇Φ₈Φ₉Φ₁₀Φ₁₁Φ₁₄Φ₁₆Φ₁₈Φ₂₀Φ₂₂</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Symbols.jl#L448-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.gendeg_symbol" href="#Gapjm.Symbols.gendeg_symbol"><code>Gapjm.Symbols.gendeg_symbol</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>gendeg_symbol(s)</code></p><p>Let  <code>s=[S₁,…,Sₙ]</code>  be  a  symbol.  The  function returns as a <code>CycPol</code> the generic degree of the unipotent character parameterized by <code>s</code>.</p><pre><code class="language-julia-repl">julia&gt; Symbols.gendeg_symbol([[1,2],[1,5,6]])
q¹³Φ₅Φ₆Φ₇Φ₈²Φ₉Φ₁₀Φ₁₁Φ₁₄Φ₁₆Φ₁₈Φ₂₀Φ₂₂/2</code></pre><p>Works for symbols for:</p><pre><code class="language-none">   G(e,1,r) (d==1, defect==0)
   G(e,e,r) (d==0, defect==0)
  ²G(e,e,2) (d==0, defect==1) (this includes ²Dₙ, ²B₂, ²G₂)</code></pre><p>here d=Inhalt mod. e  See cite[3.9 and 6.4]{Malle Unipotente Grade}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Symbols.jl#L494-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.degree_feg_symbol" href="#Gapjm.Symbols.degree_feg_symbol"><code>Gapjm.Symbols.degree_feg_symbol</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>degree_feg_symbol(s)</code></p><p>Let  <code>s=[S₁,…,Sₙ]</code> be  a symbol  given as  a list  of lists.  This function returns  the degree  of the  fake degree  of the character parameterized by <code>s</code>.</p><pre><code class="language-julia-repl">julia&gt; degree_feg_symbol([[1,5,6],[1,2]])
88</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Symbols.jl#L283-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.degree_gendeg_symbol" href="#Gapjm.Symbols.degree_gendeg_symbol"><code>Gapjm.Symbols.degree_gendeg_symbol</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>degree_gendeg_symbol(s)</code></p><p>Let  <code>s=[S₁,…,Sₙ]</code> be  a symbol  given as  a list  of lists.  This function returns  the  degree  of  the  generic  degree  of  the unipotent character parameterized by <code>s</code>.</p><pre><code class="language-julia-repl">julia&gt; degree_gendeg_symbol([[1,5,6],[1,2]])
91</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Symbols.jl#L243-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.valuation_feg_symbol" href="#Gapjm.Symbols.valuation_feg_symbol"><code>Gapjm.Symbols.valuation_feg_symbol</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>valuation_feg_symbol(s)</code></p><p>Let  <code>s=[S₁,…,Sₙ]</code> be a symbol <code>valuation_feg_symbol</code> returns the valuation of the fake degree of the character parameterized by <code>s</code>.</p><pre><code class="language-julia-repl">julia&gt; valuation_feg_symbol([[1,2],[1,5,6]])
-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Symbols.jl#L313-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.valuation_gendeg_symbol" href="#Gapjm.Symbols.valuation_gendeg_symbol"><code>Gapjm.Symbols.valuation_gendeg_symbol</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>valuation_gendeg_symbol(s)</code></p><p>Let  <code>s=[S₁,…,Sₙ]</code> be a  symbol. The function  returns the valuation of the generic degree of the unipotent character parameterized by <code>s</code>.</p><pre><code class="language-julia-repl">julia&gt; valuation_gendeg_symbol([[1,2],[1,5,6]])
13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Symbols.jl#L224-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.tableaux" href="#Gapjm.Symbols.tableaux"><code>Gapjm.Symbols.tableaux</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>tableaux(S)</code></p><p><code>S</code>  is a  partition tuple  or a  partition. returns  the list  of standard tableaux  associated to the partition  tuple <code>S</code>, that is  a filling of the associated  young diagrams  with the  numbers <code>1:sum(sum,S)</code>  such that the numbers  increase across the rows  and down the columns.  If the imput is a single partition, the standard tableaux for that partition are returned.</p><pre><code class="language-julia-repl">julia&gt; tableaux([[2,1],[1]])
8-element Array{Any,1}:
 [[[2, 4], [3]], [[1]]]
 [[[1, 4], [3]], [[2]]]
 [[[1, 4], [2]], [[3]]]
 [[[2, 3], [4]], [[1]]]
 [[[1, 3], [4]], [[2]]]
 [[[1, 2], [4]], [[3]]]
 [[[1, 3], [2]], [[4]]]
 [[[1, 2], [3]], [[4]]]

julia&gt; tableaux([2,2])
2-element Array{Array{Array{Int64,1},1},1}:
 [[1, 3], [2, 4]]
 [[1, 2], [3, 4]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Symbols.jl#L569-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Symbols.symbols" href="#Gapjm.Symbols.symbols"><code>Gapjm.Symbols.symbols</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>symbols(e,r,c)</code> e-symbols of rank r and content=c mode e</p><p>The content of a symbol <code>S</code>is <code>sum(length,S)%length(S)</code>. The symbols for unipotent  characters of  <code>G(d,1,r)</code> are  <code>symbols(d,r,1)</code> and those for unipotent characters of <code>G(e,e,r)</code> are <code>symbols(e,r,0)</code>.</p><pre><code class="language-julia-repl">julia&gt; stringsymbol.(symbols(3,2,1))
14-element Array{String,1}:
 &quot;(12,0,0)&quot;   
 &quot;(02,1,0)&quot;   
 &quot;(02,0,1)&quot;   
 &quot;(012,12,01)&quot;
 &quot;(01,1,1)&quot;   
 &quot;(012,01,12)&quot;
 &quot;(2,,)&quot;      
 &quot;(01,2,0)&quot;   
 &quot;(01,0,2)&quot;   
 &quot;(1,012,012)&quot;
 &quot;(,02,01)&quot;   
 &quot;(,01,02)&quot;   
 &quot;(0,,012)&quot;   
 &quot;(0,012,)&quot;   

julia&gt; stringsymbol.(symbols(3,3,0))
10-element Array{String,1}:
 &quot;(1,1,1)&quot;      
 &quot;(01,12,02)&quot;   
 &quot;(01,02,12)&quot;   
 &quot;(012,012,123)&quot;
 &quot;(0,1,2)&quot;      
 &quot;(0,2,1)&quot;      
 &quot;(01,01,13)&quot;   
 &quot;(0,0,3)&quot;      
 &quot;(012,,)&quot;      
 &quot;(012,012,)&quot;   </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Symbols.jl#L359-L397">source</a></section></article><h1 id="Signed-permutations-1"><a class="docs-heading-anchor" href="#Signed-permutations-1">Signed permutations</a><a class="docs-heading-anchor-permalink" href="#Signed-permutations-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.SPerms" href="#Gapjm.SPerms"><code>Gapjm.SPerms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A  signed permutation of <code>1:n</code> is  a permutation of the set <code>-n,…,-1,1,…,n</code> which  preserves the  pairs <code>(-i,i)</code>.  It is  represented internally as the images of <code>1:n</code>. It is printed as a product of signed cycles.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; SPerm([-2,-1,-3])
SPerm{Int64}: (1,-2)(3,-3)

julia&gt; p=SPerm(-1)
(1,-1)

julia&gt; q=SPerm(1,2)
(1,2)

julia&gt; elements(Group([p,q]))
8-element Array{SPerm{Int16},1}:
 ()          
 (1,-1)(2,-2)
 (1,-2,-1,2) 
 (1,-2)      
 (1,2)       
 (1,2,-1,-2) 
 (2,-2)      
 (1,-1)      </code></pre><p>The  complete type of signed permutations is <code>SPerm{T}</code> where <code>T&lt;:Integer</code>, where <code>Vector{T}</code> is the type of the vector which holds the image of <code>1:n</code>. This  can used to save space or time when possible. If <code>T</code> is not specified we  take it to be <code>Int16</code> since this is a good compromise between speed and compactness.</p><p>SPerms have methods <code>copy, hash, ==, cmp, isless</code> (total order) so they can be  keys in hashes or elements of sets; two <code>SPerms</code> are equal if they move the same points to the same images. For instance,</p><pre><code class="language-julia-repl">julia&gt; SPerm([-2,-1,-3])==SPerm([-2,-1,-3,4])
true</code></pre><p>SPerms are considered as scalars for broadcasting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/SPerms.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.SPerms.SPerm" href="#Gapjm.SPerms.SPerm"><code>Gapjm.SPerms.SPerm</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct SPerm</code></p><p>An  <code>SPerm</code> represents a signed permutation of <code>1:n</code>, that is a permutation of  the  set  <code>-n,…,-1,1,…,n</code>  which  preserves  the  pairs <code>(-i,i)</code>. It is implemented  by a <code>struct SPerm</code>  with one field <code>d</code>,  a vector holding the images of <code>1:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/SPerms.jl#L48-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Perms.Perm-Tuple{SPerm}" href="#Gapjm.Perms.Perm-Tuple{SPerm}"><code>Gapjm.Perms.Perm</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Perm(p::SPerm)</code> returns the underlying Perm of an SPerm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/SPerms.jl#L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Groups.orbit-Tuple{SPerm,Integer}" href="#Gapjm.Groups.orbit-Tuple{SPerm,Integer}"><code>Gapjm.Groups.orbit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>orbit(a::SPerm,i::Integer) returns the orbit of a on i</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/SPerms.jl#L131-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.order-Tuple{SPerm}" href="#Gapjm.order-Tuple{SPerm}"><code>Gapjm.order</code></a> — <span class="docstring-category">Method</span></header><section><div><p>order(a) </p><p>order of the signed permutation a</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/SPerms.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Matrix" href="#Base.Matrix"><code>Base.Matrix</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Matrix(a::Perm,n=degree(a))</code>  the  permutation  matrix  for  <code>a</code>  operating  on <code>n</code> points. If given, <code>n</code> should be larger than <code>largest_moved_point(a)</code>.</p><pre><code class="language-julia-repl">julia&gt; Matrix(Perm(2,3,4),5)
5×5 Array{Bool,2}:
 1  0  0  0  0
 0  0  1  0  0
 0  0  0  1  0
 0  1  0  0  0
 0  0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Perms.jl#L262-L276">source</a></section><section><div><p><code>Matrix(a::SPerm)</code> is the permutation matrix for a</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Matrix(SPerm([-2,-1,-3]))
3×3 Array{Int64,2}:
  0  -1   0
 -1   0   0
  0   0  -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/SPerms.jl#L275-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.SPerms.CoxHyperoctaedral" href="#Gapjm.SPerms.CoxHyperoctaedral"><code>Gapjm.SPerms.CoxHyperoctaedral</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>CoxHyperoctaedral(n)</code> The Hyperoctaedral group on ±1,…,±n as a Coxeter group   of type B, with generators (1,-1) and (i,i+1)(-i,-i-1)</p><pre><code class="language-julia-repl">julia&gt; elements(CoxHyperoctaedral(2))
8-element Array{SPerm{Int8},1}:
 ()          
 (1,2)       
 (1,-1)      
 (1,2,-1,-2) 
 (1,-2,-1,2) 
 (2,-2)      
 (1,-2)      
 (1,-1)(2,-2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/SPerms.jl#L440-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection_subgroup-Tuple{CoxHyperoctaedral,AbstractArray{Int64,1}}" href="#Gapjm.PermRoot.reflection_subgroup-Tuple{CoxHyperoctaedral,AbstractArray{Int64,1}}"><code>Gapjm.PermRoot.reflection_subgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Only parabolics defined are I=1:m for m≤n</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/SPerms.jl#L500">source</a></section></article><h1 id="Utilities-1"><a class="docs-heading-anchor" href="#Utilities-1">Utilities</a><a class="docs-heading-anchor-permalink" href="#Utilities-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util" href="#Gapjm.Util"><code>Gapjm.Util</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This  module contains  various utility  functions used  in the  rest of the code.  Maybe some  of them  exist in  some Julia  module I am not aware of; please tell me.</p><p>The code is divided in sections  according to semantics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Util.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.groupby" href="#Gapjm.Util.groupby"><code>Gapjm.Util.groupby</code></a> — <span class="docstring-category">Function</span></header><section><div><p>group items of list l according to the corresponding values in list v</p><pre><code class="language-none">julia&gt; groupby([31,28,31,30,31,30,31,31,30,31,30,31],
       [:Jan,:Feb,:Mar,:Apr,:May,:Jun,:Jul,:Aug,:Sep,:Oct,:Nov,:Dec])
Dict{Int64,Array{Symbol,1}} with 3 entries:
  31 =&gt; Symbol[:Jan, :Mar, :May, :Jul, :Aug, :Oct, :Dec]
  28 =&gt; Symbol[:Feb]
  30 =&gt; Symbol[:Apr, :Jun, :Sep, :Nov]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Util.jl#L47-L57">source</a></section><section><div><p>group items of list l according to the values taken by function f on them</p><pre><code class="language-none">julia&gt; groupby(iseven,1:10)
Dict{Bool,Array{Int64,1}} with 2 entries:
  false =&gt; [1, 3, 5, 7, 9]
  true  =&gt; [2, 4, 6, 8, 10]</code></pre><p>Note:in this version l is required to be non-empty since I do not know how to access the return type of a function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Util.jl#L66-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.constant" href="#Gapjm.Util.constant"><code>Gapjm.Util.constant</code></a> — <span class="docstring-category">Function</span></header><section><div><p>whether all elements in list a are equal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Util.jl#L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.format" href="#Gapjm.Util.format"><code>Gapjm.Util.format</code></a> — <span class="docstring-category">Function</span></header><section><div><p>format(io, table; options )</p><p>General routine to format a table. Used for character tables.   Options:      row<em>labels          Labels for rows      col</em>labels          Labels for columns      rows<em>label          Label for column of rowLabels      separators          line numbers after which to put a separator      column</em>repartition  display in pieces of sizes these numbers of cols      rows                show only these rows      cols                show only these columns</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Util.jl#L157-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.prime_residues" href="#Gapjm.Util.prime_residues"><code>Gapjm.Util.prime_residues</code></a> — <span class="docstring-category">Function</span></header><section><div><p>the numbers less than n and prime to n </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Util.jl#L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.phi" href="#Gapjm.Util.phi"><code>Gapjm.Util.phi</code></a> — <span class="docstring-category">Function</span></header><section><div><p>the Euler function ϕ </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Util.jl#L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.primitiveroot" href="#Gapjm.Util.primitiveroot"><code>Gapjm.Util.primitiveroot</code></a> — <span class="docstring-category">Function</span></header><section><div><p>primitiveroot(m::Integer) a primitive root mod. m,   that is it generates multiplicatively prime_residues(m).   It exists if m is of the form 4, 2p^a or p^a for p prime&gt;2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Util.jl#L289-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Util.gcd_repr" href="#Gapjm.Util.gcd_repr"><code>Gapjm.Util.gcd_repr</code></a> — <span class="docstring-category">Function</span></header><section><div><p>gcd_repr(x,y) returns a,b such that ax+by=gcd(x,y)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Util.jl#L308-L310">source</a></section></article><h1 id="Combinatorics-1"><a class="docs-heading-anchor" href="#Combinatorics-1">Combinatorics</a><a class="docs-heading-anchor-permalink" href="#Combinatorics-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.arrangements" href="#Gapjm.Combinat.arrangements"><code>Gapjm.Combinat.arrangements</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>arrangements(mset[,k])</code></p><p><code>arrangements</code> returns the set of arrangements of the multiset <code>mset</code>. It a second argument <code>k</code> is given, it returns all arrangements with <code>k</code> elements of the multiset <code>mset</code>.</p><p>An  <em>arrangement</em> of <code>mset</code>  is an ordered selection  without repetitions and is represented by a list that contains only elements from <code>mset</code>, but maybe  in a different  order.</p><p>As an example of arrangements of a multiset, think  of the game Scrabble. Suppose you have the six characters of the word &#39;settle&#39;  and you have to make a four letter word.  Then the possibilities are given by</p><p>``julia-repl julia&gt; length(arrangements(collect(&quot;settle&quot;),4)) 102</p><p>julia&gt; length(arrangements(collect(&quot;settle&quot;))) 523 ```</p><p>Note that the fact that the list returned by &#39;arrangements&#39; is a proper set means  in this example that the possibilities  are listed in the same order as they appear in the dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Combinat.jl#L60-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.combinations" href="#Gapjm.Combinat.combinations"><code>Gapjm.Combinat.combinations</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>combinations(mset[,k])</code></p><p>&#39;combinations&#39;  returns the set of all combinations of the multiset <code>mset</code>. If  a second argument <code>k</code> is given,  it returns the set of all combinations of the multiset <code>mset</code> with <code>k</code> elements.</p><p>A <em>combination</em> of <code>mset</code> is an unordered selection without repetitions and is  represented by a sorted  sublist of <code>mset</code>. If  <code>mset</code> is a proper set, the set of all combinations is just the <em>powerset</em> of <code>mset</code>.</p><pre><code class="language-julia-repl">julia&gt; combinations([1,2,2,3])
12-element Array{Array{Int64,1},1}:
 []
 [1]
 [2]
 [3]
 [1, 2]
 [1, 3]
 [2, 2]
 [2, 3]
 [1, 2, 2]
 [1, 2, 3]
 [2, 2, 3]
 [1, 2, 2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Combinat.jl#L15-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.compositions" href="#Gapjm.Combinat.compositions"><code>Gapjm.Combinat.compositions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>compositions(n[,i])</code></p><p>returns  the list of compositions of the integer <code>n</code> (the compositions with <code>i</code> parts if a second argument <code>i</code> is given).</p><pre><code class="language-julia-repl">julia&gt; compositions(4)
8-element Array{Array{Int64,1},1}:
 [1, 1, 1, 1]
 [2, 1, 1]
 [1, 2, 1]
 [3, 1]
 [1, 1, 2]
 [2, 2]
 [1, 3]
 [4]

julia&gt; compositions(4,2)
3-element Array{Array{Int64,1},1}:
 [3, 1]
 [2, 2]
 [1, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Combinat.jl#L281-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.conjugate_partition" href="#Gapjm.Combinat.conjugate_partition"><code>Gapjm.Combinat.conjugate_partition</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>conjugate_partition(pi)</code></p><p>returns the conjugate partition of the partition <code>pi</code>.</p><pre><code class="language-julia-repl">julia&gt; conjugate_partition([4,2,1])
4-element Array{Int64,1}:
 3
 2
 1
 1

julia&gt; conjugate_partition([6])
6-element Array{Int64,1}:
 1
 1
 1
 1
 1
 1</code></pre><p>The  <em>conjugate  partition</em>  of  a  partition  <code>pi</code>  is  defined  to be the partition belonging to the transposed of the Young diagram of <code>pi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Combinat.jl#L235-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.dominates" href="#Gapjm.Combinat.dominates"><code>Gapjm.Combinat.dominates</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>dominates(mu,nu)</code></p><p>The  dominance  ordering  is  an  important partial order in representation theory.  <code>dominates(mu,nu)</code> returns  <code>true</code> if  either <code>mu==nu</code>  or for all <code>i≥1</code> we have <code>sumⱼ₌₁ⁱ muⱼ≥sumⱼ₌₁ⁱ nuⱼ</code>, and <code>false</code> otherwise.</p><pre><code class="language-julia-repl">julia&gt; dominates([5,4],[4,4,1])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Combinat.jl#L267-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.partitions" href="#Gapjm.Combinat.partitions"><code>Gapjm.Combinat.partitions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>partitions(n)</code></p><p><code>partitions</code> returns the set of all partitions of the positive integer <code>n</code>.</p><p>A  <em>partition</em>  is  a  sum  <code>n=p₁+p₂+…+  pₖ</code>  of  positive  integers and is represented  by the  list <code>p=[p₁,p₂,…,pₖ]</code>,  in nonincreasing  order, i.e., <code>p₁≥p₂≥…≥pₖ</code>.  We write <code>p⊢n</code>.  There are approximately <code>exp(π√(2n/3))/(4√3 n)</code> such partitions.</p><pre><code class="language-julia-repl">julia&gt; partitions(7)
15-element Array{Array{Int64,1},1}:
 [1, 1, 1, 1, 1, 1, 1]
 [2, 1, 1, 1, 1, 1]
 [2, 2, 1, 1, 1]
 [2, 2, 2, 1]
 [3, 1, 1, 1, 1]
 [3, 2, 1, 1]
 [3, 2, 2]
 [3, 3, 1]
 [4, 1, 1, 1]
 [4, 2, 1]
 [4, 3]
 [5, 1, 1]
 [5, 2]
 [6, 1]
 [7]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Combinat.jl#L103-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Combinat.submultisets" href="#Gapjm.Combinat.submultisets"><code>Gapjm.Combinat.submultisets</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>submultisets(set,k)</code></p><p><code>submultisets</code> returns the  set of all  multisets length <code>k</code> of elements of the set <code>set</code>.</p><p>An <em>multiset</em> of length <code>k</code> is a  selection with repetitions  of length <code>k</code> from <code>set</code> and  is represented by a vector of length <code>k</code> containing  elements  from  <code>set</code>.   There  are   <code>binomial(|set|+k-1,k)</code> such sub-multisets.</p><pre><code class="language-julia-repl">julia&gt; Combinat.submultisets(1:4,3)
20-element Array{Array{Int64,1},1}:
 [1, 1, 1]
 [1, 1, 2]
 [1, 1, 3]
 [1, 1, 4]
 [1, 2, 2]
 [1, 2, 3]
 [1, 2, 4]
 [1, 3, 3]
 [1, 3, 4]
 [1, 4, 4]
 [2, 2, 2]
 [2, 2, 3]
 [2, 2, 4]
 [2, 3, 3]
 [2, 3, 4]
 [2, 4, 4]
 [3, 3, 3]
 [3, 3, 4]
 [3, 4, 4]
 [4, 4, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Combinat.jl#L316-L351">source</a></section></article><h1 id="ModuleElts.jl-Documentation-1"><a class="docs-heading-anchor" href="#ModuleElts.jl-Documentation-1">ModuleElts.jl Documentation</a><a class="docs-heading-anchor-permalink" href="#ModuleElts.jl-Documentation-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.ModuleElts" href="#Gapjm.ModuleElts"><code>Gapjm.ModuleElts</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A  <code>ModuleElt</code> represents an element of a  module. It is essentially a list of pairs <code>b=&gt;c</code> where <code>b</code> is a basis element and <code>c</code> its coefficient.</p><p>The  constructors  take  as  argument  a  list  of  pairs,  or several pair arguments,  or a generator of pairs. We provide two implementations, one by dicts and one by sorting pairs by key.</p><p>Here is an example where basis elements are represented by Symbols.</p><pre><code class="language-julia-repl">julia&gt; a=ModuleElt(:xy=&gt;1,:yx=&gt;-1)
:xy-:yx

julia&gt; a-a
0

julia&gt; a*99
99:xy-99:yx

julia&gt; push!(a,:yy=&gt;2)
:xy-:yx+2:yy

julia&gt; a+ModuleElt(:yx=&gt;1)
:xy+2:yy

julia&gt; a[:xy]
1

julia&gt; haskey(a,:xx)
false</code></pre><p>both implementations provide an option check which normalizes an element, removing zero coefficients</p><pre><code class="language-julia-repl">julia&gt; a=ModuleElt(:yy=&gt;1, :yx=&gt;2, :xy=&gt;3, :yy=&gt;-1)
:yy+2:yx+3:xy-:yy

julia&gt; a=ModuleElt([:yy=&gt;1, :yx=&gt;2, :xy=&gt;3, :yy=&gt;-1];check=true)
3:xy+2:yx

julia&gt; a
3:xy+2:yx</code></pre><p>setting the property showbasis determines how the basis elements are printed.</p><pre><code class="language-julia-rep1">julia&gt; show(IOContext(stdout,:showbasis=&gt;(io,s)-&gt;String(s)),a)
3xy+2yx</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/ModuleElts.jl#L1-L54">source</a></section></article><h1 id="Cyclotomic-polynomials-1"><a class="docs-heading-anchor" href="#Cyclotomic-polynomials-1">Cyclotomic polynomials</a><a class="docs-heading-anchor-permalink" href="#Cyclotomic-polynomials-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CycPols" href="#Gapjm.CycPols"><code>Gapjm.CycPols</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Cyclotomic  numbers, and cyclotomic polynomials  over the rationals or some cyclotomic field, are important in reductive groups or Spetses. This module deals  with them: the type <code>CycPol</code>  represents the product of a polynomial with  a rational fraction in one variable with all poles or zeroes equal to 0  or  roots  of  unity.  The  advantages  of representing as <code>CycPol</code> such objects    are:   nice   display   (factorized),   less   storage,   faster multiplication,  division and evaluation. The drawback is that addition and subtraction are not implemented!</p><pre><code class="language-julia-repl">julia&gt; Pol(:q)
Pol{Int64}: q

julia&gt; p=CycPol(q^25-q^24-2q^23-q^2+q+2)
(q-2)Φ₁Φ₂Φ₂₃

julia&gt; p(q) # a CycPol is a callable object, this call evaluates p at q
Pol{Cyc{Int64}}: q²⁵-q²⁴-2q²³-q²+q+2

julia&gt; p*inv(CycPol(q^2+q+1))
(q-2)Φ₁Φ₂Φ₃⁻¹Φ₂₃
</code></pre><p>The variable name in a <code>CycPol</code> is set by default to the same as for <code>Pols</code>.</p><p><code>CycPol</code>s are internally a <code>struct</code> with fields:</p><p><code>.coeff</code>:  a coefficient, usually a cyclotomic number or a polynomial.</p><p><code>.valuation</code>: an <code>Int</code>.</p><p><code>.v</code>: a list of pairs <code>r=&gt;m</code> of a root of unity <code>r</code> and a multiplicity <code>m</code>. Here <code>r</code> is a <code>Root1</code>, internally a fraction <code>n//e</code> with <code>n&lt;e</code> representing <code>E(r)=E(e,n)</code>.</p><p>So <code>CycPol(c,val,v)</code> represents <code>c*q^val*prod((q-E(r))^m for (r,m) in v)</code>.</p><p>When   showing,  some  factors  of   the  cyclotomic  polynomial  <code>Φₙ</code>  are represented.  If <code>n</code> has a primitive root  <code>ξ</code>, <code>ϕ′ₙ</code> is the product of the <code>(q-ζ)</code> where <code>ζ</code> runs over the odd powers of <code>ξ</code>, and <code>ϕ″ₙ</code> is the product for the even powers. The function <code>show_factors</code> gives the complete list of recognized factors:</p><pre><code class="language-julia-rep1">julia&gt; CycPols.show_factors(24)
Φ₂₄=q⁸-q⁴+1
Φ′₂₄=q⁴+ζ₃²
Φ″₂₄=q⁴+ζ₃
Φ‴₂₄=q⁴-√2q³+q²-√2q+1
Φ⁗₂₄=q⁴+√2q³+q²+√2q+1
Φ⁽⁵⁾₂₄=q⁴-√6q³+3q²-√6q+1
Φ⁽⁶⁾₂₄=q⁴+√6q³+3q²+√6q+1
Φ⁽⁷⁾₂₄=q⁴+(√-2)q³-q²+(-√-2)q+1
Φ⁽⁸⁾₂₄=q⁴+(-√-2)q³-q²+(√-2)q+1
Φ⁽⁹⁾₂₄=q⁴-ζ₄q²-1
Φ⁽¹⁰⁾₂₄=q⁴+ζ₄q²-1
Φ⁽¹¹⁾₂₄=q²+(ζ₂₄+ζ₂₄¹⁹)q-ζ₃
Φ⁽¹²⁾₂₄=q²+(-ζ₂₄-ζ₂₄¹⁹)q-ζ₃
Φ⁽¹³⁾₂₄=q²+(ζ₂₄¹¹+ζ₂₄¹⁷)q-ζ₃²
Φ⁽¹⁴⁾₂₄=q²+(-ζ₂₄¹¹-ζ₂₄¹⁷)q-ζ₃²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CycPols.jl#L1-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CycPols.CycPol" href="#Gapjm.CycPols.CycPol"><code>Gapjm.CycPols.CycPol</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>CycPol(p::Pol)</code></p><p>Converts a polynomial to <code>CycPol</code></p><pre><code class="language-julia-repl">julia&gt; CycPol(3*q^3-3)
3Φ₁Φ₃</code></pre><p>Special code makes the conversion fast if <code>p</code> has not more than two nonzero coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/CycPols.jl#L313-L325">source</a></section><section><div><p><code>CycPol(v::AbstractVector)</code></p><p>This  form is a fast  and efficient way of  specifying a <code>CycPol</code> with only positive multiplicities: <code>v</code> should be a vector. The first element is taken as  a  the  <code>.coeff</code>  of  the  <code>CycPol</code>,  the  second  as the <code>.valuation</code>. Subsequent  elements are rationals <code>i//d</code>  representing <code>(q-E(d)^i)</code> or are integers <code>d</code> representing <code>Φ_d(q)</code>.</p><pre><code class="language-julia-repl">julia&gt; CycPol([3,-5,6,3//7])
3q⁻⁵Φ₆(q-ζ₇³)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/HasType.jl#L75-L88">source</a></section></article><h1 id="Posets-1"><a class="docs-heading-anchor" href="#Posets-1">Posets</a><a class="docs-heading-anchor-permalink" href="#Posets-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets" href="#Gapjm.Posets"><code>Gapjm.Posets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Posets  are represented as  Dicts where at  least one of  the two following fields is present:</p><p><code>:incidence</code>:  a  boolean  matrix  such that <code>:incidence[i][j]==true</code> iff   <code>i&lt;=j</code> in the poset.</p><p><code>:hasse</code>:  a list representing  the Hasse diagram  of the poset: the i-th   entry  is the list of indices  of elements which are immediate successors   (covers)  of the i-th element, that is the  list of j such that <code>i&lt;j</code> and   such that there is no k such that i&lt;k&lt;j.</p><p>If  only one field is present, the other  is computed on demand. Here is an example of use;</p><pre><code class="language-julia-repl">julia&gt; p=Poset(coxgroup(:A,2))
&lt;1,2&lt;21,12&lt;121

julia&gt; hasse(p)
6-element Array{Array{Int64,1},1}:
 [2, 3]
 [4, 5]
 [4, 5]
 [6]   
 [6]   
 []    

julia&gt; incidence(p)
6×6 Array{Bool,2}:
 1  1  1  1  1  1
 0  1  0  1  1  1
 0  0  1  1  1  1
 0  0  0  1  0  1
 0  0  0  0  1  1
 0  0  0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Posets.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.Poset" href="#Gapjm.Posets.Poset"><code>Gapjm.Posets.Poset</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Poset(m::Matrix{Bool})</code></p><p>Creates a poset from an incidence matrix <code>m</code>, that is <code>m[i,j]==true</code> if and only if <code>i≤j</code> in the poset,</p><pre><code class="language-julia-repl">julia&gt; Poset(Bool[1 1 1 1 1;0 1 0 1 1;0 0 1 1 1;0 0 0 1 0;0 0 0 0 1])
1&lt;2,3&lt;4,5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Posets.jl#L143-L153">source</a></section><section><div><p><code>Poset(h::Vector{&lt;:Vector{&lt;:Integer}})</code></p><p>Creates a poset from a Hasse diagram given as a <code>Vector</code> whose <code>i</code>-th entry is  the list of indices of elements which are immediate successors (covers) of the <code>i</code>-th element, that is <code>h[i]</code> is the list of <code>j</code> such that <code>i&lt;j</code> in the poset and such that there is no <code>k</code> such that <code>i&lt;k&lt;j</code>.</p><pre><code class="language-julia-repl">julia&gt; Poset([[2,3],[4,5],[4,5],Int[],Int[]])
1&lt;2,3&lt;4,5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Posets.jl#L157-L169">source</a></section><section><div><p><code>Poset(W::CoxeterGroup,w=longest(W))</code></p><p>returns  as a poset the Bruhat interval <code>[1,w]</code>of <code>W</code>. If <code>w</code> is not given, the whole Bruhat Poset of <code>W</code> is returned (<code>W</code> must then be finite).</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; Poset(W)
&lt;1,2&lt;21,12&lt;121

julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; Poset(W,W(1,3))
&lt;3,1&lt;13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Posets.jl#L460-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.lcm_partitions" href="#Gapjm.Posets.lcm_partitions"><code>Gapjm.Posets.lcm_partitions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>lcm_partitions(p1,...,pn)</code></p><p>each  argument is  a partition  of the  same set  <code>S</code>, given  as a  list of disjoint  vectors whose  union is  <code>S</code>. Equivalently  each argument  can be interpreted as an equivalence relation on <code>S</code>.</p><p>The result is the finest partition of <code>S</code> such that each argument partition refines it. It represents the &#39;or&#39; of the equivalence relations represented by the arguments.</p><pre><code class="language-julia-repl">julia&gt; lcm_partitions([[1,2],[3,4],[5,6]],[[1],[2,5],[3],[4],[6]])
2-element Array{Array{Int64,1},1}:
 [1, 2, 5, 6]
 [3, 4]      </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Posets.jl#L44-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.gcd_partitions" href="#Gapjm.Posets.gcd_partitions"><code>Gapjm.Posets.gcd_partitions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>gcd_partitions(p1,...,pn)</code> Each  argument is  a partition  of the  same set  <code>S</code>, given  as a  list of disjoint  vectors whose  union is  <code>S</code>. Equivalently  each argument  can be interpreted as an equivalence relation on <code>S</code>.</p><p>The result is the coarsest partition which refines all argument partitions. It  represents the  &#39;and&#39; of  the equivalence  relations represented by the arguments.</p><pre><code class="language-julia-repl">julia&gt; gcd_partitions([[1,2],[3,4],[5,6]],[[1],[2,5],[3],[4],[6]])
6-element Array{Array{Int64,1},1}:
 [1]
 [2]
 [3]
 [4]
 [5]
 [6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Posets.jl#L77-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.transitive_closure" href="#Gapjm.Posets.transitive_closure"><code>Gapjm.Posets.transitive_closure</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>transitive_closure(M)</code></p><p><code>M</code>  should be a  square boolean matrix  representing a relation; returns a boolean  matrix representing the  transitive closure of  this relation. The transitive  closure is computed  by the Floyd-Warshall  algorithm, which is quite fast even for large matrices.</p><pre><code class="language-julia-repl">julia&gt; m=[j-i in [0,1] for i in 1:5, j in 1:5]
5×5 Array{Bool,2}:
 1  1  0  0  0
 0  1  1  0  0
 0  0  1  1  0
 0  0  0  1  1
 0  0  0  0  1

julia&gt;transitive_closure(m)
5×5 Array{Bool,2}:
 1  1  1  1  1
 0  1  1  1  1
 0  0  1  1  1
 0  0  0  1  1
 0  0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Posets.jl#L109-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.linear_extension" href="#Gapjm.Posets.linear_extension"><code>Gapjm.Posets.linear_extension</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>linear_extension(P)</code></p><p>returns  a  linear  extension  of  the  poset  <code>P</code>,  that  is  a vector <code>l</code> containing  a permutation of the integers  <code>1:length(P)</code> such that if <code>i&lt;j</code> in  <code>P</code>,  then  <code>findfirst(isequal(i),l)&lt;findfirst(isequal(j),l)</code>.  This is also called a topological sort of <code>P</code>.</p><pre><code class="language-julia-repl">julia&gt; p=Poset([j%i==0 for i in 1:5, j in 1:5])
1&lt;3,5
1&lt;2&lt;4

julia&gt; linear_extension(p)
5-element Array{Int64,1}:
 1
 2
 3
 5
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Posets.jl#L195-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.hasse" href="#Gapjm.Posets.hasse"><code>Gapjm.Posets.hasse</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>hasse(P)</code></p><p>returns the Hasse diagram of the poset <code>P</code>.</p><pre><code class="language-julia-repl">julia&gt; p=Poset([j%i==0 for i in 1:5, j in 1:5])
1&lt;3,5
1&lt;2&lt;4

julia&gt; hasse(p)
5-element Array{Array{Int64,1},1}:
 [2, 3, 5]
 [4]      
 []       
 []       
 []       </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Posets.jl#L235-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.incidence" href="#Gapjm.Posets.incidence"><code>Gapjm.Posets.incidence</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>incidence(P)</code></p><p>returns the incidence matrix of the poset <code>P</code>.</p><pre><code class="language-julia-repl">julia&gt; p=Poset(push!([[i+1] for i in 1:5],Int[]))
1&lt;2&lt;3&lt;4&lt;5&lt;6

julia&gt; incidence(p)
6×6 Array{Bool,2}:
 1  1  1  1  1  1
 0  1  1  1  1  1
 0  0  1  1  1  1
 0  0  0  1  1  1
 0  0  0  0  1  1
 0  0  0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Posets.jl#L261-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse" href="#Base.reverse"><code>Base.reverse</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reverse(P)</code></p><p>returns the opposed poset to <code>P</code>.</p><pre><code class="language-julia-repl">julia&gt; p=Poset([i==j || i%4&lt;j%4 for i in 1:8, j in 1:8])
4,8&lt;1,5&lt;2,6&lt;3,7

julia&gt; reverse(p)
3,7&lt;2,6&lt;1,5&lt;4,8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Posets.jl#L305-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.partition" href="#Gapjm.Posets.partition"><code>Gapjm.Posets.partition</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>partition(P::Poset)</code></p><p>returns  the  partition  of  <code>1:length(P)</code>  determined  by  the equivalence relation  associated to <code>P</code>; that  is, <code>i</code> and <code>j</code>  are in the same part of the  partition if the <code>k</code> such that <code>i&lt;k</code> and <code>j&lt;k</code> are the same as well as the <code>k</code> such that <code>k&lt;i</code> and <code>k&lt;j</code>.</p><pre><code class="language-julia-repl">julia&gt; p=Poset([i==j || i%4&lt;j%4 for i in 1:8, j in 1:8])
4,8&lt;1,5&lt;2,6&lt;3,7

julia&gt; partition(p)
4-element Array{Array{Int64,1},1}:
 [4, 8]
 [2, 6]
 [3, 7]
 [1, 5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Posets.jl#L332-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.restricted-Tuple{Poset,AbstractArray{#s5,1} where #s5&lt;:Integer}" href="#Gapjm.restricted-Tuple{Poset,AbstractArray{#s5,1} where #s5&lt;:Integer}"><code>Gapjm.restricted</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>restricted(P,indices)</code></p><p>returns  the  sub-poset  of  <code>P</code>  determined  by <code>indices</code>, which must be a sublist<code>of</code>1:length(P)`.</p><pre><code class="language-julia-repl">julia&gt; p=Poset([i==j || i%4&lt;j%4 for i in 1:8, j in 1:8])
4,8&lt;1,5&lt;2,6&lt;3,7

julia&gt; restricted(p,2:6)
3&lt;4&lt;1,5&lt;2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Posets.jl#L365-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.is_join_lattice" href="#Gapjm.Posets.is_join_lattice"><code>Gapjm.Posets.is_join_lattice</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>is_join_lattice(P::Poset)</code></p><p>returns  <code>true</code> if <code>P</code> is  a join semilattice, that  is any two elements of <code>P</code> have a unique smallest upper bound; returns <code>false</code> otherwise.</p><pre><code class="language-julia-repl">julia&gt; p=Poset([i==j || i%4&lt;j%4 for i in 1:8, j in 1:8])
4,8&lt;1,5&lt;2,6&lt;3,7

julia&gt; is_join_lattice(p)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Posets.jl#L429-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.is_meet_lattice" href="#Gapjm.Posets.is_meet_lattice"><code>Gapjm.Posets.is_meet_lattice</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>is_meet_lattice(P)</code></p><p>returns  <code>true</code> if <code>P</code> is  a meet semilattice, that  is any two elements of <code>P</code> have a unique highest lower bound; returns <code>false</code> otherwise.</p><pre><code class="language-julia-repl">julia&gt; p=Poset([i==j || i%4&lt;j%4 for i in 1:8, j in 1:8])
4,8&lt;1,5&lt;2,6&lt;3,7

julia&gt; is_meet_lattice(p)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Posets.jl#L444-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.Poset" href="#Gapjm.Posets.Poset"><code>Gapjm.Posets.Poset</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Poset(W::CoxeterGroup,w=longest(W))</code></p><p>returns  as a poset the Bruhat interval <code>[1,w]</code>of <code>W</code>. If <code>w</code> is not given, the whole Bruhat Poset of <code>W</code> is returned (<code>W</code> must then be finite).</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; Poset(W)
&lt;1,2&lt;21,12&lt;121

julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; Poset(W,W(1,3))
&lt;3,1&lt;13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Posets.jl#L460-L479">source</a></section></article><h1 id="Linear-algebra-on-any-field/ring-1"><a class="docs-heading-anchor" href="#Linear-algebra-on-any-field/ring-1">Linear algebra on any field/ring</a><a class="docs-heading-anchor-permalink" href="#Linear-algebra-on-any-field/ring-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra" href="#Gapjm.GLinearAlgebra"><code>Gapjm.GLinearAlgebra</code></a> — <span class="docstring-category">Module</span></header><section><div><p>GLinearAlgebra: linear algebra over arbitrary fields and rings</p><p>The  linear  algebra  package  in  Julia  is  not  suitable  for  a general mathematics  package: it assumes  the field is  the Real or Complex numbers and uses floating point to do approximate computations. Here we are interested in functions which work over any field (or sometimes any ring).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/GLinearAlgebra.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.echelon!" href="#Gapjm.GLinearAlgebra.echelon!"><code>Gapjm.GLinearAlgebra.echelon!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">`echelon!(m)`</code></pre><p>puts <code>m</code> in echelon form and returns:   <code>m</code>, indices of linearly independent rows of <code>m</code>   works in any field.   The echelon form transforms the rows of m into a particular basis   of the rowspace. The first non-zero element of each line is 1, and   such an element is also the only non-zero in its column.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/GLinearAlgebra.jl#L15-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.bigcell_decomposition" href="#Gapjm.GLinearAlgebra.bigcell_decomposition"><code>Gapjm.GLinearAlgebra.bigcell_decomposition</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>bigcell_decomposition(M [, b])</code></p><p><code>M</code>  should be a square  matrix, and <code>b</code> specifies  a block structure for a matrix  of  same  size  as  <code>M</code>  (it  is  a  <code>Vector</code>  of  <code>Vector</code>s  whose concatenation  is <code>1:size(M,1)</code>).  If <code>b</code>  is not  given, the trivial block structure <code>[[i] for i in axes(M,1)]</code> is assumed.</p><p>The  function  decomposes  <code>M</code>  as  a  product  <code>P₁ L P</code> where <code>P</code> is upper block-unitriangular   (with  identity  diagonal   blocks),  <code>P₁</code>  is  lower block-unitriangular  and <code>L</code> is block-diagonal for the block structure <code>b</code>. If  <code>M</code> is symmetric then  <code>P₁</code> is the transposed  of <code>P</code> and the result is the  pair  <code>[P,L]</code>;  else  the  result  is  the triple <code>[P₁,L,P]</code>. The only condition  for  this  decomposition  of  <code>M</code>  to  be  possible  is that the principal  minors  according  to  the  block  structure be invertible. This routine  is used  in the  Lusztig-Shoji algorithm  for computing  the Green functions  and the example  below is extracted  from the computation of the Green functions for <code>G₂</code>.</p><pre><code class="language-julia-repl">julia&gt; Pol(:q)
Pol{Int64}: q

julia&gt; M=[q^6 q^0 q^3 q^3 q^5+q q^4+q^2; q^0 q^6 q^3 q^3 q^5+q q^4+q^2; q^3 q^3 q^6 q^0 q^4+q^2 q^5+q; q^3 q^3 q^0 q^6 q^4+q^2 q^5+q; q^5+q q^5+q q^4+q^2 q^4+q^2 q^6+q^4+q^2+1 q^5+2*q^3+q; q^4+q^2 q^4+q^2 q^5+q q^5+q q^5+2*q^3+q q^6+q^4+q^2+1]
6×6 Array{Pol{Int64},2}:
 q⁶     1      q³     q³     q⁵+q        q⁴+q²
 1      q⁶     q³     q³     q⁵+q        q⁴+q²
 q³     q³     q⁶     1      q⁴+q²       q⁵+q
 q³     q³     1      q⁶     q⁴+q²       q⁵+q
 q⁵+q   q⁵+q   q⁴+q²  q⁴+q²  q⁶+q⁴+q²+1  q⁵+2q³+q
 q⁴+q²  q⁴+q²  q⁵+q   q⁵+q   q⁵+2q³+q    q⁶+q⁴+q²+1

julia&gt; bb=[[2],[4],[6],[3,5],[1]];

julia&gt; (P,L)=bigcell_decomposition(M,bb);

julia&gt; P
6×6 Array{Pol{Int64},2}:
 1    0  0    0    0        0
 q⁻⁶  1  q⁻³  q⁻³  q⁻¹+q⁻⁵  q⁻²+q⁻⁴
 0    0  1    0    0        0
 q⁻³  0  0    1    q⁻²      q⁻¹
 q⁻¹  0  0    0    1        0
 q⁻²  0  q⁻¹  0    q⁻¹      1

julia&gt; L
6×6 Array{Pol{Int64},2}:
 q⁶-q⁴-1+q⁻²  0   0            0     0            0
 0            q⁶  0            0     0            0
 0            0   q⁶-q⁴-1+q⁻²  0     0            0
 0            0   0            q⁶-1  0            0
 0            0   0            0     q⁶-q⁴-1+q⁻²  0
 0            0   0            0     0            q⁶-1

julia&gt; M==permutedims(P)*L*P
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/GLinearAlgebra.jl#L139-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.diagblocks" href="#Gapjm.GLinearAlgebra.diagblocks"><code>Gapjm.GLinearAlgebra.diagblocks</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>diagblocks(M::Matrix)</code></p><p><code>M</code>  should  be  a  square  matrix.  Define  a  graph  <code>G</code>  with vertices <code>1:size(M,1)</code> and with an edge between <code>i</code>  and <code>j</code> if either <code>M[i,j]</code> or <code>M[j,i]</code> is not zero or <code>false</code>. <code>diagblocks</code> returns a vector of vectors <code>I</code>  such that  <code>I[1]</code>,<code>I[2]</code>, etc..  are the  vertices in each connected component  of <code>G</code>.  In other  words, <code>M[I[1],I[1]]</code>,<code>M[I[2],I[2]]</code>,etc... are diagonal blocks of <code>M</code>.</p><pre><code class="language-julia-repl">julia&gt; m=[0 0 0 1;0 0 1 0;0 1 0 0;1 0 0 0]
4×4 Array{Int64,2}:
 0  0  0  1
 0  0  1  0
 0  1  0  0
 1  0  0  0

julia&gt; diagblocks(m)
2-element Array{Array{Int64,1},1}:
 [1, 4]
 [2, 3]

julia&gt; m[[1,4],[1,4]]
2×2 Array{Int64,2}:
 0  1
 1  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/GLinearAlgebra.jl#L313-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.ratio" href="#Gapjm.GLinearAlgebra.ratio"><code>Gapjm.GLinearAlgebra.ratio</code></a> — <span class="docstring-category">Function</span></header><section><div><p>ratio of two vectors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/GLinearAlgebra.jl#L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.exterior_power" href="#Gapjm.GLinearAlgebra.exterior_power"><code>Gapjm.GLinearAlgebra.exterior_power</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>exterior_power(mat,n)</code></p><p><code>mat</code>  should be a square matrix.  The function returns the <code>n</code>-th exterior power  of  <code>mat</code>,  in  the  basis naturally indexed by<code>combinations(1:r,n)</code> where<code>r=size(mat,1)</code></p><pre><code class="language-julia-repl">julia&gt; M=[1 2 3 4;2 3 4 1;3 4 1 2;4 1 2 3]
4×4 Array{Int64,2}:
 1  2  3  4
 2  3  4  1
 3  4  1  2
 4  1  2  3

julia&gt; exterior_power(M,2)
6×6 Array{Int64,2}:
  -1   -2   -7   -1  -10  -13
  -2   -8  -10  -10  -12    2
  -7  -10  -13    1    2    1
  -1  -10    1  -13    2    7
 -10  -12    2    2    8   10
 -13    2    1    7   10   -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/GLinearAlgebra.jl#L237-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.schur_functor" href="#Gapjm.GLinearAlgebra.schur_functor"><code>Gapjm.GLinearAlgebra.schur_functor</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>schur_functor(mat,l)</code></p><p><code>mat</code>  should be  a square  matrix and  <code>l</code> a  partition. The result is the Schur  functor  of  the  matrix  <code>mat</code>  corresponding to partition <code>l</code>; for example,   if  <code>l==[n]</code>  it  returns  the   n-th  symmetric  power  and  if <code>l==[1,1,1]</code> it returns the 3rd exterior power. The current algorithm (from Littlewood)  is rather inefficient so it is  quite slow for partitions of n where <code>n&gt;6</code>.</p><pre><code class="language-julia-repl">julia&gt; m=cartan(:A,3)
3×3 Array{Int64,2}:
  2  -1   0
 -1   2  -1
  0  -1   2

julia&gt; schur_functor(m,[2,2])
6×6 Array{Rational{Int64},2}:
 10//1   12//1  -16//1   16//1  -16//1   12//1
  3//2    9//1   -6//1    4//1   -2//1    1//1
 -4//1  -12//1   16//1  -16//1    8//1   -4//1
  2//1    4//1   -8//1   16//1   -8//1    4//1
 -4//1   -4//1    8//1  -16//1   16//1  -12//1
  3//2    1//1   -2//1    4//1   -6//1    9//1</code></pre><p>julia-repl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/GLinearAlgebra.jl#L267-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.GLinearAlgebra.Transporter" href="#Gapjm.GLinearAlgebra.Transporter"><code>Gapjm.GLinearAlgebra.Transporter</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>Transporter(l1, l2 )</code></p><p><code>l1</code>  and <code>l2</code> should be vectors of  the same length of square matrices all of the same size. The result is a basis of the vector space of matrices <code>A</code> such  that for any <code>i</code> we have  <code>A*l1[i]=l2[i]*A</code> –- the basis is returned as  a vector of matrices, empty if the vector space is 0. This is useful to find whether two representations are isomorphic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/GLinearAlgebra.jl#L358-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HasType.traces_words_mats" href="#Gapjm.HasType.traces_words_mats"><code>Gapjm.HasType.traces_words_mats</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>traces_words_mats(mats,words)</code></p><p>given  a list <code>mats</code>  of matrices and  a list <code>words</code>  of words returns the list of traces of the corresponding products of the matrices</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:F,4)
F₄

julia&gt; r=classinfo(W)[:classtext];

julia&gt; R=representation(W,17)
4-element Array{Array{Int64,2},1}:
 [-1 -1 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 1] 
 [1 0 0 0; -1 -1 -1 0; 0 0 1 0; 0 0 0 1]
 [1 0 0 0; 0 1 0 0; 0 -2 -1 -1; 0 0 0 1]
 [1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 -1 -1] 

julia&gt; traces_words_mats(R,r)==CharTable(W).irr[17,:]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/HasType.jl#L105-L127">source</a></section></article><h1 id="Eigenspaces-1"><a class="docs-heading-anchor" href="#Eigenspaces-1">Eigenspaces</a><a class="docs-heading-anchor-permalink" href="#Eigenspaces-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Eigenspaces" href="#Gapjm.Eigenspaces"><code>Gapjm.Eigenspaces</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Eigenspaces and <code>d</code>-Harish-Chandra series</p><p>Let <code>Wϕ</code> be a reflection coset on a vector space <code>V</code> and <code>Lwϕ</code> a reflection subcoset  where <code>L</code> is a  parabolic subgroup (the fixator  of a subspace of <code>V</code>).  There  are  several  interesting  cases  where  the <em>relative group</em> <code>N_W(Lwϕ)/L</code>, or a subgroup of it normalizing some further data attached to <code>L</code>, is itself a reflection group.</p><p>A first example is the case where <code>ϕ=1</code> and <code>w=1</code>, <code>W</code> is the Weyl group of a finite reductive group <code>𝐆^F</code> and the Levi subgroup <code>𝐋^F</code> corresponding to <code>L</code>  has a cuspidal unipotent character. Then <code>N_W(L)/L</code> is a Coxeter group acting  on the  space <code>X(Z𝐋)⊗ℝ</code>.  A combinatorial  characterization of such parabolic  subgroups of Coxeter  groups is that  they are normalized by the longest element of larger parabolic subgroups (see cite[5.7.1]{Lus76}).</p><p>A  second  example  is  when  <code>L</code>  is  trivial  and  <code>wϕ</code> is a <em><code>ζ</code>-regular element</em>,  that  is  the  <code>ζ</code>-eigenspace  <code>V_ζ</code>  of  <code>wϕ</code> contains a vector outside all the reflecting hyperplanes of <code>W</code>. Then <code>N_W(Lwϕ)/L=C_W(wϕ)</code> is a reflection group in its action on <code>V_ζ</code>.</p><p>A  similar but more general example is  when <code>V_ζ</code> is the <code>ζ</code>-eigenspace of some  element of  the reflection  coset <code>Wϕ</code>,  and is  of maximal dimension among such possible <code>ζ</code>-eigenspaces. Then the set of elements of <code>Wϕ</code> which act  by <code>ζ</code>  on <code>V_ζ</code>  is a  certain subcoset  <code>Lwϕ</code>, and <code>N_W(Lwϕ)/L</code> is a reflection group in its action on <code>V_ζ</code> (see cite[2.5]{LS99}).</p><p>Finally,  a  still  more  general  example,  but which only occurs for Weyl groups  or  Spetsial  reflection  groups,  is  when <code>𝐋</code> is a <code>ζ</code>-split Levi subgroup  (which means that  the corresponding subcoset  <code>Lwϕ</code> is formed of all  the elements which act by <code>ζ</code> on  some subspace <code>V_ζ</code> of <code>V</code>), and <code>λ</code> is  a  <code>d</code>-cuspidal  unipotent  character  of  <code>𝐋</code>  (which  means  that the multiplicity  of <code>ζ</code>  as a  root of  the degree  of <code>λ</code>  is the same as the multiplicity  of <code>ζ</code> as a root of the generic order of the semi-simple part of <code>𝐆</code>); then <code>N_W(Lwϕ,λ)/L</code> is a complex reflection group in its action on <code>V_ζ</code>.</p><p>Further,  in the above cases the relative group describes the decomposition of a Lusztig induction.</p><p>When  <code>𝐆^F</code>  is  a  finite  reductive  group,  and <code>λ</code> a cuspidal unipotent character  of the Levi subgroup  <code>𝐋^F</code>, then the <code>𝐆^F</code>-endomorphism algebra of  the Harish-Chandra induced representation <code>R_𝐋^𝐆(λ)</code> is a Hecke algebra attached  to the group <code>N_W(L)/L</code>, thus  the dimension of the characters of this group describe the multiplicities in the Harish-Chandra induced.</p><p>Similarly, when <code>𝐋</code> is a <code>ζ</code>-split Levi subgroup, and <code>λ</code> is a <code>d</code>-cuspidal unipotent  character  of  <code>𝐋</code>  then  (conjecturally) the <code>𝐆^F</code>-endomorphism algebra of the Lusztig induced <code>R_𝐋^𝐆(λ)</code> is a cyclotomic Hecke algebra for to  the group <code>N_W(Lwϕ,λ)/L</code>.  The constituents of  <code>R_𝐋^𝐆(λ)</code> are called a <code>ζ</code>-Harish-Chandra  series.  In  the  case  of  rational  groups or cosets, corresponding  to  finite  reductive  groups,  the conjugacy class of <code>Lwϕ</code> depends only on the order <code>d</code> of <code>ζ</code>, so one also talks of <code>d</code>-Harish-Chandra  series. These series correspond to <code>ℓ</code>-blocks where <code>l</code> is  a prime divisor of <code>Φ_d(q)</code> which  does not divide any other cyclotomic factor of the order of <code>𝐆^F</code>.</p><p>The functions described in this module allow to explore these situations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Eigenspaces.jl#L1-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Eigenspaces.relative_degrees" href="#Gapjm.Eigenspaces.relative_degrees"><code>Gapjm.Eigenspaces.relative_degrees</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>relative_degrees(WF,d)</code></p><p>Let  <code>WF</code> be a reflection group or a reflection coset. Here <code>d</code> specifies a root  of unity <code>ζ</code>: either <code>d</code> is an integer and specifies <code>ζ=E(d)</code> or is a fraction  smaller <code>a/b</code> with <code>0&lt;a&lt;b</code>  and specifies <code>ζ=E(b,a)</code>. If omitted, <code>d</code>   is  taken  to  be  <code>1</code>,  specifying  <code>ζ=1</code>.  Then  if  <code>V_ζ</code>  is  the <code>ζ</code>-eigenspace  of some element of <code>WF</code>,  and is of maximal dimension among such   possible  <code>ζ</code>-eigenspaces,  and  <code>W</code>  is  the  group  of  <code>WF</code>  then <code>N_W(V_ζ)/C_W(V_ζ)</code>  is  a  reflection  group  in  its action on <code>V_ζ</code>. The function  <code>relative_degrees</code> returns the reflection degrees of this complex reflection group, which are a subset of those of <code>W</code>.</p><p>These   degrees  are   computed  by   an  invariant-theoretic  formula:  if <code>(d₁,ε₁),…,(dₙ,εₙ)</code>  are the generalized degrees of  <code>WF</code> they are the <code>dᵢ</code> such that <code>ζ^{dᵢ}=εᵢ</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:E,8)
E₈

julia&gt; relative_degrees(W,4)
4-element Array{Int64,1}:
  8
 12
 20
 24</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Eigenspaces.jl#L66-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Eigenspaces.regular_eigenvalues" href="#Gapjm.Eigenspaces.regular_eigenvalues"><code>Gapjm.Eigenspaces.regular_eigenvalues</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>regular_eigenvalues(W)</code></p><p>Let <code>W</code> be a reflection group or a reflection coset. A root of unity <code>ζ</code> is a <em>regular eigenvalue</em> for <code>W</code> if some element of <code>W</code> has a <code>ζ</code>-eigenvector which   lies   outside   of   the   reflecting  hyperplanes.  The  function &#39;RelativeDegree&#39; returns a list describing the regular eigenvalues for <code>W</code>. If  all the primitive  <code>n</code>-th roots of  unity are regular eigenvalues, then <code>n</code>  is put on the result list.  Otherwise the fractions <code>a/n</code> are added to the  list for each <code>a</code> such that  <code>E(n,a)</code> is a primitive <code>n</code>-root of unity and a regular eigenvalue for <code>W</code>.</p><pre><code class="language-julia_repl">julia&gt; W=coxgroup(:E,8)
E₈

julia&gt; regular_eigenvalues(W)
13-element Array{Int64,1}:
  1
  2
  4
  8
  3
  6
 12
  5
 10
 20
 24
 15
 30

julia&gt; W=ComplexReflectionGroup(6)
G₆

julia&gt; L=twistings(W,[2])[2]
G₃‚₁‚₁[ζ₄]Φ′₄

julia&gt; regular_eigenvalues(L)
3-element Array{Rational{Int64},1}:
  1//4 
  7//12
 11//12
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Eigenspaces.jl#L101-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Eigenspaces.eigenspace_projector" href="#Gapjm.Eigenspaces.eigenspace_projector"><code>Gapjm.Eigenspaces.eigenspace_projector</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>eigenspace_projector(WF,w[,d=0//1])</code></p><p>Let  <code>WF</code> be a reflection group or a reflection coset. Here <code>d</code> specifies a root  of unity <code>ζ</code>: either <code>d</code> is an integer and specifies <code>ζ=E(d)&#39; or is a fraction  smaller</code>a/b<code>with</code>0&lt;a&lt;b<code>and specifies</code>ζ=E(b,a)&#39;. The function returns the unique <code>w</code>-invariant projector on the <code>ζ</code>-eigenspace of <code>w</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; w=W(1:3...)
(1,12,3,2)(4,11,10,5)(6,9,8,7)

julia&gt; p=eigenspace_projector(W,w,1//4)
3×3 Array{Cyc{Rational{Int64}},2}:
  1/4+ζ₄/4   ζ₄/2  -1/4+ζ₄/4
  1/4-ζ₄/4    1/2   1/4+ζ₄/4
 -1/4-ζ₄/4  -ζ₄/2   1/4-ζ₄/4

julia&gt; GLinearAlgebra.rank(p)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Eigenspaces.jl#L201-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Eigenspaces.position_regular_class" href="#Gapjm.Eigenspaces.position_regular_class"><code>Gapjm.Eigenspaces.position_regular_class</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>position_regular_class(WF,d=0)</code></p><p>Let  <code>WF</code> be a reflection group or a reflection coset. Here <code>d</code> specifies a root  of unity <code>ζ</code>: either <code>d</code> is an integer and specifies <code>ζ=E(d)&#39; or is a fraction  smaller</code>a/b<code>with</code>0&lt;a&lt;b<code>and specifies</code>ζ=E(b,a)&#39;. If omitted, <code>d</code>  is taken to be <code>0</code>, specifying <code>ζ=1</code>. The root <code>ζ</code> should be a regular eigenvalue  for <code>WF</code> (see &quot;regular_eigenvalues&quot;).  The function returns the index of the conjugacy class of <code>WF</code> which has a <code>ζ</code>-regular eigenvector.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:E,8)
E₈

julia&gt; position_regular_class(W,30)
65

julia&gt; W=ComplexReflectionGroup(6)
G₆

julia&gt; L=twistings(W,[2])[2]
G₃‚₁‚₁[ζ₄]Φ′₄

julia&gt; position_regular_class(L,7//12)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Eigenspaces.jl#L166-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Eigenspaces.split_levis" href="#Gapjm.Eigenspaces.split_levis"><code>Gapjm.Eigenspaces.split_levis</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>split_levis(WF,d=0,ad=-1)</code></p><p>Let  <code>WF</code>  be  a  reflection  group  or  a  reflection  coset.  If <code>W</code> is a reflection group it is treated as the trivial coset &#39;Spets(W)&#39;.</p><p>Here  <code>d</code>  specifies  a  root  of  unity  <code>ζ</code>: either <code>d</code> is an integer and specifies  <code>ζ=E(d)</code>  or  is  a  fraction  <code>a/b</code>  with <code>0&lt;a&lt;b</code> and specifies <code>ζ=E(b,a)</code>. If omitted, <code>d</code> is taken to be <code>0</code>, specifying <code>ζ=1</code>.</p><p>A  <em>Levi</em>  is  a  subcoset  of  the  form <code>W₁F₁</code> where <code>W₁</code> is a <em>parabolic subgroup</em> of <code>W</code>, that is the centralizer of some subspace of <code>V</code>.</p><p>The  function returns  a list  of representatives  of conjugacy  classes of <code>d</code>-split  Levis of <code>W</code>. A  <code>d</code>-split Levi is a  subcoset of <code>WF</code> formed of all  the  elements  which  act  by  <code>ζ</code>  on  a given subspace <code>V_ζ</code>. If the additional  argument <code>ad</code>  is given,  it returns  only those subcosets such that the common <code>ζ</code>-eigenspace of their elements is of dimension <code>ad</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; split_levis(W,4)
2-element Array{Any,1}:
 A₃   
 .Φ₂Φ₄

julia&gt; W=spets(coxgroup(:D,4),Perm(1,2,4))
³D₄

julia&gt; split_levis(W,3)
3-element Array{Any,1}:
 ³D₄ 
 A₂Φ₃
 ³D₄ 

julia&gt; W=coxgroup(:E,8)
E₈

julia&gt; split_levis(W,4,2)
3-element Array{Any,1}:
 D₄₍₁₃₂₄₎Φ₄²     
 (A₁A₁)×(A₁A₁)Φ₄²
 ²(A₂A₂)₍₁₄₂₃₎Φ₄²
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Eigenspaces.jl#L284-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Eigenspaces.cuspidal_unipotent_characters" href="#Gapjm.Eigenspaces.cuspidal_unipotent_characters"><code>Gapjm.Eigenspaces.cuspidal_unipotent_characters</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>cuspidal_unipotent_characters(WF[,d])</code></p><p>Let  <code>WF</code>  be  a  reflection  group  or  a  reflection  coset.  If <code>W</code> is a reflection group it is treated as the trivial coset <code>Spets(W)</code>.</p><p>A  unipotent character <code>γ</code> of the corresponding finite reductive group <code>bG</code> is  <code>d</code>-cuspidal if its Lusztig restriction to any proper <code>d</code>-split Levi is zero.  When  <code>d==1</code>  we  recover  the  usual  notion of cuspidal character. Equivalently  the <code>Phi_d</code>-part of the generic degree of <code>γ</code> is equal to the <code>Phi_d</code>-part of the generic order of the adjoint group of <code>bG</code>.</p><p>The  function returns the list of indices of unipotent characters which are <code>d</code>-cuspidal.  If <code>d</code> is  omitted, it is taken  to be <code>1</code>.</p><pre><code class="language-julia-repl">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; cuspidal_unipotent_characters(W)
1-element Array{Int64,1}:
 14

julia&gt; cuspidal_unipotent_characters(W,6)
8-element Array{Int64,1}:
  1
  2
  6
  7
  8
  9
 10
 12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a51501d1bcaeaf638f86c81b78a24834d45ec7d6/src/Eigenspaces.jl#L483-L517">source</a></section></article><h1 id="Dictionary-from-GAP3/Chevie-1"><a class="docs-heading-anchor" href="#Dictionary-from-GAP3/Chevie-1">Dictionary from GAP3/Chevie</a><a class="docs-heading-anchor-permalink" href="#Dictionary-from-GAP3/Chevie-1" title="Permalink"></a></h1><p>The dictionary from GAP3/Chevie is as follows:</p><pre><code class="language-none">AlgebraicCentre                             → algebraic_centre
AlmostCharacter                             → AlmostChar
Arrangements                                → arrangements
AsFraction                                  → fraction
AsReflection                                → reflection
AsRootOfUnity                               → Root1
AsWord                                      → word
AssociatedPartition                         → conjugate_partition
BetaSet                                     → βset
BigCellDecomposition                        → bigcell_decomposition
Binomial                                    → binomial
BipartiteDecomposition                      → bipartite_decomposition
Braid                                       → BraidMonoid
BraidMonoid                                 → BraidMonoid
BraidRelations                              → braid_relations
Bruhat                                      → bruhatless
BruhatPoset                                 → Poset
BruhatSmaller                               → bruhatless
CartanMat(&quot;A&quot;,5)                            → cartan(:A,5)
CartanMatFromCoxeterMatrix                  → cartan
Catalan                                     → catalan
CentralizerGenerators                       → centralizer_generators
CharNames                                   → charnames
CharParams(W)                               → charinfo(W)[:charparams]
CharRepresentationWords                     → traces_words_mats
ChevieCharInfo                              → charinfo
ChevieClassInfo                             → classinfo
Coefficient(p,i)                            → p[i]
Combinations                                → combinations
ComplexConjugate                            → conj
ComplexReflectionGroup                      → ComplexReflectionGroup
Compositions                                → compositions
ConcatenationString(s...)                   → prod(s)
ConjugacySet(b[,F][,type])                  → conjcat(b[,F],ss=type).obj
ConjugatePartition                          → conjugate_partition
CoxeterCoset                                → spets
CoxeterElements(W[,l])                      → elements(W[,l])
CoxeterGroup(&quot;A&quot;,5)                         → coxgroup(:A,5)
CoxeterGroupByCartanMatrix(C)               → gencox(C)
CoxeterGroupByCoxeterMatrix                 → gencox(cartan(C))
CoxeterGroupHyperoctaedralGroup(n)          → CoxHyperoctaedral(n)
CoxeterGroupSymmetricGroup(n)               → CoxSym(n)
CoxeterLength(W,w)                          → length(W,w)
CoxeterMatrix                               → coxmat
CoxeterMatrixFromCartanMat                  → coxmat
CoxeterSubCoset                             → subspets
CoxeterWord(W,w)                            → word(W,w)
CoxeterWords(W[,l])                         → word.(Ref(W),elements(W[,l])
CuspidalUnipotentCharacters                 → cuspidal_unipotent_characters
CycPol                                      → CycPol
CycPolFakeDegreeSymbol                      → fegsymbol
CycPolGenericDegreeSymbol                   → gendeg_symbol
CycPolUnipotentDegrees                      → CycPolUnipotentDegrees
Cycle                                       → orbit
Cycles                                      → orbits
CyclotomicPolynomial(R,i)                   → cyclotomic_polynomial(i)
DecomposedMat                               → diagblocks
DefectSymbol                                → defectsymbol
Degree(p)                                   → degree(p)
DeligneLusztigCharacter                     → DLChar
DeligneLusztigLefschetz                     → DLLeftschetz
DescribeInvolution                          → describe_involution
Dominates                                   → dominates
Drop                                        → deleteat!
DualBraid                                   → DualBraidMonoid
DualBraidMonoid                             → DualBraidMonoid
EigenspaceProjector                         → eigenspace_projector
ElementWithInversions(W,l)                  → with_inversions(W,l)
Elements                                    → elements
EltBraid                                    → image
EltWord(W,w)                                → W(w...)
ExteriorPower                               → exterior_power
FakeDegree                                  → fakedegree
FakeDegrees                                 → fakedegrees
FamiliesClassical                           → FamiliesClassical
Family                                      → Family
FamilyImprimitive                           → family_imprimitive
FiniteCoxeterTypeFromCartanMat(m)           → type_cartan(m)
FirstLeftDescending(W,w)                    → firstleftdescent(W,w)
ForEachCoxeterWord(W,f)                     → for w in W f(word(W,w)) end
ForEachElement(W,f)                         → for w in W f(w) end
FullSymbol                                  → fullsymbol
FundamentalGroup                            → fundamental_group
GaloisCyc                                   → galois
GarsideAlpha                                → α
GarsideWords                                → elements
GcdPartitions                               → gcd_partitions
GcdRepresentation                           → gcd_repr
GenericOrder                                → generic_order
GenericSign                                 → generic_sign
Hasse                                       → hasse
HeckeCentralMonomials                       → central_monomials
HeckeCharValues                             → char_values
HeckeClassPolynomials                       → class_polynomials
HighestPowerFakeDegreeSymbol                → degree_feg_symbol
HighestPowerGenericDegreeSymbol             → degree_gendeg_symbol
HyperplaneOrbits                            → hyperplane_orbits
ICCTable                                    → ICCTable
Incidence                                   → incidence
IndependentLines(M)                         → echelon(M)[2]
IndependentRoots                            → independent_roots
InducedLinearForm                           → induced_linear_form
InductionTable                              → InductionTable
IntListToString                             → joindigits
Intersection                                → intersect
InvariantForm                               → invariant_form
Inversions                                  → inversions
IsAbelian                                   → isabelian
IsCycPol(p)                                 → p isa CycPol
IsFamily(f)                                 → f isa Family
IsJoinLattice                               → is_join_lattice
IsLeftDescending(W,w,i)                     → isleftdescent(W,w,i)
IsMeetLattice                               → is_meet_lattice
IsSubset(a,b)                               → issubset(b,a)
Join                                        → join
KazhdanLusztigPolynomial                    → KLPol
KroneckerProduct                            → kron
LcmPartitions                               → lcm_partitions
LeadingCoefficient(p)                       → p[end]
LeftCell                                    → LeftCell
LeftCells                                   → LeftCells
LeftDescentSet(W,w)                         → leftdescents(W,w)
LeftDivisorsSimple                          → left_divisors
LeftGcd                                     → leftgcd
LinearExtension                             → linear_extension
ListPerm(p)                                 → vec(p)
LongestCoxeterElement(W)                    → longest(W)
LongestCoxeterWord(W)                       → word(W,longest(W))
LowestPowerFakeDegreeSymbol                 → valuation_feg_symbol
LowestPowerGenericDegreeSymbol              → valuation_gendeg_symbol
LusztigInduction                            → LusztigInduce
LusztigInductionTable                       → LusztigInductionTable
LusztigRestriction                          → LusztigRestrict
MatXPerm(W,p)                               → matX(W,p)
OnMatrices(m,p)                             → ^(m,p;dims=(1,2))
OnTuples(l,p)                               → l.^p
ParabolicRepresentatives                    → parabolic_representatives
PartBeta                                    → partβ
Partition                                   → partition
PartitionTuples                             → partition_tuples
Partitions                                  → partitions
PermList(v)                                 → Perm(v)
PermListList(l1,l2)                         → Perm(l1,l2)
PermMatX                                    → PermX
PermutationMat(p,dim)                       → Matrix(p,dim)
Permuted(v,p)                               → v^p
PermutedByCols(m,p)                         → ^(m,p;dims=2)
Poset                                       → Poset
PositionClass                               → position_class
PositionRegularClass                        → position_regular_class
PrintDiagram(W)                             → Diagram(W)
ProportionalityCoefficient(v,w)             → ratio(v,w)
Rank                                        → rank
RankSymbol                                  → ranksymbol
ReducedCoxeterWord(W,w)                     → word(W,W(w...))
ReducedExpressions(W,w)                     → words(W,w)
ReducedInRightCoset(W,w)                    → reduced(W,w)
ReducedRightCosetRepresentatives(W,H)       → reduced(H,W)
Reflection                                  → reflection
ReflectionCharacter                         → reflchar
ReflectionCoDegrees(W)                      → codegrees(W)
ReflectionDegrees(W)                        → degrees(W)
ReflectionEigenvalues                       → refleigen
ReflectionLength(W,w)                       → reflength(W,w)
ReflectionSubgroup                          → reflection_subgroup
ReflectionType                              → refltype
Reflections                                 → reflections
RegularEigenvalues                          → regular_eigenvalues
RelativeDegrees                             → relative_degrees
Representations                             → representations
RepresentativeConjugation(b,b&#39;[,F][,type])  → representative_operation(b,b&#39;[,F],ss=type)
Restricted                                  → restricted
RestrictedPerm(p,d)                         → restricted(p,d)
Reversed                                    → reverse
RightDescentSet(W,w)                        → rightdescents(W,w)
RightGcd                                    → rightgcd
RightLcm                                    → rightlcm
RootDatum                                   → rootdatum
RootsCartan(m)                              → roots(m)
Rotation(v,i)                               → circshift(v,-i)
Rotations(v)                                → circshift.(Ref(a),length(a):-1:1)
ScalMvp                                     → scal
SchurElements                               → schur_elements
SchurFunctor                                → schur_functor
SemisimpleRank                              → semisimplerank
SemisimpleRank(W)                           → coxrank(W)
ShiftBeta                                   → shiftβ
ShrinkGarsideGeneratingSet                  → shrink
SignedPerm                                  → SPerm
SignedPermListList                          → SPerm
Size(W)                                     → length(W)
Spets                                       → spets
SplitLevis                                  → split_levis
StandardParabolic                           → standard_parabolic
StandardParabolicClass                      → standard_parabolic_class
SubSpets                                    → subspets
SubTorus                                    → SubTorus
SymmetricDifference                         → symdiff
Tableaux                                    → tableaux
Torus                                       → torus
TransitiveClosure                           → transitive_closure
Twistings                                   → twistings
TwoTree(m)                                  → twotree(m)
UnipotentCharacter                          → UniChar
UnipotentCharacters                         → UnipotentCharacters
UnipotentClasses                            → UnipotentClasses
UnipotentDegrees(W,q)                       → degrees(UnipotentCharacters(W),q)
UnorderedTuples                             → submultiset
Valuation(p)                                → valuation(p)
Value(p,x)                                  → p(x)
W.N                                         → nref(W)
W.matgens[i]                                → matX(W,i)
W.orbitRepresentativeElement                → simple_conjugating_element(W,i)
W.orbitRepresentative[i]                    → simple_representative(W,i)
WeightInfo                                  → weightinfo</code></pre></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 10 April 2020 18:14">Friday 10 April 2020</span>. Using Julia version 1.4.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
