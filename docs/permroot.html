<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finite reflection groups · Gapjm.jl documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Gapjm.jl documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Gapjm</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Infrastructure</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="symbols.html">Symbols</a></li><li><a class="tocitem" href="nf.html">Number fields</a></li><li><a class="tocitem" href="presentations.html">Presentations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Reflection groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href="permroot.html">Finite reflection groups</a></li><li><a class="tocitem" href="coxgroups.html">Coxeter groups</a></li><li><a class="tocitem" href="weyl.html">Finite Coxeter groups, Weyl groups, crystallographic root systems</a></li><li><a class="tocitem" href="chars.html">Classes/characters of reflection groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Hecke algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="hecke.html">Hecke algebras</a></li><li><a class="tocitem" href="kl.html">Kazhdan-Lusztig polynomials and bases</a></li><li><a class="tocitem" href="algebras.html">Algebras</a></li></ul></li><li><a class="tocitem" href="garside.html">Garside monoids and groups, braids.</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reductive groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="semisimple.html">Reductive groups, semisimple elements</a></li><li><a class="tocitem" href="cosets.html">Reflection cosets and Spets</a></li><li><a class="tocitem" href="sscoset.html">Non-connected reductive groups</a></li><li><a class="tocitem" href="uch.html">Unipotent characters</a></li><li><a class="tocitem" href="ct.html">Classtypes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Eigenspaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="eigen.html">Eigenspaces</a></li><li><a class="tocitem" href="dseries.html">d-Harish-Chandra series</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Unipotent elements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ucl.html">Unipotent classes of reductive groups</a></li><li><a class="tocitem" href="urad.html">Unipotent Elements</a></li></ul></li><li><a class="tocitem" href="gendec.html">Decomposition Matrices</a></li><li><a class="tocitem" href="dict.html">Dictionary from GAP3/Chevie</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reflection groups</a></li><li class="is-active"><a href="permroot.html">Finite reflection groups</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="permroot.html">Finite reflection groups</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmichel7/Gapjm.jl/blob/master/docs/src/permroot.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Finite-reflection-groups"><a class="docs-heading-anchor" href="#Finite-reflection-groups">Finite reflection groups</a><a id="Finite-reflection-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-reflection-groups" title="Permalink"></a></h1><ul><li><a href="permroot.html#Gapjm.PermRoot"><code>Gapjm.PermRoot</code></a></li><li><a href="permroot.html#Gapjm.ComplexR.Reflection"><code>Gapjm.ComplexR.Reflection</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.PRG"><code>Gapjm.PermRoot.PRG</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.PermRootGroup"><code>Gapjm.PermRoot.PermRootGroup</code></a></li><li><a href="permroot.html#Combinat.catalan-Tuple{Group, Any}"><code>Combinat.catalan</code></a></li><li><a href="permroot.html#Gapjm.Chars.discriminant"><code>Gapjm.Chars.discriminant</code></a></li><li><a href="permroot.html#Gapjm.ComplexR.codegrees"><code>Gapjm.ComplexR.codegrees</code></a></li><li><a href="permroot.html#Gapjm.ComplexR.complex_reflection_group"><code>Gapjm.ComplexR.complex_reflection_group</code></a></li><li><a href="permroot.html#Gapjm.ComplexR.degrees-Tuple{PermRootGroup}"><code>Gapjm.ComplexR.degrees</code></a></li><li><a href="permroot.html#Gapjm.ComplexR.hyperplane_orbits"><code>Gapjm.ComplexR.hyperplane_orbits</code></a></li><li><a href="permroot.html#Gapjm.ComplexR.reflections"><code>Gapjm.ComplexR.reflections</code></a></li><li><a href="permroot.html#Gapjm.CoxGroups.braid_relations"><code>Gapjm.CoxGroups.braid_relations</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.PermX"><code>Gapjm.PermRoot.PermX</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.PermY"><code>Gapjm.PermRoot.PermY</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.YMatrix"><code>Gapjm.PermRoot.YMatrix</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.asreflection"><code>Gapjm.PermRoot.asreflection</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.bipartite_decomposition"><code>Gapjm.PermRoot.bipartite_decomposition</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.cartan-Tuple{PermRootGroup, Any, Any}"><code>Gapjm.PermRoot.cartan</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.cartan-Tuple{PermRootGroup}"><code>Gapjm.PermRoot.cartan</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.coroot"><code>Gapjm.PermRoot.coroot</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.coroots"><code>Gapjm.PermRoot.coroots</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.coxeter_number"><code>Gapjm.PermRoot.coxeter_number</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.diagram"><code>Gapjm.PermRoot.diagram</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.generic_order"><code>Gapjm.PermRoot.generic_order</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.inclusion"><code>Gapjm.PermRoot.inclusion</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.invariant_form"><code>Gapjm.PermRoot.invariant_form</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.invariants"><code>Gapjm.PermRoot.invariants</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.isparabolic"><code>Gapjm.PermRoot.isparabolic</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.number_of_hyperplanes"><code>Gapjm.PermRoot.number_of_hyperplanes</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.number_of_reflections"><code>Gapjm.PermRoot.number_of_reflections</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.parabolic_closure"><code>Gapjm.PermRoot.parabolic_closure</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.parabolic_reps"><code>Gapjm.PermRoot.parabolic_reps</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.rank"><code>Gapjm.PermRoot.rank</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.reflectionMatrix"><code>Gapjm.PermRoot.reflectionMatrix</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.reflection_character"><code>Gapjm.PermRoot.reflection_character</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.reflection_eigenvalues"><code>Gapjm.PermRoot.reflection_eigenvalues</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.reflection_representation-Tuple{PermRootGroup, Any}"><code>Gapjm.PermRoot.reflection_representation</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.reflection_representation-Tuple{PRG}"><code>Gapjm.PermRoot.reflection_representation</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.reflection_representation-Tuple{PRG, Integer}"><code>Gapjm.PermRoot.reflection_representation</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.reflection_subgroup-Tuple{PRG, AbstractVector}"><code>Gapjm.PermRoot.reflection_subgroup</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.refls"><code>Gapjm.PermRoot.refls</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.restriction"><code>Gapjm.PermRoot.restriction</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.roots-Tuple{PRG, Any}"><code>Gapjm.PermRoot.roots</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.roots-Tuple{PRG}"><code>Gapjm.PermRoot.roots</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.semisimplerank"><code>Gapjm.PermRoot.semisimplerank</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.simple_conjugating"><code>Gapjm.PermRoot.simple_conjugating</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.simple_reps"><code>Gapjm.PermRoot.simple_reps</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.simplecoroots"><code>Gapjm.PermRoot.simplecoroots</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.simpleroots"><code>Gapjm.PermRoot.simpleroots</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.torus_order"><code>Gapjm.PermRoot.torus_order</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.unique_refls"><code>Gapjm.PermRoot.unique_refls</code></a></li><li><a href="permroot.html#Gapjm.Weyl.standard_parabolic-Tuple{PermRootGroup, Any}"><code>Gapjm.Weyl.standard_parabolic</code></a></li><li><a href="permroot.html#PermGroups.Perms.reflection_length-Tuple{PermRootGroup, Perm}"><code>PermGroups.Perms.reflection_length</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot" href="#Gapjm.PermRoot"><code>Gapjm.PermRoot</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Let  <code>V</code> be a vector  space over a subfield  <code>K</code> of the complex numbers (in Julia  the elements  of <code>K</code>  will be  usually represented by <code>Rational</code>s or <code>Cyc</code>s).</p><p>A <em>complex reflection</em> is an element <code>s∈ GL(V)</code> of finite order whose fixed point  set is  a hyperplane,  the <em>reflecting  hyperplane</em> <code>Hₛ</code> of <code>s</code>.</p><p>Most  of the  time we  abbreviate &quot;complex  reflection&quot; to <em>reflection</em>; in some  literature &quot;reflection&quot; is reserved for  <code>s</code> of order 2 and otherwise <em>pseudo-reflection</em> is used.</p><p>A  reflection <code>s</code> has a unique eigenvalue <code>ζₛ</code> not equal to <code>1</code>, which is a root  of  unity;  if  <code>K</code>  is  a  subfield  of  the  real  numbers, <code>ζₛ</code> is necessarily  equal to <code>-1</code> and <code>s</code> is of  order 2. An eigenvector <code>r∈ V</code> of <code>s</code>  for the eigenvalue  <code>ζₛ</code> is called  a <em>root</em> of  <code>s</code> and a linear form <code>rᵛ</code> on <code>V</code> of kernel <code>Hₛ</code> is called a <em>coroot</em> of <code>s</code>. If <code>r</code> and <code>rᵛ</code> are normalized  so that  <code>rᵛ(r)=1-ζ</code>, then  <code>s</code> is  the map  on <code>V</code>  defined by <code>s(x)=x-rᵛ(x)r</code>. Such a normalized root and coroot for <code>s</code> are unique up to scaling the root and inversely scaling the coroot.</p><p>A  finite  complex  reflection  group  <code>W</code>  is  a finite group generated by complex  reflections.  Since  whenever  <code>W</code>  contains  a  reflection <code>s</code> it contains  its powers, <code>W</code> is always  generated by reflections <code>s</code> such that <code>ζₛ==E(d)</code>  where <code>d</code> is the  order of <code>s</code>; we  can also assume that <code>s</code> is not  a power of another reflection with larger order <code>d</code>. Such a reflection is  called a <em>distinguished</em> reflection of <code>W</code>; it is a canonical generator of  the cyclic  subgroup of  <code>W</code> centralizing  <code>Hₛ</code>. The  generators of the complex   reflection   groups   we   construct   are  always  distinguished reflections; the set of distinguished reflections are in bijection with the reflecting  hyperplanes.  In  a  real  reflection group all reflections are distinguished.</p><p>It  is much  more efficient  to compute  with permutation  groups than with matrix  groups; hence we use for computing with a finite complex reflection group  <code>W</code> a permutation representation on  a <code>W</code>-invariant set of root and coroot vectors for reflections of <code>W</code>; that is, a set <code>R</code> of pairs <code>(r,rᵛ)∈ V×Vᵛ</code>  invariant by <code>W</code> and such that every distinguished reflection in <code>W</code> is determined by some pair in <code>R</code> (see <a href="permroot.html#Gapjm.PermRoot.reflectionMatrix"><code>reflectionMatrix</code></a>). Using a <code>W</code>-invariant  set implies that there may  be several pairs determining the same reflection, which differ by roots of unity. This generalizes the usual construction  for Coxeter groups (the case <code>K=ℝ</code>) where to each reflection of  <code>W</code>  is  associated  two  roots,  one  positive  and  one negative. </p><p>A  complex reflection group  is <em>irreducible</em> if  the representation <code>V</code> is irreducible.  For irreducible complex reflection groups, there are at least as many roots for a given reflection as the order of the center of <code>W</code>.</p><p>The  following  methods  are  always  defined for finite complex reflection groups:</p><ul><li><p><code>gens(W)</code>: the (distinguished) reflections which generate <code>W</code>, given as permutations of the roots. <code>reflrep(W)</code> gives them as matrices.</p></li><li><p><code>roots(W)</code>: the list of roots of <code>W</code>.</p></li><li><p><code>coroots(W)</code>: the list of coroots, in the same order as the roots.</p></li><li><p><code>refls(W)</code>:  a list of  distinguished reflections of  <code>W</code>, as permutations. This list is of same length as the roots, and its <code>i</code>-th element is the distinguished   reflection  for  the  <code>i</code>-th  root,  so  it  will  have repetitions. <code>unique_refls(W)</code> returns a sublist of <code>1:length(roots(W))</code> such that the distinguished reflections around the corresponding  roots reach one time  only each distinguished reflection of <code>W</code>.</p></li></ul><p>The  lists <code>roots</code>, <code>coroots</code> and <code>refls</code> starts with the &quot;generating&quot; ones (those corresponding to <code>gens(W)</code>).</p><ul><li><p><code>simpleroots(W)</code>:  the generating roots as a matrix.</p></li><li><p><code>simplecoroots(W)</code>:  the generating coroots as a matrix.</p></li><li><p><code>reflections(W)</code> gives a list without repetitions of all reflections of <code>W</code>   (not   only   the   distinguished   ones),  as  objects  of  type <a href="permroot.html#Gapjm.ComplexR.Reflection"><code>Reflection</code></a>.  These objects  contain more  information on each reflection.</p></li></ul><p>The  finite  irreducible  complex  reflection  groups  have been completely classified  by Shephard and  Todd, see <a href="biblio.htm#ST54">ShephardTodd1954</a>. They  consist of one infinite family  <code>G(de,e,r)</code> depending on 3 parameters (which  includes the infinite families of  Weyl groups), and 34 exceptional groups  which have been given  by Shephard and Todd  names which range from <code>G₄</code>  to  <code>G₃₇</code>.  These  exceptional  groups  include  the exceptional Weyl groups, e.g., <code>coxgroup(:E,8)</code> is the same as <code>G₃₇</code>.</p><p>We provide functions to build any finite reflection group, either by giving a  list  of  roots  and  coroots  defining  the generating reflections (see <a href="permroot.html#Gapjm.PermRoot.PRG"><code>PRG</code></a>), or in terms of the classification (see <a href="permroot.html#Gapjm.ComplexR.complex_reflection_group"><code>complex_reflection_group</code></a>).  In the  context e.g.  of Weyl groups, one  wants to  describe the  particular root  system chosen  in term of the traditional  classification of crystallographic root  systems. This is done via   calls  to  the  function   <a href="coxgroups.html#Gapjm.CoxGroups.coxeter_group-Tuple{AbstractMatrix}"><code>coxeter_group</code></a>  (see  the  module <a href="weyl.html#Gapjm.Weyl"><code>Weyl</code></a>).  There is not yet  a general theory on  how to construct a nice  set of roots for  a non-real reflection group;  the roots chosen here where  obtained  case-by-case;  however,  they  satisfy  several  important properties:</p><ul><li><p>The generating reflections  satisfy braid relations  which present the braid group associated to <code>W</code> (see <a href="permroot.html#Gapjm.PermRoot.diagram"><code>diagram</code></a>).</p></li><li><p>The <em>field  of definition</em>  of <code>W</code>  is the  field <code>K</code> generated by the traces  of the elements of <code>W</code> acting on  <code>V</code>. It is a theorem that <code>W</code> may be realized as a reflection group over <code>K</code>.</p></li><li><p>The Cartan matrix <code>rᵛ(r&#39;)</code> where <code>r</code> and <code>r&#39;</code> runs over the roots and</p></li></ul><p>coroots  for the generating reflections has  entries in the ring <code>ℤₖ</code> of    integers  of  <code>K</code>,  and  the  other  roots  (resp.  coroots)  are linear    combinations with coefficients in <code>ℤₖ</code>  of a linearly independent subset    of them.</p><p>It  turns out that all representations of <code>W</code> are defined over the field of definition <code>K</code> (see. <a href="biblio.htm#Ben76">Benard1976</a> and D.~Bessis&#39; thesis). This  has been known for a  long time in the case  <code>K=ℚ</code>, the case of Weyl groups, whose representations are all integral.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4)
G₄

julia&gt; gens(W) # as permutations of the 24 roots
2-element Vector{Perm{Int16}}:
 (1,3,9)(2,4,7)(5,10,18)(6,11,16)(8,12,19)(13,15,20)(14,17,21)(22,23,24)
 (1,5,13)(2,6,10)(3,7,14)(4,8,15)(9,16,22)(11,12,17)(18,19,23)(20,21,24)

julia&gt; length(unique(refls(W)))
4

julia&gt; length(refls(W)) # 24=4*(number of roots of unity in ℚ (ζ₃))
24

julia&gt; reflrep(W) # the generators as matrices
2-element Vector{Matrix{Cyc{Rational{Int64}}}}:
 [1 0; 0 ζ₃]
 [√-3/3 -ζ₃²√-3/3; (-3+√-3)/3 -ζ₃√-3/3]</code></pre><p>For  almost  all  irreducible  complex  reflection  groups,  the generating matrices  for <code>W</code> we give have coefficients in the field of definition <code>K</code>. Further,  the set of matrices for all elements of <code>W</code> is globally invariant under  the  Galois  group  of  <code>K/ℚ</code>,  thus  the  Galois  action  induces automorphisms  of <code>W</code>. The exceptions are <code>G₂₂, G₂₇</code> where the matrices are in  a  degree  two  extension  of  <code>K</code>  (this  is needed to have a globally invariant  model, see <a href="biblio.htm#MarinMichel10">MarinMichel2010</a>) and some dihedral  groups, as well as  <code>H₃</code> and <code>H₄</code>, where  the matrices given (the usual   Coxeter  reflection  representation  over  <code>K</code>)  are  not  globally invariant (but one can get invariant ones by <code>chevieget(:H4,:InvariantModel)</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; braid_relations(W) # as tuples of equal words in the generators
1-element Vector{Tuple{Vector{Int64}, Vector{Int64}}}:
 ([1, 2, 1], [2, 1, 2])

julia&gt; diagram(W) # the same in pictures
③ ——③ G₄
1   2

julia&gt; cartan(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
 ζ₃²√-3     ζ₃²
   -ζ₃²  ζ₃²√-3

julia&gt; simpleroots(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
    0  ζ₃²√-3
 2ζ₃²     ζ₃²

julia&gt; simplecoroots(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
     0      1
 √-3/3  √-3/3</code></pre><p>Let <code>SV</code> be the symmetric algebra of <code>V</code>. The invariants of <code>W</code> in <code>SV</code> are called the <em>polynomial invariants</em> of <code>W</code>. If <code>n=dim V</code>, they are generated as   a  polynomial  ring  by   <code>n</code>  homogeneous  algebraically  independent polynomials <code>f₁,…,fₙ</code>. The polynomials <code>fᵢ</code> are not uniquely determined but their  degrees are. The <code>fᵢ</code> are called  the <em>basic invariants</em> of <code>W</code>, and their  degrees the <em>reflection  degrees</em> of <code>W</code>;  the function <code>degrees(W)</code> returns these invariants.</p><p>Let  <code>I</code> be the  ideal generated by  the homogeneous invariants of positive degree  in <code>SV</code>. Then <code>SV/I</code> is isomorphic to the regular representation of <code>W</code>  as a  <code>W</code>-module. It  is thus  a graded  (by the degree of elements of <code>SV</code>)  version of the  regular representation of  <code>W</code>. The polynomial which gives  the graded  multiplicity of  a character  <code>φ</code> of  <code>W</code> in  the graded module   <code>SV/I</code>  is  called   the  <em>fake  degree</em>   of  <code>φ</code>.  The  function <code>fakedegrees</code> returns these polynomials.</p><pre><code class="language-julia-repl hljs">julia&gt; degrees(W)
2-element Vector{Int64}:
 4
 6

julia&gt; fakedegrees(W,Pol(:x))
7-element Vector{Pol{Int64}}:
 1
 x⁴
 x⁸
 x⁷+x⁵
 x⁵+x³
 x³+x
 x⁶+x⁴+x²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.asreflection" href="#Gapjm.PermRoot.asreflection"><code>Gapjm.PermRoot.asreflection</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>asreflection(s::Matrix [,r::AbstractVector])</code></p><p><code>s</code>  should be is a square  matrix, and if given <code>r</code>  should be a vector of length  <code>size(s,1)</code>.  The  function  determines  if  <code>s</code> is the matrix of a complex  reflection  (resp.  if  <code>r</code>  is  given  if  it  is the matrix of a reflection  of root <code>r</code>; the point of  giving <code>r</code> is to specify exactly the desired root and coroot, which otherwise are determined only up to a scalar and  its  inverse).  The  function  returns  <code>nothing</code>  if  <code>s</code> if is not a reflection  (resp. not a reflection with root <code>r</code>), and otherwise returns a named tuple with four fields:</p><p><code>.root</code>:   the root of the reflection <code>s</code> (equal to <code>r</code> if given)</p><p><code>.coroot</code>:  the coroot of <code>s</code></p><p><code>.eigenvalue</code>:  the non-trivial eigenvalue of <code>s</code></p><p><code>.isunitary</code>: a boolean which is <code>true</code> if and only if <code>s</code> is unitary   with  respect to the usual scalar product  (then <code>s</code> is determined by the   root and the eigenvalue as <code>reflectionMatrix(.root,.eigenvalue)</code>)</p><pre><code class="language-julia-repl hljs">julia&gt; asreflection([-1 0 0;1 1 0;0 0 1])
(root = [2, 0, 0], coroot = Rational{Int64}[1//1, -1//2, 0//1], eig = -1, isunitary = false)

julia&gt; asreflection([-1 0 0;1 1 0;0 0 1],[1,0,0])
(root = [1, 0, 0], coroot = Rational{Int64}[2//1, -1//1, 0//1], eig = -1, isunitary = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L304-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflectionMatrix" href="#Gapjm.PermRoot.reflectionMatrix"><code>Gapjm.PermRoot.reflectionMatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reflectionMatrix(root,  coroot)</code> the matrix of the reflection with a given root and coroot.</p><p>A (complex) reflection is a finite order element <code>s</code> of <code>GL(V)</code>, the linear group of a vector space over a subfield of the complex numbers, whose fixed points  form  a  hyperplane  <code>H</code>  (the  <em>reflecting hyperplane</em> of <code>s</code>); an eigenvector  <code>r</code> for  the non-trivial  eigenvalue <code>ζ</code>  (a root of unity) is called  a <em>root</em> of <code>s</code>. If we choose  a linear form <code>rᵛ</code> defining <code>H</code> such that <code>rᵛ(r)=1-ζ</code> (a <em>coroot</em> of <code>s</code>) then <code>s</code> is given by <code>x↦ x-rᵛ(x)r</code>.</p><p>A  way  of  specifying  <code>s</code>  is  by  giving  a root and a coroot, which are uniquely determined by <code>s</code> up to multiplication of the root by a scalar and of  the coroot by the inverse scalar. The function <code>reflectionMatrix</code> gives the  matrix of the  corresponding reflection in  the standard basis of <code>V</code>, where  the <code>root</code> and the <code>coroot</code> are  vectors given in the standard bases of <code>V</code> and <code>Vᵛ</code>, so the pairing <code>rᵛ(r)</code> is obtained as <code>transpose(root)*coroot</code>.</p><pre><code class="nohighlight hljs">julia&gt; r=reflectionMatrix([1,0,0],[2,-1,0])
3×3 Matrix{Int64}:
 -1  0  0
  1  1  0
  0  0  1

julia&gt; r==reflrep(coxgroup(:A,3),1)
true

julia&gt; r*[2,-1,0]
3-element Vector{Int64}:
 -2
  1
  0

julia&gt; [1 0 0]*r
1×3 Matrix{Int64}:
 -1  0  0</code></pre><p>As  we see in the last lines, in  Julia a matrix operates from the right on the  vector space <code>V</code>  of row vectors  and from the  left on the dual space <code>Vᵛ</code> of column vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L236-L278">source</a></section><section><div><p><code>reflectionMatrix(r, ζ=-1)</code></p><p>returns the matrix of the unitary complex reflection determined by the root <code>r</code> and the eigenvalue <code>ζ</code>, that is, when the vector space and its dual are identified  via the scalar product  <code>&lt;x,y&gt;=transpose(x)*y</code>; the coroot <code>rᵛ</code> is then equal to the linear form <code>x-&gt;(1-ζ)&lt;x,r&gt;/&lt;r,r&gt;</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; reflectionMatrix([1,0,-E(3,2)])
3×3 Matrix{Cyc{Rational{Int64}}}:
  0  0  ζ₃²
  0  1    0
 ζ₃  0    0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L284-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.PermRootGroup" href="#Gapjm.PermRoot.PermRootGroup"><code>Gapjm.PermRoot.PermRootGroup</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PermRootGroup</code>   is  the  type  of  reflection  groups  represented  as  a permutation group on a set of roots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L493-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.ComplexR.complex_reflection_group" href="#Gapjm.ComplexR.complex_reflection_group"><code>Gapjm.ComplexR.complex_reflection_group</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>complex_reflection_group(STnumber)</code> or <code>crg(STnumber)</code></p><p><code>complex_reflection_group(p,q,r)</code> or <code>crg(p,q,r)</code></p><p>The  first form of <code>complex_reflection_group</code>  returns the complex reflection group which has Shephard-Todd number <code>STnumber</code>, see <a href="biblio.htm#ST54">Shephard-Todd1954</a>.   The   second   form   returns   the imprimitive complex reflection group <code>G(p,q,r)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; G=complex_reflection_group(4)
G₄

julia&gt; degrees(G)
2-element Vector{Int64}:
 4
 6

julia&gt; length(G)
24

julia&gt; W*coxgroup(:A,2) # how to make a non-irreducible group
G₄×A₂

julia&gt; complex_reflection_group(1,1,3) # another way to enter A₂
A₂

julia&gt; crg(4) # there is also a short alias
G₄</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/ComplexR.jl#L25-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.PRG" href="#Gapjm.PermRoot.PRG"><code>Gapjm.PermRoot.PRG</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PRG(roots,coroots)</code> complex reflection group with given roots and coroots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1635-L1637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.rank" href="#Gapjm.PermRoot.rank"><code>Gapjm.PermRoot.rank</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>rank(W::ComplexReflectionGroup)</code></p><p>This  function  returns  the  <em>rank</em>  of  a  reflection group, which is the dimension of the space where it acts.</p><pre><code class="language-julia-repl hljs">julia&gt; rank(complex_reflection_group(31))
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L691-L701">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.semisimplerank" href="#Gapjm.PermRoot.semisimplerank"><code>Gapjm.PermRoot.semisimplerank</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>semisimpleRank(W::ComplexReflectionGroup)</code></p><p>This  function returns the  <em>semisimple rank</em> of  the reflection group <code>W</code>, which  is the dimension of the space where it effectively acts. If <code>W</code> is a reflection  group acting on <code>V</code>, and <code>V₁</code>  is the subspace generated by the <code>roots(W)</code>,  then  the  dimension  of  <code>V₁</code>  is the semisimple rank. <code>W</code> is called <em>essential</em> if <code>V₁=V</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=reflection_subgroup(coxgroup(:A,3),[1,3])
A₃₍₁₃₎=A₁×A₁Φ₁

julia&gt; semisimplerank(W)
2

julia&gt; rank(W)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1221-L1240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.number_of_reflections" href="#Gapjm.PermRoot.number_of_reflections"><code>Gapjm.PermRoot.number_of_reflections</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>number_of_reflections(W::ComplexReflectionGroup)</code> or <code>nref(W)</code></p><p>the number of reflections of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L513-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.number_of_hyperplanes" href="#Gapjm.PermRoot.number_of_hyperplanes"><code>Gapjm.PermRoot.number_of_hyperplanes</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>number_of_hyperplanes(W::ComplexReflectionGroup)</code> or <code>nhyp(W)</code></p><p>The number of reflecting hyperplanes of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L522-L526">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.coxeter_number" href="#Gapjm.PermRoot.coxeter_number"><code>Gapjm.PermRoot.coxeter_number</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>coxeter_number(W::PermRootGroup,i)</code> or <code>coxnum</code></p><p>Gordon  and  Griffeth  <a href="biblio.htm#gg12">GG2012</a>  have defined the <em>Coxeter number</em>  of an irreducible  character <code>φ</code> of  a complex reflection group as the scalar by which the central element <code>∑_{s in reflections(W)}(1-s)</code> acts on  the representation of character <code>φ</code>.  The function <code>coxnum</code> returns the Coxeter number of the <code>i</code>-th irreducible character of <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L531-L539">source</a></section><section><div><p><code>coxeter_number(W::PermRootGroup)</code> or <code>coxnum</code></p><p>Gordon  and  Griffeth  <a href="biblio.htm#gg12">GG2012</a>  have defined the <em>Coxeter number</em> of an irreducible complex reflection group as the Coxeter number of its reflection character. It is also given by the formula <code>(nref(W)+nhyp(W))/rank(W)</code>;  for a well-generated group it is equal to the highest  reflection degree. For a non-irreducible group, the Coxeter number is the sum of those of its irreducible components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L543-L552">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.roots-Tuple{PRG}" href="#Gapjm.PermRoot.roots-Tuple{PRG}"><code>Gapjm.PermRoot.roots</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>roots(W::PermRootGroup)</code> the roots of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1706">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.roots-Tuple{PRG, Any}" href="#Gapjm.PermRoot.roots-Tuple{PRG, Any}"><code>Gapjm.PermRoot.roots</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>roots(W::PermRootGroup,i)</code> same as <code>roots(W)[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1708">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.coroots" href="#Gapjm.PermRoot.coroots"><code>Gapjm.PermRoot.coroots</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>coroots(W)</code> the list of coroots of <code>W</code> (listed in the same order as the roots)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1715">source</a></section><section><div><p><code>coroots(W,i)</code> same as but better than <code>coroots(W)[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1729">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.coroot" href="#Gapjm.PermRoot.coroot"><code>Gapjm.PermRoot.coroot</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>coroot(r,λ=-1)</code></p><p>the coroot for a unitary reflection of root <code>r</code> and eigenvalue <code>λ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L226-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.simpleroots" href="#Gapjm.PermRoot.simpleroots"><code>Gapjm.PermRoot.simpleroots</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>simpleroots(W::ComplexReflectionGroup)</code>  the  simple  roots  of <code>W</code> (those corresponding to <code>gens(W)</code>) as a matrix (each root is a row)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1710-L1713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.simplecoroots" href="#Gapjm.PermRoot.simplecoroots"><code>Gapjm.PermRoot.simplecoroots</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>simplecoroots(W::ComplexReflectionGroup)</code> the simple coroots of <code>W</code> (those <code>corresponding to gens(W)</code>) as a matrix (each coroot is a row)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1717-L1720">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.cartan-Tuple{PermRootGroup}" href="#Gapjm.PermRoot.cartan-Tuple{PermRootGroup}"><code>Gapjm.PermRoot.cartan</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>cartan(W::PermRootGroup)</code>    Cartan matrix of <code>W</code>.</p><p>Let  <code>s₁,…,sₙ</code> be reflections with associated  roots <code>rᵢ</code> and coroots <code>cᵢ</code>. The  matrix <code>C</code> with  entries <code>Cᵢ,ⱼ=cᵢ(rⱼ)</code> is  called a <em>Cartan matrix</em> of <code>s₁,…,sₙ</code>.  Since a reflection determines up to scalar a root and a coroot, <code>C</code>  is uniquely  determined by  <code>s₁,…,sₙ</code> up  to conjugation by a diagonal matrix.</p><p>If <code>s₁,…,sₙ</code> generate a reflection group <code>W</code>, then <code>C</code> up to conjugation by a  diagonal matrix is an invariant of the reflection representation of <code>W</code>. If invertible, the matrix <code>C</code> determines this representation since then the <code>rᵢ</code>  form a basis in  which the matrix for  <code>sᵢ</code> differs from the identity only  on  the  <code>i</code>-th  row,  where  the  corresponding  row of <code>C</code> has been subtracted.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; cartan(W)
3×3 Matrix{Int64}:
  2  -1   0
 -1   2  -1
  0  -1   2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L655-L681">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.cartan-Tuple{PermRootGroup, Any, Any}" href="#Gapjm.PermRoot.cartan-Tuple{PermRootGroup, Any, Any}"><code>Gapjm.PermRoot.cartan</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>cartan(W::PermRootGroup,i,j)</code> the  cartan coefficient <code>cᵢ(rⱼ)</code>, the value of the linear form given by the <code>i</code>-th coroot <code>cᵢ</code> on the <code>j</code>-th root <code>rᵢ</code> of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L648-L652">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.refls" href="#Gapjm.PermRoot.refls"><code>Gapjm.PermRoot.refls</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>refls(W::ComplexReflectionGroup)</code></p><p>a  list of same length as <code>W.roots</code> giving the corresponding element of <code>W</code> representing  a distinguished reflection.  In particular this  list is much longer  than <code>unique(refls(W))</code>  since in  general there  are several roots corresponding to a reflection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L603-L610">source</a></section><section><div><p><code>refls(W::ComplexReflectionGroup,i)</code></p><p>the  element of <code>W</code> representing  the distinguished reflection around the <code>i</code>-th root of <code>W</code> (<code>i</code> can be an index or a vector of indices)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L613-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.unique_refls" href="#Gapjm.PermRoot.unique_refls"><code>Gapjm.PermRoot.unique_refls</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>unique_refls(W::ComplexReflectionGroup)</code> A  sublist of <code>1:length(roots(W))</code> such  that the distinguished reflections around  the  corresponding  roots  reach  one  time only each distinguished reflection of <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L631-L636">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.ComplexR.Reflection" href="#Gapjm.ComplexR.Reflection"><code>Gapjm.ComplexR.Reflection</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Reflection</code>  is a <code>struct</code>  representing a reflection  <code>r</code> in a reflection group <code>W</code>. The fields are <code>W</code>, the index of a root for <code>r</code>, the non-trivial eigenvalue of <code>r</code>, and a word for <code>r</code> in the generating reflections of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=crg(8);

julia&gt; r=reflections(W)[7]
Reflection(G₈,1,-1)

julia&gt; r==Reflection(W,1,-1) # construct with group, root number, eigenvalue
true

julia&gt; Reflection(W,1) # omitting the eigenvalue gets the distinguished refl.
Reflection(G₈,1,ζ₄)

julia&gt; r.eigen # the non-trival eigenvalue, as a Root1
Root1: -1

julia&gt; root(r)
2-element Vector{Cyc{Rational{Int64}}}:
  0
 ζ₄

julia&gt; coroot(r)
2-element Vector{Cyc{Int64}}:
    0
 -2ζ₄

julia&gt; Matrix(r)
2×2 Matrix{Cyc{Rational{Int64}}}:
 1   0
 0  -1

julia&gt; hyperplane(r) # the fixed hyperplane, as a rowspace
1×2 Matrix{Cyc{Rational{Int64}}}:
 1  0

julia&gt; hyperplane(r)*Matrix(r)==hyperplane(r)
true

julia&gt; isdistinguished(r) # r is not distinguished
false

julia&gt; exponent(r) # which power of a distinguished reflection it is
2

julia&gt; Perm(r)
(1,8)(2,9)(3,16)(4,15)(5,17)(6,18)(7,19)(10,22)(11,21)(12,23)

julia&gt; hyperplane_orbit(r) # r is in the first hyperplane orbit
1

julia&gt; position_class(r) # the index of the conjugacy class of r in W 
15

julia&gt; simple_rep(r) # smallest root index affording a conjugate reflection
1

julia&gt; word(r) # a word in the generators for r
2-element Vector{Int64}:
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/ComplexR.jl#L356-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.ComplexR.reflections" href="#Gapjm.ComplexR.reflections"><code>Gapjm.ComplexR.reflections</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reflections(W)</code>  the list of  all reflections of  the reflection group <code>W</code> (including  the  non-distinguished  ones),  given as a <code>Vector{Reflection}</code> (see   <a href="permroot.html#Gapjm.ComplexR.Reflection"><code>Reflection</code></a>).   <code>reflections(W)[1:nhyp(W)]</code>   contains  the distinguished reflections.</p><pre><code class="language-julia-repl hljs">julia&gt; W=crg(4)
G₄

julia&gt; reflections(W)
8-element Vector{Reflection{PRG{Cyc{Rational{Int64}}, Int16}}}:
 Reflection(G₄,1,ζ₃)
 Reflection(G₄,2,ζ₃)
 Reflection(G₄,4,ζ₃)
 Reflection(G₄,5,ζ₃)
 Reflection(G₄,1,ζ₃²)
 Reflection(G₄,2,ζ₃²)
 Reflection(G₄,4,ζ₃²)
 Reflection(G₄,5,ζ₃²)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/ComplexR.jl#L494-L515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PermGroups.Perms.reflection_length-Tuple{PermRootGroup, Perm}" href="#PermGroups.Perms.reflection_length-Tuple{PermRootGroup, Perm}"><code>PermGroups.Perms.reflection_length</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflection_length(W::PermRootGroup,w::Perm)</code> or <code>reflength</code></p><p>This  function returns the  number of eigenvalues  of <code>w</code> in the reflection representation  which are not equal to 1.  For a finite Coxeter group, this is  equal to the  reflection length of  <code>w</code>, that is  the minimum number of reflections  of which  <code>w</code> is  a product.  This also  holds in general in a well-generated  complex reflection group  if <code>w</code> divides  a Coxeter element for the reflection length.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,4)
A₄

julia&gt; reflength(W,longest(W))
2

julia&gt; reflength(W,W(1,2,3,4))
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1130-L1150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.simple_reps" href="#Gapjm.PermRoot.simple_reps"><code>Gapjm.PermRoot.simple_reps</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>simple_reps(W)</code></p><p>for each root, the index of the first simple root conjugate to it</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L571-L575">source</a></section><section><div><p><code>simple_reps(W,i)</code></p><p>the  smallest index  of a root in the same <code>W</code>-orbit as the <code>i</code>-th root.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L596-L600">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.simple_conjugating" href="#Gapjm.PermRoot.simple_conjugating"><code>Gapjm.PermRoot.simple_conjugating</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>simple_conjugating(W::ComplexReflectionGroup)</code></p><p>For each index <code>i</code> of a root, an element <code>w∈ W</code> such that <code>restriction(W,inclusion(W,simple_reps(W,i))^w)==i</code> (or <code>action(W,simple_reps(W,i))==i</code>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L622-L628">source</a></section><section><div><p><code>simple_conjugating(W,i)</code></p><p>an element <code>w∈ W</code> such that <code>restriction(W,inclusion(W,simple_reps(W,i))^w)==i</code> (or <code>action(W,simple_reps(W,i))==i</code>). In particular <code>W(simple_reps(W,i))^simple_conjugating(W,i)==refls(W,i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L639-L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.diagram" href="#Gapjm.PermRoot.diagram"><code>Gapjm.PermRoot.diagram</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>diagram(W)</code> diagram of finite reflection group <code>W</code></p><pre><code class="language-julia-repl hljs">julia&gt; diagram(coxgroup(:E,8))
    O 2
    ￨
O—O—O—O—O—O—O E₈
1 3 4 5 6 7 8

julia&gt; diagram(crg(33))
      3       G₃₃
     /^\
1———2———4———5 423423==342342</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L476-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.ComplexR.hyperplane_orbits" href="#Gapjm.ComplexR.hyperplane_orbits"><code>Gapjm.ComplexR.hyperplane_orbits</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>hyperplane_orbits(W::ComplexReflectionGroup)</code></p><p>returns  a  list  of  named  tuples,  one  for each hyperplane orbit of the reflection  group <code>W</code>. If <code>o</code> is the named tuple for such an orbit, and <code>s</code> is  the first  element of  <code>gens(W)</code> whose  hyperplane is  in the orbit, it contains the following fields</p><p><code>.s</code>:     index of <code>s</code> in <code>gens(W)</code></p><p><code>.order</code>: order of s</p><p><code>.cl_s</code>:  for i in <code>1:order-1</code>, <code>position_class(W,W(s)^i)</code></p><p><code>.N_s</code>:    size of hyperplane orbit</p><p><code>.det_s</code>:  for i in <code>1:order-1</code>, position in <code>CharTable(W)</code> of <code>detₛⁱ</code>, where    <code>detₛ</code> is the linear character taking the value <code>det(reflrep(W,s))</code> on <code>s</code>    and <code>1</code> on non-conjugate reflections.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; hyperplane_orbits(W)
2-element Vector{NamedTuple{(:s, :cl_s, :order, :N_s, :det_s), Tuple{Int64, Vector{Int64}, Int64, Int64, Vector{Int64}}}}:
 (s = 1, cl_s = [2], order = 2, N_s = 2, det_s = [5])
 (s = 2, cl_s = [4], order = 2, N_s = 2, det_s = [1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/ComplexR.jl#L283-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.braid_relations" href="#Gapjm.CoxGroups.braid_relations"><code>Gapjm.CoxGroups.braid_relations</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>braid_relations(W)</code></p><p>this  function returns the  relations which present  the braid group of the reflection group <code>W</code>. These are homogeneous (both sides of the same length) relations  between generators in bijection  with the generating reflections of  <code>W</code>. A presentation  of <code>W</code> is  obtained by adding relations specifying the order of the generators.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(29)
G₂₉

julia&gt; braid_relations(W)
7-element Vector{Tuple{Vector{Int64}, Vector{Int64}}}:
 ([1, 2, 1], [2, 1, 2])
 ([2, 4, 2], [4, 2, 4])
 ([3, 4, 3], [4, 3, 4])
 ([2, 3, 2, 3], [3, 2, 3, 2])
 ([1, 3], [3, 1])
 ([1, 4], [4, 1])
 ([4, 3, 2, 4, 3, 2], [3, 2, 4, 3, 2, 4])</code></pre><p>each  relation  is  represented  as  a  pair  of lists, specifying that the product  of the  generators according  to the  indices on  the left side is equal  to the product according to the  indices on the right side. See also <code>diagram</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/CoxGroups.jl#L761-L789">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection_representation-Tuple{PermRootGroup, Any}" href="#Gapjm.PermRoot.reflection_representation-Tuple{PermRootGroup, Any}"><code>Gapjm.PermRoot.reflection_representation</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflection_representation(W,w)</code>  or <code>reflrep(W,w)</code></p><p>Let  <code>W</code> be a  finite reflection group  on the space  <code>V</code> and let  <code>w</code> be a permutation  of the roots of <code>W</code>. The function <code>reflrep</code> returns the matrix of  <code>w</code> acting on <code>V</code>  (recall that matrices operate  <em>from the right</em> on a vector  space in <code>Gapjm</code>).  This is the  linear transformation of <code>V</code> which acts  trivially on the orthogonal of the coroots and has same effect as <code>w</code> on the simple roots. The function makes sense more generally for an element of the normalizer of <code>W</code> in the whole permutation group of the roots.</p><pre><code class="language-julia-repl hljs">julia&gt; W=reflection_subgroup(rootdatum(&quot;E7sc&quot;),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia&gt; reflrep(W,longest(W))
7×7 Matrix{Int64}:
  0   0   0   0   0  -1  2
  0  -1   0   0   0   0  2
  0   0   0   0  -1   0  3
  0   0   0  -1   0   0  4
  0   0  -1   0   0   0  3
 -1   0   0   0   0   0  2
  0   0   0   0   0   0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1479-L1504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection_representation-Tuple{PRG}" href="#Gapjm.PermRoot.reflection_representation-Tuple{PRG}"><code>Gapjm.PermRoot.reflection_representation</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflection_representation(W::ComplexReflectionGroup)</code> or <code>reflrep(W)</code></p><p>returns  the  list  of  <code>reflrep(W,x)</code>  for  <code>x</code>  in <code>gens(W)</code>, that is the generators of <code>W</code> as matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1750-L1755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection_representation-Tuple{PRG, Integer}" href="#Gapjm.PermRoot.reflection_representation-Tuple{PRG, Integer}"><code>Gapjm.PermRoot.reflection_representation</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflection_representation(W,i::Integer)</code>  or <code>reflrep(W,i)</code></p><p>for <code>i∈ 1:ngens(W)</code> same as but faster than <code>reflrep(W,W(i))</code>. For  <code>ngens(W)&lt;i≤nref(W)</code>  returns  the  matrix  for  the  i-th  reflection <code>refls(W,i)</code> of <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1758-L1764">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection_character" href="#Gapjm.PermRoot.reflection_character"><code>Gapjm.PermRoot.reflection_character</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reflection_character(W::ComplexReflectionGroup,w)</code> or <code>reflchar</code></p><p>Returns  the trace  of the  element <code>w</code>  of <code>W</code>  as an  endomorphism of the vector space <code>V</code> on which <code>W</code> acts. This is the same as <code>tr(reflrep(W,w))</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,3)
B₃

julia&gt; reflchar(W,longest(W))
-3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1043-L1056">source</a></section><section><div><p><code>reflection_character(W::ComplexReflectionGroup)</code> or <code>reflchar</code></p><p>Returns   the  reflection   character  of   <code>W</code>.  This   is  the   same  as <code>map(c-&gt;reflchar(W,c),class-reps(W))</code>.  When <code>W</code> is irreducible, it is also <code>CharTable(W).irr[charinfo(W).extRefl[2]]</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; reflchar(coxgroup(:A,3))
5-element Vector{Int64}:
  3
  1
 -1
  0
 -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1061-L1077">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.YMatrix" href="#Gapjm.PermRoot.YMatrix"><code>Gapjm.PermRoot.YMatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>YMatrix(W,w)</code></p><p>Let  <code>W</code> be a  finite reflection group  on the space  <code>V</code> and let <code>w</code> be an element of <code>W</code>. The function <code>YMatrix</code> returns the matrix of <code>w</code> acting on the dual  of <code>V</code>. This  is the linear  transformation of this  space which acts trivially  on the orthogonal of the roots and has same effect as <code>w</code> on the simple  coroots. The function makes sense  more generally for an element of the normalizer of <code>W</code> in the whole permutation group of the coroots.</p><pre><code class="language-julia-repl hljs">julia&gt; W=reflection_subgroup(rootdatum(&quot;E7sc&quot;),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia&gt; YMatrix(W,longest(W))
7×7 transpose(::Matrix{Int64}) with eltype Int64:
  0   0   0   0   0  -1  0
  0  -1   0   0   0   0  0
  0   0   0   0  -1   0  0
  0   0   0  -1   0   0  0
  0   0  -1   0   0   0  0
 -1   0   0   0   0   0  0
  2   2   3   4   3   2  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1517-L1541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.PermX" href="#Gapjm.PermRoot.PermX"><code>Gapjm.PermRoot.PermX</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>PermX(W::ComplexReflectionGroup,M::AbstractMatrix)</code></p><p>Let <code>M</code> be an invertible linear map of the reflection representation of <code>W</code> which  preserves the set  of roots of  <code>parent(W)</code>, and normalizes <code>W</code> (for the  action of  matrices on  the right).  <code>PermX</code> returns the corresponding permutation  of the roots of <code>parent(W)</code>;  it returns <code>nothing</code> if <code>M</code> does not normalize the set of roots of <code>parent(W)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=reflection_subgroup(rootdatum(&quot;E7sc&quot;),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia&gt; PermX(W,reflrep(W,longest(W)))==longest(W)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1277-L1293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.PermY" href="#Gapjm.PermRoot.PermY"><code>Gapjm.PermRoot.PermY</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>PermY(W::ComplexReflectionGroup,M::AbstractMatrix)</code></p><p>Let  <code>M</code>  be  an  invertible  linear  map  on  the  dual  of the reflection representation  of <code>W</code> which  preserves the set  of coroots of <code>parent(W)</code>, and  normalizes  <code>W</code>  (for  the  action  of matrices on the right). <code>PermY</code> returns  the corresponding  permutation of  the coroots  of <code>parent(W)</code>; it returns  <code>nothing</code>  if  <code>M</code>  does  not  normalize  the  set  of  coroots of <code>parent(W)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=reflection_subgroup(rootdatum(&quot;E7sc&quot;),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia&gt; PermY(W,YMatrix(W,longest(W)))==longest(W)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1543-L1560">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection_eigenvalues" href="#Gapjm.PermRoot.reflection_eigenvalues"><code>Gapjm.PermRoot.reflection_eigenvalues</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reflection_eigenvalues(W)</code> or <code>refleigen(W)</code></p><p>Let <code>W</code> be a reflection group on the vector space <code>V</code>. <code>reflection_eigenvalues(W)</code> returns for each conjugacy class representative <code>x</code>  of <code>W</code> (see <code>classreps</code>)  the eigenvalues of <code>x</code>  on <code>V</code>, as a list of <code>Root1</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; refleigen(coxgroup(:B,2))
5-element Vector{Vector{Root1}}:
 [1, 1]
 [-1, 1]
 [-1, -1]
 [-1, 1]
 [ζ₄³, ζ₄]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1080-L1097">source</a></section><section><div><p><code>refleigen(W,i)</code> faster than <code>refleigen(W)[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.ComplexR.degrees-Tuple{PermRootGroup}" href="#Gapjm.ComplexR.degrees-Tuple{PermRootGroup}"><code>Gapjm.ComplexR.degrees</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>degrees(W::ComplexReflectionGroup)</code></p><p>returns  a list  holding the  degrees of  <code>W</code> as  a reflection group on the vector  space <code>V</code> on which  it acts. These are  the degrees <code>d₁,…,dₙ</code> where <code>n</code>  is the dimension of  <code>V</code> of the basic  invariants of <code>W</code> in <code>SV</code>. They reflect  various properties  of <code>W</code>;  in particular,  their product  is the cardinality of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(30)
H₄

julia&gt; degrees(W)
4-element Vector{Int64}:
  2
 12
 20
 30

julia&gt; length(W)
14400</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/ComplexR.jl#L105-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.ComplexR.codegrees" href="#Gapjm.ComplexR.codegrees"><code>Gapjm.ComplexR.codegrees</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>codegrees(W::ComplexReflectionGroup)</code></p><p>returns  the vector of codegrees of <code>W</code>  as a reflection group on the space <code>V</code>  of <code>reflrep(W)</code>.  These are  one less  than the  degrees of  the basic derivations of <code>W</code> on <code>SV⊗ V^vee</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4)
G₄

julia&gt; codegrees(W)
2-element Vector{Int64}:
 0
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/ComplexR.jl#L249-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.invariants" href="#Gapjm.PermRoot.invariants"><code>Gapjm.PermRoot.invariants</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>invariants(W::ComplexReflectionGroup)</code></p><p>returns  the fundamental invariants of <code>W</code> in its reflection representation <code>V</code>.  That is, returns  a set of  algebraically independent elements of the symmetric  algebra  of  the  dual  of  <code>V</code> which generate the <code>W</code>-invariant polynomial  functions on <code>V</code>. Each such invariant function is returned as a function:  if <code>e₁,…,eₙ</code> is a basis of <code>V</code> and <code>f</code> is the function, then the value  of the polynomial  function on <code>a₁e₁+…+aₙeₙ</code>  is obtained by calling <code>f(a₁,…,aₙ)</code>. This function depends on the classification, and is dependent on the exact reflection representation of <code>W</code>. So for the moment it is only implemented   when  the  reflection   representation  for  the  irreducible components has the same Cartan matrix as the one provided by Chevie for the corresponding  irreducible  group.  The  polynomials  are invariant for the natural   action  of   the  group   elements  as   matrices;  that  is,  if <code>m==reflrep(W,w)</code>  for some  <code>w</code> in  <code>W</code>, then  an invariant  <code>f</code> satisfies <code>f(a₁,…,aₙ)=f(v₁,…,vₙ)</code>   where  <code>[v₁,…,vₙ]=[a₁,…,aₙ]×m</code>.  This  action  is implemented on <code>Mvp</code>s by the function <code>^</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; @Mvp x,y,z

julia&gt; i=invariants(W);

julia&gt; i[1](x,y)
Mvp{Int64}: -2x²+2xy-2y²

julia&gt; i[2](x,y)
Mvp{Int64}: 6x²y-6xy²

julia&gt; W=complex_reflection_group(24)
G₂₄

julia&gt; i=invariants(W)[1];

julia&gt; p=i(x,y,z)
Mvp{Rational{Int64}}: (14//1)x⁴+(-12//1)x²y²+(-42//1)x²yz+(21//2)x²z²+(18//7)y⁴+(-6//1)y³z+(-9//2)y²z²+(-21//8)z⁴

julia&gt; p^reflrep(W,1)-p
Mvp{Cyc{Rational{Int64}}}: 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L2034-L2078">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.discriminant" href="#Gapjm.Chars.discriminant"><code>Gapjm.Chars.discriminant</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>discriminant(W)</code></p><p>returns  the  discriminant  of  the  complex  reflection  group  <code>W</code>,  as a polynomial in the fundamental invariants. The discriminant is the invariant obtained  by  taking  the  product  of  the  linear  forms  describing  the reflecting   hyperplanes  of  <code>W</code>,   each  raised  to   the  order  of  the corresponding  reflection. The discriminant  is returned as  a function <code>f</code> such  that  the  discriminant  in  the  variables  <code>a₁,…,aₙ</code> is obtained by calling <code>f(a₁,…,aₙ)</code>. For the moment, this function is implemented only for the exceptional complex reflection groups <code>G₄</code> to <code>G₃₃</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4);@Mvp x,y

julia&gt; discriminant(W)(x,y)
Mvp{Int64}: x³-y²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/Chars.jl#L1675-L1693">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.invariant_form" href="#Gapjm.PermRoot.invariant_form"><code>Gapjm.PermRoot.invariant_form</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>invariant_form(W::ComplexReflectionGroup)</code></p><p>This  function  returns  the  matrix  <code>F</code>  (defined  up  to a scalar) of an Hermitian form invariant under the action of the reflection group <code>W</code>. That is, if <code>M</code> is the matrix of an element of <code>W</code>, then <code>M*F*M&#39;=F</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4)
G₄

julia&gt; invariant_form(W)
2×2 Matrix{Int64}:
 1  0
 0  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1970-L1986">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.bipartite_decomposition" href="#Gapjm.PermRoot.bipartite_decomposition"><code>Gapjm.PermRoot.bipartite_decomposition</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>bipartite_decomposition(W)</code></p><p>Returns  a bipartite decomposition <code>[L,R]</code> of the indices of the generators of  the  reflection  group  <code>W</code>,  such  that <code>reflection_subgroup(W,L)</code> and <code>reflection_subgroup(W,R)</code> are abelian subgroups, and <code>W=reflection_subgroup(W,   vcat(L,R))</code>.   Gives   an   error  if  no  such decomposition is possible.</p><pre><code class="language-julia-repl hljs">julia&gt; bipartite_decomposition(coxgroup(:E,8))
([1, 4, 6, 8], [3, 2, 5, 7])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1006-L1020">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Combinat.catalan-Tuple{Group, Any}" href="#Combinat.catalan-Tuple{Group, Any}"><code>Combinat.catalan</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>catalan(W::ComplexReflectionGroup)</code></p><p>returns the Catalan Number of the irreducible complex reflection group <code>W</code>. For well-generated groups, this number is equal to the number of simples in the  dual Braid  monoid. For  other groups  it was  defined by  <a href="biblio.htm#gg12">Gordon and Griffeth2012</a>.  For Weyl groups, it also counts the number of antichains of roots.</p><pre><code class="language-julia-repl hljs">julia&gt; catalan(coxgroup(:A,7))
1430</code></pre><p><code>catalan(W,i)</code></p><p>returns   the  <code>i</code>-th  Fuss-Catalan  Number   of  the  irreducible  complex reflection  group <code>W</code>. For  well-generated groups, this  number is equal to the  number of chains  <code>s₁,…,sᵢ</code> of simples  in the dual  monoid where <code>sⱼ</code> divides  <code>sⱼ₊₁</code>. For these groups, it is also equal to <code>∏ⱼ(ih+dⱼ)/dⱼ</code> where the  product runs over the reflection degrees  of <code>W</code>, and where <code>h</code> is the Coxeter  number of <code>W</code>. For non-well generated groups, the definition is in <a href="biblio.htm#gg12">Gordon and Griffeth2012</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; catalan(complex_reflection_group(7),2)
16</code></pre><p><code>catalan(W;q=1)</code>, resp. <code>catalan(W,i;q=1)</code></p><p>for  <code>q</code>  a  variable  (like  <code>Pol()</code>  or an <code>Mvp</code>) returns the <code>q</code>-Catalan number  (resp.  the  <code>i</code>-th  <code>q</code>-Fuss  Catalan  number)  of  <code>W</code>. Again the definitions in general are in <a href="biblio.htm#gg12">Gordon and Griffeth2012</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; catalan(complex_reflection_group(7),2;q=Pol())
Pol{Int64}: q⁷²+2q⁶⁰+3q⁴⁸+4q³⁶+3q²⁴+2q¹²+1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1912-L1951">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.generic_order" href="#Gapjm.PermRoot.generic_order"><code>Gapjm.PermRoot.generic_order</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>generic_order(W,q=Pol())</code></p><p>returns  the generic  order of  <code>W</code> as  a polynomial  in <code>q</code> (the &quot;compact&quot; order  of the  Spets). This  is <span>$q^{Nₕ}Πᵢ(q^{dᵢ}-1)$</span>  where <code>dᵢ</code>  are the reflection  degrees and  <code>Nₕ</code> the  number of  reflecting hyperplanes. For a Weyl  group, it is the order  of the associated semisimple finite reductive group over the field with <code>q</code> elements.</p><pre><code class="language-julia-repl hljs">julia&gt; PermRoot.generic_order(complex_reflection_group(4),Pol(:q))
Pol{Int64}: q¹⁴-q¹⁰-q⁸+q⁴</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L2018-L2031">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.torus_order" href="#Gapjm.PermRoot.torus_order"><code>Gapjm.PermRoot.torus_order</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>torus_order(W::ComplexReflectionGroup,i,q=Pol())</code></p><p>returns  as a  polynomial in  <code>q</code> the  toric order  of the <code>i</code>-th conjugacy class  of <code>W</code>. This is the characteristic  polynomial of an element of that class  on  the  reflection  representation  of  <code>W</code>.  It is the same as the generic  order of the reflection subcoset <code>torus(W,i)</code> of <code>W</code> determined by the trivial subgroup and a representative of the <code>i</code>-th conjugacy class.</p><pre><code class="language-julia-repr hljs">julia&gt; W=complex_reflection_group(4)

julia&gt; torus_order.(Ref(W),1:nconjugacy_classes(W),Pol(:q))
7-element Vector{Pol{Cyc{Int64}}}:
 q²-2q+1
 q²+2q+1
 q²+1
 q²-ζ₃q+ζ₃²
 q²+ζ₃q+ζ₃²
 q²+ζ₃²q+ζ₃
 q²-ζ₃²q+ζ₃</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1155-L1177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection_subgroup-Tuple{PRG, AbstractVector}" href="#Gapjm.PermRoot.reflection_subgroup-Tuple{PRG, AbstractVector}"><code>Gapjm.PermRoot.reflection_subgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflection_subgroup(W,r)</code></p><p>returns  the  reflection  subgroup  of  the  complex  reflection  group <code>W</code> generated by <code>refls(W,r)</code>.</p><p>A  reflection subgroup <code>H</code> of  <code>W</code> is a permutation  subgroup with the same additional  information as  <code>W</code>, and  some new  one added which express the relationship with the parent <code>W</code>:</p><p><code>inclusion(H)</code>:   the indices of the roots of <code>H</code> in the roots of <code>W</code></p><p><code>parent(H)</code>:  is set to <code>W</code>.</p><p><code>restriction(H)</code>:  a list of length <code>length(roots(W))</code> with non-zero entries    in positions <code>inclusion(H)</code> bound to <code>eachindex(roots(H))</code>.</p><p>A  reflection  group  which  is  not  a  subgroup  actually  also  has this information, set to the trivial values: <code>inclusion(W)==restriction(W)==eachindex(roots(W))</code>,   and   <code>parent()==W</code>. This  allows a lot of code to be  written in the same way for parent groups or reflection subgroups.</p><p><code>reflection_subgroup(R)</code> where <code>R</code> is itself a reflection subgroup returns a  reflection subgroup of the parent of <code>R</code>.</p><pre><code class="language-julia_repl hljs">julia&gt; W=coxgroup(:F,4)
F₄

julia&gt; H=reflection_subgroup(W,[1,2,11,20])
F₄₍₉‚₂‚₁‚₁₆₎=D₄₍₃₂₁₄₎

julia&gt; [restriction(H)]
1-element Vector{Vector{Int64}}:
 [1, 2, 0, 0, 5, 0, 0, 0, 3, 0  …  0, 16, 0, 19, 0, 21, 0, 22, 23, 24]

julia&gt; reflection_subgroup(H,[1,2,3])
F₄₍₉₁₂₎=A₃₍₃₁₂₎Φ₁</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1815-L1855">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.inclusion" href="#Gapjm.PermRoot.inclusion"><code>Gapjm.PermRoot.inclusion</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>inclusion(W::PermRootGroup)</code></p><p>the indices of the roots of <code>W</code> in the roots of <code>parent(W)</code>.</p><p><code>inclusion(W::PermRootGroup,i::Integer)</code> <code>inclusion(W::PermRootGroup,v::AbstractVector{&lt;:Integer})</code></p><p>same as <code>inclusion(W)[i]</code> or <code>inclusion(W)[v]</code> (but more efficient).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L500-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.restriction" href="#Gapjm.PermRoot.restriction"><code>Gapjm.PermRoot.restriction</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>restriction(W::PermRootGroup)</code></p><p>A  list for each root of <code>parent(W)</code>, which  holds <code>0</code> if the root is not a root of <code>W</code> and <code>i</code> if the root is the <code>i</code>-th root of <code>W</code>.</p><p><code>restriction(W::PermRootGroup,i::Integer)</code> <code>restriction(W::PermRootGroup,v::AbstractVector{&lt;:Integer})</code></p><p>same as <code>restriction(W)[i]</code> or <code>restriction(W)[v]</code> (but more efficient).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1779-L1789">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.standard_parabolic-Tuple{PermRootGroup, Any}" href="#Gapjm.Weyl.standard_parabolic-Tuple{PermRootGroup, Any}"><code>Gapjm.Weyl.standard_parabolic</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>standard_parabolic(W::PermRootGroup, H)</code></p><p>Let  <code>H</code> be a  reflection subgroup of  <code>W</code>. Returns an  element <code>w∈ W</code> such that  <code>H^w</code> is a standard  parabolic subgroup of <code>W</code>  (or nothing if <code>H</code> is not parabolic or not conjugate to a standard parabolic).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/Eigenspaces.jl#L378-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.parabolic_reps" href="#Gapjm.PermRoot.parabolic_reps"><code>Gapjm.PermRoot.parabolic_reps</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>parabolic_reps(W)</code></p><p>For  a Coxeter group or finite complex reflection group <code>W</code>, returns a list of  indices  of  roots  of  <code>W</code>  describing  representatives  of  orbits of parabolic  subgroups  under  conjugation  by  <code>W</code>. For Coxeter groups, each orbit  has a representative which is a standard parabolic subgroup, that is whose indices is a subset of <code>eachindex(gens(W))</code>. This may not be the case in general.</p><pre><code class="language-julia-repl hljs">julia&gt; parabolic_reps(coxgroup(:A,4))
7-element Vector{Vector{Int64}}:
 []
 [1]
 [1, 2]
 [1, 3]
 [1, 2, 3]
 [1, 2, 4]
 [1, 2, 3, 4]

julia&gt; parabolic_reps(complex_reflection_group(3,3,3))
7-element Vector{Vector{Int64}}:
 []
 [1]
 [1, 2]
 [1, 3]
 [1, 9]
 [2, 3]
 [1, 2, 3]</code></pre><p><code>parabolic_reps(W,r)</code></p><p>If  a second  argument <code>r</code>  is given,  returns only  representatives of the parabolic subgroups of semisimple rank <code>r</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; parabolic_reps(coxgroup(:A,4),2)
2-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]

julia&gt; parabolic_reps(complex_reflection_group(3,3,3),2)
4-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]
 [1, 9]
 [2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1359-L1408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.parabolic_closure" href="#Gapjm.PermRoot.parabolic_closure"><code>Gapjm.PermRoot.parabolic_closure</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>parabolic_closure(W,I)</code></p><p><code>I</code>  should be a  list of indices  of reflections of  <code>W</code>. Returns <code>J</code> such that  <code>reflection_subgroup(W,J)</code> is the smallest  parabolic subgroup of <code>W</code> containing <code>reflection_subgroup(W,I)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(7)
G₇

julia&gt; parabolic_closure(W,[1])
1-element Vector{Int64}:
 1

julia&gt; parabolic_closure(W,[1,2])
3-element Vector{Int64}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1588-L1609">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.isparabolic" href="#Gapjm.PermRoot.isparabolic"><code>Gapjm.PermRoot.isparabolic</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>isparabolic(W)</code></p><p>whether the reflection subgroup <code>W</code> is a parabolic subgroup of <code>parent(W)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(7)
G₇

julia&gt; isparabolic(reflection_subgroup(W,[1,2]))
false

julia&gt; isparabolic(reflection_subgroup(W,[1]))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a139d5bbdd2919d0240f3c004011c268993d460a/src/PermRoot.jl#L1563-L1577">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="presentations.html">« Presentations</a><a class="docs-footer-nextpage" href="coxgroups.html">Coxeter groups »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 18 October 2023 22:39">Wednesday 18 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
