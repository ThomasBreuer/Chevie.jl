<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finite reflection groups · Gapjm.jl documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Gapjm.jl documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Gapjm</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Infrastructure</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="cycpol.html">Cyclotomic polynomials</a></li><li><a class="tocitem" href="posets.html">Posets</a></li><li><a class="tocitem" href="sperm.html">Signed permutations</a></li><li><a class="tocitem" href="glinearalgebra.html">Linear algebra on any field/ring</a></li><li><a class="tocitem" href="matint.html">Integral matrices and lattices</a></li><li><a class="tocitem" href="ffe.html">Finite fields</a></li><li><a class="tocitem" href="presentations.html">Presentations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Reflection groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="coxgroups.html">Coxeter groups</a></li><li><a class="tocitem" href="weyl.html">Finite Coxeter groups and Weyl groups</a></li><li class="is-active"><a class="tocitem" href="permroot.html">Finite reflection groups</a></li><li><a class="tocitem" href="chars.html">Classes/characters of reflection groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Hecke algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="hecke.html">Hecke algebras</a></li><li><a class="tocitem" href="kl.html">Kazhdan-Lusztig polynomials and bases</a></li></ul></li><li><a class="tocitem" href="garside.html">Garside monoids and groups, braids.</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reductive groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="semisimple.html">Reductive groups, semisimple elements</a></li><li><a class="tocitem" href="cosets.html">Reflection cosets</a></li><li><a class="tocitem" href="sscoset.html">Non-connected reductive groups</a></li><li><a class="tocitem" href="uch.html">Unipotent characters</a></li></ul></li><li><a class="tocitem" href="eigen.html">Eigenspaces</a></li><li><a class="tocitem" href="dseries.html">d-Harish-Chandra series</a></li><li><a class="tocitem" href="symbols.html">Symbols</a></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Unipotent elements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ucl.html">Unipotent classes of reductive groups</a></li><li><a class="tocitem" href="urad.html">Unipotent Elements</a></li></ul></li><li><a class="tocitem" href="ct.html">Classtypes</a></li><li><a class="tocitem" href="gendec.html">Decomposition Matrices</a></li><li><a class="tocitem" href="dict.html">Dictionary from GAP3/Chevie</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reflection groups</a></li><li class="is-active"><a href="permroot.html">Finite reflection groups</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="permroot.html">Finite reflection groups</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmichel7/Gapjm.jl/blob/master/docs/src/permroot.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Finite-reflection-groups"><a class="docs-heading-anchor" href="#Finite-reflection-groups">Finite reflection groups</a><a id="Finite-reflection-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-reflection-groups" title="Permalink"></a></h1><ul><li><a href="permroot.html#Gapjm.PermRoot.Diagram"><code>Gapjm.PermRoot.Diagram</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.PRG"><code>Gapjm.PermRoot.PRG</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.PermRootGroup"><code>Gapjm.PermRoot.PermRootGroup</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.PermX"><code>Gapjm.PermRoot.PermX</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.bipartite_decomposition"><code>Gapjm.PermRoot.bipartite_decomposition</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.cartan-Tuple{PermRootGroup}"><code>Gapjm.PermRoot.cartan</code></a></li><li><a href="coxgroups.html#Gapjm.PermRoot.cartan-Tuple{AbstractMatrix}"><code>Gapjm.PermRoot.cartan</code></a></li><li><a href="weyl.html#Gapjm.PermRoot.cartan-Tuple{Symbol, Integer, Integer}"><code>Gapjm.PermRoot.cartan</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.cartan-Tuple{PermRootGroup, Any, Any}"><code>Gapjm.PermRoot.cartan</code></a></li><li><a href="coxgroups.html#Gapjm.PermRoot.cartan-Tuple{CoxSym}"><code>Gapjm.PermRoot.cartan</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.coroot"><code>Gapjm.PermRoot.coroot</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.coroots"><code>Gapjm.PermRoot.coroots</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.generic_order"><code>Gapjm.PermRoot.generic_order</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.inclusion"><code>Gapjm.PermRoot.inclusion</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.invariant_form"><code>Gapjm.PermRoot.invariant_form</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.invariants"><code>Gapjm.PermRoot.invariants</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.isparabolic"><code>Gapjm.PermRoot.isparabolic</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.nhyp"><code>Gapjm.PermRoot.nhyp</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.nref"><code>Gapjm.PermRoot.nref</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.parabolic_closure"><code>Gapjm.PermRoot.parabolic_closure</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.parabolic_reps"><code>Gapjm.PermRoot.parabolic_reps</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.rank"><code>Gapjm.PermRoot.rank</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.reflchar"><code>Gapjm.PermRoot.reflchar</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.reflection"><code>Gapjm.PermRoot.reflection</code></a></li><li><a href="sperm.html#Gapjm.PermRoot.reflection_subgroup-Tuple{CoxHyperoctaedral, AbstractVector{Int64}}"><code>Gapjm.PermRoot.reflection_subgroup</code></a></li><li><a href="weyl.html#Gapjm.PermRoot.reflection_subgroup-Tuple{Gapjm.Weyl.FCG, AbstractVector{&lt;:Integer}}"><code>Gapjm.PermRoot.reflection_subgroup</code></a></li><li><a href="coxgroups.html#Gapjm.PermRoot.reflection_subgroup-Tuple{CoxSym, AbstractVector{Int64}}"><code>Gapjm.PermRoot.reflection_subgroup</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.reflectionmat"><code>Gapjm.PermRoot.reflectionmat</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.refleigen"><code>Gapjm.PermRoot.refleigen</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.reflrep-Tuple{PRG, Integer}"><code>Gapjm.PermRoot.reflrep</code></a></li><li><a href="hecke.html#Gapjm.PermRoot.reflrep-Tuple{HeckeAlgebra}"><code>Gapjm.PermRoot.reflrep</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.reflrep-Tuple{PRG}"><code>Gapjm.PermRoot.reflrep</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.reflrep-Tuple{PermRootGroup, Any}"><code>Gapjm.PermRoot.reflrep</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.refls"><code>Gapjm.PermRoot.refls</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.restriction"><code>Gapjm.PermRoot.restriction</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.roots-Tuple{PRG}"><code>Gapjm.PermRoot.roots</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.roots-Tuple{PRG, Any}"><code>Gapjm.PermRoot.roots</code></a></li><li><a href="weyl.html#Gapjm.PermRoot.roots-Tuple{AbstractMatrix}"><code>Gapjm.PermRoot.roots</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.semisimplerank"><code>Gapjm.PermRoot.semisimplerank</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.simple_conjugating"><code>Gapjm.PermRoot.simple_conjugating</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.simple_reps"><code>Gapjm.PermRoot.simple_reps</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.simplecoroots"><code>Gapjm.PermRoot.simplecoroots</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.simpleroots"><code>Gapjm.PermRoot.simpleroots</code></a></li><li><a href="permroot.html#Gapjm.PermRoot.torus_order"><code>Gapjm.PermRoot.torus_order</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot" href="#Gapjm.PermRoot"><code>Gapjm.PermRoot</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Let  <code>V</code>  be  a  vector  space  over  a subfield <code>K</code> of the complex numbers (usually  in Julia elements  of <code>K</code> are  <code>Rational</code>s or <code>Cyc</code>s). A <em>complex reflection</em>  is an element <code>s∈ GL(V)</code> of finite order whose fixed point set is  an hyperplane, the <em>reflecting hyperplane</em> <code>Hₛ</code>  of <code>s</code> (we will in the following   abbreviate  &quot;complex  reflection&quot;   to  <em>reflection</em>;  in  some literature   &quot;reflection&quot;  is  reserved  for  the  order  2  and  otherwise <em>pseudo-reflection</em> is used). Thus a reflection <code>s</code> has a unique eigenvalue <code>ζₛ</code>  not equal to <code>1</code>, which  is a root of unity  (if <code>K</code> is a subfield of the  real numbers, <code>ζₛ</code> is necessarily equal  to <code>-1</code>). A reflection <code>s</code> is determined  by a vector <code>r∈ V</code> (a <em>root</em>)  and a linear form <code>rᵛ</code> on <code>V</code> (a <em>coroot</em>)  such that  <code>rᵛ(r)=1-ζ</code>. Then  <code>s</code> is  the map  on <code>V</code> defined by <code>s(x)=x-rᵛ(x)r</code>.  The root and the coroot for  <code>s</code> are unique up to scaling the root and inversely scaling the coroot.</p><p>A  complex reflection group <code>W</code> is a  group generated by a finite number of complex reflections.</p><p>Since  when <code>W</code> contains  a reflection <code>s</code>  it contains its  powers, <code>W</code> is always  generated by reflections <code>s</code> such  that <code>ζₛ==E(d)</code> where <code>d</code> is the order  of <code>s</code>; we may in addition assume that <code>s</code> is not a power of another reflection   with  larger  order  <code>d</code>.  Such   a  reflection  is  called  a <em>distinguished</em>  reflection  of  <code>W</code>;  it  is  a canonical generator of the cyclic  subgroup of  <code>W</code> centralizing  <code>Hₛ</code>. The  generators of the complex reflection  groups we construct are  always distinguished reflections (in a real reflection group all reflections are distinguished).</p><p>We deal in this module with finite complex reflection groups. Note that <code>W</code> does  <em>not</em> need to be a matrix group. But by definition <code>W</code> has a faithful representation (the <em>reflection representation</em>) where <code>reflections(W)</code> act as  reflections (see <a href="hecke.html#Gapjm.PermRoot.reflrep-Tuple{HeckeAlgebra}"><code>reflrep</code></a>). Note that the set of distinguished reflections are in bijection with the reflecting hyperplanes.</p><p>It  is much  more efficient  to compute  with permutation  groups than with matrix groups, when possible; thus the efficient representation that we use for  computing with <code>W</code>, is a permutation representation on a <code>W</code>-invariant set  of root and coroot vectors for reflections  of <code>W</code>; that is, a set <code>R</code> of  pairs <code>(r,rᵛ)∈ V×Vᵛ</code> invariant by  <code>W</code> and such that each distinguished reflection in <code>W</code> is defined by some pair in <code>R</code> (see <a href="permroot.html#Gapjm.PermRoot.reflection"><code>reflection</code></a>). Trying  to find a <code>W</code>-invariant set implies that there may be several pairs for  each reflection,  differing by  roots of  unity. This  generalizes the usual  construction  for  Coxeter  groups  (the  case <code>K=ℝ</code>) where to each reflection  of <code>W</code> is associated two roots,  a positive and a negative one. For irreducible complex reflection groups, there are at least as many roots on a given line as the order of the center of <code>W</code>.</p><p>For these groups the following methods are defined:</p><p><code>gens(W)</code>: the (distinguished) reflections which generate <code>W</code>, given as permutations of the roots.</p><p><code>refls(W)</code>: the list of distinguished reflections of <code>W</code>, which starts with gens(W).  Actually this list is of same length as the roots, and its <code>i</code>-th element is the distinguished reflection for the <code>i</code>-th root.</p><p>The  finite  irreducible  complex  reflection  groups  have been completely classified  by  Shepard  and  Todd.  They  consist  of  one infinite family <code>G(de,e,r)</code> depending on 3 parameters, and 34 exceptional groups which have been given by Shephard and Todd names which range from <code>G₄</code> to <code>G₃₇</code>. These exceptional   groups   contain   the   exceptional  Coxeter  groups,  e.g., <code>coxgroup(:E,8)</code> is the same as <code>G₃₇</code>.</p><p>We provide functions to build any finite reflection group, either by giving a  list  of  roots  and  coroots  defining  the generating reflections (see <a href="permroot.html#Gapjm.PermRoot.PRG"><code>PRG</code></a>), or in terms of the classification (see <a href="permroot.html#Gapjm.ComplexR.complex_reflection_group"><code>complex_reflection_group</code></a>).  The output is  a permutation group on set  of roots . In  the context e.g. of  Weyl groups, one wants to describe the particular root system chosen in term of the traditional classification of  crystallographic root systems.  This is done  via calls to the function <a href="weyl.html#Gapjm.CoxGroups.coxgroup"><code>coxgroup</code></a>  (see  the  module  <a href="weyl.html#Gapjm.Weyl"><code>Weyl</code></a>).  There is not yet a general  theory on  how to  construct a  nice set  of roots  for a non-real reflection  group;  the  roots  chosen  here  where  obtained case-by-case; however, they satisfy several important properties:</p><ul><li><p>The generating reflections  satisfy braid relations  which present the braid group associated to <code>W</code> (see <a href="permroot.html#Gapjm.PermRoot.Diagram"><code>Diagram</code></a>).</p></li><li><p>The <em>field  of definition</em>  of <code>W</code>  is the  field <code>K</code> generated by the traces  of the elements of <code>W</code> acting on  <code>V</code>. It is a theorem that <code>W</code> may be realized as a reflection group over <code>K</code>.</p></li></ul><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4)
G₄

julia&gt; gens(W) # as a permutation of the 24 roots
2-element Vector{Perm{Int16}}:
 (1,3,9)(2,4,7)(5,10,18)(6,11,16)(8,12,19)(13,15,20)(14,17,21)(22,23,24)
 (1,5,13)(2,6,10)(3,7,14)(4,8,15)(9,16,22)(11,12,17)(18,19,23)(20,21,24)

julia&gt; length(unique(refls(W)))
4

julia&gt; length(refls(W)) # 24=4*(number of roots of unity in ℚ (ζ₃))
24

julia&gt; reflrep(W) # the reflection representations
2-element Vector{Matrix{Cyc{Rational{Int64}}}}:
 [1 0; 0 ζ₃]
 [√-3/3 -ζ₃²√-3/3; (-3+√-3)/3 -ζ₃√-3/3]

julia&gt; braid_relations(W) # the braid relation between generators
1-element Vector{Vector{Vector{Int64}}}:
 [[1, 2, 1], [2, 1, 2]]

julia&gt; Diagram(W) # the same in pictures
③ ——③ G₄
1   2</code></pre><p>For  almost  all  irreducible  complex  reflection  groups,  the generating matrices  for <code>W</code>  we give  have coefficients  in <code>K</code>.  Further, the set of matrices  for all  elements of  <code>W</code> is  globally invariant under the Galois group  of <code>K/ℚ</code>, thus the Galois  action induces automorphisms of <code>W</code>. The exceptions  are <code>G₂₂, G₂₇</code> where the matrices are in a degree two extension of   <code>K</code>  (this  is  needed  to   have  a  globally  invariant  model,  see <a href="biblio.htm#MarinMichel10">MarinMichel2010</a>)  and some  dihedral groups, as well  as  <code>H₃</code>  and  <code>H₄</code>,  where  the  matrices  given  (the usual Coxeter reflection representation over <code>K</code>) are not globally invariant (but one can get invariant ones by <code>chevieget(:H4,:InvariantModel)</code>).</p><p>It  turns out that all representations of <code>W</code> are defined over the field of definition <code>K</code> (see. <a href="biblio.htm#Ben76">Benard1976</a> and D.~Bessis&#39; thesis). This  has been known for a  long time in the case  <code>K=ℚ</code>, the case of Weyl groups, which have integral representations.</p><ul><li>The Cartan matrix (see <a href="coxgroups.html#Gapjm.PermRoot.cartan-Tuple{AbstractMatrix}"><code>cartan</code></a>) for the generating roots (those  which  correspond to the generating reflections) has entries in the ring  <code>ℤₖ</code>  of  integers  of  <code>K</code>,  and  the  roots (resp. coroots) are linear  combination  with coefficients in <code>ℤₖ</code>  of a linearly independent subset  of them.</li></ul><p>Some additional methods for finite reflection groups:</p><p><code>roots(W)</code>:  a set  of complex  roots in  <code>V</code>, given  as a list of vectors,     on which <code>W</code> has a faithful permutation representation.</p><p><code>simpleroots(W)</code>:  the generating roots as a matrix.</p><p><code>simplecoroots(W)</code>:  the generating coroots as a matrix.</p><pre><code class="language-julia-repl hljs">julia&gt; cartan(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
 ζ₃²√-3     ζ₃²
   -ζ₃²  ζ₃²√-3

julia&gt; simpleroots(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
    0  ζ₃²√-3
 2ζ₃²     ζ₃²

julia&gt; simplecoroots(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
     0      1
 √-3/3  √-3/3</code></pre><p>Let <code>SV</code> be the symmetric algebra of <code>V</code>. The invariants of <code>W</code> in <code>SV</code> are called  the  <em>polynomial  invariants</em>  of  <code>W</code>.  They  are  generated  as a polynomial   ring   by   <code>dim   V</code>  homogeneous  algebraically  independent polynomials  <code>f₁,…,f_{dim  V}</code>.  The  polynomials  <code>fᵢ</code>  are  not  uniquely determined   but  their  degrees  are.  The  <code>fᵢ</code>  are  called  the  <em>basic invariants</em>  of <code>W</code>, and their degrees the <em>reflection degrees</em> of <code>W</code>; the function <code>degrees(W)</code> returns these invariants.</p><p>Let  <code>I</code> be the  ideal generated by  the homogeneous invariants of positive degree  in <code>SV</code>. Then <code>SV/I</code> is isomorphic to the regular representation of <code>W</code>  as a  <code>W</code>-module. It  is thus  a graded  (by the degree of elements of <code>SV</code>)  version of the  regular representation of  <code>W</code>. The polynomial which gives  the graded  multiplicity of  a character  <code>φ</code> of  <code>W</code> in  the graded module   <code>SV/I</code>  is  called   the  <em>fake  degree</em>   of  <code>φ</code>.  The  function <code>fakedegrees</code> returns these polynomials.</p><pre><code class="language-julia-repl hljs">julia&gt; degrees(W)
2-element Vector{Int64}:
 4
 6

julia&gt; fakedegrees(W,Pol(:x))
7-element Vector{Pol{Int64}}:
 1
 x⁴
 x⁸
 x⁷+x⁵
 x⁵+x³
 x³+x
 x⁶+x⁴+x²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.PermRootGroup" href="#Gapjm.PermRoot.PermRootGroup"><code>Gapjm.PermRoot.PermRootGroup</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PermRootGroup</code>   is  the  type  of   reflection  group  represented  as  a permutation group on a set of roots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L570-L573">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.ComplexR.complex_reflection_group" href="#Gapjm.ComplexR.complex_reflection_group"><code>Gapjm.ComplexR.complex_reflection_group</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>complex_reflection_group(STnumber)</code> or <code>crg(STnumber)</code></p><p><code>complex_reflection_group(p,q,r)</code> or <code>crg(p,q,r)</code></p><p>The  first form of <code>complex_reflection_group</code>  returns the complex reflection group which has Shephard-Todd number <code>STnumber</code>, see <a href="biblio.htm#ST54">Shephard-Todd1954</a>.   The   second   form   returns   the imprimitive complex reflection group <code>G(p,q,r)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; G=complex_reflection_group(4)
G₄

julia&gt; degrees(G)
2-element Vector{Int64}:
 4
 6

julia&gt; length(G)
24

julia&gt; W*coxgroup(:A,2) # how to make a non-irreducible group
G₄×A₂

julia&gt; complex_reflection_group(1,1,3) # another way to enter A₂
A₂

julia&gt; crg(4) # there is also a short alias
G₄</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/ComplexR.jl#L23-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.PRG" href="#Gapjm.PermRoot.PRG"><code>Gapjm.PermRoot.PRG</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PRG(roots,coroots)</code> complex reflection group with given roots and coroots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1599-L1601">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.rank" href="#Gapjm.PermRoot.rank"><code>Gapjm.PermRoot.rank</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>rank(W::ComplexReflectionGroup)</code></p><p>This  function  returns  the  <em>rank</em>  of  a  reflection group, which is the dimension of the space where it acts.</p><pre><code class="language-julia-repl hljs">julia&gt; rank(complex_reflection_group(31))
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L722-L732">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.semisimplerank" href="#Gapjm.PermRoot.semisimplerank"><code>Gapjm.PermRoot.semisimplerank</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>semisimpleRank(W::ComplexReflectionGroup)</code></p><p>This  function returns the  <em>semisimple rank</em> of  the reflection group <code>W</code>, which  is the dimension of the space  where it effectively acts. If <code>W</code>is a reflection  group acting on <code>V</code>, and <code>V₁</code>  is the subspace generated by the <code>roots(W)</code>,  then  the  dimension  of  <code>V₁</code>  is the semisimple rank. <code>W</code> is called <em>essential</em> if <code>V₁=V</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=reflection_subgroup(coxgroup(:A,3),[1,3])
A₃₍₁₃₎=A₁×A₁Φ₁

julia&gt; semisimplerank(W)
2

julia&gt; rank(W)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1250-L1269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.nref" href="#Gapjm.PermRoot.nref"><code>Gapjm.PermRoot.nref</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>nref(W::ComplexReflectionGroup)</code> the number of reflections of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L599">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.nhyp" href="#Gapjm.PermRoot.nhyp"><code>Gapjm.PermRoot.nhyp</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>nhyp(W::ComplexReflectionGroup)</code></p><p>The number of reflecting hyperplanes of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L601-L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.roots-Tuple{PRG}" href="#Gapjm.PermRoot.roots-Tuple{PRG}"><code>Gapjm.PermRoot.roots</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>roots(W::PermRootGroup)</code> the roots of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1664">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.roots-Tuple{PRG, Any}" href="#Gapjm.PermRoot.roots-Tuple{PRG, Any}"><code>Gapjm.PermRoot.roots</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>roots(W::PermRootGroup,i)</code> same as but better than <code>roots(W)[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.coroots" href="#Gapjm.PermRoot.coroots"><code>Gapjm.PermRoot.coroots</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>coroots(W)</code> the list of coroots of <code>W</code> (listed in the same order as the roots)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1673">source</a></section><section><div><p><code>coroots(W,i)</code> same as but better than <code>coroots(W)[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.coroot" href="#Gapjm.PermRoot.coroot"><code>Gapjm.PermRoot.coroot</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>coroot(r,λ=1)</code></p><p>the coroot for an orthogonal reflection of root <code>r</code> and eigenvalue <code>λ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L203-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.inclusion" href="#Gapjm.PermRoot.inclusion"><code>Gapjm.PermRoot.inclusion</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>inclusion(W::PermRootGroup)</code>  </p><p>the indices of the roots of <code>W</code> in the roots of <code>parent(W)</code>.</p><p><code>inclusion(W::PermRootGroup,i::Integer)</code>   <code>inclusion(W::PermRootGroup,v::AbstractVector{&lt;:Integer})</code>  </p><p>same as <code>inclusion(W)[i]</code> or <code>inclusion(W)[v]</code> (but more efficient).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L587-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.restriction" href="#Gapjm.PermRoot.restriction"><code>Gapjm.PermRoot.restriction</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>restriction(W::PermRootGroup)</code>  </p><p>A  list for each  root of <code>parent(W)</code>,  which hold <code>0</code>if  the root is not a root of <code>W</code> and <code>i</code> if the root is the <code>i</code>-th root of <code>W</code>.</p><p><code>restriction(W::PermRootGroup,i::Integer)</code>   <code>restriction(W::PermRootGroup,v::AbstractVector{&lt;:Integer})</code>  </p><p>same as <code>restriction(W)[i]</code> or <code>restriction(W)[v]</code> (but more efficient).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1724-L1734">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.degrees-Tuple{PermRootGroup}" href="#Gapjm.CoxGroups.degrees-Tuple{PermRootGroup}"><code>Gapjm.CoxGroups.degrees</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>degrees(W::ComplexReflectionGroup)</code></p><p>returns  a list  holding the  degrees of  <code>W</code> as  a reflection group on the vector  space <code>V</code> on which  it acts. These are  the degrees <code>d₁,…,dₙ</code> where <code>n</code>  is the dimension of  <code>V</code> of the basic  invariants of <code>W</code> in <code>SV</code>. They reflect  various properties  of <code>W</code>;  in particular,  their product  is the cardinality of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(30)
H₄

julia&gt; degrees(W)
4-element Vector{Int64}:
  2
 12
 20
 30

julia&gt; length(W)
14400</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/ComplexR.jl#L103-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.ComplexR.codegrees" href="#Gapjm.ComplexR.codegrees"><code>Gapjm.ComplexR.codegrees</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>codegrees(W::ComplexReflectionGroup)</code></p><p>returns  the vector of codegrees of <code>W</code>  as a reflection group on the space <code>V</code>  of <code>reflrep(W)</code>.  These are  one less  than the  degrees of  the basic derivations of <code>W</code> on <code>SV⊗ V^vee</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4)
G₄

julia&gt; codegrees(W)
2-element Vector{Int64}:
 0
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/ComplexR.jl#L242-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.cartan-Tuple{PermRootGroup}" href="#Gapjm.PermRoot.cartan-Tuple{PermRootGroup}"><code>Gapjm.PermRoot.cartan</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>cartan(W::PermRootGroup)</code>    Cartan matrix of <code>W</code>.</p><p>Let  <code>s₁,…,sₙ</code> be reflections with associated  roots <code>rᵢ</code> and coroots <code>cᵢ</code>. The  matrix <code>C</code> with  entries <code>Cᵢ,ⱼ=cᵢ(rⱼ)</code> is  called a <em>Cartan matrix</em> of <code>s₁,…,sₙ</code>.  It is uniquely  determined by <code>s₁,…,sₙ</code>  up to conjugation by a diagonal matrix.</p><p>If <code>s₁,…,sₙ</code> generate a reflection group <code>W</code>, then <code>C</code> up to conjugation by a  diagonal matrix is an invariant of the reflection representation of <code>W</code>. If invertible, the matrix <code>C</code> determines this representation since then the <code>rᵢ</code>  form a basis in  which the matrix for  <code>sᵢ</code> differs from the identity only  on the  <code>i</code>-th line,  where the  corresponding line  of <code>C</code>  has been subtracted.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; cartan(W)
3×3 Matrix{Int64}:
  2  -1   0
 -1   2  -1
  0  -1   2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L687-L712">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.cartan-Tuple{PermRootGroup, Any, Any}" href="#Gapjm.PermRoot.cartan-Tuple{PermRootGroup, Any, Any}"><code>Gapjm.PermRoot.cartan</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>cartan(W::PermRootGroup,i,j)</code> the  cartan coefficient <code>cᵢ(rⱼ)</code>, the value of the linear form given by the <code>i</code>-th coroot <code>cᵢ</code> on the <code>j</code>-th root <code>rᵢ</code> of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L680-L684">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.simpleroots" href="#Gapjm.PermRoot.simpleroots"><code>Gapjm.PermRoot.simpleroots</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>simpleroots(W::ComplexReflectionGroup)</code>  the  simple  roots  of <code>W</code> (those corresponding to <code>gens(W)</code>) as a matrix (each root is a row)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1668-L1671">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.simplecoroots" href="#Gapjm.PermRoot.simplecoroots"><code>Gapjm.PermRoot.simplecoroots</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>simplecoroots(W::ComplexReflectionGroup)</code> the simple coroots of <code>W</code> (those <code>corresponding to gens(W)</code>) as a matrix (each coroot is a row)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1675-L1678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection" href="#Gapjm.PermRoot.reflection"><code>Gapjm.PermRoot.reflection</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reflection(s::Matrix [,r::AbstractVector])</code></p><p><code>s</code>  should be is a square  matrix, and if given <code>r</code>  should be a vector of length  <code>size(s,1)</code>.  The  function  determines  if  <code>s</code> is the matrix of a reflection  (resp. if <code>r</code> is  given if it is  the matrix of a reflection of root  <code>r</code>; the point of  giving <code>r</code> is to  specify exactly the desired root and  coroot, which  otherwise are  determined only  up to  a scalar and its inverse).  The function  returns <code>nothing</code>  if <code>s</code>  if is  not a reflection (resp. not a reflection with root <code>r</code>), and otherwise returns a named tuple with four fields:</p><p><code>.root</code>:   the root of the reflection <code>s</code> (equal to <code>r</code> if given)</p><p><code>.coroot</code>:  the coroot of <code>s</code></p><p><code>.eigenvalue</code>:  the non-trivial eigenvalue of <code>s</code></p><p><code>.isOrthogonal</code>: a boolean which is <code>true</code> if and only if <code>s</code> is orthogonal   with  respect to the usual scalar product  (then <code>s</code> is determined by the   root and the eigenvalue as <code>reflectionmat(.root,.eigenvalue)</code>)</p><pre><code class="language-julia-repl hljs">julia&gt; reflection([-1 0 0;1 1 0;0 0 1])
(root = [2, 0, 0], coroot = Rational{Int64}[1//1, -1//2, 0//1], eig = -1, isOrthogonal = false)

julia&gt; reflection([-1 0 0;1 1 0;0 0 1],[1,0,0])
(root = [1, 0, 0], coroot = Rational{Int64}[2//1, -1//1, 0//1], eig = -1, isOrthogonal = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L280-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflectionmat" href="#Gapjm.PermRoot.reflectionmat"><code>Gapjm.PermRoot.reflectionmat</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reflectionmat(root,  coroot)</code> the  matrix of  the reflection  with a given root and coroot.</p><p>A (complex) reflection is a finite order element <code>s</code> of <code>GL(V)</code>, the linear group of a vector space over a subfield of the complex numbers, whose fixed points  form  a  hyperplane  <code>H</code>  (the  <em>reflecting hyperplane</em> of <code>s</code>); an eigenvector  <code>r</code> for  the non-trivial  eigenvalue <code>ζ</code>  (a root of unity) is called  a <em>root</em> of <code>s</code>. If we choose  a linear form <code>rᵛ</code> defining <code>H</code> such that <code>rᵛ(r)=1-ζ</code> (a <em>coroot</em> of <code>s</code>) then <code>s</code> is given by <code>x↦ x-rᵛ(x)r</code>.</p><p>A  way  of  specifying  <code>s</code>  is  by  giving  a root and a coroot, which are uniquely determined by <code>s</code> up to multiplication of the root by a scalar and of the coroot by the inverse scalar. The function <code>reflectionmat</code> gives the matrix  of the corresponding reflection in the standard basis of <code>V</code>, where the  <code>root</code> and the <code>coroot</code> are vectors given in the standard bases of <code>V</code> and <code>Vᵛ</code>, so the pairing <code>rᵛ(r)</code> is obtained as <code>transpose(root)*coroot</code>.</p><pre><code class="nohighlight hljs">julia&gt; r=reflectionmat([1,0,0],[2,-1,0])
3×3 Matrix{Int64}:
 -1  0  0
  1  1  0
  0  0  1

julia&gt; r==reflrep(coxgroup(:A,3),1)
true

julia&gt; r*[2,-1,0]
3-element Vector{Int64}:
 -2
  1
  0

julia&gt; [1 0 0]*r
1×3 Matrix{Int64}:
 -1  0  0</code></pre><p>As  we see in the last lines, in  Julia a matrix operates from the right on the  vector space <code>V</code>  of row vectors  and from the  left on the dual space <code>Vᵛ</code> of column vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L213-L254">source</a></section><section><div><p><code>reflectionmat(r, ζ=-1)</code></p><p>returns the matrix of the complex reflection determined by the root <code>r</code> and the  eigenvalue <code>ζ</code> when the  vector space and its  dual are identified via the  scalar product <code>&lt;x,y&gt;=transpose(x)*y</code>; the coroot <code>rᵛ</code> is then equal to the linear form <code>x-&gt;(1-ζ)&lt;x,r&gt;/&lt;r,r&gt;</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; reflectionmat([1,0,-E(3,2)])
3×3 Matrix{Cyc{Rational{Int64}}}:
  0  0  ζ₃²
  0  1    0
 ζ₃  0    0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L260-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.refls" href="#Gapjm.PermRoot.refls"><code>Gapjm.PermRoot.refls</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>refls(W::ComplexReflectionGroup)</code></p><p>a  list of same length as  <code>W.roots</code> giving the corresponding distinguished reflections. In particular this list is much longer than <code>unique(refls(W))</code> since in general there are several roots corresponding to a reflection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L644-L650">source</a></section><section><div><p><code>refls(W,i)</code></p><p>reflection for <code>i</code>-th root(s) of <code>W</code> (<code>i</code> can be an index or a vector of indices)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L653-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PermGroups.Perms.reflength-Tuple{PermRootGroup, Perm}" href="#PermGroups.Perms.reflength-Tuple{PermRootGroup, Perm}"><code>PermGroups.Perms.reflength</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflength(W::PermRootGroup,w::Perm)</code></p><p>This  function returns the  number of eigenvalues  of <code>w</code> in the reflection representation  which are not equal to 1.  For a finite Coxeter group, this is  equal to the  reflection length of  <code>w</code>, that is  the minimum number of reflections  of which  <code>w</code> is  a product.  This also  holds in general in a well-generated  complex reflection group  if <code>w</code> divides  a Coxeter element for the reflection length.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,4)
A₄

julia&gt; reflength(W,longest(W))
2

julia&gt; reflength(W,W(1,2,3,4))
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1159-L1179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.simple_conjugating" href="#Gapjm.PermRoot.simple_conjugating"><code>Gapjm.PermRoot.simple_conjugating</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>simple_conjugating(W)</code></p><p>For each index <code>i</code> of a root, an element <code>w∈ W</code> such that  <code>restriction(W,inclusion(W,simple_reps(W,i))^w)==i</code>  (or <code>action(W,simple_reps(W,i))==i</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L661-L667">source</a></section><section><div><p><code>simple_conjugating(W,i)</code></p><p>an element <code>w∈ W</code> such that <code>restriction(W,inclusion(W,simple_reps(W,i))^w)==i</code>  (or <code>action(W,simple_reps(W,i))==i</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L672-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.simple_reps" href="#Gapjm.PermRoot.simple_reps"><code>Gapjm.PermRoot.simple_reps</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>simple_reps(W)</code></p><p>for each root, the index of the first simple root conjugate to it</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L612-L616">source</a></section><section><div><p><code>simple_reps(W,i)</code></p><p>the  smallest index  of a root in the same <code>W</code>-orbit as the <code>i</code>-th root.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L637-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.Diagram" href="#Gapjm.PermRoot.Diagram"><code>Gapjm.PermRoot.Diagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Diagram(W)</code> diagram of finite reflection group <code>W</code></p><pre><code class="language-julia-repl hljs">julia&gt; Diagram(crg(33))
G₃₃     3
       /^1---2---4---5 423423==342342</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L576-L583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.ComplexR.hyperplane_orbits" href="#Gapjm.ComplexR.hyperplane_orbits"><code>Gapjm.ComplexR.hyperplane_orbits</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>hyperplane_orbits(W)</code></p><p>returns  a  list  of  named  tuples,  one  for each hyperplane orbit of the reflection  group <code>W</code>. If <code>o</code> is the named tuple for such an orbit, and <code>s</code> is  the first  element of  <code>gens(W)</code> whose  hyperplane is  in the orbit, it contains the following fields</p><p><code>o.s</code>:     index of <code>s</code> in <code>gens(W)</code></p><p><code>o.cl_s</code>:  <code>map(i-&gt;position_class(W,s^i),1:o.order-1)</code></p><p><code>o.order</code>: order of s</p><p><code>.N_s</code>:    Size of orbit</p><p><code>.det_s</code>:  for i in <code>1:o.order-1</code>, position in CharTable of <code>(det_s)^i</code></p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; hyperplane_orbits(W)
2-element Vector{NamedTuple{(:s, :cl_s, :order, :N_s, :det_s), Tuple{Int64, Vector{Int64}, Int64, Int64, Vector{Int64}}}}:
 (s = 1, cl_s = [2], order = 2, N_s = 2, det_s = [5])
 (s = 2, cl_s = [4], order = 2, N_s = 2, det_s = [1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/ComplexR.jl#L286-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.ComplexR.Reflection" href="#Gapjm.ComplexR.Reflection"><code>Gapjm.ComplexR.Reflection</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Reflection</code>  is a <code>struct</code>  representing a reflection  <code>r</code> in a reflection group <code>W</code>. The fields are <code>W</code>, the index of a root for <code>r</code>, the non-trivial eigenvalue of <code>r</code>, and a word for <code>r</code> in the generating reflections of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; r=reflections(crg(8))[2]
Reflection(G₈,1,-1)

julia&gt; r.eigen # the non-trival eigenvalue, as a Root1
Root1: -1

julia&gt; root(r)
2-element Vector{Cyc{Rational{Int64}}}:
  0
 ζ₄

julia&gt; coroot(r)
2-element Vector{Cyc{Rational{Int64}}}:
    0
 -2ζ₄

julia&gt; Matrix(r)
2×2 Matrix{Cyc{Rational{Int64}}}:
 1   0
 0  -1

julia&gt; isdistinguished(r) # r is not distinguished
false

julia&gt; exponent(r) # which power of a distinguished reflection it is
2

julia&gt; Perm(r)
(1,8)(2,9)(3,16)(4,15)(5,17)(6,18)(7,19)(10,22)(11,21)(12,23)

julia&gt; hyperplane_orbit(r) # r is in the first hyperplane orbit
1

julia&gt; position_class(r) # the index of the conjugacy class of r in W 
15

julia&gt; word(r) # a word in the generators for r
2-element Vector{Int64}:
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/ComplexR.jl#L358-L404">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.ComplexR.reflections" href="#Gapjm.ComplexR.reflections"><code>Gapjm.ComplexR.reflections</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reflections(W)</code>  the list of  all reflections of  the reflection group <code>W</code> (including  the  non-distinguished  ones),  given as a <code>Vector{Reflection}</code> (see <a href="permroot.html#Gapjm.ComplexR.Reflection"><code>Reflection</code></a>).</p><pre><code class="language-julia-repl hljs">julia&gt; W=crg(4)
G₄

julia&gt; reflections(W)
8-element Vector{Reflection{PRG{Cyc{Rational{Int64}}, Int16}}}:
 Reflection(G₄,1,ζ₃)
 Reflection(G₄,1,ζ₃²)
 Reflection(G₄,2,ζ₃)
 Reflection(G₄,2,ζ₃²)
 Reflection(G₄,4,ζ₃)
 Reflection(G₄,4,ζ₃²)
 Reflection(G₄,5,ζ₃)
 Reflection(G₄,5,ζ₃²)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/ComplexR.jl#L453-L473">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.braid_relations" href="#Gapjm.CoxGroups.braid_relations"><code>Gapjm.CoxGroups.braid_relations</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>braid_relations(W)</code></p><p>this  function returns the  relations which present  the braid group of the reflection group <code>W</code>. These are homogeneous (both sides of the same length) relations  between generators in bijection  with the generating reflections of  <code>W</code>. A presentation  of <code>W</code> is  obtained by adding relations specifying the order of the generators.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(29)
G₂₉

julia&gt; braid_relations(W)
7-element Vector{Vector{Vector{Int64}}}:
 [[1, 2, 1], [2, 1, 2]]
 [[2, 4, 2], [4, 2, 4]]
 [[3, 4, 3], [4, 3, 4]]
 [[2, 3, 2, 3], [3, 2, 3, 2]]
 [[1, 3], [3, 1]]
 [[1, 4], [4, 1]]
 [[4, 3, 2, 4, 3, 2], [3, 2, 4, 3, 2, 4]]</code></pre><p>each  relation  is  represented  as  a  pair  of lists, specifying that the product  of the  generators according  to the  indices on  the left side is equal  to the product according to the  indices on the right side. See also <code>Diagram</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/CoxGroups.jl#L764-L792">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflrep-Tuple{PermRootGroup, Any}" href="#Gapjm.PermRoot.reflrep-Tuple{PermRootGroup, Any}"><code>Gapjm.PermRoot.reflrep</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflrep(W,w)</code>  Reflection representation</p><p>Let  <code>W</code> be a  finite reflection group  on the space  <code>V</code> and let  <code>w</code> be a permutation  of the roots of <code>W</code>. The function <code>reflrep</code> returns the matrix of  <code>w</code> acting on <code>V</code>  (recall that matrices operate  <em>from the right</em> on a vector  space in <code>Gapjm</code>).  This is the  linear transformation of <code>V</code> which acts  trivially on the orthogonal of the coroots and has same effect as <code>w</code> on the simple roots. The function makes sense more generally for an element of the normalizer of <code>W</code> in the whole permutation group of the roots.</p><pre><code class="language-julia-repl hljs">julia&gt; W=reflection_subgroup(rootdatum(&quot;E7sc&quot;),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia&gt; reflrep(W,longest(W))
7×7 Matrix{Int64}:
  0   0   0   0   0  -1  2
  0  -1   0   0   0   0  2
  0   0   0   0  -1   0  3
  0   0   0  -1   0   0  4
  0   0  -1   0   0   0  3
 -1   0   0   0   0   0  2
  0   0   0   0   0   0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1500-L1525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflrep-Tuple{PRG}" href="#Gapjm.PermRoot.reflrep-Tuple{PRG}"><code>Gapjm.PermRoot.reflrep</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflrep(W::ComplexReflectionGroup)</code> returns the list of <code>reflrep(W,x)</code> for <code>x</code> in <code>gens(W)</code>, that is the generators of <code>W</code> as matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1705-L1708">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflrep-Tuple{PRG, Integer}" href="#Gapjm.PermRoot.reflrep-Tuple{PRG, Integer}"><code>Gapjm.PermRoot.reflrep</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflrep(W,i)</code> same as but better than <code>reflrep(W,W(i))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1710">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.refleigen" href="#Gapjm.PermRoot.refleigen"><code>Gapjm.PermRoot.refleigen</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>refleigen(W)</code> Reflection eigenvalues</p><p>Let  <code>W</code>  be  a  reflection  group  on the vector space <code>V</code>. <code>refleigen(W)</code> returns   for  each  conjugacy   class  representative  <code>x</code>   of  <code>W</code>  (see <code>classreps</code>) the eigenvalues of <code>x</code> on <code>V</code>, as a list of <code>Root1</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; refleigen(coxgroup(:B,2))
5-element Vector{Vector{Root1}}:
 [1, 1]
 [-1, 1]
 [-1, -1]
 [-1, 1]
 [ζ₄³, ζ₄]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1112-L1128">source</a></section><section><div><p><code>refleigen(W,i)</code> faster than <code>refleigen(W)[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.bipartite_decomposition" href="#Gapjm.PermRoot.bipartite_decomposition"><code>Gapjm.PermRoot.bipartite_decomposition</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>bipartite_decomposition(W)</code></p><p>Returns  a bipartite decomposition <code>[L,R]</code> of the indices of the generators of  the  reflection  group  <code>W</code>,  such  that <code>reflection_subgroup(W,L)</code> and <code>reflection_subgroup(W,R)</code> are abelian subgroups, and <code>W=reflection_subgroup(W,   vcat(L,R))</code>.   Gives   an   error  if  no  such decomposition is possible.</p><pre><code class="language-julia-repl hljs">julia&gt; bipartite_decomposition(coxgroup(:E,8))
([1, 4, 6, 8], [3, 2, 5, 7])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1037-L1051">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Combinat.catalan-Tuple{Any, Any}" href="#Combinat.catalan-Tuple{Any, Any}"><code>Combinat.catalan</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Catalan(W::ComplexReflectionGroup)</code></p><p>returns the Catalan Number of the irreducible complex reflection group <code>W</code>. For well-generated groups, this number is equal to the number of simples in the  dual Braid  monoid. For  other groups  it was  defined by  <a href="biblio.htm#gg12">Gordon and Griffeth2012</a>.  For Weyl groups, it also counts the number of antichains of roots.</p><pre><code class="language-julia-repl hljs">julia&gt; catalan(coxgroup(:A,7))
1430</code></pre><p><code>Catalan(W,i)</code></p><p>returns   the  <code>i</code>-th  Fuss-Catalan  Number   of  the  irreducible  complex reflection  group <code>W</code>. For  well-generated groups, this  number is equal to the  number of chains  <code>s₁,…,sᵢ</code> of simples  in the dual  monoid where <code>sⱼ</code> divides  <code>sⱼ₊₁</code>. For these groups, it is also equal to <code>∏ⱼ(ih+dⱼ)/dⱼ</code> where the  product runs over the reflection degrees  of <code>W</code>, and where <code>h</code> is the Coxeter  number of <code>W</code>. For non-well generated groups, the definition is in <a href="biblio.htm#gg12">Gordon and Griffeth2012</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; catalan(complex_reflection_group(7),2)
16</code></pre><p><code>Catalan(W;q=1)</code>, resp. <code>Catalan(W,i;q=1)</code></p><p>for  <code>q</code>  a  variable  (like  <code>Pol()</code>  or an &#39;Mvp&#39;) returns the <code>q</code>-Catalan number  (resp.  the  <code>i</code>-th  <code>q</code>-Fuss  Catalan  number)  of  <code>W</code>. Again the definitions in general are in <a href="biblio.htm#gg12">Gordon and Griffeth2012</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; catalan(complex_reflection_group(7),2;q=Pol())
Pol{Int64}: q⁷²+2q⁶⁰+3q⁴⁸+4q³⁶+3q²⁴+2q¹²+1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1816-L1855">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.PermX" href="#Gapjm.PermRoot.PermX"><code>Gapjm.PermRoot.PermX</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>PermX(W::ComplexReflectionGroup,M::AbstractMatrix)</code></p><p>Let <code>M</code> be an invertible linear map of the reflection representation of <code>W</code> which  preserves the set  of roots of  <code>parent(W)</code>, and normalizes <code>W</code> (for the  action of  matrices on  the right).  <code>PermX</code> returns the corresponding permutation  of the roots of <code>parent(W)</code>;  it returns <code>nothing</code> if <code>M</code> does not normalize the set of roots of <code>parent(W)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=reflection_subgroup(rootdatum(&quot;E7sc&quot;),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia&gt; PermX(W,reflrep(W,longest(W)))==longest(W)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1306-L1322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflchar" href="#Gapjm.PermRoot.reflchar"><code>Gapjm.PermRoot.reflchar</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reflchar(W::ComplexReflectionGroup,w)</code> Reflection character</p><p>Returns  the trace  of the  element <code>w</code>  of <code>W</code>  as an  endomorphism of the vector space <code>V</code> on which <code>W</code> acts. This is the same as <code>trace(reflrep(W,w))</code>.</p><p>julia-repl``` julia&gt; W=coxgroup(:B,3) B₃</p><p>julia&gt; reflchar(W,longest(W)) -3 julia-repl```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1076-L1090">source</a></section><section><div><p><code>reflchar(W::ComplexReflectionGroup)</code></p><p>Returns   the  reflection   character  of   <code>W</code>.  This   is  the   same  as <code>map(c-&gt;reflchar(W,c),class-reps(W))</code>.  When <code>W</code> is irreducible, it is also <code>CharTable(W).irr[charinfo(W).extRefl[2]]</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; reflchar(coxgroup(:A,3))
5-element Vector{Int64}:
  3
  1
 -1
  0
 -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1093-L1109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.invariant_form" href="#Gapjm.PermRoot.invariant_form"><code>Gapjm.PermRoot.invariant_form</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>invariant_form(W::ComplexReflectionGroup)</code></p><p>This  function returns the matrix <code>F</code>  of an Hermitian form invariant under the action of the reflection group <code>W</code>. That is, if <code>M</code> is the matrix of an element of <code>W</code>, then <code>M*F*M&#39;=F</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4)
G₄

julia&gt; invariant_form(W)
2×2 Matrix{Int64}:
 1  0
 0  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1874-L1890">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.invariants" href="#Gapjm.PermRoot.invariants"><code>Gapjm.PermRoot.invariants</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>invariants(W::ComplexReflectionGroup)</code></p><p>returns  the fundamental invariants of <code>W</code> in its reflection representation <code>V</code>.  That is, returns  a set of  algebraically independent elements of the symmetric  algebra  of  the  dual  of  <code>V</code> which generate the <code>W</code>-invariant polynomial  functions on <code>V</code>. Each such invariant function is returned as a function:  if <code>e₁,…,eₙ</code> is a basis of <code>V</code> and <code>f</code> is the function, then the value  of the polynomial  function on <code>a₁e₁+…+aₙeₙ</code>  is obtained by calling <code>f(a₁,…,aₙ)</code>. This function depends on the classification, and is dependent on the exact reflection representation of <code>W</code>. So for the moment it is only implemented   when  the  reflection   representation  for  the  irreducible components has the same Cartan matrix as the one provided by Chevie for the corresponding  irreducible  group.  The  polynomials  are invariant for the natural   action  of   the  group   elements  as   matrices;  that  is,  if <code>m==reflrep(W,w)</code>  for some  <code>w</code> in  <code>W</code>, then  an invariant  <code>f</code> satisfies <code>f(a₁,…,aₙ)=f(v₁,…,vₙ)</code>   where  <code>[v₁,…,vₙ]=[a₁,…,aₙ]×m</code>.  This  action  is implemented on <code>Mvp</code>s by the function <code>^</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; @Mvp x,y,z

julia&gt; i=invariants(W);

julia&gt; i[1](x,y)
Mvp{Int64}: -2x²+2xy-2y²

julia&gt; i[2](x,y)
Mvp{Int64}: 6x²y-6xy²

julia&gt; W=complex_reflection_group(24)
G₂₄

julia&gt; i=invariants(W)[1];

julia&gt; p=i(x,y,z)
Mvp{Rational{Int64}}: (14//1)x⁴+(-12//1)x²y²+(-42//1)x²yz+(21//2)x²z²+(18//7)y⁴+(-6//1)y³z+(-9//2)y²z²+(-21//8)z⁴

julia&gt; p^reflrep(W,1)-p
Mvp{Cyc{Rational{Int64}}}: 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1941-L1985">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.generic_order" href="#Gapjm.PermRoot.generic_order"><code>Gapjm.PermRoot.generic_order</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>generic_order(W,q)</code></p><p>returns  the &quot;compact&quot; generic order of <code>W</code> as a polynomial in <code>q</code>. This is <code>q^(Nₕ)Πᵢ(q^(dᵢ)-1)</code>  where <code>dᵢ</code>  are the  reflection degrees  and <code>Nₕ</code> the number  of reflecting hyperplanes. For a Weyl group, it is the order of the associated  semisimple  finite  reductive  group  over  the  field with <code>q</code> elements.</p><pre><code class="language-julia-repl hljs">julia&gt; @Pol q
Pol{Int64}: q

julia&gt; PermRoot.generic_order(complex_reflection_group(4),q)
Pol{Int64}: q¹⁴-q¹⁰-q⁸+q⁴</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1922-L1938">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.torus_order" href="#Gapjm.PermRoot.torus_order"><code>Gapjm.PermRoot.torus_order</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>torus_order(W::ComplexReflectionGroup,i,q)</code></p><p>returns  as a  polynomial in  <code>q</code> the  toric order  of the <code>i</code>-th conjugacy class  of <code>W</code>. This is the characteristic  polynomial of an element of that class  on  the  reflection  representation  of  <code>W</code>.  It is the same as the generic  order of the reflection subcoset <code>torus(W,i)</code> of <code>W</code> determined by the trivial subgroup and a representative of the <code>i</code>-th conjugacy class.</p><pre><code class="language-julia-repr hljs">julia&gt; W=complex_reflection_group(4)

julia&gt; torus_order.(Ref(W),1:nconjugacy_classes(W),Pol(:q))
7-element Vector{Pol{Cyc{Int64}}}:
 q²-2q+1
 q²+2q+1
 q²+1
 q²-ζ₃q+ζ₃²
 q²+ζ₃q+ζ₃²
 q²+ζ₃²q+ζ₃
 q²-ζ₃²q+ζ₃</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1184-L1206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.standard_parabolic-Tuple{PermRootGroup, Any}" href="#Gapjm.Weyl.standard_parabolic-Tuple{PermRootGroup, Any}"><code>Gapjm.Weyl.standard_parabolic</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>standard_parabolic(W::PermRootGroup, H)</code></p><p>Let  <code>H</code> be a  reflection subgroup of  <code>W</code>. Returns an  element <code>w∈ W</code> such that  <code>H^w</code> is a standard  parabolic subgroup of <code>W</code>  (or nothing if <code>H</code> is not parabolic or not conjugate to a standard parabolic).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/Eigenspaces.jl#L377-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.parabolic_reps" href="#Gapjm.PermRoot.parabolic_reps"><code>Gapjm.PermRoot.parabolic_reps</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>parabolic_reps(W)</code></p><p>Returns  a list  of indices  of roots  of <code>W</code> describing representatives of orbits of parabolic subgroups under conjugation by <code>W</code>. For Coxeter groups, each   orbit  has   a  representative   whose  indices   is  a   subset  of <code>eachindex(gens(W))</code>. This may not be the case in general.</p><pre><code class="language-julia-repl hljs">julia&gt; parabolic_reps(coxgroup(:A,4))
7-element Vector{Vector{Int64}}:
 []
 [1]
 [1, 2]
 [1, 3]
 [1, 2, 3]
 [1, 2, 4]
 [1, 2, 3, 4]

julia&gt; parabolic_reps(complex_reflection_group(3,3,3))
7-element Vector{Vector{Int64}}:
 []
 [1]
 [1, 2]
 [1, 3]
 [1, 9]
 [2, 3]
 [1, 2, 3]</code></pre><p><code>parabolic_reps(W,r)</code></p><p>If  a second  argument <code>r</code>  is given,  returns only  representatives of the parabolic subgroups of semisimple rank <code>r</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; parabolic_reps(coxgroup(:A,4),2)
2-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]

julia&gt; parabolic_reps(complex_reflection_group(3,3,3),2)
4-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]
 [1, 9]
 [2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1382-L1429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.parabolic_closure" href="#Gapjm.PermRoot.parabolic_closure"><code>Gapjm.PermRoot.parabolic_closure</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>parabolic_closure(W,I)</code></p><p><code>I</code>  should be a  list of indices  of reflections of  <code>W</code>. Returns <code>J</code> such that  <code>reflection_subgroup(W,J)</code> is the smallest  parabolic subgroup of <code>W</code> containing <code>reflection_subgroup(W,I)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(7)
G₇

julia&gt; parabolic_closure(W,[1])
1-element Vector{Int64}:
 1

julia&gt; parabolic_closure(W,[1,2])
3-element Vector{Int64}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1561-L1582">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.isparabolic" href="#Gapjm.PermRoot.isparabolic"><code>Gapjm.PermRoot.isparabolic</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>isparabolic(W)</code></p><p>whether the reflection subgroup <code>W</code> is a parabolic subgroup of <code>parent(W)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(7)
G₇

julia&gt; isparabolic(reflection_subgroup(W,[1,2]))
false

julia&gt; isparabolic(reflection_subgroup(W,[1]))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/9c591f22adcb9797b3c424beab613fd834000848/src/PermRoot.jl#L1537-L1551">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="weyl.html">« Finite Coxeter groups and Weyl groups</a><a class="docs-footer-nextpage" href="chars.html">Classes/characters of reflection groups »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 23 September 2022 19:26">Friday 23 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
