<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Posets · Gapjm.jl documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Gapjm.jl documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Gapjm</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Infrastructure</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href="posets.html">Posets</a></li><li><a class="tocitem" href="sperm.html">Signed permutations</a></li><li><a class="tocitem" href="symbols.html">Symbols</a></li><li><a class="tocitem" href="ffe.html">Finite fields</a></li><li><a class="tocitem" href="nf.html">Number fields</a></li><li><a class="tocitem" href="presentations.html">Presentations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Reflection groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="permroot.html">Finite reflection groups</a></li><li><a class="tocitem" href="coxgroups.html">Coxeter groups</a></li><li><a class="tocitem" href="weyl.html">Finite Coxeter groups and Weyl groups</a></li><li><a class="tocitem" href="chars.html">Classes/characters of reflection groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Hecke algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="hecke.html">Hecke algebras</a></li><li><a class="tocitem" href="kl.html">Kazhdan-Lusztig polynomials and bases</a></li></ul></li><li><a class="tocitem" href="garside.html">Garside monoids and groups, braids.</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reductive groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="semisimple.html">Reductive groups, semisimple elements</a></li><li><a class="tocitem" href="cosets.html">Reflection cosets and Spets</a></li><li><a class="tocitem" href="sscoset.html">Non-connected reductive groups</a></li><li><a class="tocitem" href="uch.html">Unipotent characters</a></li><li><a class="tocitem" href="ct.html">Classtypes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Eigenspaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="eigen.html">Eigenspaces</a></li><li><a class="tocitem" href="dseries.html">d-Harish-Chandra series</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Unipotent elements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ucl.html">Unipotent classes of reductive groups</a></li><li><a class="tocitem" href="urad.html">Unipotent Elements</a></li></ul></li><li><a class="tocitem" href="gendec.html">Decomposition Matrices</a></li><li><a class="tocitem" href="dict.html">Dictionary from GAP3/Chevie</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Infrastructure</a></li><li class="is-active"><a href="posets.html">Posets</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="posets.html">Posets</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmichel7/Gapjm.jl/blob/master/docs/src/posets.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Posets"><a class="docs-heading-anchor" href="#Posets">Posets</a><a id="Posets-1"></a><a class="docs-heading-anchor-permalink" href="#Posets" title="Permalink"></a></h1><ul><li><a href="posets.html#Gapjm.Posets"><code>Gapjm.Posets</code></a></li><li><a href="posets.html#Gapjm.Posets.CPoset"><code>Gapjm.Posets.CPoset</code></a></li><li><a href="posets.html#Gapjm.Posets.Poset"><code>Gapjm.Posets.Poset</code></a></li><li><a href="posets.html#Gapjm.Posets.Poset"><code>Gapjm.Posets.Poset</code></a></li><li><a href="posets.html#Gapjm.Posets.covering_chains"><code>Gapjm.Posets.covering_chains</code></a></li><li><a href="posets.html#Gapjm.Posets.dual"><code>Gapjm.Posets.dual</code></a></li><li><a href="posets.html#Gapjm.Posets.hasse"><code>Gapjm.Posets.hasse</code></a></li><li><a href="posets.html#Gapjm.Posets.incidence"><code>Gapjm.Posets.incidence</code></a></li><li><a href="posets.html#Gapjm.Posets.induced"><code>Gapjm.Posets.induced</code></a></li><li><a href="posets.html#Gapjm.Posets.isjoinlattice"><code>Gapjm.Posets.isjoinlattice</code></a></li><li><a href="posets.html#Gapjm.Posets.ismeetlattice"><code>Gapjm.Posets.ismeetlattice</code></a></li><li><a href="posets.html#Gapjm.Posets.linear_extension"><code>Gapjm.Posets.linear_extension</code></a></li><li><a href="posets.html#Gapjm.Posets.maxima"><code>Gapjm.Posets.maxima</code></a></li><li><a href="posets.html#Gapjm.Posets.minima"><code>Gapjm.Posets.minima</code></a></li><li><a href="posets.html#Gapjm.Posets.moebius"><code>Gapjm.Posets.moebius</code></a></li><li><a href="posets.html#Gapjm.Posets.moebiusmatrix"><code>Gapjm.Posets.moebiusmatrix</code></a></li><li><a href="posets.html#Gapjm.Posets.partition"><code>Gapjm.Posets.partition</code></a></li><li><a href="posets.html#Gapjm.Posets.transitive_closure"><code>Gapjm.Posets.transitive_closure</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets" href="#Gapjm.Posets"><code>Gapjm.Posets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This  package deals with  finite posets. </p><p>There  are two kinds of  posets. A &quot;canonical poset&quot;  or <code>CPoset</code> is on the elements  <code>1:n</code>  where  <code>n=length(P)</code>.  A  <code>Poset</code>  is  on  a given list of elements  which may be of any type. A <code>Poset</code> contains internally a<code>CPoset</code> working  on  the  indices  of  the  elements,  which is more efficient than working  with  the  elements  themselves.  Similarly  for  efficiency  many functions  work with the  <code>CPoset</code> by transformeing  their input to indices and their output to elements.</p><p>A  <code>CPoset</code> has the field:</p><ul><li><code>hasse</code>:  a list representing  the Hasse diagram  of the poset: the <code>i</code>-th  entry is the list of elements which cover (are immediate  successors of) <code>i</code>, that  is the list of <code>j</code> such that <code>i&lt;j</code> and there is no <code>k</code> such that <code>i&lt;k&lt;j</code>.</li></ul><p>The following is cached when computed to speed up subsequent computations:</p><ul><li><code>incidence</code>: a  boolean matrix  such that <code>incidence[i,j]==true</code> iff <code>i&lt;=j</code>. This is sometimes called the ζ-matrix of the poset.</li></ul><p>There are several ways of defining a poset.  By entering the Hasse diagram:</p><pre><code class="language-julia-repl hljs">julia&gt; p=CPoset([[2,3],[4],[4],Int[]])
1&lt;2,3&lt;4</code></pre><p>As  seen above, <code>p</code> is shown as a list of covering maximal chains; elements which  are  equivalent  for  the  poset  are  printed together separated by commas.</p><pre><code class="language-julia-repl hljs">julia&gt; length(p) # the number of elements of `p`
4

julia&gt; incidence(p)
4×4 Matrix{Bool}:
 1  1  1  1
 0  1  0  1
 0  0  1  1
 0  0  0  1

julia&gt; linear_extension(p) # a total order compatible with p
4-element Vector{Int64}:
 1
 2
 3
 4</code></pre><p>A <code>Poset</code> is constructed from a <code>CPoset</code> and a list of elements</p><pre><code class="language-julia-repl hljs">julia&gt; P=Poset(p,[:a,:b,:c,:d])
a&lt;b,c&lt;d

julia&gt; P.C # the CPoset attached to P
1&lt;2,3&lt;4</code></pre><p>A  convenient  constructor  for  <code>Poset</code>s  takes  a  function  representing <code>isless</code>  for the poset and  the list of elements  and constructs the poset from  the incidence matrix, computed by  applying the function to each pair of  elements. For <code>isless</code> one can  give either a function implementing <code>&lt;</code> or a function implementing <code>≤</code> (it is <code>or</code>-ed with <code>=</code> in any case).</p><pre><code class="language-julia-repl hljs">julia&gt; l=vec(collect(Iterators.product(1:2,1:2)))
4-element Vector{Tuple{Int64, Int64}}:
 (1, 1)
 (2, 1)
 (1, 2)
 (2, 2)

julia&gt; P=Poset((x,y)-&gt;all(map(&lt;=,x,y)),l)
(1, 1)&lt;(2, 1),(1, 2)&lt;(2, 2)

julia&gt; eltype(P) # the type of the elements of P
Tuple{Int64, Int64}

julia&gt; summary(P) # useful for big posets
&quot;Poset{Tuple{Int64, Int64}} of length 4&quot;</code></pre><p>A  poset  can  also  be  constructed  from  an incidence matrix so the last example could also be entered as</p><pre><code class="language-julia-repl hljs">julia&gt; P=Poset(CPoset([all(map(&lt;=,x,y)) for x in l, y in l]),l)
(1, 1)&lt;(2, 1),(1, 2)&lt;(2, 2)</code></pre><p>Flexibility  on  printing  a  <code>Poset</code>  is  obtained by setting the function <code>show_element</code>  which takes as arguments an  <code>IO</code>, the poset, and the index of the element to print:</p><pre><code class="language-julia-repl hljs">julia&gt; P.show_element=(io,p,n)-&gt;join(io,p.elements[n],&quot;.&quot;);

julia&gt; P
1.1&lt;2.1,1.2&lt;2.2

julia&gt; delete!(P,:show_element); # back to default</code></pre><p>The above fancy printing applies only when printing at the REPL or in pluto or  Jupyter. The default printing  gives a form which  can be input back in Julia</p><pre><code class="language-julia-rep1 hljs">julia&gt; print(P) 
Poset(CPoset([[2, 3], [4], [4], Int64[]]),[(1, 1), (2, 1), (1, 2), (2, 2)])</code></pre><p>A poset can be specified by a list of tuples specifing order relations. The transitive  closure  of  these  relations  is computed, giving an incidence matrix  from which the  poset is built.  The elements of  the poset, if not specified separately, will be all the elements which appear in the tuples.</p><pre><code class="language-julia-repl hljs">julia&gt; Poset([(:a,:b),(:c,:d)])
a&lt;b
c&lt;d

julia&gt; CPoset([(1,3),(2,5)]) # the CPoset is on 1:maximum(entries)
4
1&lt;3
2&lt;5</code></pre><p>To get the order relation <code>≤</code> of the poset <code>p</code> between elements <code>i</code> and <code>j</code> just call <code>≤(p,i,j)</code>. </p><pre><code class="language-julia-repl hljs">julia&gt; ≤(P,(1,1),(2,1))
true

julia&gt; ≤(P.C,1,2) # the same
true</code></pre><p>Intervals in a poset can be computed with strict or not bounds.</p><pre><code class="language-julia-repl hljs">julia&gt; interval(P,≤,(1,2)) # elements below (1,2)
2-element Vector{Tuple{Int64, Int64}}:
 (1, 1)
 (1, 2)

julia&gt; interval(P,≥,(1,2)) # elements above (1,2)
2-element Vector{Tuple{Int64, Int64}}:
 (1, 2)
 (2, 2)

julia&gt; interval(P,&lt;,(1,2)) # elements strictly below (1,2)
1-element Vector{Tuple{Int64, Int64}}:
 (1, 1)

julia&gt; interval(P,≥,(2,1),≤,(2,2)) # elements between (2,1) and (2,2)
2-element Vector{Tuple{Int64, Int64}}:
 (2, 1)
 (2, 2)

julia&gt; interval(P,&gt;,(1,1),&lt;,(2,2)) # elements strictly between
2-element Vector{Tuple{Int64, Int64}}:
 (2, 1)
 (1, 2)
julia&gt; interval(P.C,&gt;,1,&lt;,4) # in terms of indices
2-element Vector{Int64}:
 2
 3</code></pre><p>A sample of other functions available on posets:</p><pre><code class="language-julia-repl hljs">julia&gt; maximal_chains(P)
2-element Vector{Vector{Tuple{Int64, Int64}}}:
 [(1, 1), (2, 1), (2, 2)]
 [(1, 1), (1, 2), (2, 2)]

julia&gt; height(P) # the length of a maximal chain
3

julia&gt; moebiusmatrix(P)
4×4 Matrix{Int64}:
 1  -1  -1   1
 0   1   0  -1
 0   0   1  -1
 0   0   0   1

julia&gt; minima(P)
1-element Vector{Tuple{Int64, Int64}}:
 (1, 1)

julia&gt; maxima(P)
1-element Vector{Tuple{Int64, Int64}}:
 (2, 2)

julia&gt; Q=CPoset(:chain,3)
1&lt;2&lt;3

julia&gt; P1=Poset(Q) # transformed to a Poset with elements 1:3
1&lt;2&lt;3

julia&gt; P⊕ P1 # the ordinal sum
(1, 1)&lt;(2, 1),(1, 2)&lt;(2, 2)&lt;1&lt;2&lt;3

julia&gt; P1*P1
(1, 1)&lt;(2, 1)&lt;(3, 1)&lt;(3, 2)&lt;(3, 3)
(1, 1)&lt;(1, 2)&lt;(2, 2)&lt;(3, 2)
(2, 1)&lt;(2, 2)
(1, 2)&lt;(1, 3)&lt;(2, 3)&lt;(3, 3)
(2, 2)&lt;(2, 3)

julia&gt; P1⊗ P1 # the ordinal product
(1, 1)&lt;(1, 2)&lt;(1, 3)&lt;(2, 1)&lt;(2, 2)&lt;(2, 3)&lt;(3, 1)&lt;(3, 2)&lt;(3, 3)</code></pre><p>Finally <code>showpic(p)</code> where <code>p</code> is a <code>CPoset</code> or a <code>Poset</code> gives a graphical display of the poset (on Linux) provided you have the command <code>dot</code> and the command  <code>display</code> of  <code>imagemagick</code> installed.  It may  work on  MacOs and Windows but I did not test it.</p><p>see the on-line help on <code>⊕, ⊗,  chains, chainpoly, covering_chains, coxetermatrix,  dual,  hasse,  height, incidence,  induced,  interval,  isjoinlattice,  ismeetlattice,  linear_extension,  maxima, maximal_chains,  minima, moebius,  moebiusmatrix,  partition,  showpic, transitive_closure</code> for more information</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L1-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.Poset" href="#Gapjm.Posets.Poset"><code>Gapjm.Posets.Poset</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Poset(p::CPoset,e::AbstractVector)</code></p><p>creates a <code>Poset</code> with order specified by <code>p</code> and elements <code>e</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L334-L338">source</a></section><section><div><p><code>Poset(W::CoxeterGroup,w=longest(W))</code></p><p>returns  as a poset the Bruhat interval <code>[1,w]</code>of <code>W</code>. If <code>w</code> is not given, the whole Bruhat Poset of <code>W</code> is returned (<code>W</code> must then be finite).</p><pre><code class="language-julia-repl hljs">julia&gt; W=CoxSym(3)
𝔖 ₃

julia&gt; Poset(W)
.&lt;1,2&lt;21,12&lt;121</code></pre><p>The above poset is constructed efficiently by constructing the Hasse diagram, but it could be constructed naively as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; p=Poset((x,y)-&gt;bruhatless(W,x,y),elements(W))
()&lt;(2,3),(1,2)&lt;(1,2,3),(1,3,2)&lt;(1,3)</code></pre><p>The element printing is not so nice, showing permutations instead of words. This can be remedied by giving a function:</p><pre><code class="language-julia-repl hljs">julia&gt; p.show_element=(io,x,n)-&gt;(e=elements(x,n);print(io,isone(e) ? &quot;.&quot; : joindigits(word(W,e))));

julia&gt; p
.&lt;2,1&lt;21,12&lt;121

julia&gt; W=CoxSym(4)
𝔖 ₄

julia&gt; Poset(W,W(1,3))
.&lt;3,1&lt;13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/CoxGroups.jl#L517-L550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.CPoset" href="#Gapjm.Posets.CPoset"><code>Gapjm.Posets.CPoset</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>CPoset(m::Matrix{Bool})</code></p><p>Creates a poset from an incidence matrix <code>m</code>, that is <code>m[i,j]==true</code> if and only if <code>i≤j</code> in the poset,</p><pre><code class="language-julia-repl hljs">julia&gt; CPoset(Bool[1 1 1 1 1;0 1 0 1 1;0 0 1 1 1;0 0 0 1 0;0 0 0 0 1])
1&lt;2,3&lt;4,5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L354-L364">source</a></section><section><div><p><code>CPoset(h::Vector{&lt;:Vector{&lt;:Integer}})</code></p><p>Creates a poset from a Hasse diagram given as a <code>Vector</code> whose <code>i</code>-th entry is  the list of indices which are immediate successors (covers) of the <code>i</code>-th element, that is <code>h[i]</code> is the list of <code>j</code> such that <code>i&lt;j</code> in the poset and such that there is no <code>k</code> such that <code>i&lt;k&lt;j</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; CPoset([[2,3],[4,5],[4,5],Int[],Int[]])
1&lt;2,3&lt;4,5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L367-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.hasse" href="#Gapjm.Posets.hasse"><code>Gapjm.Posets.hasse</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>hasse(P::CPoset)</code></p><p>the Hasse diagram of <code>P</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; p=CPoset((i,j)-&gt;j%i==0,5)
1&lt;3,5
1&lt;2&lt;4

julia&gt; hasse(p)
5-element Vector{Vector{Int64}}:
 [2, 3, 5]
 [4]      
 []       
 []       
 []       </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L488-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.incidence" href="#Gapjm.Posets.incidence"><code>Gapjm.Posets.incidence</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>incidence(P::CPoset)</code></p><p>returns the incidence matrix (also called the ζ matrix) of <code>P</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; p=CPoset([i==6 ? Int[] : [i+1] for i in 1:6])
1&lt;2&lt;3&lt;4&lt;5&lt;6

julia&gt; incidence(p)
6×6 Matrix{Bool}:
 1  1  1  1  1  1
 0  1  1  1  1  1
 0  0  1  1  1  1
 0  0  0  1  1  1
 0  0  0  0  1  1
 0  0  0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L509-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.transitive_closure" href="#Gapjm.Posets.transitive_closure"><code>Gapjm.Posets.transitive_closure</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>transitive_closure(M)</code> <code>transitive_closure!(M)</code></p><p><code>M</code>   should  be   a  square   boolean  matrix   representing  a  relation; <code>transitive_closure</code>  returns a boolean  matrix representing the transitive closure  of this  relation; <code>transistive_closure!</code>  modifies <code>M</code>  in place, doing   no  allocations.  The   transitive  closure  is   computed  by  the Floyd-Warshall algorithm, which is quite fast even for large matrices.</p><pre><code class="language-julia-repl hljs">julia&gt; m=[j-i in [0,1] for i in 1:5, j in 1:5]
5×5 Matrix{Bool}:
 1  1  0  0  0
 0  1  1  0  0
 0  0  1  1  0
 0  0  0  1  1
 0  0  0  0  1

julia&gt;transitive_closure(m)
5×5 Matrix{Bool}:
 1  1  1  1  1
 0  1  1  1  1
 0  0  1  1  1
 0  0  0  1  1
 0  0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L262-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.linear_extension" href="#Gapjm.Posets.linear_extension"><code>Gapjm.Posets.linear_extension</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>linear_extension(P)</code></p><p>returns  a  linear  extension  of  the  poset  <code>P</code>,  that  is  a vector <code>l</code> containing  a permutation of the integers  <code>1:length(P)</code> such that if <code>i&lt;j</code> in  <code>P</code> (that is <code>incidence(P)[i,j]</code> is <code>true</code>),  then <code>i</code> is before <code>j</code> in <code>l</code>. This is also called a topological sort of <code>P</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; p=CPoset((i,j)-&gt;j%i==0,6) # divisibility poset on 1:6
1&lt;5
1&lt;2&lt;4
1&lt;3&lt;6
2&lt;6

julia&gt; linear_extension(p)
6-element Vector{Int64}:
 1
 2
 3
 5
 4
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L444-L468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.dual" href="#Gapjm.Posets.dual"><code>Gapjm.Posets.dual</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>dual(P::CPoset)</code></p><p>the dual poset to <code>P</code> (the order relation is reversed).</p><pre><code class="language-julia-repl hljs">julia&gt; p=CPoset((i,j)-&gt;i%4&lt;j%4,8)
4,8&lt;1,5&lt;2,6&lt;3,7

julia&gt; dual(p)
3,7&lt;2,6&lt;1,5&lt;4,8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L616-L628">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.partition" href="#Gapjm.Posets.partition"><code>Gapjm.Posets.partition</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>partition(P::CPoset)</code></p><p>returns  the partition of <code>1:length(P)</code> induced by the equivalence relation associated  to  <code>P</code>;  that  is,  <code>i</code>  and  <code>j</code>  are in the same part of the partition  if the <code>k</code> such that <code>i&lt;k</code> and <code>j&lt;k</code> are the same as well as the <code>k</code> such that <code>k&lt;i</code> and <code>k&lt;j</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; p=CPoset([i==j || i%4&lt;j%4 for i in 1:8, j in 1:8])
4,8&lt;1,5&lt;2,6&lt;3,7

julia&gt; partition(p)
4-element Vector{Vector{Int64}}:
 [4, 8]
 [2, 6]
 [3, 7]
 [1, 5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L640-L659">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.covering_chains" href="#Gapjm.Posets.covering_chains"><code>Gapjm.Posets.covering_chains</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>covering_chains(P::CPoset)</code></p><p>A (greedy: the first is longest possible) list of covering chains for P.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L594-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.induced" href="#Gapjm.Posets.induced"><code>Gapjm.Posets.induced</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>induced(P::CPoset,S)</code></p><p>returns  the subposet  induced by  <code>P</code> on  <code>S</code>, a sublist of <code>P.elements</code>. Note  that  the  sublist  <code>S</code>  does  not  have  to  be in the same order as <code>P.elements</code>, so this can be just used to renumber the elements of <code>P</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; p=CPoset((i,j)-&gt;i%4&lt;j%4,8)
4,8&lt;1,5&lt;2,6&lt;3,7

julia&gt; induced(p,2:6) # indices are renumbered
3&lt;4&lt;1,5&lt;2

julia&gt; induced(Poset(p),2:6) # elements are kept
4&lt;5&lt;2,6&lt;3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L670-L687">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.isjoinlattice" href="#Gapjm.Posets.isjoinlattice"><code>Gapjm.Posets.isjoinlattice</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>isjoinlattice(P::CPoset)</code></p><p>returns  <code>true</code> if <code>P</code> is  a join semilattice, that  is any two elements of <code>P</code> have a unique smallest upper bound; returns <code>false</code> otherwise.</p><pre><code class="language-julia-repl hljs">julia&gt; p=CPoset((i,j)-&gt;j%i==0,8)
1&lt;5,7
1&lt;2&lt;4&lt;8
1&lt;3&lt;6
2&lt;6

julia&gt; isjoinlattice(p)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L731-L747">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.ismeetlattice" href="#Gapjm.Posets.ismeetlattice"><code>Gapjm.Posets.ismeetlattice</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>ismeetlattice(P)</code></p><p>returns  <code>true</code> if <code>P</code> is  a meet semilattice, that  is any two elements of <code>P</code> have a unique highest lower bound; returns <code>false</code> otherwise.</p><pre><code class="language-julia-repl hljs">julia&gt; p=CPoset((i,j)-&gt;j%i==0,8)
1&lt;5,7
1&lt;2&lt;4&lt;8
1&lt;3&lt;6
2&lt;6

julia&gt; ismeetlattice(p)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L750-L766">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.moebius" href="#Gapjm.Posets.moebius"><code>Gapjm.Posets.moebius</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>moebius(P,y=maximum(P))</code></p><p>the vector of values <code>μ(x,y)</code> of the Moebius function of <code>P</code> for <code>x</code> varying. Here is an example giving the ususal Moebius function on integers.</p><pre><code class="language-julia_repl hljs">julia&gt; p=CPoset((i,j)-&gt;i%j==0,1:8)
5,7&lt;1
6&lt;2&lt;1
6&lt;3&lt;1
8&lt;4&lt;2

julia&gt; moebius(p)
8-element Vector{Int64}:
  1
 -1
 -1
  0
 -1
  1
 -1
  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L769-L792">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.moebiusmatrix" href="#Gapjm.Posets.moebiusmatrix"><code>Gapjm.Posets.moebiusmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>moebiusmatrix(P::CPoset)</code> the matrix of the Moebius function <code>μ(x,y)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L820">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.maxima" href="#Gapjm.Posets.maxima"><code>Gapjm.Posets.maxima</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia-repl hljs">julia&gt; p=CPoset([[3],[3],[4,5],Int[],Int[]])
1,2&lt;3&lt;4,5

julia&gt; maxima(p)
2-element Vector{Int64}:
 4
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L845-L855">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.minima" href="#Gapjm.Posets.minima"><code>Gapjm.Posets.minima</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia-repl hljs">julia&gt; p=CPoset([[3],[3],[4,5],Int[],Int[]])
1,2&lt;3&lt;4,5

julia&gt; minima(p)
2-element Vector{Int64}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/Posets.jl#L828-L838">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Posets.Poset" href="#Gapjm.Posets.Poset"><code>Gapjm.Posets.Poset</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Poset(W::CoxeterGroup,w=longest(W))</code></p><p>returns  as a poset the Bruhat interval <code>[1,w]</code>of <code>W</code>. If <code>w</code> is not given, the whole Bruhat Poset of <code>W</code> is returned (<code>W</code> must then be finite).</p><pre><code class="language-julia-repl hljs">julia&gt; W=CoxSym(3)
𝔖 ₃

julia&gt; Poset(W)
.&lt;1,2&lt;21,12&lt;121</code></pre><p>The above poset is constructed efficiently by constructing the Hasse diagram, but it could be constructed naively as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; p=Poset((x,y)-&gt;bruhatless(W,x,y),elements(W))
()&lt;(2,3),(1,2)&lt;(1,2,3),(1,3,2)&lt;(1,3)</code></pre><p>The element printing is not so nice, showing permutations instead of words. This can be remedied by giving a function:</p><pre><code class="language-julia-repl hljs">julia&gt; p.show_element=(io,x,n)-&gt;(e=elements(x,n);print(io,isone(e) ? &quot;.&quot; : joindigits(word(W,e))));

julia&gt; p
.&lt;2,1&lt;21,12&lt;121

julia&gt; W=CoxSym(4)
𝔖 ₄

julia&gt; Poset(W,W(1,3))
.&lt;3,1&lt;13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/a3f702fc4b9974b1d2b235854419816994fe36bb/src/CoxGroups.jl#L517-L550">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Gapjm</a><a class="docs-footer-nextpage" href="sperm.html">Signed permutations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 23 March 2023 23:07">Thursday 23 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
