<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finite Coxeter groups and Weyl groups · Gapjm.jl documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Gapjm.jl documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Gapjm</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Infrastructure</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="cycpol.html">Cyclotomic polynomials</a></li><li><a class="tocitem" href="posets.html">Posets</a></li><li><a class="tocitem" href="sperm.html">Signed permutations</a></li><li><a class="tocitem" href="glinearalgebra.html">Linear algebra on any field/ring</a></li><li><a class="tocitem" href="matint.html">Integral matrices and lattices</a></li><li><a class="tocitem" href="ffe.html">Finite fields</a></li><li><a class="tocitem" href="presentations.html">Presentations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Reflection groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="coxgroups.html">Coxeter groups</a></li><li class="is-active"><a class="tocitem" href="weyl.html">Finite Coxeter groups and Weyl groups</a></li><li><a class="tocitem" href="permroot.html">Finite reflection groups</a></li><li><a class="tocitem" href="chars.html">Classes/characters of reflection groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Hecke algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="hecke.html">Hecke algebras</a></li><li><a class="tocitem" href="kl.html">Kazhdan-Lusztig polynomials and bases</a></li></ul></li><li><a class="tocitem" href="garside.html">Garside monoids and groups, braids.</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reductive groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="semisimple.html">Reductive groups, semisimple elements</a></li><li><a class="tocitem" href="cosets.html">Reflection cosets</a></li><li><a class="tocitem" href="sscoset.html">Non-connected reductive groups</a></li><li><a class="tocitem" href="uch.html">Unipotent characters</a></li><li><a class="tocitem" href="ct.html">Classtypes</a></li></ul></li><li><a class="tocitem" href="eigen.html">Eigenspaces</a></li><li><a class="tocitem" href="dseries.html">d-Harish-Chandra series</a></li><li><a class="tocitem" href="symbols.html">Symbols</a></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Unipotent elements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ucl.html">Unipotent classes of reductive groups</a></li><li><a class="tocitem" href="urad.html">Unipotent Elements</a></li></ul></li><li><a class="tocitem" href="gendec.html">Decomposition Matrices</a></li><li><a class="tocitem" href="dict.html">Dictionary from GAP3/Chevie</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reflection groups</a></li><li class="is-active"><a href="weyl.html">Finite Coxeter groups and Weyl groups</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="weyl.html">Finite Coxeter groups and Weyl groups</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmichel7/Gapjm.jl/blob/master/docs/src/weyl.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Finite-Coxeter-groups-and-Weyl-groups"><a class="docs-heading-anchor" href="#Finite-Coxeter-groups-and-Weyl-groups">Finite Coxeter groups and Weyl groups</a><a id="Finite-Coxeter-groups-and-Weyl-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Coxeter-groups-and-Weyl-groups" title="Permalink"></a></h1><ul><li><a href="weyl.html#Gapjm.Weyl"><code>Gapjm.Weyl</code></a></li><li><a href="weyl.html#Gapjm.CoxGroups.coxeter_group"><code>Gapjm.CoxGroups.coxeter_group</code></a></li><li><a href="weyl.html#Gapjm.CoxGroups.inversions"><code>Gapjm.CoxGroups.inversions</code></a></li><li><a href="weyl.html#Gapjm.PermRoot.cartan-Tuple{Symbol, Integer, Integer}"><code>Gapjm.PermRoot.cartan</code></a></li><li><a href="weyl.html#Gapjm.PermRoot.reflection_subgroup-Tuple{Gapjm.Weyl.FCG, AbstractVector{&lt;:Integer}}"><code>Gapjm.PermRoot.reflection_subgroup</code></a></li><li><a href="weyl.html#Gapjm.PermRoot.roots-Tuple{AbstractMatrix}"><code>Gapjm.PermRoot.roots</code></a></li><li><a href="weyl.html#Gapjm.Semisimple.affine"><code>Gapjm.Semisimple.affine</code></a></li><li><a href="weyl.html#Gapjm.Weyl.badprimes"><code>Gapjm.Weyl.badprimes</code></a></li><li><a href="weyl.html#Gapjm.Weyl.describe_involution"><code>Gapjm.Weyl.describe_involution</code></a></li><li><a href="weyl.html#Gapjm.Weyl.istorus"><code>Gapjm.Weyl.istorus</code></a></li><li><a href="weyl.html#Gapjm.Weyl.relative_group"><code>Gapjm.Weyl.relative_group</code></a></li><li><a href="weyl.html#Gapjm.Weyl.rootdatum-Tuple{AbstractMatrix}"><code>Gapjm.Weyl.rootdatum</code></a></li><li><a href="weyl.html#Gapjm.Weyl.rootdatum-Tuple{AbstractMatrix, AbstractMatrix}"><code>Gapjm.Weyl.rootdatum</code></a></li><li><a href="weyl.html#Gapjm.Weyl.rootlengths"><code>Gapjm.Weyl.rootlengths</code></a></li><li><a href="weyl.html#Gapjm.Weyl.standard_parabolic-Tuple{FiniteCoxeterGroup, AbstractVector{&lt;:Integer}}"><code>Gapjm.Weyl.standard_parabolic</code></a></li><li><a href="weyl.html#Gapjm.Weyl.torus-Tuple{Integer}"><code>Gapjm.Weyl.torus</code></a></li><li><a href="weyl.html#Gapjm.Weyl.two_tree"><code>Gapjm.Weyl.two_tree</code></a></li><li><a href="weyl.html#Gapjm.Weyl.with_inversions"><code>Gapjm.Weyl.with_inversions</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl" href="#Gapjm.Weyl"><code>Gapjm.Weyl</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Finite Coxeter groups are the finite complex reflection groups which can be defined on a real vector space <code>V</code>.</p><p><em>Weyl  groups</em> are the  finite Coxeter groups  which can be  defined over a rational vector space <code>V</code> (thus over the integers).</p><p>Like   finite  complex   reflection  groups,   finite  Coxeter  groups  are implemented as groups of permutations of a root system. The particular root systems  for  Weyl  groups  play  an  important role in mathematics as they classify semi-simple Lie algebras and algebraic groups.</p><p>Let  us give precise definitions.  Let <code>V</code> be a  real vector space and <code>Vⱽ</code> its  dual. A <em>root system</em> is a finite set of vectors <code>R⊂ V</code> (the <em>roots</em>), together  with  a  map  <code>r↦  rⱽ</code>  from  <code>R</code>  to  a subset <code>Rⱽ</code> of <code>Vⱽ</code> (the <em>coroots</em>) such that:</p><ul><li>For any <code>r∈ R</code>,  we have <code>rⱽ(r)=2</code>, so  that the formula <code>x↦ x-rⱽ(x)r</code> defines  a  reflection  <code>sᵣ:V→  V</code>  with  root  <code>r</code>  and coroot <code>rⱽ</code>. </li><li>The reflection <code>sᵣ</code> stabilizes <code>R</code>.</li></ul><p>The  subgroup <code>W=W(R)</code> of <code>GL(V)</code> generated by the reflections <code>sᵣ</code> for <code>r∈ R</code>  is a finite Coxeter  group. We require <em>reduced</em>  root systems, that is such  that the only elements of <code>R</code> colinear  with <code>r∈ R</code> are <code>r</code> and <code>-r</code>; for Weyl groups, we also require that the root system be <em>crystallographic</em>, that is <code>rⱽ(s)</code> is an integer, for any <code>s∈ R,rⱽ∈ Rⱽ</code>.</p><p>If  we identify  <code>V</code> with  <code>Vⱽ</code> by  choosing a  <code>W</code>-invariant bilinear form <code>(.;.)</code>,  then we have <code>rⱽ=2r/(r;r)</code>. A root system <code>R</code> is <em>irreducible</em> if <code>R</code>   is  not  the  union  of  two  orthogonal  subsets  (equivalently  the representation  of <code>W</code> on the subspace generated by <code>R</code> is irreducible). If <code>R</code> is reducible then the corresponding Coxeter group is the direct product of the Coxeter groups associated with the irreducible components of <code>R</code>.</p><p>Let  us  now  describe  how  a  root  system  <code>R</code> and a presentation of the corresponding  <code>W</code> are encoded in  a Cartan matrix or  a Dynkin diagram. We can  choose  a  linear  form  on  <code>V</code>  which vanishes on no element of <code>R</code>. According to the sign of the value of this linear form on a root <code>r ∈ R</code> we call <code>r</code> <em>positive</em> or <em>negative</em>. Then there exists a unique subset <code>Π</code> of the  positive roots, the <em>simple  roots</em>, such that any  positive root is a linear  combination with non-negative coefficients of roots in <code>Π</code>. Any two sets of simple roots (corresponding to different choices of linear forms as above)  can be transformed into  each other by a  unique element of <code>W(R)</code>. The  set <code>S</code> of reflections  with respect to the  simple roots is such that <code>(W,S)</code>  is  a  Coxeter  system.  These  generating  reflections are called <em>Coxeter generators</em> or <em>simple reflections</em>.</p><p>Since the pairing between <code>V</code> and <code>Vⱽ</code> is <code>W</code>-invariant, if <code>Π</code> is a set of simple  roots and if we  define the <em>Cartan matrix</em>  as being the <code>n</code> times <code>n</code>  matrix <code>C={rⱽ(r&#39;)}</code>  for <code>r,r&#39;∈Π</code>,  this matrix  is independent of the chosen  linear form  up to  simultaneous permutation  of rows  and columns. Since the action of <code>sᵣ</code> on <code>r&#39;</code> for <code>r,r&#39;∈Π</code> is given by <code>sᵣ(r&#39;)=r&#39;-C(r,r&#39;)r</code>,   the   Cartan   matrix   determines  the  reflection representation of <code>W</code>.</p><p>For  a crystallographic root system the Cartan matrix has integral entries, and  in the basis <code>Π</code> (completed by a basis of the orthogonal), <code>sᵣ</code> has an integral  matrix.  All  finite-dimensional  (complex)  representations of a finite  Coxeter  group  can  be  realized  over  the field generated by the entries of the Cartan matrix.</p><p>The  Cartan matrix is encoded  in a <em>Dynkin diagram</em>,  a tree with weighted edges  and  an  orientation  on  edges  of  even weight &gt;2, as follows. The vertices are in indexed by the simple reflections; an edge is drawn between <code>s</code> and <code>t</code> if the order <code>mₛₜ</code> of <code>st</code> is greater than <code>2</code> and is given the weight  <code>mₛₜ</code>. These  weights are  encoded by  drawing the  edge single for weight  3, double for weight 4 and triple for weight 6. The arrows indicate the relative root lengths (going from the longer to the shorter root) which may  differ between different orbits of  <code>W</code> on <code>R</code>. Alternately the Dynkin diagram  can be obtained  from the Cartan  matrix as follows:  if <code>Cᵣₛ</code> and <code>Cₛᵣ</code>  are integers  such that  <code>|Cₛᵣ|≥|Cᵣₛ|=1</code> there  is an edge of weight <code>|Cₛᵣ|</code> from <code>r</code> to <code>s</code> with an arrow pointing to <code>s</code> if <code>|Cₛᵣ|&gt;1</code>.</p><p>The  irreducible  crystallographic  root  systems  are  classified  by  the following  list of Dynkin diagrams. The labeling  of the nodes is the order of the generators and is shown by the function <code>diagram</code>.</p><pre><code class="nohighlight hljs">Aₙ O—O—O—…—O   Bₙ O⇐ O—O—…—O  Cₙ O⇒ O—O—…—O  Dₙ O 2
   1 2 3 … n      1  2 3 … n     1  2 3 … n     ￨
                                              O—O—…—O
                                              1 3 … n

G₂ O⇛ O  F₄ O—O⇒O—O    E₆  O 2    E₇  O 2      E₈  O 2
   1  2     1 2 3 4        ￨          ￨            ￨
                       O—O—O—O—O  O—O—O—O—O—O  O—O—O—O—O—O—O
                       1 3 4 5 6  1 3 4 5 6 7  1 3 4 5 6 7 8</code></pre><p>We get the <em>Coxeter diagram</em>, which describes the underlying Weyl group, if we  ignore  the  arrows:  we  see  that  the  root  systems <code>B_n</code> and <code>C_n</code> correspond to the same Coxeter group (the Coxeter diagram is defined by the Coxeter  matrix).  Weyl  groups  can  also  be  characterized as the finite Coxeter  groups  such  that  all  entries  of  the  Coxeter  matrix  are in <code>{2,3,4,6}</code>.</p><p>Here  are the Coxeter diagrams for the  finite Coxeter groups which are not crystallographic:</p><pre><code class="nohighlight hljs">       e        5         5
I₂(e) O—O   H₃ O—O—O  H₄ O—O—O—O
      1 2      1 2 3     1 2 3 4</code></pre><p>The  Cartan  matrix  corresponding  to  one  of  the above irreducible root systems  (with the specified labeling) is  returned by the command <code>cartan</code> which  takes as input  a <code>Symbol</code> giving  the type (that  is <code>:A</code>, <code>:B</code>, …, <code>:I</code>)  and a positive <code>Int</code> giving the  rank (plus an <code>Int</code> giving the bond for  type <code>:I</code>). This function returns a matrix with <code>Int</code> entries for Weyl groups,  and  a  matrix  of  <code>Cyc</code>  for  the  other types. Given two Cartan matrices  <code>c1</code>  and  <code>c2</code>,  their  matrix  direct sum (corresponding to the orthogonal   direct  sum   of  the   root  systems)   can  be  obtained  by <code>cat(c1,c2,dims=[1,2])</code>.</p><p>The  whole  root  system  can  be  recovered  from the simple roots and the corresponding  coroots, since each root  is in the orbit  of a simple root. The  restriction of the simple reflections to the span of <code>R</code> is determined by the Cartan matrix, so <code>R</code> is determined by the Cartan matrix and the set of simple roots.</p><p>The  function <code>rootdatum</code> takes as input a  list of simple roots and a list of  the  corresponding  coroots  and  produces  a <code>CoxeterGroup</code> containing information  about the root  system <code>R</code> and  about <code>W(R)</code>. If  we label the positive  roots by  <code>1:N</code>, and  the negative  roots by  <code>N+1:2N</code>, then each simple  reflection is  represented by  the permutation  of <code>1:2N</code>  which it induces  on the roots. If only one  argument is given, the Cartan matrix of the  root system, it is taken as the  list of coroots and the list of roots is assumed to be the canonical basis of <code>V</code>.</p><p>If one only wants to work with Cartan matrices with a labeling as specified by  the  above  list,  the  function  call  can  be  simplified. Instead of <code>rootdatum(cartan(:D,4))</code> the following is also possible.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; cartan(W)
4×4 Matrix{Int64}:
  2   0  -1   0
  0   2  -1   0
 -1  -1   2  -1
  0   0  -1   2</code></pre><p>Also,  the Weyl group struct associated to a direct sum of irreducible root systems can be obtained as a product</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)*coxgroup(:B,2)
A₂×B₂

julia&gt; cartan(W)
4×4 Matrix{Int64}:
  2  -1   0   0
 -1   2   0   0
  0   0   2  -2
  0   0  -1   2</code></pre><p>The  same object is constructed  by applying  <code>coxgroup</code> to  the matrix <code>cat(cartan(:A,2), cartan(:B,2),dims=[1,2])</code>.</p><p>The elements of a Weyl group are permutations of the roots:</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; p=W(1,3,2,1,3)
(1,14,13,2)(3,17,8,18)(4,12)(5,20,6,15)(7,10,11,9)(16,24)(19,22,23,21)

julia&gt; word(W,p)
5-element Vector{Int64}:
 1
 3
 1
 2
 3
</code></pre><p>finally, a benchmark on julia 1.0.2</p><pre><code class="language-benchmark hljs">julia&gt; @btime length(elements(coxgroup(:E,7)))
  531.385 ms (5945569 allocations: 1.08 GiB)</code></pre><p>GAP3 for the same computation takes 2.2s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L1-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.cartan-Tuple{Symbol, Integer, Integer}" href="#Gapjm.PermRoot.cartan-Tuple{Symbol, Integer, Integer}"><code>Gapjm.PermRoot.cartan</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>cartan(type, rank [,bond])</code></p><p>the  Cartan matrix for a  finite Coxeter group described  by type and rank. The  recognized types are <code>:A, :B, :Bsym, :C, :D, :E, :F, :Fsym, :G, :Gsym, :I,  :H</code>. For type <code>:I</code> a third  argument must be given describing the bond between the two generators. The <code>sym</code> types correspond to (non-crystallographic)  root systems where all  roots have the same length. They  afford automorphisms that  the crystallographic root  system does not afford, which allow to define the &quot;very twisted&quot; Chevalley groups.</p><pre><code class="language-julia-repl hljs">julia&gt; cartan(:F,4)
4×4 Matrix{Int64}:
  2  -1   0   0
 -1   2  -1   0
  0  -2   2  -1
  0   0  -1   2

julia&gt; cartan(:I,2,5)
2×2 Matrix{Cyc{Int64}}:
       2  ζ₅²+ζ₅³
 ζ₅²+ζ₅³        2

julia&gt; cartan(:Bsym,2)
2×2 Matrix{Cyc{Int64}}:
   2  -√2
 -√2    2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L277-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.roots-Tuple{AbstractMatrix}" href="#Gapjm.PermRoot.roots-Tuple{AbstractMatrix}"><code>Gapjm.PermRoot.roots</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>roots(C::AbstractMatrix)</code></p><p>returns the set of positive roots defined by the Cartan matrix <code>C</code>, which should be the Cartan matrix of a finite Coxeter group.</p><p>For  an integer Cartan matrix, the returned  roots are sorted by height and reverse lexicographically for a given height.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L445-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.two_tree" href="#Gapjm.Weyl.two_tree"><code>Gapjm.Weyl.two_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>two_tree(m)</code></p><p>Given  a square matrix  <code>m</code> with zeroes  (or falses, for  a boolean matrix) symmetric  with respect to the diagonal, let <code>G</code> be the graph with vertices <code>axes(m)[1]</code>  and an edge between <code>i</code> and <code>j</code> iff <code>!iszero(m[i,j])</code>. </p><p>If  <code>G</code> is a line this function returns  it as a <code>Vector{Int}</code>. If <code>G</code> is a tree with one vertex <code>c</code> of valence <code>3</code> the function returns <code>(c,b1,b2,b3)</code> where  <code>b1,b2,b3</code> are  the branches  from this  vertex sorted by increasing length. Otherwise the function returns <code>nothing</code></p><pre><code class="language-julia-repl hljs">julia&gt; Weyl.two_tree(cartan(:A,4))
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; Weyl.two_tree(cartan(:E,8))
(4, [2], [3, 1], [5, 6, 7, 8])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L328-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection_subgroup-Tuple{Gapjm.Weyl.FCG, AbstractVector{&lt;:Integer}}" href="#Gapjm.PermRoot.reflection_subgroup-Tuple{Gapjm.Weyl.FCG, AbstractVector{&lt;:Integer}}"><code>Gapjm.PermRoot.reflection_subgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflection_subgroup(W::FiniteCoxeterGroup,I)</code></p><p>The subgroup of <code>W</code> generated by <code>refls(W,I)</code></p><p>A  theorem discovered independently  by <a href="biblio.htm#Deo89">Deodhar1989</a> and <a href="biblio.htm#Dye90">Dyer1990</a>  is that  a subgroup  <code>H</code> of  a Coxeter system <code>(W,S)</code>  generated by reflections  has a canonical  Coxeter generating set, formed  of  the  <code>t  ∈  Ref(H)</code>  such  <code>l(tt&#39;)&gt;l(t)</code>  for  any <code>t&#39;∈ Ref(H)</code> different  from <code>t</code>. This is used by <code>reflection_subgroup</code> to determine the Coxeter system of <code>H</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; diagram(W)
O⇛ O G₂
1  2

julia&gt; H=reflection_subgroup(W,[2,6])
G₂₍₂₆₎=Ã₁×A₁

julia&gt; diagram(H)
O Ã₁
1
O A₁
2</code></pre><p>The  notation <code>G₂₍₂₆₎</code> means  that <code>W.G.roots[2:6]</code> form  a system of simple roots for <code>H</code>.</p><p>A  reflection subgroup has specific properties  the most important of which is  <code>inclusion</code> which gives the positions of  the roots of <code>H</code> in the roots of <code>W</code>. The inverse (partial) map is <code>restriction</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; inclusion(H)
4-element Vector{Int64}:
  2
  6
  8
 12

julia&gt; restriction(H)
12-element Vector{Int64}:
 0
 1
 0
 0
 0
 2
 0
 3
 0
 0
 0
 4</code></pre><p>If  <code>H</code> is a  standard parabolic subgroup  of a Coxeter  group <code>W</code> then the length  function on  <code>H</code> (with  respect to  its set  of generators)  is the restriction  of the length function on <code>W</code>. This need not no longer be true for arbitrary reflection subgroups of <code>W</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; word(W,H(2))
5-element Vector{Int64}:
 1
 2
 1
 2
 1</code></pre><p>In  this package, finite  reflection groups are  represented as permutation groups  on a set of roots. Consequently,  a reflection subgroup <code>H⊆ W</code> is a permutation  subgroup, thus its elements are represented as permutations of the roots of the parent group.</p><pre><code class="language-julia-repl hljs">julia&gt; elH=word.(Ref(H),elements(H))
4-element Vector{Vector{Int64}}:
 []
 [2]
 [1]
 [1, 2]

julia&gt; elW=word.(Ref(W),elements(H))
4-element Vector{Vector{Int64}}:
 []
 [1, 2, 1, 2, 1]
 [2]
 [1, 2, 1, 2, 1, 2]

julia&gt; map(w-&gt;H(w...),elH)==map(w-&gt;W(w...),elW)
true
</code></pre><p>Another  basic result about reflection subgroups  of Coxeter groups is that each  coset of <code>H</code> in <code>W</code> contains  a unique element of minimal length, see <code>reduced</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L927-L1030">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.coxeter_group" href="#Gapjm.CoxGroups.coxeter_group"><code>Gapjm.CoxGroups.coxeter_group</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>coxeter_group(m)</code> or <code>coxgroup(m)</code></p><p><code>m</code>  should be a square  matrix of real cyclotomic  numbers. It returns the Coxeter  group  whose  Cartan  matrix  is  <code>m</code>.  This  is  a  matrix  group constructed  as  follows.  Let  <code>V</code>  be  a  real  vector space of dimension <code>size(m,1)</code>,  and  let  <code>⟨,⟩</code>  be  the  bilinear  form defined by <code>⟨eᵢ,eⱼ⟩= m[i,j]</code>  where <code>eᵢ</code> is the  canonical basis of <code>V</code>.  Then the result is the matrix group generated by the reflections <code>sᵢ(x)=x-2⟨x,eᵢ⟩eᵢ</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup([2 -2;-2 2])
coxeter_group([2 -2; -2 2])</code></pre><p>Above is a way to construct the affine Weyl group  <code>Ã₁</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/CoxGroups.jl#L948-L964">source</a></section><section><div><p><code>coxeter_group(type,rank[,bond];sc=false)</code> (or <code>coxgroup</code>)</p><p>This is equivalent to <code>rootdatum(cartan(type,rank[,bond]))</code>.</p><p>The  resulting object  <code>W</code>, that  we will  call a  <em>Coxeter datum</em>,  has an additional entry compared to a <code>PermRootGroup</code>.</p><ul><li><code>W.rootdec</code>:  the root vectors, given  as linear combinations of simple roots.  The first <code>nref(W)</code> roots are  positive, the next <code>nref(W)</code> are the corresponding negative roots. Moreover, the first <code>semisimplerank(W)</code>  roots are the simple roots. The positive roots are ordered by increasing height.</li></ul><p>see  the following functions for how to get various information on the root system and the Coxeter group</p><p><code>nref,  coroots,  rootlengths,  simple_reps,  simple_conjugating,  reflrep, simpleroots,  simplecoroots, PermX, cartan, inclusion, restriction, action, rank, semisimplerank</code></p><ul><li><code>gens(W)</code>: the generators, as permutations of the root vectors. They are in the same order as the simple roots.</li></ul><p>In terms of root data, this function returns the adjoint root datum of Weyl group <code>W</code>. If <code>sc=true</code> it returns the simply connected root datum.</p><pre><code class="language-julia_repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; cartan(W)
3×3 Matrix{Int64}:
  2  -1   0
 -1   2  -1
  0  -1   2

julia&gt; W.rootdec
12-element Vector{Vector{Int64}}:
 [1, 0, 0]
 [0, 1, 0]
 [0, 0, 1]
 [1, 1, 0]
 [0, 1, 1]
 [1, 1, 1]
 [-1, 0, 0]
 [0, -1, 0]
 [0, 0, -1]
 [-1, -1, 0]
 [0, -1, -1]
 [-1, -1, -1]

 julia&gt; reflrep(W)
3-element Vector{Matrix{Int64}}:
 [-1 0 0; 1 1 0; 0 0 1]
 [1 1 0; 0 -1 0; 0 1 1]
 [1 0 0; 0 1 1; 0 0 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L705-L762">source</a></section><section><div><p><code>coxeter_group()</code> or <code>coxgroup()</code> the trivial Coxeter group</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L837">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.rootlengths" href="#Gapjm.Weyl.rootlengths"><code>Gapjm.Weyl.rootlengths</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>rootlengths(W::FiniteCoxeterGroup)</code>   the vector  of the (squared)  length of the roots of <code>W</code>.  The  shortest roots in an irreducible subsystem are given the length 1. In  a Weyl group the others then have length 2 (or 3 in type <code>G₂</code>). The matrix  of the <code>W</code>-invariant bilinear form is given by  <code>map(i-&gt;rootlengths(W)[i]*W.cartan[i,:],1:semisimplerank(W))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L845-L852">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.rootdatum-Tuple{AbstractMatrix}" href="#Gapjm.Weyl.rootdatum-Tuple{AbstractMatrix}"><code>Gapjm.Weyl.rootdatum</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>rootdatum(C::AbstractMatrix)</code>  adjoint root datum  from Cartan matrix <code>C</code>. The adjoint group is also the default returned for <code>coxeter_group(type,rank)</code>. The following methods all define <code>pgl₃</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; rootdatum(cartan(:A,3))==coxgroup(:A,3)
true

julia&gt; rootdatum(:pgl,3)
pgl₃</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L766-L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.rootdatum-Tuple{AbstractMatrix, AbstractMatrix}" href="#Gapjm.Weyl.rootdatum-Tuple{AbstractMatrix, AbstractMatrix}"><code>Gapjm.Weyl.rootdatum</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>rootdatum(R::AbstractMatrix,CR::AbstractMatrix)</code></p><p>root  datum from <code>R</code> whose  rows are the simple  roots on a basis of <code>X(T)</code> and <code>CR</code> whose rows are the simple coroots on a basis of <code>Y(T)</code>. The following methods all define <code>gl₃</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; rootdatum(:gl,3)==rootdatum(&quot;gl&quot;,3)
true

julia&gt; rootdatum([1 -1 0;0 1 -1],[1 -1 0;0 1 -1])
A₂Φ₁</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L780-L794">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.describe_involution" href="#Gapjm.Weyl.describe_involution"><code>Gapjm.Weyl.describe_involution</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>describe_involution(W,w)</code></p><p>Given  an  involution  <code>w</code>  of  a  Coxeter  group  <code>W</code>,  by  a  theorem  of <a href="biblio.htm#rich82">Richardson1982</a>  there is  a unique  parabolic subgroup <code>P</code> of <code>W</code> such that that <code>w</code> is the longest element of <code>P</code>, and is central in  <code>P</code>. The function returns  <code>I</code> such that <code>P==reflection_subgroup(W,I)</code>, so that <code>w==longest(reflection_subgroup(W,I))</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; w=longest(W)
(1,5)(2,4)(3,6)

julia&gt; describe_involution(W,w)
1-element Vector{Int64}:
 3

julia&gt; w==longest(reflection_subgroup(W,[3]))
true</code></pre><p>For now only works for finite Coxeter groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L618-L642">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.badprimes" href="#Gapjm.Weyl.badprimes"><code>Gapjm.Weyl.badprimes</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>badprimes(W)</code></p><p>Let  <code>W</code>  be  a  Weyl  group.  A  prime  is  <em>bad</em>  for <code>W</code> if it divides a coefficient  of some  root on  the simple  roots. The  function <code>badprimes</code> returns the list of primes which are bad for <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,8)
E₈

julia&gt; badprimes(W)
3-element Vector{Int64}:
 5
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L595-L612">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.standard_parabolic-Tuple{FiniteCoxeterGroup, AbstractVector{&lt;:Integer}}" href="#Gapjm.Weyl.standard_parabolic-Tuple{FiniteCoxeterGroup, AbstractVector{&lt;:Integer}}"><code>Gapjm.Weyl.standard_parabolic</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>standard_parabolic(W,H)</code></p><p>Given  a reflection subgroup <code>H</code> or the indices of its simple roots returns <code>nothing</code> if <code>H</code> is not parabolic, otherwise returns <code>w</code> such that <code>H^w</code> is a standard parabolic subgroup of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,6)
E₆

julia&gt; R=reflection_subgroup(W,[20,30,19,22])
E₆₍₁₉‚₁‚₉‚₂₀₎=A₄₍₃₁₂₄₎Φ₁²

julia&gt; p=standard_parabolic(W,R)
(1,4,49,12,10)(2,54,62,3,19)(5,17,43,60,9)(6,21,34,36,20)(7,24,45,41,53)(8,65,50,15,22)(11,32,31,27,28)(13,48,46,37,40)(14,51,58,44,29)(16,23,35,33,30)(18,26,39,55,38)(42,57,70,72,56)(47,68,67,63,64)(52,59,71,69,66)

julia&gt; reflection_subgroup(W,[20,30,19,22].^p)
E₆₍₂₄₅₆₎=A₄Φ₁²

julia&gt; R=reflection_subgroup(W,[1,2,3,5,6,35])
E₆₍₁‚₃‚₂‚₃₅‚₅‚₆₎=A₂₍₁₃₎×A₂₍₂₆₎×A₂₍₄₅₎

julia&gt; standard_parabolic(W,R)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L544-L569">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.inversions" href="#Gapjm.CoxGroups.inversions"><code>Gapjm.CoxGroups.inversions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>inversions(W,w)</code></p><p>Returns  the inversions of the element <code>w</code> of the finite Coxeter group <code>W</code>, that  is, the list of the  indices of reflections <code>r</code> of <code>W</code> such that <code>l(rw)&lt;l(w)</code> where <code>l</code> is the Coxeter length.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; inversions(W,W(1,2,1))
3-element Vector{Int64}:
 1
 2
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/CoxGroups.jl#L619-L636">source</a></section><section><div><p><code>inversions(W::FiniteCoxeterGroup, w::AbstractVector{&lt;:Integer})</code></p><p>Given  a word <code>w=[s₁,…,sₙ]</code> (a vector of integers) representing the element <code>W(w...)</code>,  returns the inversions of <code>w</code>, that is the list of indices of the roots corresponding to the reflections: <code>W(s₁), W(s₁,s₂,s₁), …, W(s₁,s₂,…,sₙ,sₙ₋₁,…,s₁)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; inversions(W,W(1,2,1))
3-element Vector{Int64}:
 1
 2
 4

julia&gt; inversions(W,[2,1,2])
3-element Vector{Int16}:
 2
 4
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L480-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.with_inversions" href="#Gapjm.Weyl.with_inversions"><code>Gapjm.Weyl.with_inversions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>with_inversions(W,N)</code></p><p><code>W</code>  should be  a finite  Coxeter group  and <code>N</code>  a subset  of <code>1:nref(W)</code>. Returns  the  element  <code>w</code>  of  <code>W</code> such that <code>N==inversions(W,w)</code>. Returns <code>nothing</code> if no such element exists.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; map(N-&gt;with_inversions(W,N),combinations(1:nref(W)))
8-element Vector{Union{Nothing, Perm{Int16}}}:
 ()
 (1,4)(2,3)(5,6)
 (1,3)(2,5)(4,6)
 nothing
 nothing
 (1,6,2)(3,5,4)
 (1,2,6)(3,4,5)
 (1,5)(2,4)(3,6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L508-L530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.torus-Tuple{Integer}" href="#Gapjm.Weyl.torus-Tuple{Integer}"><code>Gapjm.Weyl.torus</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>torus(rank::Integer)</code></p><p>This  function returns the object corresponding to the notion of a torus of dimension  <code>rank</code>, a Coxeter  group of semisimple  rank 0 and given <code>rank</code>. This  corresponds to a split torus; the extension to Coxeter cosets is more useful.</p><pre><code class="language-julia-repl hljs">julia&gt; torus(3)
Φ₁³</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L817-L829">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.istorus" href="#Gapjm.Weyl.istorus"><code>Gapjm.Weyl.istorus</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>istorus(W)</code> whether <code>W</code> is a torus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L832">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Weyl.relative_group" href="#Gapjm.Weyl.relative_group"><code>Gapjm.Weyl.relative_group</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>relative_group(W::FiniteCoxeterGroup,J)</code></p><p><code>J</code>  should be a if <em>distinguished</em> subset of <code>S==eachindex(gens(W))</code>, that is  if for <code>s∈ S-J</code> we set <span>$v(s,J)=w₀^{J∪ s}w₀ᴶ$</span> then <code>J</code> is stable by all <code>v(s,J)</code>.   Then  <span>$R=N_W(W_J)/W_J$</span>  is  a   Coxeter  group  with  Coxeter generators  the  <code>v(s,J)</code>.  The  program  returns  <code>R</code>  in  its  reflection representation on <span>$X(ZL_J/ZG)$</span>. (according to <a href="biblio.htm#Lus76">Lusztig1976</a>,   the  images  of  the  roots  of  <code>W</code>  in <span>$X(ZL_J/ZG)$</span> form a root system).</p><p><code>R</code> has some extra properties reflecting its origin</p><ul><li><code>R.relativeIndices=setdiff(S,J)</code></li><li><code>R.parentMap=</code> the list of <code>v(s,J)</code> corresponding to <code>.relativeIndices</code>.</li><li><code>R.MappingFromNormalizer</code>  is  a  function  mapping <code>J</code>-reduced elements of</li></ul><p><span>$N_W(W_J)$</span> to elements of <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Weyl.jl#L1075-L1091">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Semisimple.affine" href="#Gapjm.Semisimple.affine"><code>Gapjm.Semisimple.affine</code></a> — <span class="docstring-category">Function</span></header><section><div><p>A  <em>generalized Cartan matrix</em> <code>C</code>  is a square integer  matrix of size <code>n</code> such  that <code>cᵢᵢ=2</code>, <code>cᵢⱼ≤0</code> if <code>i≠j</code>, and <code>cᵢⱼ==0</code> if and only if <code>cⱼᵢ==0</code>. We  say  that  <code>C</code>  is  <em>indecomposable</em>  if  it  does  not admit any block decomposition.</p><p>Let  <code>C</code> be a generalized  Cartan matrix. For <code>I</code>  a subset of <code>{1,…,n}</code> we denote  by <code>C_I</code> the square  submatrix with indices <code>i,j</code>  taken in <code>I</code>. If <code>v</code>  is a real vector of length <code>n</code>, we write <code>v&gt;0</code> if for all <code>i∈ {1,…,n}</code> we  have <code>vᵢ&gt;0</code>. It can be shown that <code>C</code> is a Cartan matrix if and only if for  all sets  <code>I</code>, we  have <code>det  C_I&gt;0</code>; or  equivalently, if and only if there  exists  <code>v&gt;0</code>  such  that  <code>C.v&gt;0</code>.  <code>C</code> is called an <em>affine Cartan matrix</em>  if for all proper subsets <code>I</code> we have <code>det C_I&gt;0</code>, but <code>det C==0</code>; or equivalently if there exists <code>v&gt;0</code> such that <code>C.v==0</code>.</p><p>Given  an  irreducible  Weyl  group  <code>W</code>  with  Cartan  matrix  <code>C</code>, we can construct  a generalized  Cartan matrix  <code>C̃</code> as  follows. Let  <code>α₀</code> be the opposed of the highest root. Then the matrix <span>$\left(\begin{array}{cc}C&amp;C.α₀\\  α₀.C&amp;2\end{array}\right)$</span> is  an  affine  Cartan  matrix.  The  affine  Cartan  matrices which can be obtained  in this way  are those we  are interested in,  which give rise to affine Weyl groups.</p><p>Let <code>d=n-rank(C)</code>. A <em>realization</em> of a generalized Cartan matrix is a pair <code>V,Vᵛ</code>  of vector spaces of dimension <code>n+d</code> together with vectors <code>α₁,…,αₙ∈ V</code>  (the <em>simple roots</em>), <code>αᵛ₁,…,αᵛₙ∈ Vᵛ</code> (the <em>simple coroots</em>), such that <code>(αᵛᵢ,  αⱼ)=c_{i,j}</code>.  Up  to  isomorphism,  a  realization  is obtained as follows: write <span>$C=\left(\begin{array}{c}C_1\\C_2\end{array}\right)$</span> where  <code>C₁</code> is  of same  rank as  <code>C</code>. Then  take <code>αᵢ</code>  to be the first <code>n</code> vectors  in a basis of <code>V</code>, and take <code>αᵛⱼ</code> to be given in the dual basis by the rows of the matrix <span>$\left(\begin{array}{cc}C₁&amp;0\\ C_2&amp;\hbox{Id}_d\\ \end{array}\right).$</span> To  <code>C</code> we associate a reflection group  in the space <code>V</code>, generated by the <em>fundamental  reflections</em>  <code>rᵢ</code>  given  by  <code>rᵢ(v)=v-(αᵛᵢ,v)αᵢ</code>. This is a Coxeter  group, called the <em>affine Weyl group</em> <code>ilde W</code> associated to <code>W</code> when we start with the affine Cartan matrix associated to a Weyl group <code>W</code>.</p><p>The  affine Weyl  group is  infinite; it  has one additional generator <code>s₀</code> (the  reflection with respect to <code>α₀</code>) compared  to <code>W</code>. We can not use <code>0</code> as  a label  by default  for a  generator of  a Coxeter  group (because the default  labels are used as indices, and indices start at 1 in Julia) so we label it as <code>n+1</code> where <code>n</code> is the numbers of generators of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=affine(coxgroup(:A,4))
Ã₄

julia&gt; diagram(W)
       ————5————
      /         Ã₄   1———2———3———4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/554f3ef029389032d1b73d35629f5da3a870cad1/src/Semisimple.jl#L703-L755">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="coxgroups.html">« Coxeter groups</a><a class="docs-footer-nextpage" href="permroot.html">Finite reflection groups »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 17 October 2022 17:39">Monday 17 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
