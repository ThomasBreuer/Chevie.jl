"""
Garside  monoids are a general class  of monoids whose most famous examples
are  the braid  and dual  braid monoids.  The implementation  of these last
monoids is in the framework of a general implementation of Garside monoids.

To   define  them  we  first  need   to  introduce  some  vocabulary  about
divisibility  in monoids. A *left divisor* of  `x` is a `d` such that there
exists  `y` with `x=dy` (and then we say  that `x` is a *right multiple* of
`d`).  We say that a monoid `M`  is left cancellable if an equality `dx=dy`
implies  `x=y`. We define symmetrically  right divisors, left multiples and
right cancellability. We say that `x` is an *atom* if it has no proper left
divisor (that is a `d` such that `x=dy` with `y‚â†1`) apart from `1`. A *left
gcd*  of `x` and `y` is a common left  divisor `d` of `x` and `y` such that
any  other common left divisor is a left divisor of `d`. Similarly a *right
lcm*  of `x` and  `y` is a  common multiple which  is a left divisor of any
other common multiple.

We  call *Garside* a monoid `M` which:
  * is left and right cancellable.
  * is generated by its atoms,  which are finite in number.
  * admits left and  right  gcds  and  lcms.
  * is such that any element has only finitely many left (or right) divisors.
  * admits a *Garside element*, which is an element `Œî` whose set of left
    and right divisors coincide and generate `M`.

Garside  elements are not  unique, but there  is a unique  minimal one (for
divisibility);  we assume a  Garside element `Œî`  has been chosen. Then the
divisors  of `Œî` are called  the *simples* of `M`.  A Garside monoid embeds
into  its group of fractions, which is  called a *Garside group* (a Garside
group  may have  several distinct  Garside structures,  as we  will see for
Braid groups of finite Coxeter groups).

We  also implement *locally Garside* monoids,  which are monoids where lcms
do  not always exist, but exist when any common multiple exists; the set of
simples  is then not defined using a  Garside element, but by the condition
that  they contain the atoms and are  closed under lcms and taking divisors
(see  [BDM01]); since it is not ensured by the existence of `Œî`, one has to
add  the condition that  any element is  divisible by finitely many simples
(but  the number of simples can be infinite). The main example is the braid
monoid of an infinite Coxeter group. It is not known if these monoids embed
in  their group of fractions (though that has been proved for braid monoids
of Coxeter groups by Paris [Paris01]) and thus computing in the monoid does
not help for computing in the group (only the monoid is implemented here).

What allows computing with Garside and locally Garside monoids, and Garside
groups,  is the fact  that they admit  normal forms ---  these normal forms
where exhibited for braid monoids of Coxeter groups by Deligne [Del72], who
extended previous work of Brieskorn, Saito [BS72] and Garside [Gar69]:

(i)
Let  `M` be a locally Garside monoid and let `b‚àà M`. Then there is a unique
maximal left simple divisor `Œ±(b)` of `b` --- any other simple dividing `b`
on the left divides `Œ±(b)` on the left.

(ii)
Assume  `M` is a Garside monoid, `Œî` is  its Garside element and `G` is its
group  of fractions. Then,  given any element  `x‚àà G`, there  is some power
`i` such that `Œî‚Å± x‚àà M`.

A consequence of (i) is that any element has a canonical decomposition as a
product of simples, called its left-greedy normal form. If we define `œâ(x)`
by  `x=Œ±(x)œâ(x)`, then the normal form of `x` is `Œ±(x)Œ±(œâ(x))Œ±(œâ^2(x))‚Ä¶` We
use  the normal form to represent elements  of `M`, and when `M` is Garside
(ii)  to represent elements  of `G`: given  `x‚àà G` we  compute the smallest
power  `i`  such  that  `Œî‚Å±  x‚àà  M`,  and  we  represent  `x` by the couple
`(i,Œî‚Åª‚Å±x)`.  We are thus reduced to the case where `x‚àà M`, not divisible by
`Œî`,  where we represent  `x` by the  sequence of simples which constitutes
its normal form. 

We  now describe Artin-Tits braid monoids. Let `(W,S)` be a Coxeter system,
that is `W` has presentation

`‚ü®s‚àà S‚à£s^2=1, sts‚ãØ =tst‚ãØ   (m‚Çõ‚Çú factors on each side) for s,t‚àà S‚ü©`

for  some Coxeter matrix `m‚Çõ‚Çú` for `s,t‚àà S`. The braid group `B` associated
to `(W,S)` is the group defined by the presentation

`‚ü®ùê¨‚àà ùêí‚à£ ùê¨ùê≠ùê¨‚ãØ =ùê≠ùê¨ùê≠‚ãØ  (m‚Çõ‚Çú factors on each side) for ùê¨,ùê≠‚àà ùêí‚ü©`

The *positive* braid monoid `B‚Å∫` associated to `W` is the monoid defined by
the  presentation above --- it identifies to the submonoid of `B` generated
by  `ùêí` by  the result  of Paris  mentioned above.  This monoid  is locally
Garside,  with set of simples  in bijection with elements  of `W` and atoms
the elements of `ùêí`; we will denote by `ùêñ ` the set of simples, and by `ùê∞ ‚Ü¶
w`  the bijection between simples and elements  of `W`. The group `W` has a
length  defined  in  terms  of  reduced expressions. Similarly, having only
homogeneous relations, `B‚Å∫` has a natural length function. Then `ùêñ ` can be
characterized  as the subset of the elements  of `B‚Å∫` of the same length as
their image in `W`.

If  `W` is finite, then `B‚Å∫` is Garside with Garside element the element of
`ùêñ  ` whose image is the longest element  of `W`. A finite Coxeter group is
also  a reflection group in  a real vector space,  thus in its complexified
`V`,  and `B` has also a topological definition as the fundamental group of
the  space `V ≥·µâ·µç/W`, where `V ≥·µâ·µç`  is the set of  elements of `V` which are
fixed  by no  non-identity element  of `S`;  however, we  will not use this
here.

Given a Coxeter group `W`,

# Examples
```julia-repl
julia> W=coxgroup(:A,4)
A‚ÇÑ

julia> B=BraidMonoid(W)
BraidMonoid(A‚ÇÑ)
```
constructs  the  associated  braid  monoid,  and  then  as  a  function 'B'
constructs  elements of the braid monoid (or group when `W` is finite) from
a list of generators.

```julia-repl
julia> w=B(1,2,3,4)
1234

julia> w^3
121321432.343

julia> word(W,Œ±(w^3))
9-element Array{Int64,1}:
 1
 2
 1
 3
 2
 1
 4
 3
 2

julia> w^4
Œî.232432

julia> inv(w)
(1234)‚Åª¬π
```

As  seen in the fourth  line above, the function  'Œ±(b)' returns the simple
`Œ±(b)‚àà ùêñ ` as an element of `W`.

How  an element of  a Garside group  is printed is  controlled by IOcontext
':greedy'.  By default, elements are printed  as fractions `a‚Åª¬πb` where `a`
and  `b` have no left common divisor. Each  of `a` and `b` is printed using
its left-greedy normal form, that is a maximal power of the Garside element
followed  the rest.  One can  print the  entire element  in the left-greedy
normal  from by setting the ':greedy' IOContext; with the same `w` as above
we have:

```julia-repl
julia> repr(w^-1,context=IOContext(stdout,:greedy=>true,:limit=>true))
"Œî‚Åª¬π.232432"
```
Finally,  `repr` gives   `w`  back   in  a   form  which   after  assigning
'B=BraidMonoid(W)' can be input back into Julia:

```julia-repl
julia> repr(w)
"B(1,2,3,4)"

julia> repr(w^3)
"B(1,2,1,3,2,1,4,3,2,3,4,3)"

julia> repr(w^-1)
"B(-4,-3,-2,-1)"
```
In  general elements of  a Garside monoid  are displayed thus  as a list of
their constituting atoms.

We  now describe the dual braid monoid.  For that, we first give a possible
approach  to construct Garside monoids. Given a  group `W` and a set `S` of
generators  of `W` as a monoid, we  define the length `l(w)` as the minimum
number of elements of `S` needed to write `w`. We then define left divisors
of   `x`  as  the  `d`   such  that  there  exists   `y`  with  `x=dy`  and
`l(d)+l(y)=l(x)`.  We say that  `w‚àà W` is  balanced if its  set of left and
right  divisors coincide,  is a  lattice (where  upper and lower bounds are
lcms and gcds) and generates `W`. Then we have:

suppose `w` is balanced and let `[1,w]` be its set of divisors (an interval
for  the partial order  defined by divisibility).  Then the monoid `M` with
generators  `[1,w]` and relations  `xy=z` whenever `xy=z`  holds in `W` and
`l(x)+l(y)=l(z)`  is Garside,  with simples  `[1,w]` and  atoms `S`.  It is
called the interval monoid defined by the interval `[1,w]`.

The  Artin-Tits braid monoid  is an interval  monoid by taking  for `S` the
Coxeter generators, in which case `l` is the Coxeter length, and taking for
`w`  the longest element of `W`. The dual monoid, constructed by Birman, Ko
and  Lee  for  type  `A`  and  by  Bessis  for  all  well-generated complex
reflection  groups, is obtained in  a similar way, by  taking this time for
`S`  the set of all reflections, and for `w` a Coxeter element; then `l` is
the  reflection length  'reflength' (for  well-generated complex reflection
groups  whihc are not real `S` contains only those reflections which divide
`w`  for the  reflection length);  for the  dual monoid  the simples are of
cardinality  the  generalized  Catalan  numbers.  An  interval  monoid  has
naturally  an inverse morphism from `M`  to `W`, called 'EltBraid' which is
the  quotient map from the  interval monoid to `W`  which sends back simple
braids to `[1,w]`.
#A  last notable  notion is  *reversible* monoids.  Since in Chevie we store
#only  left normal forms, it is easy to compute left lcms and gcds, but hard
#to  compute right ones.  But this becomes  easy to do  if the monoid has an
#operation  'reverse', which has the property that  'a' is a left divisor of
#'b'  if and only if  'reverse(a)' is a right  divisor of 'reverse(b)'. This
#holds  for Artin-Tits  and dual  braid monoids;  Artin-Tits monoids  have a
#reverse  operation which consists of reversing a word, written as a list of
#atoms.  The dual monoid  also has a  reverse operation defined  in the same
#way,  but this operation changes  monoid: it goes from  the dual monoid for
#the  Coxeter element `w` to the dual  monoid for the Coxeter element `w‚Åª¬π`.
#The  operations 'RightLcm' and  'RightGcd', as well  quite a few algorithms
#have faster implementations if the monoid has a reverse operation.

This module implements functions to solve the conjugacy problem and compute
centralizers  in Garside groups, following the work of Franco, Gebhardt and
Gonzalez-Meneses.

Two  elements `w` and `w'` of a monoid  `M` are *conjugate* in `M` if there
exists  `x‚àà M` such that `wx=xw'`; if  `M` satisfies the √ñre conditions, it
has  a  group  of  fractions  where  this  becomes  `x‚Åª¬πwx=w'`,  the  usual
definition  of conjugacy. A special case  which is even closer to conjugacy
in  the group is if there exists `y‚àà  M` such that `w=xy` and `w'=yx`. This
relation  is not transitive in general,  but we call *cyclic conjugacy* the
transitive closure of this relation, a restricted form of conjugacy.

The  next  observation  is  that  if  `w,w'`  are conjugate in the group of
fractions  of the Garside monoid `M` then  they are conjugate in `M`, since
if  `wx=xw'` then  there is  a power  `Œî‚Å±` which  is central and such that
`xŒî‚Å±‚àà M`. Then `wxŒî‚Å±=xŒî‚Å± w'` is a conjugation in `M`.

The  crucial observation for solving the  conjugacy problem is to introduce
`inf(w):=sup{i such  that  Œî‚Å±   divides  w}`  and
`sup(w):=inf{i such  that  w  divides Œî‚Å±}`, and to
notice  that the number of  conjugates of `w` with  same `inf` and `sup` as
`w`  is finite. Further, a  theorem of Birman shows  that the maximum `inf`
and  minimum `sup` in a conjugacy class can be achieved simultaneously; the
elements  achieving this are called the super summit set of `w`. Thus a way
to  determine if two elements are conjugate  is to find a representative of
both  of them in  their super summit  set, and then  solve conjugacy within
that  set. This can also be used  to compute the centralizer of an element:
if  we consider  the super  summit set  as the  objects of a category whose
morphisms are the conjugations by simple elements, the centralizer is given
by the endomorphisms of the given object.

We illustrate this on an example:

```julia-repl
julia> b=B(2,1,4,1,4)
214.14

julia> c=B(1,4,1,4,3)
14.143

julia> d=conjugating_elt(b,c)
(1)‚Åª¬π21321432

julia> b^d
14.143

julia> centralizer_generators(b)
3-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 4
 21.1         
 321432.213243

julia> C=conjcat(b;ss=:ss)
category with 10 objects and 32 generating maps

julia> C.obj
10-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 1214.4
 214.14
 124.24
 1343.1
 14.124
 143.13
 24.214
 134.14
 13.134
 14.143
```

There  is a faster  solution to the  conjugacy problem given in [gebgon10]:
for  each `b‚àà M`, they define a  particular simple left divisor of `b`, its
*preferred  prefix*  such  that  the  operation  *sliding* which cyclically
conjugates  `b` by  its preferred  prefix, is  eventually periodic, and the
period  is contained in the super summit set  of `x`. We say that `x` is in
its  sliding circuit if some  iterated sliding of `x`  is equal to `x`. The
set  of sliding  circuits in  a given  conjugacy class  is smaller than the
super  summit  set,  thus  allows  to  solve  the conjugacy problem faster.
Continuing from the above example,

```julia-repl
julia> word(W,preferred_prefix(b))
2-element Array{Int64,1}:
 2
 1

julia> b^B(preferred_prefix(b))
1214.4

julia> b1=b^B(preferred_prefix(b))
1214.4

julia> C=conjcat(b)
category with 2 objects and 6 generating maps

julia> C.obj
2-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 1214.4
 1343.1
```
Finally,  we have implemented  Hao Zheng's algorithm  to extract roots in a
Garside monoid:

```julia-repl
julia> W=coxgroup(:A,3)
A‚ÇÉ

julia> B=BraidMonoid(W)
BraidMonoid(A‚ÇÉ)

julia> Pi=B(B.Œ¥)^2
Œî¬≤

julia> root(Pi,2)
Œî

julia> root(Pi,3)
1232

julia> root(Pi,4)
132
```
"""
module Garside
using ..Gapjm
export BraidMonoid, braid, shrink, Œ±, DualBraidMonoid, conjcat, fraction,
centralizer_generators, preferred_prefix, left_divisors, Category,
endomorphisms, image, leftgcd, rightgcd, rightlcm, conjugating_elt

abstract type LocallyGarsideMonoid{T} end # T=type of simples
abstract type GarsideMonoid{T}<:LocallyGarsideMonoid{T} end

"""
`leftgcd(M::LocallyGarsideMonoid,elts...)`

`elts`  should be simples of  the monoid `M`. The  function return the left
gcd `d` of the `elts`, followed by a tuple of the complements `d^-1*elts[1],‚Ä¶`
"""
function leftgcd(M::LocallyGarsideMonoid{T},elts::Vararg{T,N})where {T,N}
  x=one(M)
  found=true
  while found
    found=false
    for (i,a) in enumerate(M.atoms)
      if all(b->isleftdescent(M,b,i),elts)
        found=true
        x=mul!(M,x,a)
        elts=map(y->\(M,a,y),elts)
      end
    end
  end
  return x,elts
end

"""
`rightgcd(M::LocallyGarsideMonoid,elts...)`

`elts`  should be simples of the monoid  `M`. The function return the right
gcd `d` of the `elts`, followed by a tuple of the complements `elts[1]*d^-1,‚Ä¶`
"""
function rightgcd(M::LocallyGarsideMonoid,elts...)
  x=one(M)
  found=true
  while found
    found=false
    for (i,a) in enumerate(M.atoms)
      if all(b->isrightdescent(M,b,i),elts)
        found=true
        x=*(M,a,x)
        elts=map(x->/(M,x,a),elts)
      end
    end
  end
  return x,elts
end

"""
returns Œ±(xv),œâ(xv)
"""
function Œ±2(M::LocallyGarsideMonoid,x,v)
  found=true
  while found
    found=false
    for (i,a) in enumerate(M.atoms)
      if isleftdescent(M,v,i) && isrightascent(M,x,i)
        x=*(M,x,a)
        v=\(M,a,v)
        found=true
      end
    end
  end
  (x,v)
end

# only 20% faster in julia
function Œ±2(M::GarsideMonoid,x,v)
  g,rests=leftgcd(M,rightcomplŒ¥(M,x),v)
  (*(M,x,g),rests[2])
end

"""
`rightlcm(M::GarsideMonoid,elts...)`

`elts`  should be simples of the monoid  `M`. The function return the right
lcm `m` of the `elts`, followed by a tuple of the complements `elts[1]^-1*m,‚Ä¶`
"""
function rightlcm(M::GarsideMonoid,elts...)
  x,c=rightgcd(M,rightcomplŒ¥.(Ref(M),elts)...)
  *(M,elts[1],c[1]),c
end

function (M::LocallyGarsideMonoid{T})(l::Integer...)where T
  res=GarsideElm(M,T[])
  if isempty(l) return res end
  for s in reverse(l) # faster in reversed order (see *)
    b=s<0 ? inv(GarsideElm(M,[M.atoms[-s]])) : GarsideElm(M,[M.atoms[s]])
    res=b*res
  end
  res
end

function (M::GarsideMonoid{T})(r::T)where T
  if r==one(M) GarsideElm(M,T[])
  elseif r==M.Œ¥ GarsideElm(M,T[],1)
  else GarsideElm(M,[r])
  end
end

CoxGroups.firstleftdescent(M::LocallyGarsideMonoid,w)=findfirst(
           i->isleftdescent(M,w,i),eachindex(M.atoms))
"""
`word(M::GarsideMonoid,w)`

returns a word in the atoms of `M` representing the simple `w`

```julia-repl
julia> B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia> word(B,B.Œ¥)
6-element Array{Int64,1}:
 1
 2
 1
 3
 2
 1
```
"""
function CoxGroups.word(M::LocallyGarsideMonoid,w)
  res=Int[]
  while true
    i=firstleftdescent(M,w)
    if i===nothing return res end
    push!(res,i)
    w=\(M,M.atoms[i],w)
  end
end

CoxGroups.word(io::IO,M::LocallyGarsideMonoid,w)=joindigits(word(M,w),"";sep=" ")

"""
left_divisors( M, s)

all  the left divisors of the simple element `s` of the Garside monoid `M`,
as  a vector  of vectors,  where the  i+1-th vector  holds the  divisors of
length i in the atoms.

```julia-repl
julia> W=coxgroup(:A,3)
A‚ÇÉ

julia> B=BraidMonoid(W)
BraidMonoid(A‚ÇÉ)

julia> map(x->B.(x),Garside.left_divisors(B,W(1,3,2)))
4-element Array{Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1},1}:
 [.]   
 [1, 3]
 [13]  
 [132] 

julia> B=DualBraidMonoid(W)
DualBraidMonoid(A‚ÇÉ,c=[1, 3, 2])

julia> map(x->B.(x),Garside.left_divisors(B,W(1,3,2)))
4-element Array{Array{Gapjm.Garside.GarsideElm{Perm{Int16},DualBraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1},1}:
 [.]                     
 [1, 2, 3, 4, 5, 6]      
 [12, 13, 15, 25, 34, 45]
 [Œ¥]                     
```
"""
function left_divisors(M::LocallyGarsideMonoid,s)
  rest=[(left=one(M),right=s)]
  res=[]
  while !isempty(rest)
    push!(res,rest)
    new=empty(res[1])
    for x in rest
      for i in eachindex(M.atoms)
        if isleftdescent(M,x.right,i)
          push!(new,(left=*(M,x.left,M.atoms[i]),right=\(M,M.atoms[i],x.right)))
        end
      end
    end
    rest=unique(new)
  end
  map(x->first.(x),res)
end

rightcomplŒ¥(M::GarsideMonoid,x)=\(M,x,M.Œ¥)
leftcomplŒ¥(M::GarsideMonoid,x)=/(M,M.Œ¥,x)
isrightascent(M::GarsideMonoid,x,i)=isleftdescent(M,rightcomplŒ¥(M,x),i)

# w^(M.Œ¥^i)
function Œ¥ad(M::GarsideMonoid,x,i::Integer)
  if IntervalStyle(M)==Interval() #horrible: has to know interval exists
    i=mod(i,M.orderŒ¥)
    return iszero(i) ? x : x^(M.Œ¥^i)
  end
  for j in i:-1:1 x=rightcomplŒ¥(M,rightcomplŒ¥(M,x)) end
  for j in i:-1   x=leftcomplŒ¥(M,leftcomplŒ¥(M,x)) end
  x
end

"""
`elements(M,l)`
    
`M`  should  be  a  (locally)  Garside  monoid which has an additive length
function  (that is, a product  of `l` atoms is  not equal to any product of
less  than `l` atoms). `GarsideWords(M,l)` returns  the list of elements of
length `l` in `M`.

```julia-repl
julia> M=BraidMonoid(coxgroup(:A,2))
BraidMonoid(A‚ÇÇ)

julia> elements(M,4)
12-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 1.1.1.1
 2.2.2.2
 21.12
 1.1.12
 2.21.1
 12.21
 2.2.21
 1.12.2
 12.2.2
 Œî.1
 Œî.2
 21.1.1
```
"""
function PermGroups.elements(M::LocallyGarsideMonoid,l)
  if !haskey(M.prop,:elements)
    M.prop[:elements]=Dict(0=>[M()],1=>M.(eachindex(M.atoms)))
  end
  RA(w)=filter(i->isrightascent(M,w,i),eachindex(M.atoms))
  if !haskey(M.prop[:elements],l)
    res=empty(M.prop[:elements][1])
    for b in elements(M,l-1)
      lb=length(b.elm)
      if iszero(lb) r=Int[]
      else
        r=RA(b.elm[lb])
        if lb==1 rr=Int[] else rr=RA(b.elm[lb-1]) end
        for s in r
          w=*(M,b.elm[lb],M.atoms[s])
          if !any(i->isleftdescent(M,w,i),rr)
            elm=copy(b.elm)
            elm[end]=w
            push!(res,norm(clone(b,elm)))
          end
        end
      end
      for i in setdiff(eachindex(M.atoms),r)
        push!(res,norm(clone(b,vcat(b.elm,[M.atoms[i]]))))
      end
    end
    M.prop[:elements][l]=collect(Set(res))
  end
  M.prop[:elements][l]
end

#--------------------Interval: a trait-----------------------------------
abstract type IntervalStyle end
struct Interval<:IntervalStyle end
struct NoInterval<:IntervalStyle end
IntervalStyle(M::LocallyGarsideMonoid)=NoInterval()

Base.one(M::LocallyGarsideMonoid)=one(IntervalStyle(M),M)
Base.one(::Interval,M)=one(M.W)
Base.:*(M::LocallyGarsideMonoid,x,y)=*(IntervalStyle(M),M,x,y)
Base.:*(::Interval,M,x,y)=x*y
Base.:\(M::LocallyGarsideMonoid,x,y)=\(IntervalStyle(M),M,x,y)
Base.:\(::Interval,M,x,y)=x\y
Base.:/(M::LocallyGarsideMonoid,x,y)=/(IntervalStyle(M),M,x,y)
Base.:/(::Interval,M,x,y)=x/y
Base.inv(M::LocallyGarsideMonoid,x)=inv(IntervalStyle(M),M,x)
Base.inv(::Interval,M,x)=inv(x)
isrightdescent(M::LocallyGarsideMonoid,w,i::Integer)=isrightdescent(IntervalStyle(M),M,w,i)
isrightdescent(::Interval,M,w,i)=isleftdescent(M.W,inv(w),i)
mul!(M::LocallyGarsideMonoid,x,y)=*(M,x,y)

#-----------------------BraidMonoid-----------------------------------
struct BraidMonoid{T,TW}<:GarsideMonoid{T}
  Œ¥::T
  orderŒ¥::Int
  stringŒ¥::String
  atoms::Vector{T}
  W::TW
  prop::Dict{Symbol,Any}
end

IntervalStyle(M::BraidMonoid)=Interval()
BraidMonoid(W::CoxeterGroup)=BraidMonoid(longest(W),2,"Œî",gens(W),W,
                                         Dict{Symbol,Any}())

Base.show(io::IO, M::BraidMonoid)=print(io,"BraidMonoid(",M.W,")")

CoxGroups.isleftdescent(M::BraidMonoid,w,i::Int)=isleftdescent(M.W,w,i)
CoxGroups.firstleftdescent(M::BraidMonoid,w)=firstleftdescent(M.W,w)

CoxGroups.word(M::BraidMonoid,w)=word(M.W,w)

function rightgcd(M::BraidMonoid{T,TW},elts::T...)where {T,TW}
  g,c=leftgcd(M,inv.(elts)...)
  inv(g),inv.(c)
end

mul!(M::BraidMonoid{<:Perm},x,y)=Perms.mul!(x,y)
#-----------------------GenBraidMonoid-----------------------------------
struct GenBraidMonoid{T,TW}<:LocallyGarsideMonoid{T}
  atoms::Vector{T}
  W::TW
  prop::Dict{Symbol,Any}
end

# The repetitions below reflect the poor type system of Julia
IntervalStyle(M::GenBraidMonoid)=Interval()
BraidMonoid(W::GenCox)=GenBraidMonoid(gens(W),W,Dict{Symbol,Any}())

Base.show(io::IO, M::GenBraidMonoid)=print(io,"BraidMonoid(",M.W,")")

CoxGroups.isleftdescent(M::GenBraidMonoid,w,i::Int)=isleftdescent(M.W,w,i)
CoxGroups.firstleftdescent(M::GenBraidMonoid,w)=firstleftdescent(M.W,w)

isrightdescent(M::GenBraidMonoid,w,i::Int)=isleftdescent(M.W,inv(w),i)
isrightascent(M::GenBraidMonoid,w,i::Int)=!isleftdescent(M.W,inv(w),i)

CoxGroups.word(M::GenBraidMonoid,w)=word(M.W,w)

function rightgcd(M::GenBraidMonoid{T,TW},elts::T...)where {T,TW}
  g,c=leftgcd(M,inv.(elts)...)
  inv(g),inv.(c)
end

#-----------------------DualBraidMonoid-------------------------------
struct DualBraidMonoid{T,TW}<:GarsideMonoid{T}
  Œ¥::T
  orderŒ¥::Int
  stringŒ¥::String
  atoms::Vector{T}
  W::TW
  prop::Dict{Symbol,Any}
end

IntervalStyle(M::DualBraidMonoid)=Interval()
"""
Let  `W` be a well generated complex  reflection group and `c` be a Coxeter
element  of `W` (if `W` is a Coxeter group and no `c` is given a particular
one  is chosen  by making  the product  of elements  in a  partition of the
Coxeter  diagram in two sets where  elements in each commute pairwise). The
result  is the dual braid  monoid determined by `W`  and `c`: let `w` be an
element  of `W` or a sequence  `s‚ÇÅ,‚Ä¶,s‚Çô` of integers indices of reflections
of `W`.

```julia-repl
julia> W=coxgroup(:A,3)
A‚ÇÉ

julia> B=DualBraidMonoid(W)
DualBraidMonoid(A‚ÇÉ,c=[1, 3, 2])

julia> B(2,1,2,1,1)
12.1.1.1

julia> B(-1,-2,-3,1,1)
(25.1)‚Åª¬π1.1
```
"""
function DualBraidMonoid(W::CoxeterGroup;c=reduce(vcat,bipartite_decomposition(W)))
  Œ¥=W(c...)
  DualBraidMonoid(Œ¥,order(Œ¥),"Œ¥",reflections(W)[1:nref(W)],W,
                  Dict{Symbol,Any}())
end

function CoxGroups.isleftdescent(M::DualBraidMonoid,w,i::Int)
  reflength(M.W,M.atoms[i]*w)<reflength(M.W,w)
end

Base.show(io::IO, M::DualBraidMonoid)=print(io,"DualBraidMonoid(",M.W,",c=",
                                            word(M.W,M.Œ¥),")")

function atomsinbraidmonoid(M::DualBraidMonoid)
  gets(M,:atomsinbraidmonoid)do
    W=M.W
    h=order(M.Œ¥)
    Œ¥=word(W,M.Œ¥)
    w=repeat(Œ¥,outer=div(h,2))
    if h%2!=0 append!(w,Œ¥[1:div(length(Œ¥),2)]) end
    if length(W,W(w...))!=length(w)
      w=repeat(Œ¥,outer=h)
    end
    w=map(i->vcat(w[1:i],-w[i-1:-1:1]),eachindex(w))
    B=BraidMonoid(W)
    w=unique!(map(x->B(x...),w))
    sort(w,by=x->findfirst(==(image(x)),reflections(W)))
  end
end

ordinary(M::DualBraidMonoid,s)=prod(atomsinbraidmonoid(M)[word(M,s)])

#---------------------------------------------------------------------
abstract type LocallyGarsideElm{T,TM<:LocallyGarsideMonoid} end

struct GarsideElm{T,TM}<:LocallyGarsideElm{T,TM}
  M::TM
  elm::Vector{T}
  pd::Int
end

struct GenGarsideElm{T,TM}<:LocallyGarsideElm{T,TM}
  M::TM
  elm::Vector{T}
end

GarsideElm(M::LocallyGarsideMonoid,elm)=GenGarsideElm(M,elm)
GarsideElm(M::GarsideMonoid,elm)=GarsideElm(M,elm,0)
clone(b::GenGarsideElm,elm)=GarsideElm(b.M,elm)
clone(b::GarsideElm,elm)=GarsideElm(b.M,elm,b.pd)
Base.one(b::GarsideElm)=GarsideElm(b.M,empty(b.elm),0)
Base.one(b::LocallyGarsideElm)=clone(b,empty(b.elm))
Base.copy(b::GarsideElm)=clone(b,copy(b.elm))

function Base.cmp(a::GarsideElm,b::GarsideElm)
  c=cmp(a.pd,b.pd)
  if c!=0 return c end
  cmp(a.elm,b.elm)
end

function Base.getindex(x::GarsideElm,i::Integer)
  M=x.M
  if i<=x.pd return M.Œ¥
  elseif i>x.pd+length(x.elm) return one(M)
  else return x.elm[i-x.pd]
  end
end

Base.isless(a::GarsideElm,b::GarsideElm)=cmp(a,b)==-1
Base.:(==)(a::GarsideElm,b::GarsideElm)=a.pd==b.pd && a.elm==b.elm

# hash is needed for using GarsideElm in Sets/Dicts
function Base.hash(a::GarsideElm, h::UInt)
  h=hash(a.pd, h)
  for e in a.elm
    h=hash(e, h)
  end
  h
end

function norm(a::GarsideElm)
  M=a.M
  i=1
  pd=a.pd
  while i<length(a.elm) && a.elm[i]==M.Œ¥ 
    i+=1
    pd+=1
  end
  j=length(a.elm)
  while j>0 && a.elm[j]==one(M)
    j-=1
  end
  i>1 || j<length(a.elm) ? GarsideElm(M,a.elm[i:j],pd) : a
end

function Base.inv(b::GarsideElm)
  k=length(b.elm)
  M=b.M
  GarsideElm(M,map(i->Œ¥ad(M,\(M,b.elm[i],M.Œ¥),-i-b.pd),k:-1:1),-b.pd-k)
end

"""
fraction(b)
returns a tuple `(x,y)`  of two  elements with  no non-trivial  common left
divisor and such that `b=inv(x)*y`.

```julia-repl
julia> B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia> b=B( 2, 1, -3, 1, 1)
(23)‚Åª¬π321.1.1

julia> fraction(b)
(23, 321.1.1)
```
"""
function fraction(b::GarsideElm)
  M=b.M
  if b.pd>=0 return [one(b),b] end
  if -b.pd>length(b.elm) return [inv(b),one(b)] end
  GarsideElm(M,inv(b).elm[length(b.elm)+b.pd+1:length(b.elm)]),
  GarsideElm(M,b.elm[1-b.pd:length(b.elm)])
end;

"""
`Œ±(b)`

`b` should be an element of a Garside monoid. ¬†`Œ±` returns the first simple
in the normal form of `b`.

```julia-repl
julia> W=coxgroup(:A,3)
A‚ÇÉ

julia> b=BraidMonoid(W)(2,1,2,1,1)
121.1.1

julia> word(W,Œ±(b))
3-element Array{Int64,1}:
 1
 2
 1
```
"""
function Œ±(b::GarsideElm)
  if b.pd<0 error("Œ±: element should be positive");
  elseif b.pd>0 return b.M.Œ¥
  end
  if length(b.elm)>0 return b.elm[1]
  else return one(b.M)
  end
end

"""
word(b::GarsideElm)
returns  a description  of `b`  as a  list of  the atoms  of which  it is a
product.  If `b` is in the Garside group  but not the Garside monoid, it is
represented  in  fraction  normal  form  where  as a special convention the
inverses  of  the  atoms  are  represented  by  negating  the corresponding
integer.

```julia-repl
julia> B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia> b=B(2,1,2,1,1)*inv(B(2,2))
(21)‚Åª¬π1.12.21

julia> word(b)
7-element Array{Int64,1}:
 -1
 -2
  1
  1
  2
  2
  1
```
"""
function CoxGroups.word(b::GarsideElm)
  M=b.M
  res=Int[]
  if b.pd<0 
    d,n=fraction(b)
    return vcat(-reverse(word(d)),word(n))
  end
  for i in 1:b.pd append!(res,word(M,M.Œ¥)) end
  for e in b.elm append!(res,word(M,e)) end
  res
end

CoxGroups.word(b::LocallyGarsideElm)=vcat(word.(Ref(b.M),b.elm)...)

function Base.show(io::IO,b::GarsideElm)
  M=b.M
  greedy=get(io,:greedy,false)
  if !get(io,:limit,false) && !get(io,:TeX,false)
    print(io,"B(",join(word(b),","),")")
    return
  end
  function p(b)
    l=join(map(e->word(io,M,e),b.elm),".")
    if b.pd==0 return l end
    if !isempty(l) l="."*l end
    return M.stringŒ¥*(b.pd!=1 ? "^{$(b.pd)}" : "")*l
  end
  if greedy
    printTeX(io,p(b))
  else
    den,num=map(x->fromTeX(io,p(x)),fraction(b))
    if den!="" printTeX(io,"($den)^{-1}")
      if num!="" print(io,"$num") end
    elseif num!="" print(io, num)
    else print(io,".")
    end
  end
end

function Base.show(io::IO,b::LocallyGarsideElm)
  M=b.M
  if !get(io,:limit,false) && !get(io,:TeX,false)
    print(io,"B(",join(word(b),","),")")
    return
  end
  function p(b)
    isempty(b.elm) ? "." : 
       join(map(e->joindigits(word(M,e),"";sep=" "),b.elm),".")
  end
  printTeX(io,p(b))
end

# like gap3 AddToNormal: multiply by simple
function Base.:*(a::LocallyGarsideElm,x)
  M=a.M
  if x==one(M) return a end # see if can suppress this special case
  v=copy(a.elm)
  push!(v,x)
  for i in length(v):-1:2
    x,y=Œ±2(M,v[i-1],v[i])
    if y==one(M) # this implies i==length(v)
      resize!(v,i-1) 
      v[i-1]=x 
    elseif x==v[i-1] break
    else v[[i-1,i]]=[x,y]
    end
  end
  GarsideElm(M,v)
end

function Base.:*(a::GarsideElm,x)
  M=a.M
  if x==one(M) return a end # see if can suppress this special case
  v=copy(a.elm)
  push!(v,x)
  for i in length(v):-1:2
    x,y=Œ±2(M,v[i-1],v[i])
    if y==one(M) # this implies i==length(v)
      if x==M.Œ¥
        return GarsideElm(M,Œ¥ad.(Ref(M),v[1:end-2],1),1+a.pd)
      end
      resize!(v,i-1) 
      v[i-1]=x 
    elseif x==v[i-1] break
    elseif x==M.Œ¥
      v[i]=y
      v[2:i-1]=Œ¥ad.(Ref(M),v[1:i-2],1)
      return GarsideElm(M,v[2:end],1+a.pd)
    else v[[i-1,i]]=[x,y]
    end
  end
  clone(a,v)
end

function Base.:*(a::LocallyGarsideElm,b::LocallyGarsideElm)
  res=a
  for x in b.elm 
    res*=x 
  end
  res
end

function Base.:*(a::GarsideElm,b::GarsideElm)
  res=GarsideElm(a.M,Œ¥ad.(Ref(a.M),a.elm,b.pd),a.pd+b.pd)
  for x in b.elm 
    res*=x 
  end
  res
end

# conjugation of b by simple r such that (b^r).pd>=b.pd
# About 2 times faster than (b,r)->b^b.M(r) for long words
#function Base.:^(b::GarsideElm{T},r::T) where T
#  M=b.M 
#  if r==one(M) return b end
#  l=*(M,b,r)
#  \(M,Œ¥ad(M,r,b.pd),l.elm[1])*clone(b,l.elm[2:end])
#end

Base.:^(y::GarsideElm{T},r::T,F=x->x) where T=inv(y.M(r))*(y*F(r))

Base.:^(a::LocallyGarsideElm, n::Integer)=n>=0 ? Base.power_by_squaring(a,n) :
                                             Base.power_by_squaring(inv(a),-n)

Base.:^(a::GarsideElm,b::GarsideElm,F=x->x)=inv(b)*a*F(b)

# multiply a simple x by a Garside element b; Gap's PrefixToNormal
function Base.:*(x,b::GarsideElm)
  M=b.M
  v=b.elm
  res=empty(v)
  pd=0
  x=Œ¥ad(M,x,b.pd)
  for i in 1:length(v)
    a,x=Œ±2(M,x,v[i])
    if a==M.Œ¥ pd+=1 else push!(res,a) end
    if x==v[i] return GarsideElm(M,append!(res,v[i:end]),pd+b.pd)
    elseif isone(x) return GarsideElm(M,append!(res,v[i+1:end]),pd+b.pd)
    end
  end
  GarsideElm(M,push!(res,x),pd+b.pd)
end

"""
`leftgcd(a1,..,an)` 

`a‚ÇÅ,‚Ä¶,a‚Çô`  should be elements of the same (locally) Garside monoid. returns
`(d,(d‚Åª¬πa‚ÇÅ,‚Ä¶,d‚Åª¬πa‚Çô))` where `d=leftgcd(a‚ÇÅ,‚Ä¶,a‚Çô)`.

```julia-repl
julia> W=coxgroup(:A,3)
A‚ÇÉ

julia> B=BraidMonoid(W)
BraidMonoid(A‚ÇÉ)

julia> leftgcd(B(2,1,2)^2,B(3,2)^2)
(2, (121.21, 32.2))
```
"""
function leftgcd(elts::GarsideElm...)
  if isempty(elts) error("leftgcd needs an argument") end
  if length(elts)==1 return (elts[1],(one(elts[1]),)) end
  M=elts[1].M
  m=minimum(map(x->x.pd,elts))
  gcd=GarsideElm(M,empty(elts[1].elm),m)
  elts=map(e->GarsideElm(M,e.elm),elts)
  while true
    ff=map(x->x[1],elts)
    if any(isone,ff) g=one(M)
    else g,rest=leftgcd(M,ff...)
    end
    if isone(g) return (gcd,elts)
    else gcd*=g
      elts=map((r,e)->r*GarsideElm(M,e.elm[2:end]),rest,elts)
    end
  end
end

function Cosets.Frobenius(x::GarsideElm,phi)
  y=deepcopy(x)
  y.elm.=Frobenius.(y.elm,phi)
  y
end

"""
`image(b::GarsideElm)`
    
This  function is defined only if `b`  is an element of an interval monoid,
for instance a braid. It returns the image of `b` in the group of which the
monoid  is an interval  monoid. For instance  it gives the  projection of a
braid in an Artin monoid back to the Coxeter group.

```julia-repl
julia> W=CoxSym(4)
ùîñ ‚ÇÑ

julia> b=BraidMonoid(W)(2,1,2,1,1)
121.1.1

julia> p=image(b)
Perm{UInt8}: (1,3)

julia> word(W,p)
3-element Array{Int64,1}:
 1
 2
 1
```
"""
function image(a::GarsideElm)
  if IntervalStyle(a.M)==Interval() a.M.Œ¥^a.pd*prod(a.elm)
  else error(a," should be an element of an interval monoid")
  end
end
#----------------------------------------------------------------------------
struct Category{TO,TM} # TO type of objs TM type of maps
  obj::Vector{TO}
  atoms::Vector{Vector{Pair{TM,Int}}}
  # atoms[i] is a list of (m=>j): map m from obj[i] to obj[j]
end

function Base.show(io::IO,C::Category)
  print(io,"category with ",length(C.obj)," objects and ",
        sum(length,C.atoms)," generating maps")
end

function Category(atomsfrom::Function,o;action::Function=^)
  TM=eltype(atomsfrom(o))
  C=Category([o],[Pair{TM,Int}[]])
  i=1
  while i<=length(C.obj) 
    b=C.obj[i]
    for m in atomsfrom(b)
      target=action(b,m)
      p=findfirst(isequal(target),C.obj)
  #	Print(b,"^",m.map,"->",m.tgt,"\n");
      if p===nothing
         push!(C.obj,target)
         push!(C.atoms,empty(C.atoms[1]))
         p=length(C.obj)
      end
      push!(C.atoms[i],m=>p)
    end
    i+=1
    if iszero(i%100) print(".") end
  end
  C
end

showgraph(C;k...)=showgraph(IOContext(stdout,:limit=>true),C;k...)

function showgraph(io,C::Category;showobj=show,showmap=show)
  maps=vcat(map(i->map(((m,t),)->[i,m,t],sort(C.atoms[i],by=x->abs(x[2]-i))),
                 eachindex(C.obj))...)
  found=true
  while found
    found=false
    new=empty(maps)
    for m in maps
      p=findfirst(x->x[end]==m[1],new)
      if p===nothing
        p=findfirst(x->x[1]==m[end],new)
        if p===nothing
          push!(new,m)
        else 
          new[p]=vcat(m[1:end-1],new[p])
          found=true
        end
      else new[p]=vcat(new[p],m[2:end])
           found=true
      end
    end
    maps=new
  end
  for f in maps
    l1=l2=""
    for i in 1:2:length(f)-2
      a=sprint(showobj,C.obj[f[i]];context=io)
      ff=sprint(showmap,f[i+1];context=io)
      l=max(2,textwidth(ff))
      if textwidth(l1)+textwidth(a)+l+1>displaysize(io)[2]
        println(io,l1,"\n",l2)
        l1=l2=""
      end
      l2*=a*'\u2500'^(l-1)*"‚Üí "
      l1*=' '^textwidth(a)*lpad(ff,l)*' '
    end
    println(io,l1,"\n",l2,C.obj[f[end]])
  end
end

"""
endomorphisms(C,o) 
for category C, returns generators of the endomorphisms of C.obj[o]
"""
function endomorphisms(C::Category{TO,TM},o)where {TO,TM}
  paths=[Tuple{Int,Int}[] for i in eachindex(C.obj)]
  paths[o]=Tuple{Int,Int}[]
  if isempty(C.atoms[o]) return TM[] end
  maps=[one(C.atoms[o][1][1]) for i in eachindex(C.obj)]
  function foo()
    reached=[o]
    for i in reached t=C.atoms[i]
      for (j,m) in enumerate(t)
        (mp,o1)=m
        if !(o1 in reached)
          paths[o1]=vcat(paths[i],[(i,j)])
          if i!=o maps[o1]=maps[i]*mp
          else maps[o1]=mp
          end
          push!(reached,o1)
          if length(reached)==length(C.obj) return end
        end
      end
    end
  end
  foo()
  # here paths[p] describes a path to get from obj o to  obj p
  gens=Set(empty(maps))
  for i in eachindex(C.obj)
    t=C.atoms[i]
    for j in eachindex(t)
     if vcat(paths[i],[(i,j)])!=paths[t[j][2]]
       if i==o nmap=t[j][1]
       else nmap=maps[i]*t[j][1]
        end
        if t[j][2]==o push!(gens,nmap)
        elseif nmap!=maps[t[j][2]] push!(gens,nmap*inv(maps[t[j][2]]))
        end
      end
    end
  end
  gens
end

function AtomicMaps(a,s::Symbol=:sc,F=(x,y=1)->x)
  M=a.M
  res=typeof(a)[]
  for i in eachindex(M.atoms)
    m=minc(a,M.atoms[i],Val(s),F)
    if m!==nothing && !any(k->isleftdescent(M,m,k),i+1:length(M.atoms))
      push!(res,M(m))
    end
  end
  filter(x->count(y->(inv(y)*x).pd>=0,res)==1,res)
end

# a braid x atom
function minc(a,x,::Val{:cyc},F=(x,y=1)->x)
  if a.pd>0 return x end
  if isempty(a.elm) return nothing end
  M=a.M
  if !isleftdescent(M,a.elm[1],findfirst(isequal(x),M.atoms)) return nothing end
  x
end

function preferred_prefix(b,F=(x,y=1)->x)
  M=b.M
  if isempty(b.elm) return one(M) end
  o=b.elm[end]
  F(\(M,o,Œ±2(M,o,F(Œ¥ad(M,b.elm[1],-b.pd)))[1]),-1)
end

# Inf(a,x)  minimal m such that x<m and inf(a^m)>=inf(a). 
# m is simple; see algorithm 2 in Franco-Gonzales 1.
function minc(a,x,::Val{:inf},F=(x,y=1)->x)
  M=a.M
  m=x
  while true
    x=Œ¥ad(M,m,a.pd)
    for s in a.elm x=rightlcm(M,x,s)[2][2] end
    m,c=rightlcm(M,x,F(m))
    m=F(m,-1)
    if c[2]==one(M) break end
  end
  m
end

# SS(a,x)  Assumes a in SSS(a). Returns minimal m such that x<m and
# a^m is in SSS(a). m is simple. See algorithm 5 in Franco-Gonzales 1
function minc(a,x,::Val{:ss},F=(x,y=1)->x)
  ai=inv(a)
  while true
    m=x
    x=minc(a,x,Val(:inf),F)
    x=F(minc(ai,F(x),Val(:inf),(x,y=1)->F(x,-y)),-1)
    if x==m return m end
  end
end

# representativeSC(b) returns
# (conj=minimal r such that b^r in sliding circuit, 
#  circuit=sliding circuit)
function representativeSC(b,F=(x,y=1)->x)
  seen=typeof(b)[]
  l=[[b,b^0]]
  while !(b in seen)
    push!(seen,b)
    e=b.M(preferred_prefix(b,F))
    b=^(b,e,F)
    push!(l,[b,l[end][2]*e])
  end
  t=findfirst(x->x[1]==b,l)
  (conj=l[t][2],circuit=first.(l[t:end-1]))
end

# minc(a::GarsideElm,x::simple,:sc) 
# minimal simple m such that x<m and a^m is in SC(a).
function minc(a,x,::Val{:sc},F=(x,y=1)->x)
  M=a.M
# Gebhart-Gonzalez function F for a in SC such that a^x in SSS
  function ggF(a,x,F)
    f=empty([(a,x)])
    y=a
    while true # find the history under sliding of (a,x)
      push!(f,(y,x))
      r=preferred_prefix(y,F)
      x=\(M,r,*(M,x,preferred_prefix(^(y,x,F),F)))
      if x==one(M) return [one(M)] end
      y=^(y,r,F)
      p=findfirst(==((y,x)),f)
      if p!==nothing break end
    end
    map(last,filter(x->x[1]==a,f[p:end]))
  end
  x=minc(a,x,Val(:ss),F)
  f=ggF(a,x,F)
  if f!=[one(M)]
    p=findfirst(s->leftgcd(M,x,s)[2][1]==one(M),f)
    p===nothing ? nothing : f[p]
  else p=preferred_prefix(a,F)
    if leftgcd(M,x,p)[2][1]!=one(M) return nothing end
#   l:=Filtered(Concatenation(LeftDivisorsSimple(M,p)),
#            s->s<>x and M.LeftGcdSimples(x,s)[2]=M.identity);
    l=left_divisors(M,\(M,x,p))
#   println("x=$x p=$p")
    l=.*(Ref(M),Ref(x),reduce(vcat,l[2:end];init=eltype(l)[]))
#   println("Warning: for b=",a," F=1 & x=",x," divides p=",p," ",length(l));
    l[findfirst(x->x==p || x in ggF(a,x,F),l)]
  end
end

minc(a,x,F=(x,y=1)->x)=minc(a,x,Val(:sc),F)

"""
'conjcat(b[,F];ss=:sc)'

returns  the conjugacy category  of the summit  set of `b`  of the required
type.  By default,  computes the  category of  sliding circuits  of `b`. If
`ss==:ss`,  computes  the  super  summit  set.  If `ss==:cyc`, computes the
cyclic  conjugacy category. Finally, if `ss==:inf` computes the category of
all conjugate elements with same `Inf` as `b`.

If  an argument  `F` is  given it  should be  the Frobenius of a Reflection
coset attached to `b.M.W`. Then the `F`-conjugacy category is returned.

```julia-repl
julia> W=coxgroup(:A,4)
A‚ÇÑ

julia> w=BraidMonoid(W)(4,3,3,2,1)
43.321

julia> conjcat(w)
category with 2 objects and 4 generating maps

julia> conjcat(w).obj
2-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 32143
 21324

julia> conjcat(w;ss=:ss).obj
4-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 32143
 13243
 21432
 21324
```
"""
function conjcat(b,F=(x,y=1)->x;ss::Symbol=:sc)
  if ss==:sc || ss==:ss b=representativeSC(b,F).circuit[1] end
  Category(x->AtomicMaps(x,ss,F),b;action=(b,m)->^(b,m,F))
end

"""
conjugating_elt(b,b1[,F];ss=:sc)

`b`  and `b1` should  be elements of  the same Garside  group. The function
returns  `a` such that `b^a=b1` if such exists, and `nothing` otherwise. If
an  argument `ss`  is given,  the computation  is done in the corresponding
category  --- see "conjcat".  If an argument  `F` is given  it should be an
automorphism  of the braid monoid, like the Frobenius of a reflection coset
attached  to `b.M.W`;  the computation  is then  done in  the corresponding
`F`-conjugacy category.

```julia-repl
julia> W=coxgroup(:D,4)
D‚ÇÑ

julia> B=BraidMonoid(W)
BraidMonoid(D‚ÇÑ)

julia> b=B(2,3,1,2,4,3);b1=B(1,4,3,2,2,2)
1432.2.2

julia> conjugating_elt(b,b1)
(134312.23)‚Åª¬π

julia> c=conjugating_elt(b,b1;ss=:cyc)
232.2

julia> b^c
1432.2.2

julia> WF=spets(W,Perm(1,2,4))
¬≥D‚ÇÑ

julia> F=Frobenius(WF);

julia> c=B(3,4,3,1,2,3)
343123

julia> conjugating_elt(b,c,F)
124312

julia> ^(b,B(1,2,4,3,1,2),F)
343123
```
"""
function conjugating_elt(b,c,F=(x,y=1)->x;ss::Symbol=:sc)
  if ss==:sc || ss==:ss
    bconj=representativeSC(b,F)
    cconj=representativeSC(c,F)
    b=bconj.circuit[1]
    bconj=bconj.conj
    c=cconj.circuit[1] 
    cconj=cconj.conj
    if b.pd!=c.pd || length(b.elm)!=length(c.elm) return nothing end
  else
    bconj=cconj=one(b)
  end
  if b==c return bconj*cconj^-1 end
  res=[bconj]
  class=[b]
  for (i,a) in enumerate(class)
    for m in AtomicMaps(a,ss,F)
      target=^(a,m,F)
      if !(target in class)
        e=res[i]*m
        if target==c 
          return e*cconj^-1 
        end
        push!(class,target)
        push!(res,e)
      end
    end 
  end
end

"""
`centralizer_generators(b[,F];ss=:sc)`

a  list of generators of the centralizer of `b`. The computation is done by
computing  the  endomorphisms  of  the  object  `b`  in the category of its
sliding  circuits. If an argument `ss` is given, the computation is done in
the corresponding category --- see `conjcat`.

If  an argument  `F` is  given it  should be  an automorphism  of the braid
monoid,  like the Frobenius of a reflection coset attached to `b.M.W`; then
the `F`-centralizer is computed.

```julia-repl
julia> W=coxgroup(:D,4)
D‚ÇÑ

julia> B=BraidMonoid(W)
BraidMonoid(D‚ÇÑ)

julia> w=B(4,4,4)
4.4.4

julia> cc=centralizer_generators(w)
8-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 (2)‚Åª¬π34.432
 4
 (32431)‚Åª¬π132431
 2
 1
 (31432)‚Åª¬π231432
 (1)‚Åª¬π34.431
 34.43

julia> shrink(cc)
5-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 4            
 2            
 1            
 34.43        
 (3243)‚Åª¬π13243

julia> centralizer_generators(w;ss=:cyc)
Set{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}}} with 1 element:
  4

julia> F=Frobenius(spets(W,Perm(1,2,4)));

julia> centralizer_generators(w,F)
2-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},FiniteCoxeterGroup{Perm{Int16},Int64}}},1}:
 312343123
 124      
```
"""
function centralizer_generators(b,F=(x,y=1)->x;ss::Symbol=:sc)
  if ss==:ss || ss==:sc
    b=representativeSC(b,F)
    a=b.conj
    b=b.circuit[1]
    Ref(a).*endomorphisms(conjcat(b,F;ss=ss),1).*Ref(a^-1)
  else
    endomorphisms(conjcat(b,F;ss=ss),1)
  end
end

#----------------------------------------------------------------------------
struct TwistedPowerMonoid{T,TM}<:GarsideMonoid{T}
  Œ¥::T
  orderŒ¥::Int
  stringŒ¥::String
  atoms::Vector{T}
  n::Int # twisting
  M::TM
  prop::Dict{Symbol,Any}
end

struct TPMSimple{T,TM}
  v::Vector{T}
  t::Bool
  M::TM
end

Base.:(==)(a::TPMSimple,b::TPMSimple)=(a.v==b.v)&&(a.t==b.t)&&(a.M==b.M)

Base.hash(a::TPMSimple, h::UInt)=hash(a.v,hash(a.t,hash(a.M,h)))

function Base.show(io::IO,r::TPMSimple)
  if r.t print(io,"t") end
  print(io,"(",join(map(a->joindigits(word(r.M,a)),r.v),","),")")
end

function TwistedPowerMonoid(M,n)
  Œ¥=TPMSimple([M.Œ¥ for i in 1:n],true,M)
  atoms=[TPMSimple([one(M) for i in 1:n],true,M)]
  for i in 1:n
    append!(atoms,map(a->
      TPMSimple([j==i ? a : one(M) for j in 1:n],false,M),
      M.atoms))
  end
  TwistedPowerMonoid(Œ¥,n*M.orderŒ¥,M.stringŒ¥*"_n",atoms,n,M,Dict{Symbol,Any}())
end

function isrightdescent(M::TwistedPowerMonoid,s,i::Integer)
  if i==1 return s.t end
  i1,i2=1 .+divrem(i-2,length(M.M.atoms))
  isrightdescent(M.M,s.v[i1],i2)
end

# function isrightascent(M,s,i)if i=1 then return !s.t end
#   i1,i2=1 .+divrem(i-2,length(M.M.atoms))
#   isrightascent(M.M,s.v[i1],i2)
# end

function CoxGroups.isleftdescent(M::TwistedPowerMonoid,s,i)
  if i==1 return s.t end
  i1,i2=1 .+divrem(i-2,length(M.M.atoms))
  isleftdescent(M.M,s.v[s.t ? 1+mod(i1-2,M.n) : i1],i2)
end

Base.one(M::TwistedPowerMonoid)=TPMSimple(
           [one(M.M) for i in 1:M.n],false,M.M)

Base.:*(M::TwistedPowerMonoid,a::TPMSimple,b::TPMSimple)=TPMSimple(
     map(i->*(M.M,a.v[b.t ? 1+mod(i,M.n) : i],b.v[i]),1:M.n),a.t||b.t,M.M)

Base.:\(M::TwistedPowerMonoid,a::TPMSimple,b::TPMSimple)=TPMSimple(
     map(i->\(M.M,a.v[b.t!=a.t ? 1+mod(i,M.n) : i],b.v[i]),1:M.n),b.t!=a.t,M.M)

Base.:/(M::TwistedPowerMonoid,a::TPMSimple,b::TPMSimple)=TPMSimple(
     map(i->/(M.M,a.v[b.t ? 1+mod(i-2,M.n) : i],
                  b.v[b.t ? 1+mod(i-2,M.n) : i]),1:M.n),a.t!=b.t,M.M)

function Base.show(io::IO,M::TwistedPowerMonoid)
  print(io,"twisted $(ordinal(M.n)) power of $(M.M)");
end

# Algorithm following Hao Zheng "A new approach to extracting roots in Garside
# groups" Comm. Algebra 34 (2006) 1793--1802
function Gapjm.root(b0::GarsideElm,n=2)
  M=b0.M
  tM=TwistedPowerMonoid(M,n)
  l=vcat(fill(M.Œ¥,b0.pd),b0.elm)
  b=GarsideElm(tM,map(eachindex(l)) do j
          TPMSimple([i==1 ? l[j] : one(M) for i in 1:n],j==1,M)
          end)
  function inner(b)
    cst=b->all(x->constant(x.v),b.elm)
    sc=representativeSC(b)
    conj=[sc.conj]
    class=[sc.circuit[1]]
    if cst(class[1]) return conj[1] end
    for a in class 
      for m in AtomicMaps(a)
        target=a^m
        if !(target in class)
          e=conj[findfirst(isequal(a),class)]*m
          if cst(target) return e end
          push!(class,target)
          push!(conj,e)
        end
      end
    end
  end
  conj=inner(b)
  if conj==nothing return nothing end
  a=b^conj
  a=GarsideElm(M,map(x->x.v[1],a.elm),a.pd)
  l=length(conj.elm)
  k=count(x->x.t,conj.elm)
  conj=norm(GarsideElm(M,vcat(map(i->conj.elm[i].v[1+mod(i,n)],1:k),
                              map(i->conj.elm[i].v[1+mod(k,n)],k+1:l)),conj.pd))
  conj*a*conj^-1
end
#----------------------------------------------------------------------------
"""
shrink(l)

The  list `l` is a  list of  elements of  the same Garside group `G`. This
function  tries to find  another set of  generators of the  subgroup of `G`
generated by the elements of `l`, of smaller total length (the length being
counted  as returned by the function  `word`).

```julia-repl
julia> B=BraidMonoid(CoxSym(3))
BraidMonoid(ùîñ ‚ÇÉ)

julia> b=[B(1)^3,B(2)^3,B(-2,-1,-1,2,2,2,2,1,1,2),B(1,1,1,2)]
4-element Array{Gapjm.Garside.GarsideElm{Perm{UInt8},BraidMonoid{Perm{UInt8},CoxSym{UInt8}}},1}:
 1.1.1              
 2.2.2              
 (1.12)‚Åª¬π2.2.2.21.12
 1.1.12             

julia> shrink(b)
2-element Array{Gapjm.Garside.GarsideElm{Perm{UInt8},BraidMonoid{Perm{UInt8},CoxSym{UInt8}}},1}:
 2  
 1  
```
"""
function shrink(b1::Vector{T})where T<:GarsideElm
  function f(b)
    ld,ln=length.(word.(fraction(b)))
    ld>ln ? (l=ld+ln,ld=ln,b=inv(b),s=true) : (l=ld+ln,ld=ld,b=b,s=true)
  end
  simplified=false
  function test(el,j)
    p=f(el)
    pos=findfirst(isequal(p),bs)
    if pos!==nothing && pos!=j
      print(" eliminated")
      simplified=true
      splice!(bs,max(pos,j))
      return true
    end
    if p>=bs[j] return false end
    print("<$(p.l)√∑$(p.ld)>")
    bs[j]=p
    simplified=true
    return false
  end
  bs=sort!(f.(b1))
  while true
    globsimplified=false
    print("#I total length $(sum(x->x.l,bs)) maximal length $(bs[end].l)\n")
    for j in length(bs):-1:2
      simplified=false
      print("#I $j:<$(bs[j].l)√∑$(bs[j].ld)>")
      for ab in bs
        if !bs[j].s && !ab.s continue end
        if ab>=bs[j] break end
        print(".")
        a=ab.b
        ai=inv(a)
        b=bs[j].b
        aib=ai*b
        bai=b*ai
#       print("i=",i,"bs[i]=",bs[i]," bs[j]=",bs[j],"\n")
        if test(aib,j) || test(bai,j) || test(aib*a,j) || 
           test(a*bai,j) || test(a*b,j) || test(b*a,j) 
         break end
      end
      if simplified globsimplified=true
      elseif j<=length(bs) bs[j]=(l=bs[j].l,ld=bs[j].ld,b=bs[j].b,s=false)
      else break
      end
      print("\n")
    end
    if !globsimplified 
      print("\n")
      break 
    end
    unique!(sort!(bs))
  end
  return map(x->x.b,bs)
end
B=BraidMonoid(CoxSym(21))
b=[
B(19,19,19),B(11,11),B(10,10,10,10),B(8,8,8),B(3,3,3),B(-1,-1,2,2,1,1),B(2,2,
2,2),B(-3,-1,-2,-2,-1,-13,-14,-15,-16,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,
-13,-14,-15,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-1,-2,-3,-4,-5,-6,-7,
-8,-9,-10,-11,-12,-13,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-1,-2,-3,-4,-5,-6,
-7,-8,-9,-10,-11,-15,-11,-12,-13,-14,-12,-13,-11,-12,-14,-12,-13,-13,14,13,13,
12,14,12,11,13,12,14,13,12,11,15,11,10,9,8,7,6,5,4,3,2,1,12,11,10,9,8,7,6,5,4,
3,2,13,12,11,10,9,8,7,6,5,4,3,2,1,14,13,12,11,10,9,8,7,6,5,4,3,2,15,14,13,12,
11,10,9,8,7,6,5,4,3,2,1,16,15,14,13,1,2,2,1,3),B(-3,-1,-2,-2,-1,-1,-2,-3,-4,
-2,-3,-1,-2,-4,-2,-3,-1,2,2,2,1,3,2,4,2,1,3,2,4,3,2,1,1,2,2,1,3),B(-3,-1,-2,
-2,-3,-4,-1,-2,-3,-3,-2,-2,3,3,3,2,2,3,3,2,1,4,3,2,2,1,3),B(-3,-1,-2,-2,-3,-4,
-1,-2,-3,-3,-4,-2,-3,-3,4,4,3,3,2,4,3,3,2,1,4,3,2,2,1,3),B(-3,-1,-2,-2,-3,-4,
-5,-6,-7,-8,-9,-10,-11,-12,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-3,-4,-5,-6,-7,
-8,-9,-10,-2,-3,-4,-5,-6,-7,-8,-9,-9,-10,-11,-12,-10,-11,-9,-10,-12,-10,11,10,
12,10,9,11,10,12,11,10,9,9,8,7,6,5,4,3,2,10,9,8,7,6,5,4,3,11,10,9,8,7,6,5,4,3,
2,1,12,11,10,9,8,7,6,5,4,3,2,2,1,3),B(-5,-4,-3,-1,-2,-2,3,2,2,1,3,4,5),B(-19,
-18,-17,-16,-15,-14,-13,12,13,14,15,16,17,18,19),B(-5,-4,-3,-2,-1,-1,-2,-3,-4,
-5,-5,-3,-4,-4,5,4,4,3,5,5,4,3,2,1,1,2,3,4,5),B(-1,2,2,2,1),B(-3,4,4,4,
3),B(-3,2,2,2,3),B(-1,-2,-3,4,4,3,2,1),B(-3,-2,1,1,2,3),B(-3,-2,-10,-9,-8,-7,
-5,-6,-4,-5,-2,-3,-4,-4,-2,3,3,3,2,4,4,3,2,5,4,6,5,7,8,9,10,2,3),B(-3,-2,-10,
-9,-8,-7,-5,-6,-4,-5,-2,-3,-4,-4,-5,-2,-3,4,3,2,5,4,4,3,2,5,4,6,5,7,8,9,10,2,
3),B(-3,-1,-2,-10,-11,-5,-6,-7,-8,-9,-10,-4,-5,-6,-7,-8,-9,-2,-3,-4,-5,-6,-7,
-8,-1,-2,-3,-4,-5,-6,-7,-1,-2,-3,-4,-5,-6,-6,-7,-8,-9,-10,-6,-7,-8,-9,-7,-8,
-6,-7,-9,-10,-9,-7,-8,-6,-7,-10,-9,-7,8,7,9,10,7,6,8,7,9,10,9,7,6,8,7,9,8,7,6,
10,9,8,7,6,6,5,4,3,2,1,7,6,5,4,3,2,1,8,7,6,5,4,3,2,9,8,7,6,5,4,10,9,8,7,6,5,
11,10,2,1,3),B(-3,-1,-2,-2,-3,-4,-1,-2,-3,-3,-2,-2,-3,-3,2,3,3,2,2,3,3,2,1,4,
3,2,2,1,3),B(-3,-1,-2,-2,-3,-4,-1,-2,-3,-3,-4,-2,3,3,3,2,4,3,3,2,1,4,3,2,2,1,
3),B(-3,-1,-2,-2,-1,-1,-2,-2,-3,-4,-2,-3,-1,-2,-4,-2,-3,-1,2,2,2,1,3,2,4,2,1,
3,2,4,3,2,2,1,1,2,2,1,3),B(-3,-1,-2,-2,-1,-1,-2,-3,-4,-2,-3,-1,-2,-4,-2,-3,-1,
-2,-2,3,3,3,2,2,1,3,2,4,2,1,3,2,4,3,2,1,1,2,2,1,3),B(-5,6,6,6,5),B(-5,4,4,4,
5),B(-5,-3,-4,-2,3,3,3,2,4,3,5),B(-5,-4,-3,-2,-15,-13,-14,-12,-13,-11,-12,-10,
-11,-2,-11,-12,-13,-8,-9,-10,-11,-12,-7,-8,-9,-10,-11,-6,-7,-8,-9,-10,-2,-3,
-4,-5,-6,-7,-8,9,8,7,6,5,4,3,2,10,9,8,7,6,11,10,9,8,7,12,11,10,9,8,13,12,11,2,
11,10,12,11,13,12,14,13,15,2,3,4,5),B(-5,-4,-3,-2,-2,-3,-3,-2,-2,-2,3,3,2,2,2,
3,3,2,2,3,4,5),B(-5,-6,-1,-2,-3,-4,5,5,5,5,4,3,2,1,6,5),B(-5,-6,-4,-5,-3,4,3,
5,4,6,5),B(-7,8,8,7),B(-5,-6,-7,-4,-5,-6,-3,-4,-5,-2,-3,4,3,2,5,4,3,6,5,4,7,6,
5),B(-15,-13,-14,-12,-13,-13,12,12,12,13,13,12,14,13,15),B(-15,-13,-14,-12,
-13,-15,-13,14,14,14,13,15,13,12,14,13,15),B(-15,-13,-14,-12,-13,-17,-16,-15,
-13,-14,-12,13,13,13,12,14,13,15,16,17,13,12,14,13,15),B(-15,-13,-14,-12,-13,
-18,-17,-16,-15,-13,-14,-12,13,12,14,13,15,16,17,18,13,12,14,13,15),B(-15,-16,
-13,-14,-12,-13,-16,-15,-13,-14,-12,13,12,14,13,15,16,13,12,14,13,16,
15),B(-13,-14,-15,-16,-14,-12,-13,-16,-15,-13,14,13,15,16,13,12,14,16,15,14,
13),B(-13,-14,-15,-16,-17,-14,-12,-13,-17,-16,-15,-13,-14,-12,13,13,12,14,13,
15,16,17,13,12,14,17,16,15,14,13),B(-17,-15,-16,-13,-14,-15,-12,-13,-14,-17,
-16,-14,15,14,16,17,14,13,12,15,14,13,16,15,17),B(-10,11,11,11,10),B(-10,-10,
-9,-8,-7,6,6,7,8,9,10,10),B(-10,-7,-8,9,8,7,10),B(-8,-9,-10,11,10,9,8),B(-10,
-11,-13,-14,-15,-16,-11,-12,-13,-14,-15,-8,-9,-10,-11,-12,-13,14,13,12,11,10,
9,8,15,14,13,12,11,16,15,14,13,11,10),B(-13,-14,-15,-16,-10,-11,-16,-11,-12,
-13,-14,-15,-7,-8,-9,-10,-11,-12,-13,14,13,12,11,10,9,8,7,15,14,13,12,11,16,
11,10,16,15,14,13),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,-11,-12,13,13,13,12,
11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,-11,-12,
-13,-13,-8,-9,-10,-11,-12,-7,-8,-9,-10,-11,-5,-6,-7,-8,-9,-10,-1,-2,-3,-4,-5,
-6,-7,-8,-9,-7,-9,-10,-7,-8,9,8,7,10,9,7,9,8,7,6,5,4,3,2,1,10,9,8,7,6,5,11,10,
9,8,7,12,11,10,9,8,13,13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,
-13,-11,-12,-10,-11,-15,-11,-12,-13,14,13,12,11,15,11,10,12,11,13,12,14,13,
15),B(-10,-9,-8,-7,6,6,6,7,8,9,10),B(-13,-14,-10,-11,-12,-13,-13,-11,-12,-10,
11,11,10,12,11,13,13,12,11,10,14,13),B(-10,-9,-8,-7,-5,-6,-3,-4,-5,-2,-3,4,4,
4,3,2,5,4,3,6,5,7,8,9,10),B(-10,-9,-8,-7,-6,-5,-4,-3,-2,1,2,3,4,5,6,7,8,9,
10),B(-10,-11,-9,10,9,11,10),B(-12,11,12),B(-8,-8,9,8,8),B(-10,-8,-9,-9,-8,-7,
-6,-5,-3,-4,-2,3,2,4,3,5,6,7,8,9,9,8,10),B(-13,12,12,13),B(-13,-12,11,12,
13),B(-13,-14,-12,-13,-11,12,12,12,11,13,12,14,13),B(-13,-14,-8,-9,-10,-11,
-12,-13,-7,-8,-9,-10,-11,-12,-5,-6,-7,-8,-9,-10,-11,-4,-5,-6,-7,-8,-9,10,9,8,
7,6,5,4,11,10,9,8,7,6,5,12,11,10,9,8,7,13,12,11,10,9,8,14,13),B(-15,16,16,16,
16,15),B(-15,14,14,14,15),B(-13,-14,-15,16,16,16,16,15,14,13),B(-10,-9,-8,-7,
-5,-6,-6,-3,-4,-5,-2,-3,4,3,2,5,4,3,6,6,5,7,8,9,10),B(-15,-13,-14,-12,13,13,
13,12,14,13,15),B(-15,-13,-14,-12,-13,-16,-15,-13,-14,-16,-14,15,15,14,16,14,
13,15,16,13,12,14,13,15),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,-11,-12,-13,
-13,-11,12,12,12,11,13,13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,
-13,-11,-12,-10,-11,-11,-12,-13,-13,-11,-8,-9,-10,-11,-12,-13,-7,-8,-9,-10,
-11,-12,-5,-6,-7,-8,-9,-10,-11,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-9,-7,-8,-10,-8,
-9,-7,8,7,9,8,10,8,7,9,10,9,8,7,6,5,4,3,2,1,11,10,9,8,7,6,5,12,11,10,9,8,7,13,
12,11,10,9,8,11,13,13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,-13,
-11,-12,-10,-11,-11,-12,-13,-13,-11,-8,-9,-10,-11,-12,-13,-7,-8,-9,-10,-11,
-12,-11,-9,-10,-12,-10,11,10,12,10,9,11,12,11,10,9,8,7,13,12,11,10,9,8,11,13,
13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,
-17,-18,-16,-17,-15,-16,-11,-12,-13,-14,-15,-13,-14,-11,-12,-13,-15,-13,14,13,
15,13,12,11,14,13,15,14,13,12,11,16,15,17,16,18,17,11,10,12,11,13,12,14,13,
15),B(-5,-4,-8,-7,-6,-4,5,4,6,7,8,4,5),B(-13,-14,-15,-16,17,17,17,16,15,14,
13),B(-13,-14,-15,-16,-10,-11,-12,-13,-14,15,14,13,12,11,10,16,15,14,13),B(-5,
-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,
-14,-15,-15,-16,-16,15,15,16,16,15,15,14,13,12,11,10,9,8,7,6,5,4,3,16,15,14,
13,12,11,10,9,8,7,6,5),B(-3,-3,-4,-2,3,2,4,3,3),B(-15,-13,-14,-12,-13,-11,-12,
-10,-11,-5,-4,-3,-11,-12,-13,-3,-2,-13,-8,-9,-10,-11,-12,-7,-8,-9,-10,-11,-6,
-7,-8,-9,-10,-2,-3,-4,-5,-6,-7,-8,-9,-9,-7,8,7,9,9,8,7,6,5,4,3,2,10,9,8,7,6,
11,10,9,8,7,12,11,10,9,8,13,2,3,13,12,11,3,4,5,11,10,12,11,13,12,14,13,
15),B(-17,-15,-16,-14,15,15,14,16,15,17),B(-17,-15,-16,-13,-14,-15,-12,-13,14,
14,14,13,12,15,14,13,16,15,17),B(-17,-16,-15,-14,-13,-12,-10,11,10,12,13,14,
15,16,17),B(-5,-6,-7,-8,-9,-10,-11,-12,-3,-4,-5,-6,-7,-8,-9,-10,-11,-11,-12,
-13,-14,-15,-16,-12,-13,-14,-15,-11,-12,-13,-14,-14,-15,-16,-15,-14,-16,-14,
15,15,15,15,14,16,14,15,16,15,14,14,13,12,11,15,14,13,12,16,15,14,13,12,11,11,
10,9,8,7,6,5,4,3,12,11,10,9,8,7,6,5),B(-17,-18,-19,-15,-16,-17,-18,-13,-14,
-15,-16,-17,-12,-13,-14,-15,-16,-11,-12,-13,-14,15,14,13,12,11,16,15,14,13,12,
17,16,15,14,13,18,17,16,15,19,18,17),B(-10,-3,-2,-10,-9,-8,-7,-6,-5,-4,-2,3,2,
4,5,6,7,8,9,10,2,3,10),B(-5,-4,-3,-2,-19,-17,-18,-15,-16,-17,-13,-14,-15,-16,
-8,-9,-10,-11,-12,-13,-14,-15,-7,-8,-9,-10,-11,-12,-13,-14,-6,-7,-8,-9,-10,
-11,-12,-13,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,12,11,10,9,8,7,6,5,4,3,2,13,12,11,
10,9,8,7,6,14,13,12,11,10,9,8,7,15,14,13,12,11,10,9,8,16,15,14,13,17,16,15,18,
17,19,2,3,4,5),B(-5,-4,-3,-2,-2,-3,-3,-2,-2,3,3,3,2,2,3,3,2,2,3,4,5)]
end
