"""
Garside  monoids are a general class  of monoids whose most famous examples
are  the braid  and dual  braid monoids.  The implementation  of these last
monoids is in the framework of a general implementation of Garside monoids.

To   define  them  we  first  need   to  introduce  some  vocabulary  about
divisibility  in monoids. A *left divisor* of  `x` is a `d` such that there
exists  `y` with `x=dy` (and then we say  that `x` is a *right multiple* of
`d`).  We say  that a  monoid `M`  is left  (resp. right) cancellable if an
equality `dx=dy` (resp. `xd=yd`) implies `x=y`. The divisor `d` is *proper*
if  `y‚â†1`. We say  that `x` is  an *atom* if  it has no proper left divisor
apart from `1`. A *left gcd* of `x` and `y` is a common left divisor `d` of
`x`  and `y` such that  any other common left  divisor is a left divisor of
`d`. Similarly a *right lcm* of `x` and `y` is a common multiple which is a
left divisor of any other common multiple.

We  call *Garside* a monoid `M` which is:
  * left and right cancellable.
  * generated by its atoms,  which are finite in number.
  * such that any element has only finitely many divisors.
  * admits left and  right  gcds  and  lcms.
  * admits a *Garside element*, which is an element `Œî` whose set of left
    and right divisors coincide and generate `M`.

Garside  elements are not  unique, but there  is a unique  minimal one (for
divisibility); we assume such an element has been chosen. Then the divisors
of  `Œî` are called the  *simples* of `M`. A  Garside monoid embeds into its
group  of fractions, which is called a *Garside group* (a Garside group may
have  several distinct Garside structures, as  we will see for Braid groups
of finite Coxeter groups).

We  also implement *locally Garside* monoids,  which are monoids where lcms
do  not always exist, but exist when any common multiple exists; the set of
simples  is then not defined using a  Garside element, but by the condition
that  they contain the atoms and are  closed under lcms and taking divisors
(see  [BDM01]); since it is not ensured by the existence of `Œî`, one has to
add  the condition that  any element is  divisible by finitely many simples
(but  the number of simples can be infinite). The main example is the braid
monoid of an infinite Coxeter group. It is not known if these monoids embed
in  their group of fractions (though that has been proved for braid monoids
of Coxeter groups by Paris [Paris01]) and thus computing in the monoid does
not help for computing in the group (only the monoid is implemented here).

What allows computing with Garside and locally Garside monoids, and Garside
groups,  is the fact  that they admit  normal forms ---  these normal forms
where  first exhibited for  braid monoids by  Deligne [Del72], who extended
previous work of Brieskorn, Saito [BS72] and Garside [Gar69]:

(i)
Let  `M` be a locally Garside monoid and let `b‚àà M`. Then there is a unique
maximal left simple divisor `Œ±(b)` of `b`, called the *head* of `b` --- any
other simple dividing `b` on the left divides `Œ±(b)` on the left.

(ii)
Assume  `M` is a Garside monoid, `Œî` is  its Garside element and `G` is its
group  of fractions. Then,  given any element  `x‚àà G`, there  is some power
`Œî‚Å±` such that `Œî‚Å± x‚àà M`.

A consequence of (i) is that any element has a canonical decomposition as a
product of simples, called its left-greedy normal form. If we define `œâ(x)`
by  `x=Œ±(x)œâ(x)`, then the normal form of `x` is `Œ±(x)Œ±(œâ(x))Œ±(œâ^2(x))‚Ä¶` We
use  the normal form to represent elements  of `M`, and when `M` is Garside
(ii)  to represent elements  of `G`: given  `x‚àà G` we  compute the smallest
power  `i`  such  that  `Œî‚Å±  x‚àà  M`,  and  we  represent  `x` by the couple
`(i,Œî‚Åª‚Å±x)`.  We are thus reduced to the case where `x‚àà M`, not divisible by
`Œî`,  where we represent  `x` by the  sequence of simples which constitutes
its normal form. We now describe Artin-Tits braid monoids. Let `(W,S)` be a
Coxeter system, that is `W` has presentation

`‚ü®s‚àà S‚à£s^2=1, sts‚ãØ =tst‚ãØ   (m‚Çõ‚Çú factors on each side) for s,t‚àà S‚ü©`

for  some Coxeter matrix `m‚Çõ‚Çú` for `s,t‚àà S`. The braid group `B` associated
to `(W,S)` is the group defined by the presentation

`‚ü®ùê¨‚àà ùêí‚à£ ùê¨ùê≠ùê¨‚ãØ =ùê≠ùê¨ùê≠‚ãØ  (m‚Çõ‚Çú factors on each side) for ùê¨,ùê≠‚àà ùêí‚ü©`

The *positive* braid monoid `B‚Å∫` associated to `W` is the monoid defined by
the  presentation above --- it identifies to the submonoid of `B` generated
by  `ùêí` by  the result  of Paris  mentioned above.  This monoid  is locally
Garside,  with set of simples  in bijection with elements  of `W` and atoms
the elements of `ùêí`; we will denote by `ùêñ ` the set of simples, and by `ùê∞ ‚Ü¶
w`  the bijection between simples and elements  of `W`. The group `W` has a
length  defined  in  terms  of  reduced expressions. Similarly, having only
homogeneous relations, `B‚Å∫` has a natural length function. Then `ùêñ ` can be
characterized  as the subset of the elements  of `B‚Å∫` of the same length as
their image in `W`.

If  `W` is finite, then `B‚Å∫` is Garside with Garside element the element of
`ùêñ  ` whose image is the longest element  of `W`. A finite Coxeter group is
also  a reflection group in  a real vector space,  thus in its complexified
`V`,  and `B` has also a topological definition as the fundamental group of
the  space `V ≥·µâ·µç/W`, where `V ≥·µâ·µç`  is the set of  elements of `V` which are
fixed  by no  non-identity element  of `S`;  however, we  will not use this
here.

Given a Coxeter group `W`,

# Examples
```julia-repl
julia> W=coxgroup(:A,4)
W(A‚ÇÑ)

julia> B=BraidMonoid(W)
BraidMonoid(coxgroup(:A,4))
```
constructs  the  associated  braid  monoid,  and  then  as  a  function 'B'
constructs  elements of the braid monoid (or group when `W` is finite) from
a list of generators.

```julia-repl
julia> w=B(1,2,3,4)
1234

julia> w^3
121321432.343

julia> word(W,Œ±(w^3))
9-element Array{Int64,1}:
 1
 2
 1
 3
 2
 1
 4
 3
 2

julia> w^4
Œ¥.232432

julia> inv(w)
(1234)‚Åª¬π
```

As  seen in the fourth  line above, the function  'Œ±(b)' returns the simple
`Œ±(b)‚àà ùêñ ` as an element of `W`.

How  an element of  a Garside group  is printed is  controlled by IOcontext
':greedy'.  By default, elements are printed  as fractions `a‚Åª¬πb` where `a`
and  `b` have no left common divisor. Each  of `a` and `b` is printed using
its left-greedy normal form, that is a maximal power of the Garside element
followed  the rest.  One can  print the  entire element  in the left-greedy
normal  from by setting the ':greedy' IOContext; with the same `w` as above
we have:

```julia-repl
julia> repr(w^-1,context=IOContext(stdout,:greedy=>true,:limit=>true))
"Œ¥‚Åª¬π.232432"
```
Finally,  `repr` gives   `w`  back   in  a   form  which   after  assigning
'B=braid(braid_monoid(W))' can be input back into Julia:

```julia-repl
julia> repr(w)
"B(1,2,3,4)"

julia> repr(w^3)
"B(1,2,1,3,2,1,4,3,2,3,4,3)"

julia> repr(w^-1)
"B(-4,-3,-2,-1)"
```
In  general elements of  a Garside monoid  are displayed thus  as a list of
their constituting atoms.
"""
module Garside
#
#We  now describe the dual braid monoid.  For that, we first give a possible
#approach  to construct Garside monoids. Given a  group `W` and a set `S` of
#generators  of `W` as a monoid, we  define the length `l(w)` as the minimum
#number of elements of `S` needed to write `w`. We then define left divisors
#of   `x`  as  the  `d`   such  that  there  exists   `y`  with  `x=dy`  and
#`l(d)+l(y)=l(x)`.  We say that `w‚àà W` is  balanced if its set of left and
#right  divisors coincide,  is a  lattice (where  upper and lower bounds are
#lcms and gcds) and generates `W`. Then we have:
#
#suppose `w` is balanced and let `[1,w]` be its set of divisors (an interval
#for  the partial order  defined by divisibility).  Then the monoid `M` with
#generators  `[1,w]` and relations  `xy=z` whenever `xy=z`  holds in `W` and
#`l(x)+l(y)=l(z)`  is Garside,  with simples  `[1,w]` and  atoms `S`.  It is
#called the interval monoid defined by the interval `[1,w]`.
#
#The  Artin-Tits braid monoid  is an interval  monoid by taking  for `S` the
#Coxeter generators, in which case `l` is the Coxeter length, and taking for
#`w`  the longest element of `W`. The dual monoid, constructed by Birman, Ko
#and  Lee  for  type  `A`  and  by  Bessis  for  all  well-generated complex
#reflection  groups, is obtained in  a similar way, by  taking this time for
#`S`  the set of all reflections, and for `w` a Coxeter element; then `l` is
#the  'ReflectionLength',  see  "ReflectionLength";  (this  is  for  Coxeter
#groups;  for  well-generated  complex  reflection  groups `S` contains only
#those reflections which divide `w` for the reflection length); for the dula
#monoid  the simple are  of cardinality the  generalized Catalan numbers. An
#interval  monoid has naturally an inverse  morphism from `M` to `W`, called
#'EltBraid'  which is the quotient map from the interval monoid to `W` which
#sends back simple braids to `[1,w]`.
#
#A  last notable  notion is  *reversible* monoids.  Since in CHEVIE we store
#only  left normal forms, it is easy to compute left lcms and gcds, but hard
#to  compute right ones.  But this becomes  easy to do  if the monoid has an
#operation  'reverse', which has the property that  'a' is a left divisor of
#'b'  if and only if  'reverse(a)' is a right  divisor of 'reverse(b)'. This
#holds  for Artin-Tits  and dual  braid monoids;  Artin-Tits monoids  have a
#reverse  operation which consists of reversing a word, written as a list of
#atoms.  The dual monoid  also has a  reverse operation defined  in the same
#way,  but this operation changes  monoid: it goes from  the dual monoid for
#the  Coxeter element `w` to the dual  monoid for the Coxeter element `w‚Åª¬π`.
#The  operations 'RightLcm' and  'RightGcd', as well  quite a few algorithms
#have faster implementations if the monoid has a reverse operation.
#
#We  have implemented functions  to solve the  conjugacy problem and compute
#centralizers  in Garside groups, following the work of Franco, Gebhardt and
#Gonzalez-Meneses [gebgon10] and [fragon03].
#
#Two  elements `w` and `w'` of a monoid  `M` are *conjugate* in `M` if there
#exists  `x‚àà M` such that `wx=xw'`; if  `M` satisfies the √ñre conditions, it
#has  a  group  of  fractions  where  this  becomes  `x‚Åª¬πwx=w'`,  the  usual
#definition  of conjugacy. A special case  which is even closer to conjugacy
#in  the group is if there exists `y‚àà  M` such that `w=xy` and `w'=yx`. This
#relation  is not transitive in general,  but we call *cyclic conjugacy* the
#transitive closure of this relation, a restricted form of conjugacy.
#
#The  next  observation  is  that  if  `w,w'`  are conjugate in the group of
#fractions  of the Garside monoid `M` then  they are conjugate in `M`, since
#if  `wx=xw'` then  there is  a power  `Œî‚Å±` which  is central and such that
#`xŒî‚Å±‚àà M`. Then `wxŒî‚Å±=xŒî‚Å± w'` is a conjugation in `M`.
#
#The  crucial observation for solving the  conjugacy problem is to introduce
#`inf(w):=sup{i such  that  Œî‚Å±   divides  w}`  and
#`sup(w):=inf{i such  that  w  divides Œî‚Å±}`, and to
#notice  that the number of  conjugates of `w` with  same `inf` and `sup` as
#`w`  is finite. Further, a  theorem of Birman shows  that the maximum `inf`
#and  minimum `sup` in a conjugacy class can be achieved simultaneously; the
#elements  achieving this are called the super summit set of `w`. Thus a way
#to  determine if two elements are conjugate  is to find a representative of
#both  of them in  their super summit  set, and then  solve conjugacy within
#that  set. This can also be used  to compute the centralizer of an element:
#if  we consider  the super  summit set  as the  objects of a category whose
#morphisms are the conjugations by simple elements, the centralizer is given
#by the endomorphisms of the given object.
#
#We illustrate this on an example:
#
#|    gap> w:=B(2,1,4,1,4);
#    214.14
#    gap> ConjugacySet(w,"SS"); # super summit set
#    [ 1214.4, 214.14, 124.24, 1343.1, 14.124, 143.13, 24.214, 134.14,
#      13.134, 14.143 ]
#    gap> RepresentativeConjugation(w,B(1,4,1,4,3));
#    (1)^-1.21321432
#    gap> w^B(-1,2,1,3,2,1,4,3,2);
#    14.143
#    gap> CentralizerGenerators(w);
#    [ 4, 321432.213243, 21.1 ]|
#
#There  is a faster  solution to the  conjugacy problem given in [gebgon10]:
#for  each `b‚àà M`, they define a  particular simple left divisor of `b`, its
#*preferred  prefix*  such  that  the  operation  *sliding* which cyclically
#conjugates  `b` by  its preferred  prefix, is  eventually periodic, and the
#period  is contained in the super summit set  of `x`. We say that `x` is in
#its  sliding circuit if some  iterated sliding of `x`  is equal to `x`. The
#set  of sliding  circuits in  a given  conjugacy class  is smaller than the
#super  summit  set,  thus  allows  to  solve  the conjugacy problem faster.
#Continuing from the above example,
#
#|    gap> CoxeterWord(W,PreferredPrefix(w));
#    [ 2, 1 ]
#    gap> w^B(PreferredPrefix(w));
#    1214.4
#    gap> last^B(PreferredPrefix(last));
#    1214.4
#    gap> ConjugacySet(w,"SC"); # set of sliding circuits
#    [ 1214.4, 1343.1 ]|
#
#Finally,  we have implemented  Hao Zheng's algorithm  to extract roots in a
#Garside monoid:
#
#|    gap> W:=coxgroup("A",3);; M:=BraidMonoid(W);
#    BraidMonoid(coxgroup("A",3))
#    gap> pi:=M.B(M.delta)^2;
#    w0.w0
#    gap> GetRoot(pi,2);
#    w0
#    gap> GetRoot(pi,3);
#    1232
#    gap> GetRoot(pi,4);
#    132|
using Gapjm
export BraidMonoid, braid, shrink, Œ±

abstract type AbstractIntervalMonoid{T,TW<:Group{T}} end

function deltaaction(M::AbstractIntervalMonoid,w,i::Int)
# w^(M.delta^i)
  i=mod(i,M.orderdelta)
  if iszero(i) return w end
  w^(i==1 ? M.delta : M.delta^i)
end

"""
elts must be simples
"""
function leftgcd(M::AbstractIntervalMonoid,elts...)
  x=one(M.W)
  elts=collect(elts)
  found=true
  while found
    found=false
    for i in eachindex(M.atoms)
    let M=M, i=i
      if all(b->isleftdescent(M,b,i),elts)
        found=true
        Perms.mul!(x,M.atoms[i])
        elts .= M.atoms[i] .\ elts
      end
    end
    end
  end
  return x,elts
end

"""
returns Œ±(xv),œâ(xv)
"""
function alpha2(M::AbstractIntervalMonoid,x,v)
  g,rests=leftgcd(M,inv(x)*M.delta,v)
  (x*g,rests[2])
end

#-----------------------BraidMonoid-----------------------------------
struct BraidMonoid{T,TW}<:AbstractIntervalMonoid{T,TW}
  delta::T
  orderdelta::Int
  atoms::Vector{T}
  W::TW
end

BraidMonoid(W::CoxeterGroup)=BraidMonoid(longest(W),2,gens(W),W)

Base.show(io::IO, M::BraidMonoid)=print(io,"BraidMonoid($(M.W))")

function CoxGroups.isleftdescent(M::BraidMonoid,w,i::Int)
   isleftdescent(M.W,w,i)
end

function CoxGroups.word(M::BraidMonoid,w)
  word(M.W,w)
end

function (M::BraidMonoid{T})(l::Int...)where T
  res=GarsideElm(0,T[],M)
  if isempty(l) return res end
  for s in reverse(l) # faster in reversed order (see *)
    if s<0 b=inv(GarsideElm(0,[M.atoms[-s]],M))
    else   b=GarsideElm(0,[M.atoms[s]],M)
    end
    res=b*res 
  end
  res
end

#-----------------------DualBraidMonoid-------------------------------
struct DualBraidMonoid{T,TW}<:AbstractIntervalMonoid{T,TW}
  delta::T
  orderdelta::Int
  atoms::Vector{T}
  W::TW
end

function DualBraidMonoid(W::CoxeterGroup{T},delta::T=prod(gens(W)))where T
  DualBraidMonoid(delta,order(delta),reflections(W),W)
end

#---------------------------------------------------------------------
struct GarsideElm{T,TM<:AbstractIntervalMonoid}
  pd::Int
  elm::Vector{T}
  M::TM
end

Base.one(b::GarsideElm)=GarsideElm(0,empty(b.elm),b.M)
Base.copy(b::GarsideElm)=GarsideElm(b.pd,b.elm,b.M)

function Base.cmp(a::GarsideElm,b::GarsideElm)
  c=cmp(a.pd,b.pd)
  if c!=0 return c end
  cmp(a.elm,b.elm)
end

Base.isless(a::GarsideElm,b::GarsideElm)=cmp(a,b)==-1
Base.:(==)(a::GarsideElm,b::GarsideElm)=cmp(a,b)==0

# hash is needed for using permutations in Sets/Dicts
function Base.hash(a::GarsideElm, h::UInt)
  b = 0x595dee0e71d271d0%UInt
  b = xor(b,xor(hash(a.pd, h),h))
  b = (b << 1) | (b >> (sizeof(Int)*8 - 1))
  for e in a.elm
    b = xor(b,xor(hash(e, h),h))
    b = (b << 1) | (b >> (sizeof(Int)*8 - 1))
  end
  b
end

function Base.inv(b::GarsideElm)
  k=length(b.elm)
  M=b.M
  GarsideElm(-b.pd-k,
    map(i->deltaaction(M,inv(b.elm[i])*M.delta,-i-b.pd),k:-1:1),M)
end

function fraction(b::GarsideElm)
  M=b.M
  if b.pd>=0 return [one(b),b] end
  if -b.pd>length(b.elm) return [inv(b),one(b)] end
  GarsideElm(0,inv(b).elm[length(b.elm)+b.pd+1:length(b.elm)],M),
  GarsideElm(0,b.elm[1-b.pd:length(b.elm)],M)
end;

function Œ±(b)
  if b.pd<0 error("Œ±: element should be positive");
  elseif b.pd>0 return b.M.delta
  end
  if length(b.elm)>0 return b.elm[1]
  else return b.M.identity
  end
end

function CoxGroups.word(b::GarsideElm)
  M=b.M
  res=Int[]
  if b.pd<0 
    d,n=fraction(b)
    return vcat(-reverse(word(d)),word(n))
  end
  for i in 1:b.pd append!(res,word(M,M.delta)) end
  for e in b.elm append!(res,word(M,e)) end
  res
end

function Base.show(io::IO,b::GarsideElm)
  M=b.M
  repl=get(io,:limit,false)
  TeX=get(io,:TeX,false)
  greedy=get(io,:greedy,false)
  if !repl && !TeX 
    print(io,"B("*join(word(b),",")*")")
    return
  end
  function p(b)
    l=join(map(b.elm) do e
      w=word(M,e)
      pad=any(x->x>=10,w) ? " " : ""
      return join(map(string,w),pad)
    end,".")
    if b.pd==0 return l end
    if !isempty(l) l="."*l end
    return b.pd!=1 ? "Œ¥^{$(b.pd)}$l" : "Œ¥$l"
  end
  if greedy
   print(io,TeXstrip(p(b)))
  else
   den,num=map(x->TeXstrip(p(x)),fraction(b))
   if den!="" print(io,TeXstrip("($den)^{-1}"))
      if num!="" print(io,"$num") end
    elseif num!="" print(io, num)
    else print(io,".")
    end
  end
end

function Base.:*(a::GarsideElm{T},x::T)::GarsideElm{T} where T
  v=copy(a.elm)::Vector{T}
  push!(v,x)
  M=a.M
  for i in length(v):-1:2
    x,y=alpha2(M,v[i-1],v[i])
#   y=M.one
    if y==one(T) # this implies i==Length(v)
      if x==M.delta
        return GarsideElm(1+a.pd,v[1:end-2].^M.delta,M)
      end
      resize!(v,i-1) 
      v[i-1]=x 
    elseif x==v[i-1] return GarsideElm(a.pd,v,M)
    elseif x==M.delta
      v[i]=y
      v[2:i-1]=v[1:i-2].^M.delta
      return GarsideElm(1+a.pd,v[2:end],M)
    else v[[i-1,i]]=[x,y]
    end
  end
  GarsideElm(a.pd,v,M)
end

function Base.:*(a::GarsideElm,b::GarsideElm)
  res=GarsideElm(a.pd+b.pd,copy(a.elm),a.M)
  res.elm.=deltaaction.(Ref(a.M),res.elm,Ref(b.pd))
  for x in b.elm res*=x end
  res
end

Base.:^(a::GarsideElm, n::Integer)= n>=0 ? Base.power_by_squaring(a,n) : 
                                   Base.power_by_squaring(inv(a),-n)

function shrink(b1::Vector{T})where T<:GarsideElm
  function f(b::GarsideElm)
    ld,ln=map(x->length(word(x)),fraction(b))
    if ld>ln return (l=ld+ln,ld=ln,b=inv(b),s=true)
    else return (l=ld+ln,ld=ld,b=b,s=true)
    end
  end
  simplified=false
  function test(el::GarsideElm,j::Int)
    p=f(el)
    pos=findfirst(isequal(p),bs)
    if !isnothing(pos) && pos!=j
      print(" eliminated")
      splice!(bs,max(pos,j))
      return true
    end
    if p>=bs[j] return false end
    print("<$(p.l)√∑$(p.ld)>");
    bs[j]=p
    simplified=true
    return false
  end
  bs=map(f,b1)
  sort!(bs)
  while true
    globsimplified=false
    print("#I total length $(sum(x->x.l,bs)) maximal length $(bs[end].l)\n")
    for j in length(bs):-1:2
      simplified=false
      print("#I $j:<$(bs[j].l)√∑$(bs[j].ld)>")
      for ab in bs
        if !bs[j].s && !ab.s continue end
        if ab>=bs[j] break end
        print(".")
        a=ab.b
        ai=inv(a)
        b=bs[j].b
        aib=ai*b
        bai=b*ai
#       print("i=",i,"bs[i]=",bs[i]," bs[j]=",bs[j],"\n")
        if test(aib,j) || test(bai,j) || test(aib*a,j) || 
           test(a*bai,j) || test(a*b,j) || test(b*a,j) 
         break end
      end
      if simplified globsimplified=true
      elseif j<=length(bs) bs[j]=(l=bs[j].l,ld=bs[j].ld,b=bs[j].b,s=false)
      else break
      end
      print("\n")
    end
    if !globsimplified 
      print("\n")
      break 
    end
    unique!(sort!(bs))
  end
  return map(x->x.b,bs)
end
B=BraidMonoid(coxsym(21))
b=[
B(19,19,19),B(11,11),B(10,10,10,10),B(8,8,8),B(3,3,3),B(-1,-1,2,2,1,1),B(2,2,
2,2),B(-3,-1,-2,-2,-1,-13,-14,-15,-16,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,
-13,-14,-15,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-1,-2,-3,-4,-5,-6,-7,
-8,-9,-10,-11,-12,-13,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-1,-2,-3,-4,-5,-6,
-7,-8,-9,-10,-11,-15,-11,-12,-13,-14,-12,-13,-11,-12,-14,-12,-13,-13,14,13,13,
12,14,12,11,13,12,14,13,12,11,15,11,10,9,8,7,6,5,4,3,2,1,12,11,10,9,8,7,6,5,4,
3,2,13,12,11,10,9,8,7,6,5,4,3,2,1,14,13,12,11,10,9,8,7,6,5,4,3,2,15,14,13,12,
11,10,9,8,7,6,5,4,3,2,1,16,15,14,13,1,2,2,1,3),B(-3,-1,-2,-2,-1,-1,-2,-3,-4,
-2,-3,-1,-2,-4,-2,-3,-1,2,2,2,1,3,2,4,2,1,3,2,4,3,2,1,1,2,2,1,3),B(-3,-1,-2,
-2,-3,-4,-1,-2,-3,-3,-2,-2,3,3,3,2,2,3,3,2,1,4,3,2,2,1,3),B(-3,-1,-2,-2,-3,-4,
-1,-2,-3,-3,-4,-2,-3,-3,4,4,3,3,2,4,3,3,2,1,4,3,2,2,1,3),B(-3,-1,-2,-2,-3,-4,
-5,-6,-7,-8,-9,-10,-11,-12,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-3,-4,-5,-6,-7,
-8,-9,-10,-2,-3,-4,-5,-6,-7,-8,-9,-9,-10,-11,-12,-10,-11,-9,-10,-12,-10,11,10,
12,10,9,11,10,12,11,10,9,9,8,7,6,5,4,3,2,10,9,8,7,6,5,4,3,11,10,9,8,7,6,5,4,3,
2,1,12,11,10,9,8,7,6,5,4,3,2,2,1,3),B(-5,-4,-3,-1,-2,-2,3,2,2,1,3,4,5),B(-19,
-18,-17,-16,-15,-14,-13,12,13,14,15,16,17,18,19),B(-5,-4,-3,-2,-1,-1,-2,-3,-4,
-5,-5,-3,-4,-4,5,4,4,3,5,5,4,3,2,1,1,2,3,4,5),B(-1,2,2,2,1),B(-3,4,4,4,
3),B(-3,2,2,2,3),B(-1,-2,-3,4,4,3,2,1),B(-3,-2,1,1,2,3),B(-3,-2,-10,-9,-8,-7,
-5,-6,-4,-5,-2,-3,-4,-4,-2,3,3,3,2,4,4,3,2,5,4,6,5,7,8,9,10,2,3),B(-3,-2,-10,
-9,-8,-7,-5,-6,-4,-5,-2,-3,-4,-4,-5,-2,-3,4,3,2,5,4,4,3,2,5,4,6,5,7,8,9,10,2,
3),B(-3,-1,-2,-10,-11,-5,-6,-7,-8,-9,-10,-4,-5,-6,-7,-8,-9,-2,-3,-4,-5,-6,-7,
-8,-1,-2,-3,-4,-5,-6,-7,-1,-2,-3,-4,-5,-6,-6,-7,-8,-9,-10,-6,-7,-8,-9,-7,-8,
-6,-7,-9,-10,-9,-7,-8,-6,-7,-10,-9,-7,8,7,9,10,7,6,8,7,9,10,9,7,6,8,7,9,8,7,6,
10,9,8,7,6,6,5,4,3,2,1,7,6,5,4,3,2,1,8,7,6,5,4,3,2,9,8,7,6,5,4,10,9,8,7,6,5,
11,10,2,1,3),B(-3,-1,-2,-2,-3,-4,-1,-2,-3,-3,-2,-2,-3,-3,2,3,3,2,2,3,3,2,1,4,
3,2,2,1,3),B(-3,-1,-2,-2,-3,-4,-1,-2,-3,-3,-4,-2,3,3,3,2,4,3,3,2,1,4,3,2,2,1,
3),B(-3,-1,-2,-2,-1,-1,-2,-2,-3,-4,-2,-3,-1,-2,-4,-2,-3,-1,2,2,2,1,3,2,4,2,1,
3,2,4,3,2,2,1,1,2,2,1,3),B(-3,-1,-2,-2,-1,-1,-2,-3,-4,-2,-3,-1,-2,-4,-2,-3,-1,
-2,-2,3,3,3,2,2,1,3,2,4,2,1,3,2,4,3,2,1,1,2,2,1,3),B(-5,6,6,6,5),B(-5,4,4,4,
5),B(-5,-3,-4,-2,3,3,3,2,4,3,5),B(-5,-4,-3,-2,-15,-13,-14,-12,-13,-11,-12,-10,
-11,-2,-11,-12,-13,-8,-9,-10,-11,-12,-7,-8,-9,-10,-11,-6,-7,-8,-9,-10,-2,-3,
-4,-5,-6,-7,-8,9,8,7,6,5,4,3,2,10,9,8,7,6,11,10,9,8,7,12,11,10,9,8,13,12,11,2,
11,10,12,11,13,12,14,13,15,2,3,4,5),B(-5,-4,-3,-2,-2,-3,-3,-2,-2,-2,3,3,2,2,2,
3,3,2,2,3,4,5),B(-5,-6,-1,-2,-3,-4,5,5,5,5,4,3,2,1,6,5),B(-5,-6,-4,-5,-3,4,3,
5,4,6,5),B(-7,8,8,7),B(-5,-6,-7,-4,-5,-6,-3,-4,-5,-2,-3,4,3,2,5,4,3,6,5,4,7,6,
5),B(-15,-13,-14,-12,-13,-13,12,12,12,13,13,12,14,13,15),B(-15,-13,-14,-12,
-13,-15,-13,14,14,14,13,15,13,12,14,13,15),B(-15,-13,-14,-12,-13,-17,-16,-15,
-13,-14,-12,13,13,13,12,14,13,15,16,17,13,12,14,13,15),B(-15,-13,-14,-12,-13,
-18,-17,-16,-15,-13,-14,-12,13,12,14,13,15,16,17,18,13,12,14,13,15),B(-15,-16,
-13,-14,-12,-13,-16,-15,-13,-14,-12,13,12,14,13,15,16,13,12,14,13,16,
15),B(-13,-14,-15,-16,-14,-12,-13,-16,-15,-13,14,13,15,16,13,12,14,16,15,14,
13),B(-13,-14,-15,-16,-17,-14,-12,-13,-17,-16,-15,-13,-14,-12,13,13,12,14,13,
15,16,17,13,12,14,17,16,15,14,13),B(-17,-15,-16,-13,-14,-15,-12,-13,-14,-17,
-16,-14,15,14,16,17,14,13,12,15,14,13,16,15,17),B(-10,11,11,11,10),B(-10,-10,
-9,-8,-7,6,6,7,8,9,10,10),B(-10,-7,-8,9,8,7,10),B(-8,-9,-10,11,10,9,8),B(-10,
-11,-13,-14,-15,-16,-11,-12,-13,-14,-15,-8,-9,-10,-11,-12,-13,14,13,12,11,10,
9,8,15,14,13,12,11,16,15,14,13,11,10),B(-13,-14,-15,-16,-10,-11,-16,-11,-12,
-13,-14,-15,-7,-8,-9,-10,-11,-12,-13,14,13,12,11,10,9,8,7,15,14,13,12,11,16,
11,10,16,15,14,13),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,-11,-12,13,13,13,12,
11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,-11,-12,
-13,-13,-8,-9,-10,-11,-12,-7,-8,-9,-10,-11,-5,-6,-7,-8,-9,-10,-1,-2,-3,-4,-5,
-6,-7,-8,-9,-7,-9,-10,-7,-8,9,8,7,10,9,7,9,8,7,6,5,4,3,2,1,10,9,8,7,6,5,11,10,
9,8,7,12,11,10,9,8,13,13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,
-13,-11,-12,-10,-11,-15,-11,-12,-13,14,13,12,11,15,11,10,12,11,13,12,14,13,
15),B(-10,-9,-8,-7,6,6,6,7,8,9,10),B(-13,-14,-10,-11,-12,-13,-13,-11,-12,-10,
11,11,10,12,11,13,13,12,11,10,14,13),B(-10,-9,-8,-7,-5,-6,-3,-4,-5,-2,-3,4,4,
4,3,2,5,4,3,6,5,7,8,9,10),B(-10,-9,-8,-7,-6,-5,-4,-3,-2,1,2,3,4,5,6,7,8,9,
10),B(-10,-11,-9,10,9,11,10),B(-12,11,12),B(-8,-8,9,8,8),B(-10,-8,-9,-9,-8,-7,
-6,-5,-3,-4,-2,3,2,4,3,5,6,7,8,9,9,8,10),B(-13,12,12,13),B(-13,-12,11,12,
13),B(-13,-14,-12,-13,-11,12,12,12,11,13,12,14,13),B(-13,-14,-8,-9,-10,-11,
-12,-13,-7,-8,-9,-10,-11,-12,-5,-6,-7,-8,-9,-10,-11,-4,-5,-6,-7,-8,-9,10,9,8,
7,6,5,4,11,10,9,8,7,6,5,12,11,10,9,8,7,13,12,11,10,9,8,14,13),B(-15,16,16,16,
16,15),B(-15,14,14,14,15),B(-13,-14,-15,16,16,16,16,15,14,13),B(-10,-9,-8,-7,
-5,-6,-6,-3,-4,-5,-2,-3,4,3,2,5,4,3,6,6,5,7,8,9,10),B(-15,-13,-14,-12,13,13,
13,12,14,13,15),B(-15,-13,-14,-12,-13,-16,-15,-13,-14,-16,-14,15,15,14,16,14,
13,15,16,13,12,14,13,15),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,-11,-12,-13,
-13,-11,12,12,12,11,13,13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,
-13,-11,-12,-10,-11,-11,-12,-13,-13,-11,-8,-9,-10,-11,-12,-13,-7,-8,-9,-10,
-11,-12,-5,-6,-7,-8,-9,-10,-11,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-9,-7,-8,-10,-8,
-9,-7,8,7,9,8,10,8,7,9,10,9,8,7,6,5,4,3,2,1,11,10,9,8,7,6,5,12,11,10,9,8,7,13,
12,11,10,9,8,11,13,13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,-13,
-11,-12,-10,-11,-11,-12,-13,-13,-11,-8,-9,-10,-11,-12,-13,-7,-8,-9,-10,-11,
-12,-11,-9,-10,-12,-10,11,10,12,10,9,11,12,11,10,9,8,7,13,12,11,10,9,8,11,13,
13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,
-17,-18,-16,-17,-15,-16,-11,-12,-13,-14,-15,-13,-14,-11,-12,-13,-15,-13,14,13,
15,13,12,11,14,13,15,14,13,12,11,16,15,17,16,18,17,11,10,12,11,13,12,14,13,
15),B(-5,-4,-8,-7,-6,-4,5,4,6,7,8,4,5),B(-13,-14,-15,-16,17,17,17,16,15,14,
13),B(-13,-14,-15,-16,-10,-11,-12,-13,-14,15,14,13,12,11,10,16,15,14,13),B(-5,
-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,
-14,-15,-15,-16,-16,15,15,16,16,15,15,14,13,12,11,10,9,8,7,6,5,4,3,16,15,14,
13,12,11,10,9,8,7,6,5),B(-3,-3,-4,-2,3,2,4,3,3),B(-15,-13,-14,-12,-13,-11,-12,
-10,-11,-5,-4,-3,-11,-12,-13,-3,-2,-13,-8,-9,-10,-11,-12,-7,-8,-9,-10,-11,-6,
-7,-8,-9,-10,-2,-3,-4,-5,-6,-7,-8,-9,-9,-7,8,7,9,9,8,7,6,5,4,3,2,10,9,8,7,6,
11,10,9,8,7,12,11,10,9,8,13,2,3,13,12,11,3,4,5,11,10,12,11,13,12,14,13,
15),B(-17,-15,-16,-14,15,15,14,16,15,17),B(-17,-15,-16,-13,-14,-15,-12,-13,14,
14,14,13,12,15,14,13,16,15,17),B(-17,-16,-15,-14,-13,-12,-10,11,10,12,13,14,
15,16,17),B(-5,-6,-7,-8,-9,-10,-11,-12,-3,-4,-5,-6,-7,-8,-9,-10,-11,-11,-12,
-13,-14,-15,-16,-12,-13,-14,-15,-11,-12,-13,-14,-14,-15,-16,-15,-14,-16,-14,
15,15,15,15,14,16,14,15,16,15,14,14,13,12,11,15,14,13,12,16,15,14,13,12,11,11,
10,9,8,7,6,5,4,3,12,11,10,9,8,7,6,5),B(-17,-18,-19,-15,-16,-17,-18,-13,-14,
-15,-16,-17,-12,-13,-14,-15,-16,-11,-12,-13,-14,15,14,13,12,11,16,15,14,13,12,
17,16,15,14,13,18,17,16,15,19,18,17),B(-10,-3,-2,-10,-9,-8,-7,-6,-5,-4,-2,3,2,
4,5,6,7,8,9,10,2,3,10),B(-5,-4,-3,-2,-19,-17,-18,-15,-16,-17,-13,-14,-15,-16,
-8,-9,-10,-11,-12,-13,-14,-15,-7,-8,-9,-10,-11,-12,-13,-14,-6,-7,-8,-9,-10,
-11,-12,-13,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,12,11,10,9,8,7,6,5,4,3,2,13,12,11,
10,9,8,7,6,14,13,12,11,10,9,8,7,15,14,13,12,11,10,9,8,16,15,14,13,17,16,15,18,
17,19,2,3,4,5),B(-5,-4,-3,-2,-2,-3,-3,-2,-2,3,3,3,2,2,3,3,2,2,3,4,5)]
end
