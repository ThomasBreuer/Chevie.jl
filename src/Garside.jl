"""
Garside  monoids are a general class  of monoids whose most famous examples
are  the braid  and dual  braid monoids.  The implementation  of these last
monoids is in the framework of a general implementation of Garside monoids.

To   define  them  we  first  need   to  introduce  some  vocabulary  about
divisibility  in monoids. A *left divisor* of  `x` is a `d` such that there
exists  `y` with `x=dy` (and then we say  that `x` is a *right multiple* of
`d`).  We say  that a  monoid `M`  is left  (resp. right) cancellable if an
equality `dx=dy` (resp. `xd=yd`) implies `x=y`. The divisor `d` is *proper*
if  `y‚â†1`. We say  that `x` is  an *atom* if  it has no proper left divisor
apart from `1`. A *left gcd* of `x` and `y` is a common left divisor `d` of
`x`  and `y` such that  any other common left  divisor is a left divisor of
`d`. Similarly a *right lcm* of `x` and `y` is a common multiple which is a
left divisor of any other common multiple.

We  call *Garside* a monoid `M` which is:
  * left and right cancellable.
  * generated by its atoms,  which are finite in number.
  * such that any element has only finitely many divisors.
  * admits left and  right  gcds  and  lcms.
  * admits a *Garside element*, which is an element `Œî` whose set of left
    and right divisors coincide and generate `M`.

Garside  elements are not  unique, but there  is a unique  minimal one (for
divisibility); we assume such an element has been chosen. Then the divisors
of  `Œî` are called the  *simples* of `M`. A  Garside monoid embeds into its
group  of fractions, which is called a *Garside group* (a Garside group may
have  several distinct Garside structures, as  we will see for Braid groups
of finite Coxeter groups).

We  also implement *locally Garside* monoids,  which are monoids where lcms
do  not always exist, but exist when any common multiple exists; the set of
simples  is then not defined using a  Garside element, but by the condition
that  they contain the atoms and are  closed under lcms and taking divisors
(see  [BDM01]); since it is not ensured by the existence of `Œî`, one has to
add  the condition that  any element is  divisible by finitely many simples
(but  the number of simples can be infinite). The main example is the braid
monoid of an infinite Coxeter group. It is not known if these monoids embed
in  their group of fractions (though that has been proved for braid monoids
of Coxeter groups by Paris [Paris01]) and thus computing in the monoid does
not help for computing in the group (only the monoid is implemented here).

What allows computing with Garside and locally Garside monoids, and Garside
groups,  is the fact  that they admit  normal forms ---  these normal forms
where  first exhibited for  braid monoids by  Deligne [Del72], who extended
previous work of Brieskorn, Saito [BS72] and Garside [Gar69]:

(i)
Let  `M` be a locally Garside monoid and let `b‚àà M`. Then there is a unique
maximal left simple divisor `Œ±(b)` of `b`, called the *head* of `b` --- any
other simple dividing `b` on the left divides `Œ±(b)` on the left.

(ii)
Assume  `M` is a Garside monoid, `Œî` is  its Garside element and `G` is its
group  of fractions. Then,  given any element  `x‚àà G`, there  is some power
`Œî‚Å±` such that `Œî‚Å± x‚àà M`.

A consequence of (i) is that any element has a canonical decomposition as a
product of simples, called its left-greedy normal form. If we define `œâ(x)`
by  `x=Œ±(x)œâ(x)`, then the normal form of `x` is `Œ±(x)Œ±(œâ(x))Œ±(œâ^2(x))‚Ä¶` We
use  the normal form to represent elements  of `M`, and when `M` is Garside
(ii)  to represent elements  of `G`: given  `x‚àà G` we  compute the smallest
power  `i`  such  that  `Œî‚Å±  x‚àà  M`,  and  we  represent  `x` by the couple
`(i,Œî‚Åª‚Å±x)`.  We are thus reduced to the case where `x‚àà M`, not divisible by
`Œî`,  where we represent  `x` by the  sequence of simples which constitutes
its normal form. We now describe Artin-Tits braid monoids. Let `(W,S)` be a
Coxeter system, that is `W` has presentation

`‚ü®s‚àà S‚à£s^2=1, sts‚ãØ =tst‚ãØ   (m‚Çõ‚Çú factors on each side) for s,t‚àà S‚ü©`

for  some Coxeter matrix `m‚Çõ‚Çú` for `s,t‚àà S`. The braid group `B` associated
to `(W,S)` is the group defined by the presentation

`‚ü®ùê¨‚àà ùêí‚à£ ùê¨ùê≠ùê¨‚ãØ =ùê≠ùê¨ùê≠‚ãØ  (m‚Çõ‚Çú factors on each side) for ùê¨,ùê≠‚àà ùêí‚ü©`

The *positive* braid monoid `B‚Å∫` associated to `W` is the monoid defined by
the  presentation above --- it identifies to the submonoid of `B` generated
by  `ùêí` by  the result  of Paris  mentioned above.  This monoid  is locally
Garside,  with set of simples  in bijection with elements  of `W` and atoms
the elements of `ùêí`; we will denote by `ùêñ ` the set of simples, and by `ùê∞ ‚Ü¶
w`  the bijection between simples and elements  of `W`. The group `W` has a
length  defined  in  terms  of  reduced expressions. Similarly, having only
homogeneous relations, `B‚Å∫` has a natural length function. Then `ùêñ ` can be
characterized  as the subset of the elements  of `B‚Å∫` of the same length as
their image in `W`.

If  `W` is finite, then `B‚Å∫` is Garside with Garside element the element of
`ùêñ  ` whose image is the longest element  of `W`. A finite Coxeter group is
also  a reflection group in  a real vector space,  thus in its complexified
`V`,  and `B` has also a topological definition as the fundamental group of
the  space `V ≥·µâ·µç/W`, where `V ≥·µâ·µç`  is the set of  elements of `V` which are
fixed  by no  non-identity element  of `S`;  however, we  will not use this
here.

Given a Coxeter group `W`,

# Examples
```julia-repl
julia> W=coxgroup(:A,4)
W(A‚ÇÑ)

julia> B=BraidMonoid(W)
BraidMonoid(W(A‚ÇÑ))
```
constructs  the  associated  braid  monoid,  and  then  as  a  function 'B'
constructs  elements of the braid monoid (or group when `W` is finite) from
a list of generators.

```julia-repl
julia> w=B(1,2,3,4)
1234

julia> w^3
121321432.343

julia> word(W,Œ±(w^3))
9-element Array{Int64,1}:
 1
 2
 1
 3
 2
 1
 4
 3
 2

julia> w^4
Œ¥.232432

julia> inv(w)
(1234)‚Åª¬π
```

As  seen in the fourth  line above, the function  'Œ±(b)' returns the simple
`Œ±(b)‚àà ùêñ ` as an element of `W`.

How  an element of  a Garside group  is printed is  controlled by IOcontext
':greedy'.  By default, elements are printed  as fractions `a‚Åª¬πb` where `a`
and  `b` have no left common divisor. Each  of `a` and `b` is printed using
its left-greedy normal form, that is a maximal power of the Garside element
followed  the rest.  One can  print the  entire element  in the left-greedy
normal  from by setting the ':greedy' IOContext; with the same `w` as above
we have:

```julia-repl
julia> repr(w^-1,context=IOContext(stdout,:greedy=>true,:limit=>true))
"Œ¥‚Åª¬π.232432"
```
Finally,  `repr` gives   `w`  back   in  a   form  which   after  assigning
'B=braid(braid_monoid(W))' can be input back into Julia:

```julia-repl
julia> repr(w)
"B(1,2,3,4)"

julia> repr(w^3)
"B(1,2,1,3,2,1,4,3,2,3,4,3)"

julia> repr(w^-1)
"B(-4,-3,-2,-1)"
```
In  general elements of  a Garside monoid  are displayed thus  as a list of
their constituting atoms.

We  now describe the dual braid monoid.  For that, we first give a possible
approach  to construct Garside monoids. Given a  group `W` and a set `S` of
generators  of `W` as a monoid, we  define the length `l(w)` as the minimum
number of elements of `S` needed to write `w`. We then define left divisors
of   `x`  as  the  `d`   such  that  there  exists   `y`  with  `x=dy`  and
`l(d)+l(y)=l(x)`.  We say that `w‚àà W` is  balanced if its set of left and
right  divisors coincide,  is a  lattice (where  upper and lower bounds are
lcms and gcds) and generates `W`. Then we have:

suppose `w` is balanced and let `[1,w]` be its set of divisors (an interval
for  the partial order  defined by divisibility).  Then the monoid `M` with
generators  `[1,w]` and relations  `xy=z` whenever `xy=z`  holds in `W` and
`l(x)+l(y)=l(z)`  is Garside,  with simples  `[1,w]` and  atoms `S`.  It is
called the interval monoid defined by the interval `[1,w]`.

The  Artin-Tits braid monoid  is an interval  monoid by taking  for `S` the
Coxeter generators, in which case `l` is the Coxeter length, and taking for
`w`  the longest element of `W`. The dual monoid, constructed by Birman, Ko
and  Lee  for  type  `A`  and  by  Bessis  for  all  well-generated complex
reflection  groups, is obtained in  a similar way, by  taking this time for
`S`  the set of all reflections, and for `w` a Coxeter element; then `l` is
the  reflection length  'reflength' (for  well-generated complex reflection
groups  whihc are not real `S` contains only those reflections which divide
`w`  for the  reflection length);  for the  dual monoid  the simples are of
cardinality  the  generalized  Catalan  numbers.  An  interval  monoid  has
naturally  an inverse morphism from `M`  to `W`, called 'EltBraid' which is
the  quotient map from the  interval monoid to `W`  which sends back simple
braids to `[1,w]`.
#A  last notable  notion is  *reversible* monoids.  Since in CHEVIE we store
#only  left normal forms, it is easy to compute left lcms and gcds, but hard
#to  compute right ones.  But this becomes  easy to do  if the monoid has an
#operation  'reverse', which has the property that  'a' is a left divisor of
#'b'  if and only if  'reverse(a)' is a right  divisor of 'reverse(b)'. This
#holds  for Artin-Tits  and dual  braid monoids;  Artin-Tits monoids  have a
#reverse  operation which consists of reversing a word, written as a list of
#atoms.  The dual monoid  also has a  reverse operation defined  in the same
#way,  but this operation changes  monoid: it goes from  the dual monoid for
#the  Coxeter element `w` to the dual  monoid for the Coxeter element `w‚Åª¬π`.
#The  operations 'RightLcm' and  'RightGcd', as well  quite a few algorithms
#have faster implementations if the monoid has a reverse operation.

This module implements functions to solve the conjugacy problem and compute
centralizers  in Garside groups, following the work of Franco, Gebhardt and
Gonzalez-Meneses.

Two  elements `w` and `w'` of a monoid  `M` are *conjugate* in `M` if there
exists  `x‚àà M` such that `wx=xw'`; if  `M` satisfies the √ñre conditions, it
has  a  group  of  fractions  where  this  becomes  `x‚Åª¬πwx=w'`,  the  usual
definition  of conjugacy. A special case  which is even closer to conjugacy
in  the group is if there exists `y‚àà  M` such that `w=xy` and `w'=yx`. This
relation  is not transitive in general,  but we call *cyclic conjugacy* the
transitive closure of this relation, a restricted form of conjugacy.

The  next  observation  is  that  if  `w,w'`  are conjugate in the group of
fractions  of the Garside monoid `M` then  they are conjugate in `M`, since
if  `wx=xw'` then  there is  a power  `Œî‚Å±` which  is central and such that
`xŒî‚Å±‚àà M`. Then `wxŒî‚Å±=xŒî‚Å± w'` is a conjugation in `M`.

The  crucial observation for solving the  conjugacy problem is to introduce
`inf(w):=sup{i such  that  Œî‚Å±   divides  w}`  and
`sup(w):=inf{i such  that  w  divides Œî‚Å±}`, and to
notice  that the number of  conjugates of `w` with  same `inf` and `sup` as
`w`  is finite. Further, a  theorem of Birman shows  that the maximum `inf`
and  minimum `sup` in a conjugacy class can be achieved simultaneously; the
elements  achieving this are called the super summit set of `w`. Thus a way
to  determine if two elements are conjugate  is to find a representative of
both  of them in  their super summit  set, and then  solve conjugacy within
that  set. This can also be used  to compute the centralizer of an element:
if  we consider  the super  summit set  as the  objects of a category whose
morphisms are the conjugations by simple elements, the centralizer is given
by the endomorphisms of the given object.

We illustrate this on an example:

```julia-repl
julia> b=B(2,1,4,1,4)
214.14

julia> c=B(1,4,1,4,3)
14.143

julia> d=representative_operation(b,c)
(1)‚Åª¬π21321432

julia> b^d
14.143

julia> centralizer_generators(b)
3-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FiniteCoxeterGroup{Int16,Int64}}},1}:
 21.1         
 321432.213243
 4

julia> C=conjcat(b,:ss)
category with 10 objects and 32 maps

julia> C.obj
10-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FiniteCoxeterGroup{Int16,Int64}}},1}:
 214.14
 14.124
 143.13
 1214.4
 13.134
 124.24
 1343.1
 24.214
 134.14
 14.143
```

There  is a faster  solution to the  conjugacy problem given in [gebgon10]:
for  each `b‚àà M`, they define a  particular simple left divisor of `b`, its
*preferred  prefix*  such  that  the  operation  *sliding* which cyclically
conjugates  `b` by  its preferred  prefix, is  eventually periodic, and the
period  is contained in the super summit set  of `x`. We say that `x` is in
its  sliding circuit if some  iterated sliding of `x`  is equal to `x`. The
set  of sliding  circuits in  a given  conjugacy class  is smaller than the
super  summit  set,  thus  allows  to  solve  the conjugacy problem faster.
Continuing from the above example,

```julia-repl
julia> word(W,preferred_prefix(b))
2-element Array{Int64,1}:
 2
 1

julia> b^B(preferred_prefix(b))
1214.4

julia> b1=b^B(preferred_prefix(b))
1214.4

julia> C=conjcat(b)
category with 3 objects and 7 maps

julia> C.obj
3-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FiniteCoxeterGroup{Int16,Int64}}},1}:
 214.14
 1214.4
 1343.1
```
Finally,  we have implemented  Hao Zheng's algorithm  to extract roots in a
Garside monoid:

```julia-repl
julia> W=coxgroup(:A,3)
W(A‚ÇÉ)

julia> B=BraidMonoid(W)
BraidMonoid(W(A‚ÇÉ))

julia> pi=B(B.delta)^2
Œ¥¬≤

julia> root(pi,2)
Œ¥

julia> root(pi,3)
1232

julia> root(pi,4)
132
```
"""
module Garside
using Gapjm
export BraidMonoid, braid, shrink, Œ±, DualBraidMonoid, conjcat, fraction,
representative_operation, centralizer_generators, preferred_prefix,
left_divisors

abstract type GarsideMonoid{T} end # T=type of simples

"""
elts must be simples
"""
function leftgcd(M::GarsideMonoid,elts...)
  x=one(M)
  elts=collect(elts)
  found=true
  while found
    found=false
    for i in eachindex(M.atoms)
    let M=M, i=i
      if all(b->isleftdescent(M,b,i),elts)
        found=true
        x=mul!(M,x,M.atoms[i])
        elts .= .\(Ref(M),Ref(M.atoms[i]),elts)
      end
    end
    end
  end
  return x,elts
end

function rightgcd(M::GarsideMonoid,elts...)
  x=one(M)
  elts=collect(elts)
  found=true
  while found
    found=false
    for i in eachindex(M.atoms)
      let M=M, i=i
      if all(b->isrightdescent(M,b,i),elts)
        found=true
        x=*(M,M.atoms[i],x)
        elts .= ./(Ref(M),elts,Ref(M.atoms[i]))
      end
      end
    end
   end
   return x,elts
end

function rightlcm(M::GarsideMonoid,elts...)
  x,c=rightgcd(M,rightcomplŒ¥.(Ref(M),elts)...)
  *(M,elts[1],c[1]),c
end

"""
returns Œ±(xv),œâ(xv)
"""
function alpha2(M::GarsideMonoid,x,v)
  g,rests=leftgcd(M,\(M,x,M.delta),v)
  (*(M,x,g),rests[2])
end

function element(M::GarsideMonoid{T},l::Int...)where T
  res=GarsideElm(0,T[],M)
  if isempty(l) return res end
  for s in reverse(l) # faster in reversed order (see *)
    if s<0 b=inv(GarsideElm(0,[M.atoms[-s]],M))
    else   b=GarsideElm(0,[M.atoms[s]],M)
    end
    res=b*res
  end
  res
end

function element(M::GarsideMonoid{T},r::T)where T
  if r==one(M) GarsideElm(0,T[],M)
  elseif r==M.delta GarsideElm(1,T[],M)
  else GarsideElm(0,[r],M)
  end
end

function CoxGroups.word(M::GarsideMonoid,w)
  res=Int[]
  while w!=one(M)
    for i in eachindex(M.atoms)
       if isleftdescent(M,w,i)
         push!(res,i)
         w=\(M,M.atoms[i],w)
       end
    end
  end
  res
end

"""
left_divisors( M, s)

all  the left divisors of the simple element `s` of the Garside monoid `M`,
as  a vector  of vectors,  where the  i+1-th vector  holds the  divisors of
length i in the atoms.

```julia-repl
julia> W=coxgroup(:A,3)
W(A‚ÇÉ)

julia> B=BraidMonoid(W)
BraidMonoid(W(A‚ÇÉ))

julia> map(x->B.(x),Garside.left_divisors(B,W(1,3,2)))
4-element Array{Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FiniteCoxeterGroup{Int16,Int64}}},1},1}:
 [.]   
 [1, 3]
 [13]  
 [132] 

julia> B=DualBraidMonoid(W)
DualBraidMonoid(W(A‚ÇÉ),c=[1, 3, 2])

julia> map(x->B.(x),Garside.left_divisors(B,W(1,3,2)))
4-element Array{Array{Gapjm.Garside.GarsideElm{Perm{Int16},DualBraidMonoid{Perm{Int16},Gapjm.Weyl.FiniteCoxeterGroup{Int16,Int64}}},1},1}:
 [.]                     
 [1, 2, 3, 4, 5, 6]      
 [12, 13, 15, 25, 34, 45]
 [Œ¥]                     
```
"""
function left_divisors(M::GarsideMonoid,s)
  rest=[(left=one(M),right=s)]
  res=[]
  while !isempty(rest)
    push!(res,rest)
    new=empty(res[1])
    for x in rest
      for i in eachindex(M.atoms)
        if isleftdescent(M,x.right,i)
          push!(new,(left=*(M,x.left,M.atoms[i]),right=\(M,M.atoms[i],x.right)))
        end
      end
    end
    rest=unique(new)
  end
  map(x->first.(x),res)
end

rightcomplŒ¥(M::GarsideMonoid,x)=\(M,x,M.delta)
leftcomplŒ¥(M::GarsideMonoid,x)=/(M,M.delta,x)

function Œ¥ad(M::GarsideMonoid,x,i)
  while i>0 
    x=\(M,rightcomplŒ¥(M,x),M.delta)
    i-=1 
  end
  while i<0 
    x=/(M,M.delta,leftcomplŒ¥(M,x))
    i+=1 
  end
  x
end

"elements(M,l) returns the elements of M of length l."
function PermGroups.elements(M::GarsideMonoid,l)
  if !haskey(M.prop,:elements)
    M.prop[:elements]=Dict(0=>[M()],1=>[M(i) for i in eachindex(M.atoms)])
  end
  RA(w)=filter(i->!isrightdescent(M,w,i),eachindex(M.atoms))
  if !haskey(M.prop[:elements],l)
    res=empty(M.prop[:elements][1])
    for b in elements(M,l-1)
      lb=length(b.elm)
      if iszero(lb) r=Int[]
      else
        r=RA(b.elm[lb])
        if lb==1 rr=Int[] else rr=RA(b.elm[lb-1]) end
        for s in r
          w=*(M,b.elm[lb],M.atoms[s])
          if !any(i->isleftdescent(M,w,i),rr)
            elm=copy(b.elm)
            elm[end]=w
            push!(res,norm(GarsideElm(b.pd,elm,M)))
          end
        end
      end
      for i in setdiff(eachindex(M.atoms),r)
        push!(res,norm(GarsideElm(b.pd,vcat(b.elm,[M.atoms[i]]),M)))
      end
    end
    M.prop[:elements][l]=collect(Set(res))
  end
  M.prop[:elements][l]
end

#--------------------AbstractIntervalMonoid-----------------------------------
abstract type AbstractIntervalMonoid{T,TW<:Group{T}}<:GarsideMonoid{T} end

function Œ¥ad(M::AbstractIntervalMonoid,w,i::Int)
# w^(M.delta^i)
  i=mod(i,M.orderdelta)
  if iszero(i) return w end
  w^(i==1 ? M.delta : M.delta^i)
end

Base.one(M::AbstractIntervalMonoid)=one(M.W)
Base.:\(M::AbstractIntervalMonoid,x,y)=x\y
Base.:/(M::AbstractIntervalMonoid,x,y)=x/y
Base.:*(M::AbstractIntervalMonoid,x,y)=x*y
Base.inv(M::AbstractIntervalMonoid,x)=inv(x)
mul!(M::AbstractIntervalMonoid,x,y)=Perms.mul!(x,y)

rightcomplŒ¥(M::AbstractIntervalMonoid,x)=x\M.delta

#-----------------------BraidMonoid-----------------------------------
struct BraidMonoid{T,TW}<:AbstractIntervalMonoid{T,TW}
  delta::T
  orderdelta::Int
  atoms::Vector{T}
  W::TW
  prop::Dict{Symbol,Any}
end

" BraidMonoid(W) returns the BraidMonoid of the Coxeter group W"
BraidMonoid(W::CoxeterGroup)=BraidMonoid(longest(W),2,gens(W),W,Dict{Symbol,Any}())

Base.show(io::IO, M::BraidMonoid)=print(io,"BraidMonoid(",M.W,")")

function CoxGroups.isleftdescent(M::BraidMonoid,w,i::Int)
   isleftdescent(M.W,w,i)
end

function isrightdescent(M::BraidMonoid,w,i::Int)
  isleftdescent(M.W,inv(w),i)
end

function CoxGroups.word(M::BraidMonoid,w)
  word(M.W,w)
end

(M::BraidMonoid)(l...)=element(M,l...)

function rightgcd(M::BraidMonoid,elts...)
  g,c=leftgcd(M,inv.(elts)...)
  inv(g),inv.(c)
end

#-----------------------DualBraidMonoid-------------------------------
struct DualBraidMonoid{T,TW}<:AbstractIntervalMonoid{T,TW}
  delta::T
  orderdelta::Int
  atoms::Vector{T}
  W::TW
end
"""
Let  `W` be a well generated complex  reflection group and `c` be a Coxeter
element  of `W` (if `W` is a Coxeter group and no `c` is given a particular
one  is chosen  by making  the product  of elements  in a  partition of the
Coxeter  diagram in two sets where  elements in each commute pairwise). The
result  is the dual braid  monoid determined by `W`  and `c`: let `w` be an
element  of `W` or a sequence  `s‚ÇÅ,‚Ä¶,s‚Çô` of integers indices of reflections
of `W`.

```julia-repl
julia> W=coxgroup(:A,3)
W(A‚ÇÉ)

julia> B=DualBraidMonoid(W)
DualBraidMonoid(W(A‚ÇÉ),c=[1, 3, 2])

julia> B(2,1,2,1,1)
12.1.1.1

julia> B(-1,-2,-3,1,1)
(25.1)‚Åª¬π1.1
```
"""
function DualBraidMonoid(W::CoxeterGroup;c=vcat(bipartite_decomposition(W)...))
  delta=W(c...)
  DualBraidMonoid(delta,order(delta),reflections(W)[1:nref(W)],W)
end

(M::DualBraidMonoid)(l...)=element(M,l...)

function CoxGroups.isleftdescent(M::DualBraidMonoid,w,i::Int)
  reflength(M.W,M.atoms[i]*w)<reflength(M.W,w)
end

Base.show(io::IO, M::DualBraidMonoid)=print(io,"DualBraidMonoid(",M.W,",c=",
                                            word(M.W,M.delta),")")
#---------------------------------------------------------------------
struct GarsideElm{T,TM<:GarsideMonoid}
  pd::Int
  elm::Vector{T}
  M::TM
end

Base.one(b::GarsideElm)=GarsideElm(0,empty(b.elm),b.M)
Base.copy(b::GarsideElm)=GarsideElm(b.pd,b.elm,b.M)

function Base.cmp(a::GarsideElm,b::GarsideElm)
  c=cmp(a.pd,b.pd)
  if c!=0 return c end
  cmp(a.elm,b.elm)
end

Base.isless(a::GarsideElm,b::GarsideElm)=cmp(a,b)==-1
Base.:(==)(a::GarsideElm,b::GarsideElm)=a.pd==b.pd && a.elm==b.elm

# hash is needed for using permutations in Sets/Dicts
function Base.hash(a::GarsideElm, h::UInt)
  b = 0x595dee0e71d271d0%UInt
  b = xor(b,xor(hash(a.pd, h),h))
  b = (b << 1) | (b >> (sizeof(Int)*8 - 1))
  for e in a.elm
    b = xor(b,xor(hash(e, h),h))
    b = (b << 1) | (b >> (sizeof(Int)*8 - 1))
  end
  b
end

function norm(a::GarsideElm)
  M=a.M
  i=1
  pd=a.pd
  while i<length(a.elm) && a.elm[i]==M.delta 
    i+=1
    pd+=1
  end
  j=length(a.elm)
  while j>0 && a.elm[j]==one(M)
    j-=1
  end
  i>1 || j<length(a.elm) ? GarsideElm(pd,a.elm[i:j],M) : a
end

function Base.inv(b::GarsideElm)
  k=length(b.elm)
  M=b.M
  GarsideElm(-b.pd-k,
    map(i->Œ¥ad(M,\(M,b.elm[i],M.delta),-i-b.pd),k:-1:1),M)
end

"""
fraction(b)
returns a tuple `(x,y)`  of two  elements with  no non-trivial  common left
divisor and such that `b=inv(x)*y`.

```julia-repl
julia> B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(W(A‚ÇÉ))

julia> b=B( 2, 1, -3, 1, 1)
(23)‚Åª¬π321.1.1

julia> fraction(b)
(23, 321.1.1)
```
"""
function fraction(b::GarsideElm)
  M=b.M
  if b.pd>=0 return [one(b),b] end
  if -b.pd>length(b.elm) return [inv(b),one(b)] end
  GarsideElm(0,inv(b).elm[length(b.elm)+b.pd+1:length(b.elm)],M),
  GarsideElm(0,b.elm[1-b.pd:length(b.elm)],M)
end;

function Œ±(b)
  if b.pd<0 error("Œ±: element should be positive");
  elseif b.pd>0 return b.M.delta
  end
  if length(b.elm)>0 return b.elm[1]
  else return one(b.M)
  end
end

"""
word(b)
returns  a description  of `b`  as a  list of  the atoms  of which  it is a
product.  If `b` is in the Garside group  but not the Garside monoid, it is
represented  in  fraction  normal  form  where  as a special convention the
inverses  of  the  atoms  are  represented  by  negating  the corresponding
integer.

```julia-repl
julia> B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(W(A‚ÇÉ))

julia> b=B(2,1,2,1,1)*inv(B(2,2))
(21)‚Åª¬π1.12.21

julia> word(b)
7-element Array{Int64,1}:
 -1
 -2
  1
  1
  2
  2
  1
```
"""
function CoxGroups.word(b::GarsideElm)
  M=b.M
  res=Int[]
  if b.pd<0 
    d,n=fraction(b)
    return vcat(-reverse(word(d)),word(n))
  end
  for i in 1:b.pd append!(res,word(M,M.delta)) end
  for e in b.elm append!(res,word(M,e)) end
  res
end

function Base.show(io::IO,b::GarsideElm)
  M=b.M
  repl=get(io,:limit,false)
  TeX=get(io,:TeX,false)
  greedy=get(io,:greedy,false)
  if !repl && !TeX 
    print(io,"B(",join(word(b),","),")")
    return
  end
  function p(b)
    l=join(map(b.elm) do e
      w=word(M,e)
      pad=any(x->x>=10,w) ? " " : ""
      return join(map(string,w),pad)
    end,".")
    if b.pd==0 return l end
    if !isempty(l) l="."*l end
    return b.pd!=1 ? "Œ¥^{$(b.pd)}$l" : "Œ¥$l"
  end
  if greedy
   print(io,TeXstrip(p(b)))
  else
   den,num=map(x->TeXstrip(p(x)),fraction(b))
   if den!="" print(io,TeXstrip("($den)^{-1}"))
      if num!="" print(io,"$num") end
    elseif num!="" print(io, num)
    else print(io,".")
    end
  end
end

function Base.:*(a::GarsideElm{T},x::T)::GarsideElm{T} where T
  v=copy(a.elm)::Vector{T}
  push!(v,x)
  M=a.M
  for i in length(v):-1:2
    x,y=alpha2(M,v[i-1],v[i])
#   y=M.one
    if y==one(M) # this implies i==Length(v)
      if x==M.delta
       return GarsideElm(1+a.pd,Œ¥ad.(Ref(M),v[1:end-2],1),M)
      end
      resize!(v,i-1) 
      v[i-1]=x 
    elseif x==v[i-1] return GarsideElm(a.pd,v,M)
    elseif x==M.delta
      v[i]=y
      v[2:i-1]=Œ¥ad.(Ref(M),v[1:i-2],1)
      return GarsideElm(1+a.pd,v[2:end],M)
    else v[[i-1,i]]=[x,y]
    end
  end
  GarsideElm(a.pd,v,M)
end

function Base.:*(a::GarsideElm,b::GarsideElm)
  res=GarsideElm(a.pd+b.pd,copy(a.elm),a.M)
  res.elm.=Œ¥ad.(Ref(a.M),res.elm,Ref(b.pd))
  for x in b.elm 
    res*=x 
  end
  res
end

Base.:^(a::GarsideElm, n::Integer)= n>=0 ? Base.power_by_squaring(a,n) : Base.power_by_squaring(inv(a),-n)

Base.:^(a::GarsideElm, b::GarsideElm)=inv(b)*a*b
#----------------------------------------------------------------------------
struct Category{TO}
  obj::Vector{TO}
  atoms::Vector{Vector{Pair{TO,Int}}}
end

function Base.show(io::IO,C::Category)
  print(io,"category with ",length(C.obj)," objects and ",
        sum(length,C.atoms)," maps")
end

function Category(atomsfrom::Function,o::TO) where TO
  C=Category([o],[Pair{TO,Int}[]])
  i=1
  while i<=length(C.obj) 
    b=C.obj[i]
    for m in atomsfrom(b)
      p=findfirst(isequal(m[2]),C.obj)
  #	Print(b,"^",m.map,"->",m.tgt,"\n");
      if isnothing(p)
         push!(C.obj,m[2])
         push!(C.atoms,empty(C.atoms[1]))
         p=length(C.obj)
      end
      push!(C.atoms[i],m[1]=>p)
    end
    i+=1
    if iszero(i%100) print(".") end
  end
  C
end

###############################################
# Endomorphisms(C,o) for category C, returns  #
# generators of the endomorphisms of C.obj[o] #
###############################################
function endomorphisms(C::Category{TO},o) where TO
  paths=[Tuple{Int,Int}[] for i in eachindex(C.obj)]
  paths[o]=Tuple{Int,Int}[]
  maps=copy(C.obj)
  function foo()
    reached=[o]
    for i in reached t=C.atoms[i]
      for j in eachindex(t) m=t[j]
        if !(m[2] in reached)
          paths[m[2]]=vcat(paths[i],[(i,j)])
          if i!=o maps[m[2]]=maps[i]*m[1]
          else maps[m[2]]=m[1]
          end
          push!(reached,m[2])
          if length(reached)==length(C.obj) return end
        end
      end
    end
  end
  foo()
  # here paths[p] describes a path to get from obj o to  obj p
  gens=Set{TO}()
  for i in eachindex(C.obj)
    t=C.atoms[i]
    for j in eachindex(t)
     if vcat(paths[i],[(i,j)])!=paths[t[j][2]]
       if i==o nmap=t[j][1]
       else nmap=maps[i]*t[j][1]
        end
        if t[j][2]==o push!(gens,nmap)
        elseif nmap!=maps[t[j][2]] push!(gens,nmap*inv(maps[t[j][2]]))
        end
      end
    end
  end
  gens
end

function AtomicMaps(a,s::Symbol=:sc)
  M=a.M
  res=typeof(a=>a)[]
  for i in eachindex(M.atoms)
   m=minc(a,M.atoms[i],Val(s))
    if !isnothing(m) && !any(k->isleftdescent(M,m,k),i+1:length(M.atoms))
      bm=M(m)
      push!(res,bm=>a^bm)
    end
  end
  filter(x->count(y->(y[1]^-1*x[1]).pd>=0,res)==1,res)
end

# a braid x atom
function minc(a,x,::Val{:cyc})
  if a.pd>0 return x end
  if isempty(a.elm) return nothing end
  M=a.M
  if !isleftdescent(M,a.elm[1],findfirst(isequal(x),M.atoms)) return nothing end
  x
end

function preferred_prefix(b)
  M=b.M
  if isempty(b.elm) return one(M) end
  o=b.elm[end]
  \(M,o,alpha2(M,o,Œ¥ad(M,b.elm[1],-b.pd))[1])
end

# Inf(a,x)  minimal m such that x<m and inf(a^m)>=inf(a). 
# m is simple; see algorithm 2 in Franco-Gonzales 1.
function minc(a,x,::Val{:inf})
  M=a.M
  m=x
  while true
    x=Œ¥ad(M,m,a.pd)
    for s in a.elm x=rightlcm(M,x,s)[2][2] end
    m,c=rightlcm(M,x,m)
    if c[2]==one(M) break end
  end
  m
end

# SS(a,x)  Assumes a in SSS(a). Returns minimal m such that x<m and
# a^m is in SSS(a). m is simple. See algorithm 5 in Franco-Gonzales 1
function minc(a,x,::Val{:ss})
  ai=inv(a)
  m=x # because scope
  while true
    m=x
    x=minc(a,x,Val(:inf))
    x=minc(ai,x,Val(:inf))
    if x==m break end
  end
  m
end

# representativeSC(b) returns
# (conj=minimal r such that b^r in sliding circuit, 
#  circuit=sliding circuit)
function representativeSC(b)
  seen=typeof(b)[]
  l=[[b,b^0]]
  while !(b in seen)
    push!(seen,b)
    e=b.M(preferred_prefix(b))
    b=b^e
    push!(l,[b,l[end][2]*e])
  end
  t=findfirst(x->x[1]==b,l)
  (conj=l[t][2],circuit=first.(l[t:end-1]))
end

PositiveSimpleConjugation(y,r)=y^y.M(r)

# MinConjugating.SC(a,x,F) minimal m such that x<m and m^-1*a*F(m) is in SC(a).
# m is a simple.
function minc(a,x,::Val{:sc})
    M=a.M
# Gebhart-Gonzalez function F for a in SC such that a^x in SSS
  function ggF(a,x)
    f=typeof([a,x])[]
    y=a
    while true # find the history under sliding of the pair [a,x]
      push!(f,[y,x])
      r=preferred_prefix(y)
      x=\(M,r,*(M,x,preferred_prefix(PositiveSimpleConjugation(y,x))))
      if x==one(M) return [one(M)] end
      y=PositiveSimpleConjugation(y,r)
      p=findfirst(isequal([y,x]),f)
      if !isnothing(p) break end
    end
    map(x->x[2],filter(x->x[1]==a,f[p:end]))
  end
  x=minc(a,x,Val(:ss))
  f=ggF(a,x)
  if f!=[one(M)]
    p=findfirst(s->leftgcd(M,x,s)[2][1]==one(M),f)
    isnothing(p) ? nothing : f[p]
  else p=preferred_prefix(a)
    if leftgcd(M,x,p)[2][1]!=one(M) return nothing end
#   l:=Filtered(Concatenation(LeftDivisorsSimple(M,p)),
#            s->s<>x and M.LeftGcdSimples(x,s)[2]=M.identity);
    l=left_divisors(M,\(M,x,p))
    l=.*(Ref(M),Ref(x),vcat(l[2:end]...))
#   Print("Warning: for b=",a," F=1 & x=",x," divides p=",p," ",Length(l),"\n");
    l[findfirst(x->x==p || x in ggF(a,x),l)]
  end
end

minc(a,x)=minc(a,x,Val(:sc))

conjcat(b,s::Symbol=:sc)=Category(x->AtomicMaps(x,s),b)

"""
representative_operation(b,b1)

The  function returns `a` such that  `b^a=b1` if such exists, and `nothing`
otherwise.  If an argument <type> is given,  the computation is done in the
corresponding category --- see "conjcat".

```julia-repl
julia> W=coxgroup(:D,4)
W(D‚ÇÑ)

julia> B=BraidMonoid(coxgroup(:D,4))
BraidMonoid(W(D‚ÇÑ))

julia> b=B(2,3,1,2,4,3);b1=B(1,4,3,2,2,2)
1432.2.2

julia> representative_operation(b,b1)
(134312.23)‚Åª¬π

julia> representative_operation(b,b1,:cyc)
232.2
```
"""
function representative_operation(b,c,s::Symbol=:sc)
  if s==:sc || s==:ss
    bconj=representativeSC(b)
    cconj=representativeSC(c)
    b=bconj.circuit[1]
    bconj=bconj.conj
    c=cconj.circuit[1] 
    cconj=cconj.conj
    if b.pd!=c.pd || length(b.elm)!=length(c.elm) return nothing end
  else
    bconj=cconj=one(b)
  end
  if b==c return bconj*cconj^-1 end
  res=[bconj]
  class=[b]
  for a in class 
    for m in AtomicMaps(a,s)
      if !(m[2] in class)
        e=res[findfirst(isequal(a),class)]*m[1]
        if m[2]==c return e*cconj^-1 end
        push!(class,m[2])
        push!(res,e)
      end
    end 
  end
end

"""
centralizer_generators(b)

a list of generators  of the centralizer of `b`. 
The computation is done by computing
the  endomorphisms  of  the  object  <b>  in  the  category  of its sliding
circuits.  If an argument <type>  is given, the computation  is done in the
corresponding  category --- see "ConjugacySet". The  main use of this is to
compute  the  centralizer  in  the  category  of cyclic conjugacy by giving
'\"Cyc\"' as the type.

|    gap> W:=CoxeterGroup("D",4);;
    gap> w:=Braid(W)(4,4,4);
    4.4.4
    gap> CentralizerGenerators(w);
    [ 4, 2, (1)^-1.34.431, 34.43, (32431)^-1.132431, 1, (2)^-1.34.432,
      (31432)^-1.231432 ]
    gap> ShrinkGarsideGeneratingSet(last);
    [ 4, 2, 1, 34.43, (3243)^-1.13243 ]
    gap> CentralizerGenerators(w,"Cyc");
    [ 4 ]
    gap> F:=Frobenius(CoxeterCoset(W,(1,2,4)));
    function ( arg ) ... end
    gap> CentralizerGenerators(w,F);
    [ 312343123, 124 ]|
"""
function centralizer_generators(b,s::Symbol=:sc)
  if s==:ss || s==:sc
    b=representativeSC(b)
    a=b.conj
    b=b.circuit[1]
    Ref(a).*endomorphisms(conjcat(b,s),1).*Ref(a^-1)
  else
    endomorphisms(conjcat(b,s),1)
  end
end

#----------------------------------------------------------------------------
struct TwistedPowerMonoid{T,TM}<:GarsideMonoid{T}
  delta::T
  orderdelta::Int
  atoms::Vector{T}
  n::Int # twisting
  M::TM
end

struct TwistedPowerMonoidAtom{T,TM}
  v::Vector{T}
  t::Bool
  M::TM
end

(M::TwistedPowerMonoid)(l...)=element(M,l...)

Base.:(==)(a::TwistedPowerMonoidAtom,b::TwistedPowerMonoidAtom)=(a.v==b.v)&&
  (a.t==b.t)&&(a.M==b.M)

Base.hash(a::TwistedPowerMonoidAtom, h::UInt)=
 hash(a.v,hash(a.t,hash(a.M,0x595dee0e71d271d0%UInt)))

IntListToString(l)=any(x->x>10,l) ? join(l,",") : join(l)
function Base.show(io::IO,r::TwistedPowerMonoidAtom)
  if r.t print(io,"t") end
  print(io,"(",join(map(a->IntListToString(word(r.M,a)),r.v),","),")")
end

function TwistedPowerMonoid(M,n)
  delta=TwistedPowerMonoidAtom([M.delta for i in 1:n],true,M)
  atoms=[TwistedPowerMonoidAtom([one(M) for i in 1:n],true,M)]
  for i in 1:n
    append!(atoms,map(a->
      TwistedPowerMonoidAtom([j==i ? a : one(M) for j in 1:n],false,M),
      M.atoms))
  end
  TwistedPowerMonoid(delta,n*M.orderdelta,atoms,n,M)
end

function isrightdescent(M::TwistedPowerMonoid,s,i)
  if i==1 return s.t end
  m=length(M.M.atoms)
  i1=1+div(i-2,m)
  i2=1+mod(i-2,m)
  isrightdescent(M.M,s.v[i1],i2)
end

# M.IsRightAscending:=function(s,i)if i=1 then return not s.t;fi;
# m=length(M.M.atoms);i1=1+div(i-2,m);i2=1+mod(i-2,m)
#   return M1.IsRightAscending(s.v[i1],i2);end;

function CoxGroups.isleftdescent(M::TwistedPowerMonoid,s,i)
  if i==1 return s.t end
  m=length(M.M.atoms);i1=1+div(i-2,m);i2=1+mod(i-2,m)
  isleftdescent(M.M,s.v[s.t ? 1+mod(i1-2,M.n) : i1],i2)
end

Base.one(M::TwistedPowerMonoid)=TwistedPowerMonoidAtom(
           [one(M.M) for i in 1:M.n],false,M.M)

Base.:*(M::TwistedPowerMonoid,a::TwistedPowerMonoidAtom,b::TwistedPowerMonoidAtom)=TwistedPowerMonoidAtom(
     map(i->*(M.M,a.v[b.t ? 1+mod(i,M.n) : i],b.v[i]),1:M.n),a.t||b.t,M.M)
mul!(M::TwistedPowerMonoid,a,b)=*(M,a,b)

Base.:\(M::TwistedPowerMonoid,a::TwistedPowerMonoidAtom,b::TwistedPowerMonoidAtom)=TwistedPowerMonoidAtom(
     map(i->\(M.M,a.v[b.t!=a.t ? 1+mod(i,M.n) : i],b.v[i]),1:M.n),b.t!=a.t,M.M)

Base.:/(M::TwistedPowerMonoid,a::TwistedPowerMonoidAtom,b::TwistedPowerMonoidAtom)=TwistedPowerMonoidAtom(map(i->/(M.M,a.v[
  b.t ? 1+mod(i-2,M.n) : i],b.v[b.t ? 1+mod(i-2,M.n) : i]),1:M.n),a.t!=b.t,M.M)

function Base.show(io::IO,M::TwistedPowerMonoid)
  print(io,"twisted $(ordinal(M.n)) power of $(M.M)");
end

# Algorithm following Hao Zheng "A new approach to extracting roots in Garside
# groups" Comm. Algebra 34 (2006) 1793--1802
function Gapjm.root(b0,n=2)
  M=b0.M
  tM=TwistedPowerMonoid(M,n)
  l=vcat(fill(M.delta,b0.pd),b0.elm)
  b=GarsideElm(0,map(eachindex(l)) do j
          TwistedPowerMonoidAtom([i==1 ? l[j] : one(M) for i in 1:n],j==1,M)
          end,tM)
  function inner(b)
    cst=b->all(x->constant(x.v),b.elm)
    sc=representativeSC(b)
    conj=[sc.conj]
    class=[sc.circuit[1]]
    if cst(class[1]) return conj[1] end
    for a in class 
      for m in AtomicMaps(a)
       if !(m[2] in class)
         e=conj[findfirst(isequal(a),class)]*m[1]
         if cst(m[2]) return e end
         push!(class,m[2])
         push!(conj,e)
      end
     end
    end
  end
  conj=inner(b)
  if conj==nothing return nothing end
  a=b^conj
  a=GarsideElm(a.pd,map(x->x.v[1],a.elm),M)
  l=length(conj.elm)
  k=count(x->x.t,conj.elm)
  conj=norm(GarsideElm(conj.pd,vcat(map(i->conj.elm[i].v[1+mod(i,n)],1:k),
                                    map(i->conj.elm[i].v[1+mod(k,n)],k+1:l)),M))
  conj*a*conj^-1
end
#----------------------------------------------------------------------------
"""
shrink(l)

The  list `l` is a  list of  elements of  the same Garside group `G`. This
function  tries to find  another set of  generators of the  subgroup of `G`
generated by the elements of `l`, of smaller total length (the length being
counted  as returned by the function  `word`).

```julia-repl
julia> B=BraidMonoid(coxsym(3))
BraidMonoid(coxsym(3))

julia> b=[B(1)^3,B(2)^3,B(-2,-1,-1,2,2,2,2,1,1,2),B(1,1,1,2)]
4-element Array{Gapjm.Garside.GarsideElm{Perm{UInt8},BraidMonoid{Perm{UInt8},Gapjm.CoxGroups.CoxSymmetricGroup{UInt8}}},1}:
 1.1.1              
 2.2.2              
 (1.12)‚Åª¬π2.2.2.21.12
 1.1.12             

julia> shrink(b)
2-element Array{Gapjm.Garside.GarsideElm{Perm{UInt8},BraidMonoid{Perm{UInt8},Gapjm.CoxGroups.CoxSymmetricGroup{UInt8}}},1}:
 2  
 1  
```
"""
function shrink(b1::Vector{T})where T<:GarsideElm
  function f(b)
    ld,ln=length.(word.(fraction(b)))
    ld>ln ? (l=ld+ln,ld=ln,b=inv(b),s=true) : (l=ld+ln,ld=ld,b=b,s=true)
  end
  simplified=false
  function test(el,j)
    p=f(el)
    pos=findfirst(isequal(p),bs)
    if !isnothing(pos) && pos!=j
      print(" eliminated")
      simplified=true
      splice!(bs,max(pos,j))
      return true
    end
    if p>=bs[j] return false end
    print("<$(p.l)√∑$(p.ld)>")
    bs[j]=p
    simplified=true
    return false
  end
  bs=sort!(f.(b1))
  while true
    globsimplified=false
    print("#I total length $(sum(x->x.l,bs)) maximal length $(bs[end].l)\n")
    for j in length(bs):-1:2
      simplified=false
      print("#I $j:<$(bs[j].l)√∑$(bs[j].ld)>")
      for ab in bs
        if !bs[j].s && !ab.s continue end
        if ab>=bs[j] break end
        print(".")
        a=ab.b
        ai=inv(a)
        b=bs[j].b
        aib=ai*b
        bai=b*ai
#       print("i=",i,"bs[i]=",bs[i]," bs[j]=",bs[j],"\n")
        if test(aib,j) || test(bai,j) || test(aib*a,j) || 
           test(a*bai,j) || test(a*b,j) || test(b*a,j) 
         break end
      end
      if simplified globsimplified=true
      elseif j<=length(bs) bs[j]=(l=bs[j].l,ld=bs[j].ld,b=bs[j].b,s=false)
      else break
      end
      print("\n")
    end
    if !globsimplified 
      print("\n")
      break 
    end
    unique!(sort!(bs))
  end
  return map(x->x.b,bs)
end
B=BraidMonoid(coxsym(21))
b=[
B(19,19,19),B(11,11),B(10,10,10,10),B(8,8,8),B(3,3,3),B(-1,-1,2,2,1,1),B(2,2,
2,2),B(-3,-1,-2,-2,-1,-13,-14,-15,-16,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,
-13,-14,-15,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-1,-2,-3,-4,-5,-6,-7,
-8,-9,-10,-11,-12,-13,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-1,-2,-3,-4,-5,-6,
-7,-8,-9,-10,-11,-15,-11,-12,-13,-14,-12,-13,-11,-12,-14,-12,-13,-13,14,13,13,
12,14,12,11,13,12,14,13,12,11,15,11,10,9,8,7,6,5,4,3,2,1,12,11,10,9,8,7,6,5,4,
3,2,13,12,11,10,9,8,7,6,5,4,3,2,1,14,13,12,11,10,9,8,7,6,5,4,3,2,15,14,13,12,
11,10,9,8,7,6,5,4,3,2,1,16,15,14,13,1,2,2,1,3),B(-3,-1,-2,-2,-1,-1,-2,-3,-4,
-2,-3,-1,-2,-4,-2,-3,-1,2,2,2,1,3,2,4,2,1,3,2,4,3,2,1,1,2,2,1,3),B(-3,-1,-2,
-2,-3,-4,-1,-2,-3,-3,-2,-2,3,3,3,2,2,3,3,2,1,4,3,2,2,1,3),B(-3,-1,-2,-2,-3,-4,
-1,-2,-3,-3,-4,-2,-3,-3,4,4,3,3,2,4,3,3,2,1,4,3,2,2,1,3),B(-3,-1,-2,-2,-3,-4,
-5,-6,-7,-8,-9,-10,-11,-12,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-3,-4,-5,-6,-7,
-8,-9,-10,-2,-3,-4,-5,-6,-7,-8,-9,-9,-10,-11,-12,-10,-11,-9,-10,-12,-10,11,10,
12,10,9,11,10,12,11,10,9,9,8,7,6,5,4,3,2,10,9,8,7,6,5,4,3,11,10,9,8,7,6,5,4,3,
2,1,12,11,10,9,8,7,6,5,4,3,2,2,1,3),B(-5,-4,-3,-1,-2,-2,3,2,2,1,3,4,5),B(-19,
-18,-17,-16,-15,-14,-13,12,13,14,15,16,17,18,19),B(-5,-4,-3,-2,-1,-1,-2,-3,-4,
-5,-5,-3,-4,-4,5,4,4,3,5,5,4,3,2,1,1,2,3,4,5),B(-1,2,2,2,1),B(-3,4,4,4,
3),B(-3,2,2,2,3),B(-1,-2,-3,4,4,3,2,1),B(-3,-2,1,1,2,3),B(-3,-2,-10,-9,-8,-7,
-5,-6,-4,-5,-2,-3,-4,-4,-2,3,3,3,2,4,4,3,2,5,4,6,5,7,8,9,10,2,3),B(-3,-2,-10,
-9,-8,-7,-5,-6,-4,-5,-2,-3,-4,-4,-5,-2,-3,4,3,2,5,4,4,3,2,5,4,6,5,7,8,9,10,2,
3),B(-3,-1,-2,-10,-11,-5,-6,-7,-8,-9,-10,-4,-5,-6,-7,-8,-9,-2,-3,-4,-5,-6,-7,
-8,-1,-2,-3,-4,-5,-6,-7,-1,-2,-3,-4,-5,-6,-6,-7,-8,-9,-10,-6,-7,-8,-9,-7,-8,
-6,-7,-9,-10,-9,-7,-8,-6,-7,-10,-9,-7,8,7,9,10,7,6,8,7,9,10,9,7,6,8,7,9,8,7,6,
10,9,8,7,6,6,5,4,3,2,1,7,6,5,4,3,2,1,8,7,6,5,4,3,2,9,8,7,6,5,4,10,9,8,7,6,5,
11,10,2,1,3),B(-3,-1,-2,-2,-3,-4,-1,-2,-3,-3,-2,-2,-3,-3,2,3,3,2,2,3,3,2,1,4,
3,2,2,1,3),B(-3,-1,-2,-2,-3,-4,-1,-2,-3,-3,-4,-2,3,3,3,2,4,3,3,2,1,4,3,2,2,1,
3),B(-3,-1,-2,-2,-1,-1,-2,-2,-3,-4,-2,-3,-1,-2,-4,-2,-3,-1,2,2,2,1,3,2,4,2,1,
3,2,4,3,2,2,1,1,2,2,1,3),B(-3,-1,-2,-2,-1,-1,-2,-3,-4,-2,-3,-1,-2,-4,-2,-3,-1,
-2,-2,3,3,3,2,2,1,3,2,4,2,1,3,2,4,3,2,1,1,2,2,1,3),B(-5,6,6,6,5),B(-5,4,4,4,
5),B(-5,-3,-4,-2,3,3,3,2,4,3,5),B(-5,-4,-3,-2,-15,-13,-14,-12,-13,-11,-12,-10,
-11,-2,-11,-12,-13,-8,-9,-10,-11,-12,-7,-8,-9,-10,-11,-6,-7,-8,-9,-10,-2,-3,
-4,-5,-6,-7,-8,9,8,7,6,5,4,3,2,10,9,8,7,6,11,10,9,8,7,12,11,10,9,8,13,12,11,2,
11,10,12,11,13,12,14,13,15,2,3,4,5),B(-5,-4,-3,-2,-2,-3,-3,-2,-2,-2,3,3,2,2,2,
3,3,2,2,3,4,5),B(-5,-6,-1,-2,-3,-4,5,5,5,5,4,3,2,1,6,5),B(-5,-6,-4,-5,-3,4,3,
5,4,6,5),B(-7,8,8,7),B(-5,-6,-7,-4,-5,-6,-3,-4,-5,-2,-3,4,3,2,5,4,3,6,5,4,7,6,
5),B(-15,-13,-14,-12,-13,-13,12,12,12,13,13,12,14,13,15),B(-15,-13,-14,-12,
-13,-15,-13,14,14,14,13,15,13,12,14,13,15),B(-15,-13,-14,-12,-13,-17,-16,-15,
-13,-14,-12,13,13,13,12,14,13,15,16,17,13,12,14,13,15),B(-15,-13,-14,-12,-13,
-18,-17,-16,-15,-13,-14,-12,13,12,14,13,15,16,17,18,13,12,14,13,15),B(-15,-16,
-13,-14,-12,-13,-16,-15,-13,-14,-12,13,12,14,13,15,16,13,12,14,13,16,
15),B(-13,-14,-15,-16,-14,-12,-13,-16,-15,-13,14,13,15,16,13,12,14,16,15,14,
13),B(-13,-14,-15,-16,-17,-14,-12,-13,-17,-16,-15,-13,-14,-12,13,13,12,14,13,
15,16,17,13,12,14,17,16,15,14,13),B(-17,-15,-16,-13,-14,-15,-12,-13,-14,-17,
-16,-14,15,14,16,17,14,13,12,15,14,13,16,15,17),B(-10,11,11,11,10),B(-10,-10,
-9,-8,-7,6,6,7,8,9,10,10),B(-10,-7,-8,9,8,7,10),B(-8,-9,-10,11,10,9,8),B(-10,
-11,-13,-14,-15,-16,-11,-12,-13,-14,-15,-8,-9,-10,-11,-12,-13,14,13,12,11,10,
9,8,15,14,13,12,11,16,15,14,13,11,10),B(-13,-14,-15,-16,-10,-11,-16,-11,-12,
-13,-14,-15,-7,-8,-9,-10,-11,-12,-13,14,13,12,11,10,9,8,7,15,14,13,12,11,16,
11,10,16,15,14,13),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,-11,-12,13,13,13,12,
11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,-11,-12,
-13,-13,-8,-9,-10,-11,-12,-7,-8,-9,-10,-11,-5,-6,-7,-8,-9,-10,-1,-2,-3,-4,-5,
-6,-7,-8,-9,-7,-9,-10,-7,-8,9,8,7,10,9,7,9,8,7,6,5,4,3,2,1,10,9,8,7,6,5,11,10,
9,8,7,12,11,10,9,8,13,13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,
-13,-11,-12,-10,-11,-15,-11,-12,-13,14,13,12,11,15,11,10,12,11,13,12,14,13,
15),B(-10,-9,-8,-7,6,6,6,7,8,9,10),B(-13,-14,-10,-11,-12,-13,-13,-11,-12,-10,
11,11,10,12,11,13,13,12,11,10,14,13),B(-10,-9,-8,-7,-5,-6,-3,-4,-5,-2,-3,4,4,
4,3,2,5,4,3,6,5,7,8,9,10),B(-10,-9,-8,-7,-6,-5,-4,-3,-2,1,2,3,4,5,6,7,8,9,
10),B(-10,-11,-9,10,9,11,10),B(-12,11,12),B(-8,-8,9,8,8),B(-10,-8,-9,-9,-8,-7,
-6,-5,-3,-4,-2,3,2,4,3,5,6,7,8,9,9,8,10),B(-13,12,12,13),B(-13,-12,11,12,
13),B(-13,-14,-12,-13,-11,12,12,12,11,13,12,14,13),B(-13,-14,-8,-9,-10,-11,
-12,-13,-7,-8,-9,-10,-11,-12,-5,-6,-7,-8,-9,-10,-11,-4,-5,-6,-7,-8,-9,10,9,8,
7,6,5,4,11,10,9,8,7,6,5,12,11,10,9,8,7,13,12,11,10,9,8,14,13),B(-15,16,16,16,
16,15),B(-15,14,14,14,15),B(-13,-14,-15,16,16,16,16,15,14,13),B(-10,-9,-8,-7,
-5,-6,-6,-3,-4,-5,-2,-3,4,3,2,5,4,3,6,6,5,7,8,9,10),B(-15,-13,-14,-12,13,13,
13,12,14,13,15),B(-15,-13,-14,-12,-13,-16,-15,-13,-14,-16,-14,15,15,14,16,14,
13,15,16,13,12,14,13,15),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,-11,-12,-13,
-13,-11,12,12,12,11,13,13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,
-13,-11,-12,-10,-11,-11,-12,-13,-13,-11,-8,-9,-10,-11,-12,-13,-7,-8,-9,-10,
-11,-12,-5,-6,-7,-8,-9,-10,-11,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-9,-7,-8,-10,-8,
-9,-7,8,7,9,8,10,8,7,9,10,9,8,7,6,5,4,3,2,1,11,10,9,8,7,6,5,12,11,10,9,8,7,13,
12,11,10,9,8,11,13,13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,-13,
-11,-12,-10,-11,-11,-12,-13,-13,-11,-8,-9,-10,-11,-12,-13,-7,-8,-9,-10,-11,
-12,-11,-9,-10,-12,-10,11,10,12,10,9,11,12,11,10,9,8,7,13,12,11,10,9,8,11,13,
13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,
-17,-18,-16,-17,-15,-16,-11,-12,-13,-14,-15,-13,-14,-11,-12,-13,-15,-13,14,13,
15,13,12,11,14,13,15,14,13,12,11,16,15,17,16,18,17,11,10,12,11,13,12,14,13,
15),B(-5,-4,-8,-7,-6,-4,5,4,6,7,8,4,5),B(-13,-14,-15,-16,17,17,17,16,15,14,
13),B(-13,-14,-15,-16,-10,-11,-12,-13,-14,15,14,13,12,11,10,16,15,14,13),B(-5,
-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,
-14,-15,-15,-16,-16,15,15,16,16,15,15,14,13,12,11,10,9,8,7,6,5,4,3,16,15,14,
13,12,11,10,9,8,7,6,5),B(-3,-3,-4,-2,3,2,4,3,3),B(-15,-13,-14,-12,-13,-11,-12,
-10,-11,-5,-4,-3,-11,-12,-13,-3,-2,-13,-8,-9,-10,-11,-12,-7,-8,-9,-10,-11,-6,
-7,-8,-9,-10,-2,-3,-4,-5,-6,-7,-8,-9,-9,-7,8,7,9,9,8,7,6,5,4,3,2,10,9,8,7,6,
11,10,9,8,7,12,11,10,9,8,13,2,3,13,12,11,3,4,5,11,10,12,11,13,12,14,13,
15),B(-17,-15,-16,-14,15,15,14,16,15,17),B(-17,-15,-16,-13,-14,-15,-12,-13,14,
14,14,13,12,15,14,13,16,15,17),B(-17,-16,-15,-14,-13,-12,-10,11,10,12,13,14,
15,16,17),B(-5,-6,-7,-8,-9,-10,-11,-12,-3,-4,-5,-6,-7,-8,-9,-10,-11,-11,-12,
-13,-14,-15,-16,-12,-13,-14,-15,-11,-12,-13,-14,-14,-15,-16,-15,-14,-16,-14,
15,15,15,15,14,16,14,15,16,15,14,14,13,12,11,15,14,13,12,16,15,14,13,12,11,11,
10,9,8,7,6,5,4,3,12,11,10,9,8,7,6,5),B(-17,-18,-19,-15,-16,-17,-18,-13,-14,
-15,-16,-17,-12,-13,-14,-15,-16,-11,-12,-13,-14,15,14,13,12,11,16,15,14,13,12,
17,16,15,14,13,18,17,16,15,19,18,17),B(-10,-3,-2,-10,-9,-8,-7,-6,-5,-4,-2,3,2,
4,5,6,7,8,9,10,2,3,10),B(-5,-4,-3,-2,-19,-17,-18,-15,-16,-17,-13,-14,-15,-16,
-8,-9,-10,-11,-12,-13,-14,-15,-7,-8,-9,-10,-11,-12,-13,-14,-6,-7,-8,-9,-10,
-11,-12,-13,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,12,11,10,9,8,7,6,5,4,3,2,13,12,11,
10,9,8,7,6,14,13,12,11,10,9,8,7,15,14,13,12,11,10,9,8,16,15,14,13,17,16,15,18,
17,19,2,3,4,5),B(-5,-4,-3,-2,-2,-3,-3,-2,-2,3,3,3,2,2,3,3,2,2,3,4,5)]
end
