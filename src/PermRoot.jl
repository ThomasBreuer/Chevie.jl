"""
Let  `V` be a vector space over a subfield `K` of the complex numbers; here
it  usually means  a `Rational`  or a  `Cyc`. A  *complex reflection* is an
element  `s∈ GL(V)` of finite order whose  fixed point set is an hyperplane
(we  will in the  following just call  it a *reflection*  to abbreviate; in
some  literature the term reflection  is only employed when  the order is 2
and  the  more  general  case  is  called  a  *pseudo-reflection*).  Thus a
reflection  has a unique  eigenvalue not equal  to `1`, which  is a root of
unity.  If  `K`  is  a  subfield  of  the  real numbers, this eigenvalue is
necessarily equal to `-1`.

A  reflection group `W` is a group  generated by a finite number of complex
reflections.

Since  when `W` contains  a reflection `s`  it contains its  powers, `W` is
always  generated  by  reflections  `s`  with non-trivial eigenvalue `E(d)`
where  `d` is the order of `s`; we may in addition assume that `s` is not a
power  of another reflection with larger order. Such a reflection is called
*distinguished*;  it is  a canonical  generator of  the cyclic  subgroup it
generates.  The  generators  of  reflection  groups we construct are always
distinguished  reflections. In a real  reflection group all reflections are
distinguished.

Reflection groups for us are groups `W` with the following methods defined

`gens(W)`: the reflections which generate `W`

`reflections(W)`: a list of distinguished reflections, given as elements of
`W`, which starts with gens(W).

Note  that `W`  does *not*  need to  be a  matrix group. The meaning of the
above  fields is just that `W` has a representation (called the *reflection
representation*  of `W`) where  `reflections(W)` act as  reflections. It is
much  more efficient  to compute  with permutation  groups than with matrix
groups,  when possible.  Information sufficient  to determine  a particular
reflection  representation  is  stored  for  such  groups  (see `roots` and
`coroots`). Note that when `W` is finite, the distinguished reflections are
in bijection with the reflecting hyperplanes.

Let  `W`  be  a  finite  reflection  group  on  the vector space `V` over a
subfield  `K` of the  complex numbers. An  efficient representation that we
use  for computing with such group is, is a permutation representation on a
`W`-invariant  set of root and coroot  vectors for reflections of `W`; that
is,  a  set  `R`  of  pairs  `(r,rᵛ)∈  V×Vᵛ` invariant by `W` and such each
distinguished  reflection  in  `W`  is  defined  by  some  pair in `R` (see
`reflection`). There may be several pairs for each reflection, differing by
roots  of unity. This generalizes the usual construction for Coxeter groups
(the  case `K=ℝ `) where to each reflection of `W` is associated two roots,
a  positive and a negative one.  For irreducible complex reflection groups,
there are at least as many roots on a given line as the order of the center
of `W`.

The  finite  irreducible  complex  reflection  groups  have been completely
classified   by  Shepard  and  Todd.   They  contain  one  infinite  family
`G(de,e,r)` depending on 3 parameters, and 34 exceptional groups which have
been  given by Shephard and Todd names which range from `G₄` to `G₃₇`. They
cover the exceptional Coxeter groups, e.g., `coxgroup(:E,8)` is the same as
`G₃₇`.

We provide functions to build any finite reflection group, either by giving
a  list of  roots and  corrots defining  the generating  reflections, or in
terms  of the classification. The  output is a permutation  group on set of
roots  (see `ComplexReflectionGroup`  and `PermRootGroup`).  In the context
e.g.  of  Weyl  groups,  one  wants  to describe the particular root system
chosen  in term of the  traditional classification of crystallographic root
systems. This is done via calls to the function `coxgroup` (see the chapter
on  finite Coxeter  groups). There  is not  yet a  general theory on how to
construct  a nice set of  roots for a non-real  reflection group; the roots
chosen  here  where  obtained  case-by-case;  however, they satisfy several
important properties:

- The  generating  reflections  satisfy  braid relations which  present the
  braid group associated to `W` (see `Diagram`).

- The *field of definition* of `W` is the field `K` generated by the traces
  of the elements of `W` acting on `V`.

It  is a theorem that  `W` may be realized  as a reflection group over `K`.
For  almost  all  irreducible  complex  reflection  groups,  the generating
matrices  for `W`  we give  have coefficients  in `K`.  Further, the set of
matrices  for all  elements of  `W` is  globally invariant under the Galois
group  of `K/ℚ `, thus the Galois  action induces automorphisms of `W`. The
exceptions  are `G₂₂, G₂₇` where the matrices are in a degree two extension
of   `K`  (this  is  needed  to   have  a  globally  invariant  model,  see
[MarinMichel2010](biblio.htm#MarinMichel10))  and  some  dihedral groups as
well  as  `H_3`  and  `H_4`,  where  the  matrices given (the usual Coxeter
reflection representation over `K`) are not globally invariant.

It turns out that all representations of a complex reflection group `W` are
defined  over the  field of  definition of  `W` (cf.  [Ben76] and D.~Bessis
thesis).  This has been known for a long  time in the case `K=ℚ `, the case
of Weyl groups: their representations are defined over the rationals.
-  The Cartan matrix (see "CartanMat") for the generating roots (those which
   correspond  to the generating reflections) has  entries in the ring `ℤₖ`
   of integers of `K`, and the roots (resp. coroots) are linear combination
   with coefficients in `ℤₖ` of a linearly independent subset of them.

The finite reflection groups have thus the following additional fields:

`roots`:  a  set  of  complex  roots  in  `V`,  given  as a list of lists
       (vectors), on which `W` has a faithful permutation representation.

       `coroots`: the  coroots for `gens(W)`.

Here  we  describe  functions  available  for  finite reflection groups `W`
represented  as permutation groups on a  set of roots. These functions make
use  of the classification of `W` whenever it is known, but work even if it
is not known.

Let `SV` be the symmetric algebra of `V`. The invariants of `W` in `SV` are
called  the  *polynomial  invariants*  of  `W`.  They  are  generated  as a
polynomial   ring   by   `dim   V`  homogeneous  algebraically  independent
polynomials  `f₁,…,f_{dim  V}`.  The  polynomials  `fᵢ`  are not uniquely
determined  but  their  degrees  are.  The  `fᵢ`  are  called  the  *basic
invariants*  of `W`, and their degrees the *reflection degrees* of `W`. Let
`I` be the ideal generated by the homogeneous invariants of positive degree
in  `SV`. Then `SV/I` is isomorphic to the regular representation of `W` as
a  `W`-module. It  is thus  a graded  (by the  degree of  elements of `SV`)
version  of the regular  representation of `W`.  The polynomial which gives
the  graded multiplicity  of a  character `φ`  of `W`  in the graded module
`SV/I` is called the *fake degree* of `φ`.
"""
module PermRoot

export PermRootGroup, PRG, PRSG, catalan,
 reflection_subgroup, simple_reps, simple_conjugating, 
 reflections, reflection, Diagram, refltype, cartan, independent_roots, 
 inclusion, inclusiongens, restriction, coroot, hyperplane_orbits, TypeIrred,
 refleigen, reflchar, bipartite_decomposition, torus_order, rank, reflrep, 
 PermX, coroots, baseX, invbaseX, semisimplerank, invariant_form, generic_order,
 parabolic_reps, invariants,improve_type, matY, simpleroots,
 simplecoroots, action, radical, parabolic_closure, is_parabolic,
 central_action
using ..Gapjm

best_type(x)=typeof(x)
best_type(x::Cyc{Rational{T}}) where T=iszero(x) ? Int : x.n==1 ? 
  best_type(Rational(x)) : denominator(x)==1 ?  Cyc{T} : typeof(x)
best_type(x::Cyc{T}) where T<:Integer=x.n==1 ? T : typeof(x)
best_type(x::Rational)= denominator(x)==1 ? typeof(numerator(x)) : typeof(x)
best_type(m::Array{T,N}) where {T,N}=isempty(m) ? typeof(m) : 
  Array{reduce(promote_type,best_type.(m)),N}
best_type(p::Pol)=iszero(p) ? Pol{Int} : 
  Pol{reduce(promote_type,best_type.(p.c))}
best_type(p::Mvp{T,N}) where {T,N}=iszero(p) ? Mvp{Int,Int} : 
    Mvp{reduce(promote_type,best_type.(values(p.d))),N}
  
improve_type(m)=convert(best_type(m),m)

# coroot for an orthogonal reflection
function coroot(root::Vector,eigen::Number=-1)
  cr=conj.(root)
  cr.*((1-eigen)//sum(cr.*root))
end

"""
`reflection(root, coroot)::Matrix` the reflection of given root and coroot

A  (complex) reflection in `GL(V)`, the linear group of a vector space over
a subfield of the complex numbers, is a map `s` of finite order whose fixed
points  are  a  hyperplane  `H`  (the  *reflecting  hyperplane* of `s`); an
eigenvector  `r` for  the non-trivial  eigenvalue `ζ`  (a root of unity) is
called  a *root* of `s`. If we choose a linear form `rᵛ` (called a *coroot*
of `s`) defining `H` such that `rᵛ(r)=1-ζ` then the linear map `s` is given
by `x↦x-rᵛ(x)r`.

A  way of specifying a  reflection is by giving  a root and a coroot, which
are  uniquely determined by the reflection up to multiplication of the root
by  a  scalar  and  of  the  coroot  by  the  inverse  scalar. The function
`reflection`  gives  the  matrix  of  the  corresponding  reflection in the
standard  basis of `V`, where the `root` and the `coroot` are vectors given
in  the standard  bases of  `V` and  `Vᵛ`, so  that `rᵛ(r)`  is obtained as
`permutedims(root)*coroot`.

```
julia> r=reflection([1,0,0],[2,-1,0])
3×3 Matrix{Int64}:
 -1  0  0
  1  1  0
  0  0  1

julia> r==reflrep(coxgroup(:A,3),1)
true

julia> r*[2,-1,0]
3-element Vector{Int64}:
 -2
  1
  0

julia> [1 0 0]*r
1×3 Matrix{Int64}:
 -1  0  0
```
As  we see in the last lines, in our package the matrices operate an `V` as
row vectors and on `Vᵛ` as column vectors
"""
function reflection(root::AbstractVector,coroot::AbstractVector)
  root,coroot=promote(root,coroot)
  m=[i*j for i in coroot, j in root]
  one(m)-m
end
#------------------------------------------------------------------------
@GapObj struct TypeIrred end

Base.copy(t::TypeIrred)=TypeIrred(copy(t.prop))

indices(t::TypeIrred)=haskey(t,:indices) ? t.indices : haskey(t,:orbit) ?
isempty(t.orbit) ? Int[] : length(t.orbit)==1 ? t.orbit[1].indices :
vcat(getproperty.(t.orbit,:indices)...) : nothing

indices(t::Vector{TypeIrred})=isempty(t) ? Int[] : vcat(indices.(t)...)

function rank(t::TypeIrred)
  if haskey(t,:rank) return t.rank end
  i=indices(t)
  if i!==nothing return length(i) end
end

function Base.show(io::IO, t::TypeIrred)
  replorTeX=get(io,:limit,false) || get(io,:TeX,false)
  function sub(p,n)
    s=string(n)
    string(p)*(length(s)==1 ? "_"*s : "_{"*s*"}")
  end
  if haskey(t,:series)
    s=t.series
    if s==:ST 
      if haskey(t,:ST) 
        n=replorTeX ? sub("G",t.ST) : "ComplexReflectionGroup($(t.ST))"
      else 
        n=replorTeX ? "G_{$(t.p),$(t.q),$(t.rank)}" : 
          "ComplexReflectionGroup($(t.p),$(t.q),$(t.rank))"
      end
    else 
      r=rank(t)
      if haskey(t,:cartanType)
        if s==:B
          if t.cartanType==1 s=:C
          elseif t.cartanType==2 s=:B
          elseif t.cartanType==ER(2) s=:Bsym
          else s=Symbol("B(",repr(t.cartanType;context=io),")")
          end
        elseif s==:G
          if t.cartanType==ER(3) s=:Gsym end
        elseif s==:I
          if t.cartanType==1 s=:I
          elseif t.cartanType==-(E(2*t.bond)+E(2*t.bond)) s=:Isym 
          else s=Symbol("I(",repr(t.cartanType;context=io),")")
          end
        end
      end
      if haskey(t,:bond)
        b=t.bond
        n=replorTeX ? sub(s,r)*"($b)" : "coxgroup(:$s,$r,$b)"
      elseif haskey(t,:short)
        n=replorTeX ? "\\tilde "*sub(s,r) : "coxgroup(:$s,$r)"
      else
        n=replorTeX ? sub(s,r) : "coxgroup(:$s,$r)"
      end
    end
    printTeX(io,n)
  else
    o=order(t.twist)
    if replorTeX
      if o!=1 printTeX(io,"{}^{$o}") end
      if length(t.orbit)==1 print(io,t.orbit[1]) 
      else print(io,"(")
        for t1 in t.orbit print(io,t1) end
        print(io,")") 
      end
    else
      print(io,"spets(",t.orbit)
      p=prod(map((x...)->Perm(x...),map(x->x.indices,t.orbit)...))*t.twist
      if !isone(p) print(io,",",p) end
      print(io,")")
    end
    if haskey(t,:scalar) && !all(isone,t.scalar)
      print(io,"[");join(io,t.scalar,",");print(io,"]")
    end
  end
end

struct Diagram
  t::TypeIrred
end

Base.show(io::IO,::MIME"text/plain",v::Vector{Diagram})=show(io,v)

function Base.show(io::IO,v::Vector{Diagram})
  for (i,d) in enumerate(v) 
    print(io,d)
    if i!=length(v) println(io) end 
  end
end

function Base.show(io::IO,d::Diagram)
  t=d.t
  if haskey(t,:orbit)
    act=length(t.orbit)>1
    if act
      println(io,"ϕ permutes the next ",length(t.orbit)," components")
    end
    if !isone(t.twist)
     println(io,"ϕ",act ? "^$(length(t.orbit))" : "",
      " acts as ",t.twist^mappingPerm(t.orbit[1].indices,1:rank(t.orbit[1])),
      " on the component below")
    end
    show(io,Diagram.(t.orbit))
  else
    series=t.series::Symbol
    indices=t.indices
    if isnothing(indices) ind=fill("?",rank(t))
    else ind=repr.(indices)
    end
    l=length.(ind)
    bar(n)="\u2014"^n
    rdarrow(n)="\u21D0"^(n-1)*" "
    ldarrow(n)="\u21D2"^(n-1)
    tarrow(n)="\u21DB"^(n-1)*" "
    vbar="\UFFE8" # "\u2503"
    node="O"
    if series==:A
      join(io,node.*bar.(l[1:end-1]));println(io,node);join(io,ind," ")
    elseif series==:B
      print(io,node,rdarrow(max(l[1],2)));join(io,node.*bar.(l[2:end-1]))
      println(io,node)
      print(io,rpad(ind[1],max(3,l[1]+1)));join(io,ind[2:end]," ")
    elseif series==:C
      print(io,node,ldarrow(max(l[1],2)));join(io,node.*bar(l[2:end-1]))
      println(io,node)
      print(io,rpad(ind[1],max(3,l[1]+1)));join(io,ind[2:end]," ")
    elseif series==:D
      println(io," "^l[1]," O $(ind[2])\n"," "^l[1]," ",vbar)
      println(io,node,bar(l[1]),map(l->node*bar(l),l[3:end-1])...,node)
      print(io,ind[1]," ",join(ind[3:end]," "))
    elseif series==:E
      dec=2+l[1]+l[3]
      println(io," "^dec,"O $(ind[2])\n"," "^dec,vbar)
      println(io,node,bar(l[1]),node,bar(l[3]),
                join(map(l->node*bar(l),l[4:end-1])),node)
      print(io,join(ind[[1;3:end]]," "))
    elseif series==:F
      println(io,node,bar(l[1]),node,ldarrow(max(l[2],2)),node,bar(l[3]),node)
      print(io,ind[1]," ",ind[2]," "^max(2-l[2],1),ind[3]," ",ind[4])
    elseif series==:G
      println(io,node,tarrow(max(l[1],2)),node)
      print(io,ind[1]," "^max(3-l[1],1),ind[2])
    elseif series==:ST
      if haskey(t,:ST) getchev(t,:PrintDiagram,t.indices,"G$(t.ST)") 
      else getchev(t,:PrintDiagram,t.indices,"G$(t.p),$(t.q),$(rank(t))") 
      end
    end
  end
end

#---------------------------------------------------------------------------
abstract type PermRootGroup{T,T1<:Integer}<:PermGroup{T1} end 

Diagram(W::PermRootGroup)=Diagram.(refltype(W))
inclusiongens(W::PermRootGroup)=inclusion(W,eachindex(gens(W)))
inclusion(L,W,i)=restriction(W,inclusion(L,i))
inclusiongens(L,W)=restriction(W,inclusiongens(L))
# should use independent_roots

Base.:(==)(W::PermRootGroup,W1::PermRootGroup)=roots(W)==roots(W1) &&
  coroots(W)[1:ngens(W)]==coroots(W1)[1:ngens(W1)]

"""
return for each root the index of the first simple root conjugate to it"
"""
function simple_reps(W::PermRootGroup) # fills .repelms and .reflections
  get!(W,:rootreps)do
    reps=fill(0,length(roots(W)))
    repelts=fill(one(W),length(roots(W)))
    for i in eachindex(gens(W))
      if iszero(reps[i])
        d=transversal(W,inclusion(W,i))
        for (n,e) in d 
          reps[restriction(W,n)]=i
          repelts[restriction(W,n)]=e
        end
      end
    end
    W.repelms=repelts
    W.reflections=map((i,p)->gens(W)[i]^p,reps,repelts)
    reps
  end
end

simple_reps(W::PermRootGroup,i)=simple_reps(W)[i]

"list of same length as W.roots giving corresponding reflections"
function reflections(W::PermRootGroup)
  getp(simple_reps,W,:reflections)
end

"""
`reflection(W,i)`

reflection for `i`-th root of `W`
"""
reflection(W::PermRootGroup,i)=reflections(W)[i]

simple_conjugating(W::PermRootGroup)=getp(simple_reps,W,:repelms)

"element `w` such that `simple_reps(W,i)^w==i`"
simple_conjugating(W::PermRootGroup,i)=simple_conjugating(W)[i]

"""
`cartan(W::PermRootGroup,i,j)`
the cartan coefficient `cᵢ(rⱼ)` of the `i`-th coroot and the `j`-th root of `W`
"""
function cartan(W::PermRootGroup,i,j)
# r=roots(W,j)-roots(W,action(W,j,reflection(W,i)))
# v=findfirst(!iszero,roots(W,i))
# r[v]//roots(W,i)[v]
  only(permutedims(coroots(W,i))*roots(W,j))
  #faster than sum(coroots(W,i).*roots(W,j))
end

"""
`cartan(W::PermRootGroup)`    Cartan matrix of `W`.

Let  `s₁,…,sₙ` be reflections with associated  roots `rᵢ` and coroots `cᵢ`.
The  matrix `C` with  entries `Cᵢ,ⱼ=cᵢ(rⱼ)` is  called a *Cartan matrix* of
`s₁,…,sₙ`.  It is uniquely  determined by `s₁,…,sₙ`  up to conjugation by a
diagonal matrix.

If `s₁,…,sₙ` generate a reflection group `W`, then `C` up to conjugation by
a  diagonal matrix is an invariant of the reflection representation of `W`.
If invertible `C` determines this representation since then the `rᵢ` form a
basis  in which the matrix  for `sᵢ` differs from  the identity only on the
`i`-th line, where the corresponding line of `C` has been subtracted.

```julia-repl
julia> W=coxgroup(:A,3)
A₃

julia> cartan(W)
3×3 Matrix{Int64}:
  2  -1   0
 -1   2  -1
  0  -1   2
```
"""
function cartan(W::PermRootGroup)
  get!(W,:cartan)do
    improve_type([cartan(W,i,j) for i in eachindex(gens(W)), j in
                  eachindex(gens(W))])
  end
end

function cartan(t::TypeIrred)
  c=improve_type(getchev(t,:CartanMat))
  if isempty(c) fill(0,0,0) else toM(c) end
end

cartan(W::PermRootGroup,I)=[cartan(W,i,j) for i in I, j in I]

"""
rank(W::Group)

This  function  returns  the  *rank*  of  a  reflection group, which is the
dimension of the space where it acts.

```julia-repl
julia> rank(ComplexReflectionGroup(31))
4
```
"""
function rank(W::PermRootGroup)
  if isempty(roots(W)) W.rank
  else length(roots(W,1))
  end
end

"""
Let  W be an irreducible CRG,  generated by distinguished reflections S.
type_irred classifies W (returns a type record) using:

    r=semisimplerank(W)
    s=length(W)/factorial(r)
    D=all distinguished reflections of W=orbit of S,    which gives
      o=the maximum order of a reflection=max_{s∈ D}o(s)
      h=the Coxeter number=sum_{s∈ D}o(s)

G(de,e,r) has s=(de)ʳ/e, o=max(2,d), h=ed(r-1)+d-δ_{d,1}

(r,s,o)  are  sufficient  to  determine  a G(de,e,r) excepted for ambiguity
G(2e,e,2)/G(4e,4e,2),  which is resolved  by h (excepted  for e=1, when the
two solutions are isomorphic).

(r,s,o) are also sufficient to distinguish primitive groups except in the
cases (which are resolved by h):
 G9/G(24,6,2)
 G12/G(12,6,2)/G(24,24,2)
 G13/G(24,12,2)/G(48,48,2)
 G22/G(60,30,2)/G(120,120,2)
 G7/G14/G(24,8,2)
 G8/G(12,3,2) 
 G15/G(48,16,2)
 G17/G(120,24,2)
 G21/G(120,40,2)
"""
function type_irred(W::PermRootGroup)
prim=[
  (r=0, s=0, o=0, h=0),  # 3 dummy items to get right Shephard-Todd number
  (r=0, s=0, o=0, h=0), 
  (r=0, s=0, o=0, h=0), 
  (r=2, s=12, o=3, h=6), 
  (r=2, s=36, o=3, h=12), 
  (r=2, s=24, o=3, h=12), 
  (r=2, s=72, o=3, h=18), 
  (r=2, s=48, o=4, h=12), 
  (r=2, s=96, o=4, h=24), 
  (r=2, s=144, o=4, h=24), 
  (r=2, s=288, o=4, h=36), 
  (r=2, s=24, o=2, h=12), 
  (r=2, s=48, o=2, h=18), 
  (r=2, s=72, o=3, h=24), 
  (r=2, s=144, o=3, h=30), 
  (r=2, s=300, o=5, h=30), 
  (r=2, s=600, o=5, h=60), 
  (r=2, s=900, o=5, h=60), 
  (r=2, s=1800, o=5, h=90), 
  (r=2, s=180, o=3, h=30), 
  (r=2, s=360, o=3, h=60), 
  (r=2, s=120, o=2, h=30), 
  (r=3, s=20, o=2, h=10), 
  (r=3, s=56, o=2, h=14), 
  (r=3, s=108, o=3, h=12), 
  (r=3, s=216, o=3, h=18), 
  (r=3, s=360, o=2, h=30), 
  (r=4, s=48, o=2, h=12), 
  (r=4, s=320, o=2, h=20), 
  (r=4, s=600, o=2, h=30), 
  (r=4, s=1920, o=2, h=30), 
  (r=4, s=6480, o=3, h=30), 
  (r=5, s=432, o=2, h=18), 
  (r=6, s=54432, o=2, h=42), 
  (r=6, s=72, o=2, h=12), 
  (r=7, s=576, o=2, h=18), 
  (r=8, s=17280, o=2, h=30)]

  r=semisimplerank(W)
  s=div(length(W),factorial(r))
  if s==r+1 return Dict(:series => :A, :rank => r)
  elseif r==1 return Dict(:series=>:ST,:p=>s,:q=>1,:rank=>1)
  else l=([p.^(a+m-a*r,a*r-m) for a in div(m+r-1,r):div(m,r-1)]
                       for (p,m) in factor(s))
    de=vec((x->(d=prod(first.(x)),e=prod(last.(x)))).(Iterators.product(l...)))
  end
  o=maximum(order.(gens(W)))
# println("de=$de, o=$o, h=$h")
  de=filter(x->o==max(2,x.d),de) #  here we have length(de)<=2
  ST=filter(i->r==prim[i].r && s==prim[i].s && o==prim[i].o,eachindex(prim))
# if isempty(de) && length(ST)==1 # shortcut
#   return Dict(:series=>:ST, :ST=>only(ST), :rank=> r)
# end
  h=div(sum(order,Set(reflections(W))),r) # Coxeter number
  if length(de)>1
    de=sort(de)
    if h==de[1].e de=[de[1]]
    elseif h==2*de[2].e+2 de=[de[2]]
    else return Dict(:series=>:ST, :ST=>only(ST), :rank=> r)
    end
  end
  if length(de)>0 && length(ST)>0
    ST=filter(i->prim[i].h==h,ST)
    if !isempty(ST) return Dict(:series=>:ST, :ST=>only(ST), :rank=>r) end
  end
  if length(de)==0
    if only(ST) in [23,30] return Dict(:series=>:H, :rank => r)
    elseif only(ST)==28 return Dict(:series=>:F, :rank => r)
    elseif only(ST) in 35:37 return Dict(:series=>:E, :rank => r)
    else return Dict(:series=>:ST,:ST =>only(ST),:rank => r)
    end
  end
  d=only(de)
  if d.d==2 && d.e==1 return Dict(:series=>:B, :rank=>r) end
  if d.d==1 && d.e==2 return Dict(:series=>:D,:rank=>r) end
  if d.d==1 && r==2
    if d.e==4 return Dict(:series=>:B, :rank=>2)
    elseif d.e==6 return Dict(:series=>:G, :rank=>2)
    else return Dict(:series=>:I, :rank=>2, :bond=>d.e)
    end
  end
  Dict(:series=>:ST, :p=>d.d*d.e, :q=>d.e, :rank=>r)
end

"""
`check_minimal_relation(gens,rel;verbose=false)`

returns `true` iff the homogeneous relation
`prod(gens[rel[1]])==prod(gens[rel[2]])` is a minimal relation between gens
(in  particular,  no  left  factor  homogeneous  relation  holds),  `false`
otherwise. If `verbose=true` prints a description of failure.
"""
function check_minimal_relation(gens,rel;verbose=false)
  p(l,r)=joindigits(l)*"="*joindigits(r)
  L,R=rel
  l=gens[L[1]]
  r=gens[R[1]]
  i=1
  while i<length(L)
    if l==r
      if verbose print(" relation ",p(L[1:i],R[1:i])," already holds") end
      return false
    end
    i+=1
    l*=gens[L[i]]
    r*=gens[R[i]]
  end
  if l==r return true end
  if verbose print(" relation ",p(L,R)," failed") end
  false
end

# g is a sublist of 1:length(H.roots). Returns sublist k of g such that 
# reflection.(Ref(H),k) satisfy braid and order relations of type t
function findgoodgens(H,g,t::TypeIrred)
# println("g=$g\n t=");ds(t)
  orders=t.series in [:E,:F,:G,:H] ? fill(2,rank(t)) :
           Int.(inv.(getchev(t,:EigenvaluesGeneratingReflections)))
  rels=groupby(r->maximum(r[1]),braid_relations(t))
  # check gens satisfy relations concerning them, find if can add
  # another gen from rest
  function findarr(gens,rest)
    if length(gens)==length(orders)
      if length(Group(gens))==length(H) return Int[]
      else return nothing
      end
    end
    i=length(gens)+1
    for e in rest
#     println("$e(",length(gens),")")
      r=reflection(H,e)
      if order(r)!=orders[i] continue end
      newgens=vcat(gens,[r])
      if !haskey(rels,i) || all(r->check_minimal_relation(newgens,r),rels[i])
        res=findarr(newgens,setdiff(rest,[e]))
        if !isnothing(res) return vcat([e],res) end
      end
    end
    return nothing
  end
  return findarr(eltype(H)[],g)
end

# findgoodcartan(H,g,C):  g is a sublist of eachindex(H.roots). 
# Returns sublist k of g such that cartan(H,k)=C or nothing if none exists.
function findgoodcartan(H,g,C)
  function find(k,rest) # k has good cartan, see if can add some e∈ rest
    if length(k)==size(C,1) return k end
    i=length(k)+1
    for e in rest
#     println("$e(",length(k),")")
      if cartan(H,e,e)==C[i,i] &&
         all(j->cartan(H,e,k[j])==C[i,j],1:i-1) &&
         all(j->cartan(H,k[j],e)==C[j,i],1:i-1)
        res=find(vcat(k,[e]),setdiff(rest,[e]))
        if !isnothing(res) return res end
      end
    end
    return nothing
  end
  return find(Int[],g)
end

# try to make indecomposable CartanMat(H,p) like C by rotating roots
function fixCartan(H,C,p)
  CH=cartan(H,p)
  r=Weyl.type_fincox_cartan(CH)
  if !isnothing(r) return [r,p] end
  seen=[size(CH,1)]
  for i in size(CH,1):-1:1
  # go reverse for better luck in type B?
    for j in i:-1:1
      if CH[i,j]!=C[i,j]
        if CH[i,j]==0 || (j in seen) return nothing end
          r=C[i,j]//CH[i,j]
          r=findfirst(==(roots(H,p[j])*r),roots(H))
          if r===nothing return nothing end
          p=copy(p)
          p[j]=r
          return fixCartan(H,C,p)
        end
      if C[i,j]!=0 push!(seen,j) end
    end
  end
  return [r,p]
end

# find a sublist of inclusion(H) with cartan equal to C^diagonal matrix
# returns [sublist, coeffs of corresp. diagonal matrix]
function findgensDiagCartan(H,C)
  f(x,y)=y==0 ? (x==0 ? 0 : nothing) : x//y
  # here CartanMat(H,l) is conjugate by DiagonalMat(d) to beginning of C
  function complete(l,d)local r,c,cc,n
    if length(l)==size(C,1) return (l,d) end
    n=length(l)+1
    for r in filter(i->cartan(H,i,i)==C[n,n],eachindex(roots(H)))
      cc=vcat(map(i->f(d[i]*C[i,n],cartan(H,l[i],r)),1:n-1),
              map(i->f(d[i]*cartan(H,r,l[i]),C[n,i]),1:n-1))
      cc=setdiff(cc,[0])
      if length(cc)<=1 && !(nothing in cc)
        if length(cc)==0 cc=[1] end
        c=complete(vcat(l,[r]),vcat(d,[cc[1]]))
        if c!=nothing return c end
      end
    end
  end
  return complete(Int[],eltype(C)[])
end

function refltype(W::PermRootGroup)::Vector{TypeIrred}
  get!(W,:refltype)do
    map(diagblocks(cartan(W))) do I
      R=I==eachindex(gens(W)) ? W : reflection_subgroup(W,I;NC=true)
      d=TypeIrred(type_irred(R))
      C=cartan(d)
      if C==cartan(R) indices=I
      else 
        good=findgoodcartan(R,eachindex(gens(R)),C)
        if isnothing(good) good=findgoodcartan(R,eachindex(roots(R)),C) end
        if isnothing(good) good=findgoodgens(R,
                       Int.(indexin(unique(reflections(R)),reflections(R))),d)
          better=fixCartan(R,C,good)
          if !isnothing(better) good=better[2] 
          else better=findgensDiagCartan(R,C)
            if !isnothing(better) good=better[1] end
          end
          if d.series!=:ST 
            d=TypeIrred(Weyl.type_fincox_cartan(cartan(R,good)))
          end
        end
        indices=inclusion(R,W,good)
      end
      d.indices=indices
      d
    end
  end
end

"""
`hyperplane_orbits(W)`

returns  a  list  of  named  tuples,  one  for each hyperplane orbit of the
reflection  group `W`. If `o` is the named tuple for such an orbit, and `s`
is  the first  element of  `gens(W)` whose  hyperplane is  in the orbit, it
contains the following fields

 `o.s`:     index of `s` in `gens(W)`

 `o.cl_s`:  `map(i->position_class(W,s^i),1:o.order-1)`

 `o.order`: order of s

 `.N_s`:    Size of orbit

 `.det_s`:  for i in `1:o.order-1`, position in CharTable of `(det_s)^i`

```julia-repl
julia> W=coxgroup(:B,2)
B₂

julia> hyperplane_orbits(W)
2-element Vector{NamedTuple{(:s, :cl_s, :order, :N_s, :det_s), Tuple{Int64, Vector{Int64}, Int64, Int64, Vector{Int64}}}}:
 (s = 1, cl_s = [2], order = 2, N_s = 2, det_s = [5])
 (s = 2, cl_s = [4], order = 2, N_s = 2, det_s = [1])
```
"""
function hyperplane_orbits(W::PermRootGroup)
  sr=simple_reps(W)
  rr=reflections(W)
  cr=classreps(W)
  orb=unique(sort(sr))
  class=map(orb)do s
    map(1:order(reflection(W,s))-1)do o
#     return position_class(W,reflection(W,s)^o)
      for i in eachindex(sr)
        if sr[i]==s
          p=findfirst(==(rr[i]^o),cr)
          if p!==nothing return p end
        end
      end
      error("not found")
    end
  end
  chars=CharTable(W).irr
  pairs=zip(orb,class)
  map(pairs) do (s,c)
    ord=order(W(s))
    dets=map(1:ord-1) do j
      findfirst(i->chars[i,1]==1 && chars[i,c[1]]==E(ord,j) &&
         all(p->chars[i,p[2][1]]==1 || p[1]==s,pairs),axes(chars,1))
    end
    (s=s,cl_s=c,order=ord,N_s=classinfo(W)[:classes][c[1]],det_s=dets)
  end
end
  
"""
`bipartite_decomposition(W)`
    
Returns  a bipartite decomposition `[L,R]` of the indices of the generators
of  the  reflection  group  `W`,  such  that `reflection_subgroup(W,L)` and
`reflection_subgroup(W,R)` are abelian subgroups, and
`W=reflection_subgroup(W,   vcat(L,R))`.   Gives   an   error  if  no  such
decomposition is possible.
    
```julia-repl
julia> bipartite_decomposition(coxgroup(:E,8))
([1, 4, 6, 8], [3, 2, 5, 7])

```
"""
function bipartite_decomposition(W)
  L=Int[]
  R=Int[]
  rest=collect(eachindex(gens(W)))
  commute(x,y)=W(x)*W(y)==W(y)*W(x)
  while length(rest)>0
    r=findfirst(x->any(y->!commute(x,y),L),rest)
    if r!=nothing 
      if any(y->!commute(rest[r],y),R) 
        error(W," has no bipartite decomposition")
      end
      push!(R,rest[r])
      deleteat!(rest,r)
    else r=findfirst(x->any(y->!commute(x,y),R),rest)
      if r!=nothing push!(L,rest[r]); deleteat!(rest,r)
      else push!(L,rest[1]); deleteat!(rest,1);
      end
    end
  end
  L,R
end

tr(m)=sum(i->m[i,i],axes(m,1))

"""
`reflchar(W,w)` Reflection character
    
Returns  the trace  of the  element `w`  of the  reflection group `W` as an
endomorphism of the vector space `V` on which `W` acts. This is the same as
`trace(reflrep(W,w))`.

julia-repl```
julia> W=coxgroup(:B,3)
B₃

julia> reflchar(W,longest(W))
-3
julia-repl```
"""
reflchar(W::PermRootGroup,w)=tr(reflrep(W,w))

"""
`reflchar(W)`

Returns  the reflection character of the  reflection group `W`. This is the
same  as `map(c->reflchar(W,c),class-reps(W))`. When `W` is irreducible, it
is also `CharTable(W).irr[charinfo(W)[:extRefl][2]]`.

```julia-repl
julia> reflchar(coxgroup(:A,3))
5-element Vector{Int64}:
  3
  1
 -1
  0
 -1
```
"""
reflchar(W::PermRootGroup)=reflchar.(Ref(W),classreps(W))
  
"""
`refleigen(W)` Reflection eigenvalues

Let  `W`  be  a  reflection  group  on the vector space `V`. `refleigen(W)`
returns   for  each  conjugacy   class  representative  `x`   of  `W`  (see
`classreps`) the eigenvalues of `x` on `V`, as a list of `Root1`.

```julia-repl
julia> refleigen(coxgroup(:B,2))
5-element Vector{Vector{Root1}}:
 [1, 1]
 [1, -1]
 [-1, -1]
 [1, -1]
 [ζ₄, ζ₄³]
```
"""
function refleigen(W)
  get!(W,:refleigen) do
    t=refltype(W)
    if isempty(t) ll=[Root1[]]
    elseif any(x->haskey(x,:orbit) && 
        (length(x.orbit)>1 || order(x.twist)>1),t) # slow; do it right
      return map(x->roots(CycPol(charpoly(reflrep(W,x)))),classreps(W))
    else
      ll=map(x->vcat(x...),cartesian(map(refleigen,t)...))
    end
    central=W isa Spets ? torusfactors(W) : 
                          fill(Root1(1),rank(W)-semisimplerank(W))
    ll=map(x->vcat(x,central),ll)
    W.reflengths=map(x->count(!isone,x),ll)
    ll
  end
end

function refleigen(t::TypeIrred)
  ct=CharTable(t).irr[charinfo(t)[:extRefl],:]
  v=map(i->Pol([(-1)^i],i),size(ct,1)-1:-1:0)
  l=CycPol.((permutedims(v)*ct)[1,:])
  ll=map(p->vcat(map(((r,c),)->fill(r,c),p.v.d)...),l)
  if haskey(t,:scalar) ll.*=Root1(prod(t.scalar)) end
  ll
end

refleigen(W,i)=refleigen(W)[i]

"""
`reflength(W,w)`

This  function returns the  number of eigenvalues  of `w` in the reflection
representation  which are not equal to 1.  For a finite Coxeter group, this
is  equal to the  reflection length of  `w`, that is  the minimum number of
reflections  of which  `w` is  a product.  This also  holds in general in a
well-generated  complex reflection group  if `w` divides  a Coxeter element
for the reflection length.

```julia-repl
julia> W=coxgroup(:A,4)
A₄

julia> reflength(W,longest(W))
2

julia> reflength(W,W(1,2,3,4))
4
```
"""
function Perms.reflength(W::PermRootGroup,w::Perm)
  getp(refleigen,W,:reflengths)[position_class(W,w)]
end

"""
`torus_order(W,i,q)`

returns  as a  polynomial in  `q` the  toric order  of the `i`-th conjugacy
class  of `W`. This is the characteristic  polynomial of an element of that
class  on  the  reflection  representation  of  `W`.  It is the same as the
generic  order of the reflection subcoset  of `W` determined by the trivial
subgroup and a representative of the `i`-th conjugacy class.

```julia-repr
julia> W=ComplexReflectionGroup(4);Pol(:q);

julia> torus_order.(Ref(W),1:HasType.NrConjugacyClasses(W),q)
7-element Vector{Pol{Cyc{Int64}}}:
 q²-2q+1
 q²+2q+1
 q²+1
 q²-ζ₃q+ζ₃²
 q²+ζ₃q+ζ₃²
 q²+ζ₃²q+ζ₃
 q²-ζ₃²q+ζ₃
```
"""
torus_order(W::PermRootGroup,i,q)=prod(l->q-E(l),refleigen(W)[i])

function Groups.centre(W::PermRootGroup)
  get!(W,:centre)do
    ci=classinfo(W)
    ct=ci[:classtext]
    pos=findall(i->ci[:classes][i]==1 && length(ct[i])>0,eachindex(ct))
    if isempty(pos) return Group([one(W)]) end
    central=map(x->W(ct[x]...),pos)
    Group(abelian_gens(central))
  end
end
     
cycletypes(W,x)=map(o->cycletype(x,domain=o),orbits(W)) # first invariant

# eventually rewrite this dispatching on types
function classinv(W::PermRootGroup)
  get!(W,:classinv)do
    cycletypes.(Ref(W),classreps(W))
  end
end

function Groups.position_class(W::PermRootGroup,w)
  l=findall(==(cycletypes(W,w)),classinv(W))
  if length(l)==1 return l[1] end
  if length(centre(W))>1
    central=gens(centre(W))
    l=filter(i->cycletypes.(Ref(W),classreps(W)[i].*central)==
                cycletypes.(Ref(W),w.*central),l)
    if length(l)==1 return l[1] end
  end
  # doit type by type
  if length(W)<20 return findfirst(c->w in c,conjugacy_classes(W)) end
  ncl=classinfo(W)[:classes][l]
  s=sortperm(ncl)
  for i in s 
    if length(s)==1 return l[i] end
    if ncl[i]>10000 && haskey(W,:classes) && !isassigned(W.classes,l[i])
      println("!! computing class ",l[i]," of cardinal ",ncl[i])
    end
    if w in conjugacy_class(W,l[i]) return l[i] end
  end
end

Base.show(io::IO,::MIME"text/plain",v::Vector{TypeIrred})=show(io,v)

function Base.show(io::IO, t::AbstractVector{<:TypeIrred})
  replorTeX=get(io,:limit,false) || get(io,:TeX,false)
  r=0
  n=join(map(t)do t
    n=repr(t; context=io)
    inds=indices(t)
    if isnothing(inds) n*="?"
    elseif inds!=r .+eachindex(inds) && replorTeX
      n="{"*n*"}"*"_{"*joindigits(inds;always=true)*"}"
    end
    r+=rank(t)
    n
   end,replorTeX ? "\\times{}" : "*")
  n=fromTeX(io,n)
  print(io,n)
end

function showtorus(io::IO,W)
  replorTeX=get(io,:limit,false) || get(io,:TeX,false)
  t=rank(W)-semisimplerank(W)
  e=isempty(refltype(W))
  if t>0 
    if replorTeX print(io,fromTeX(io,"\\Phi_1"*(t>1 ? "^{$t}" : "")))
    else print(io,(e ? "" : "*"),"PRG($t)")
    end
  elseif e print(io,replorTeX ? "." : "W()")
  end
end

function Base.show(io::IO, W::PermRootGroup)
  show(io,refltype(W))
  showtorus(io,W)
end

function independent_roots(W::PermRootGroup)::Vector{Int}
  get!(W,:indeproots) do
    r=roots(W)
    if isempty(r) Int[]
    else sort(echelon(toM(roots(W)))[2])
    end
  end
end

"""
`semisimpleRank(W)`

This  function returns the  *semisimple rank* of  the reflection group `W`,
which  is the dimension of the space  where it effectively acts. If `W`is a
reflection  group acting on `V`, and `V₁`  is the subspace generated by the
roots  of  the  reflections  of  `W`,  then  the  dimension  of `V₁` is the
semisimple rank. `W` is called *essential* if `V₁=V`.

```julia-repl
julia> W=reflection_subgroup(coxgroup(:A,3),[1,3])
A₃₍₁₃₎=A₁×A₁Φ₁

julia> semisimplerank(W)
2

julia> rank(W)
3
```
"""
function semisimplerank(W::PermRootGroup)
  get!(W,:semisimplerank)do
    length(independent_roots(W))
  end
end

function baseX(W::PermRootGroup{T})where T
  get!(W,:baseX) do
    ir=independent_roots(W)
    if isempty(ir) return one(zeros(T,rank(W),rank(W))) end
    res=toM(roots(W,ir))
    u=permutedims(GLinearAlgebra.nullspace(toM(coroots(W,ir))))
    if eltype(u) <:Rational
      for v in eachrow(u) v.*=lcm(denominator.(v)...) end
      u=Int.(u)
    end
    vcat(res,u)
  end
end

function invbaseX(W::PermRootGroup)
  get!(W,:invbaseX)do
    X=baseX(W)
    improve_type(inv(X//1))
  end
end

# L is a reflection subgroup and  m a matrix which normalizes L in its
# reflection representation. Returns the matrix by which m acts on X(Z_L)
function central_action(L,m)
  if size(m,2)==0 return m end
  m=baseX(L)*m*invbaseX(L)
  r=semisimplerank(L)
  improve_type(m[r+1:end,r+1:end])
end

"""
`PermX(W,M::AbstractMatrix)`

Let  `M` be  a linear  transformation of  reflection representation  of `W`
which  preserves the set  of roots of  `parent(W)`, and normalizes `W` (for
the  action of  matrices on  the right).  `PermX` returns the corresponding
permutation  of the roots of `parent(W)`;  it returns `nothing` if `M` does
not normalize the set of roots.

```julia-repl
julia> W=reflection_subgroup(rootdatum("E7sc"),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia> PermX(W,reflrep(W,longest(W)))==longest(W)
true
```
"""
function PermX(W::PermRootGroup,M::AbstractMatrix)
  Perm(parent(W).roots,Ref(transpose(M)).*parent(W).roots)
end

function PermGroups.reduced(W::PermRootGroup,F)
  function redcentre(W,F)
    FF=F.*elements(centre(W))
    if F in parent(W)
      ch=map(x->refleigen(parent(W))[position_class(parent(W),x)],FF)
    else
      ch=map(x->roots(CycPol(charpoly(reflrep(W,x)))),FF)
    end
    m=minimum(map(x->sum(conductor.(x)),ch))
    m=findall(x->sum(conductor.(x))==m,ch)
    minimum(FF[m])
  end
  if isone(F) return F end
  if issubset(inclusiongens(W).^F,inclusion(W))
    w=PermX(W,reflrep(W,F))
    if !isnothing(w) && w in W return redcentre(W,w\F)
    elseif length(W)==1 return F
    end
  end
  base=gens(W)
  w=transporting_elt(W,base,base.^F;action=(x,y)->x.^y)
  if !isnothing(w) return redcentre(W,F/w) end
  ir=sort(base.^F)
  w=transporting_elt(W,sort(base),ir;action=(x,y)->sort(x.^y))
  t=refltype(W)
  for a in t
    if Cosets.isG333(a)
      subgroup=reflection_subgroup(W,a.indices)
      base=gens(subgroup).^F
      if !all(x->x in W,base) error("F must normalize W") end
      if !all(x->x in subgroup,base) 
        error("not implemented: F permutes components") 
      end
      base=chevieget(:timp,:ReducedInRightCoset)(subgroup,F)
      if base==false error( "should not happen" ,
            " subgroup=$subgroup F=$F")
      else indices=restriction(W,base[:gen])
        F=base[:phi]
      end
      return (phi=F,reflectiongroup=reflection_subgroup(W,indices;NC=true))
    end
  end
  if !isnothing(w) return redcentre(W,F/w) end
  return nothing
end

function Groups.classreps(W::PermRootGroup)
  get!(W,:classreps)do
    map(x->W(x...),classinfo(W)[:classtext])
  end
end

function Groups.nconjugacy_classes(W::PermRootGroup)
 prod(nconjugacy_classes.(refltype(W)))
end

"""
`parabolic_reps(W)`

Returns  a list  of indices  of roots  of `W` describing representatives of
orbits of parabolic subgroups under conjugation by `W`. For Coxeter groups,
each   orbit  has   a  representative   whose  indices   is  a   subset  of
`eachindex(gens(W))`. This may not be the case in general.

```julia-repl
julia> parabolic_reps(coxgroup(:A,4))
7-element Vector{Vector{Int64}}:
 []
 [1]
 [1, 2]
 [1, 3]
 [1, 2, 3]
 [1, 2, 4]
 [1, 2, 3, 4]
```
gap> ParabolicRepresentatives(ComplexReflectionGroup(3,3,3));
[ [  ], [ 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 20 ], [ 2, 3 ], [ 1, 2, 3 ] ]

`parabolic_reps(W,r)`

If  a second  argument `r`  is given,  returns only  representatives of the
parabolic subgroups of semisimple rank `r`.
```julia-repl
julia> parabolic_reps(coxgroup(:A,4),2)
2-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]
```
gap> ParabolicRepresentatives(ComplexReflectionGroup(3,3,3),2);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 20 ], [ 2, 3 ] ]
"""
parabolic_reps(W)=vcat(parabolic_reps.(Ref(W),0:semisimplerank(W))...)

parabolic_reps(t::TypeIrred,s)=getchev(t,:ParabolicRepresentatives,s)

function parabolic_reps(W::PermRootGroup,s)
  t=refltype(W)
  sols=filter(l->sum(l)==s,cartesian(map(x->0:rank(x),t)...))
  vcat(map(c->map(x->vcat(x...),cartesian(map(eachindex(c))
    do i
      r=parabolic_reps(t[i],c[i])
      if r==false
        R=reflection_subgroup(W,inclusion(W,t[i].indices))
#    by:=1+W.nbGeneratingReflections-W.semisimpleRank;
#    Reflections(W); # make sure they are computed all
#    stoi:=s->W.rootInclusion[Position(W.reflections,s)];
#    l:=[List(Set(W.orbitRepresentative),x->ReflectionSubgroup(W,[x]))];
#    for i in [2..W.semisimpleRank-1] do
#      new:=[];ref:=[];
#      for v in l[i-1] do
#        InfoChevie("# Extending ",ReflectionName(v),"\c");
#        S:=Normalizer(W,v);
#        if v.nbGeneratingReflections=i-1 then
#          c:=Union(List([1..by],i->Combinations(List(Reflections(W),stoi),i)));
#        else c:=Combinations(List(Reflections(W),stoi),1);
#        fi;
#        c:=List(c,x->Union(x,v.rootInclusion{v.generatingReflections}));
#        c:=Filtered(c,x->RankMat(W.roots{W.rootRestriction{x}})=i);
#        InfoChevie(" ",Length(c)," new subgroups\c");
#        c:=List(c,function(x)InfoChevie("*\c");
#                             return ReflectionSubgroup(W,x);end);
#        c:=Filtered(c,IsParabolic);
#        c:=Set(List(c,x->Set(Reflections(x))));
#        O:=Orbits(S,c,OnSets);
#        O:=List(O,function(o)local m;m:=Minimum(List(o,x->Sum(x,stoi)));
#             return First(o,x->Sum(x,stoi)=m);end);
#        O:=List(O,x->ReflectionSubgroup(W,List(x,stoi)));
#        InfoChevie("# ",Length(O)," to go\n");
#        for c in O do
#          rr:=Collected(ReflectionDegrees(c));
#          cand:=Filtered([1..Length(ref)],i->ref[i]=rr);
#          InfoChevie("# candidates for ",c," to be conjugate:",new{cand},"\n");
#          if ForAll(new{cand},v->RepresentativeOperation(W,v,c)=false)
#          then InfoChevie("# new:",ReflectionName(c),"\n");
#               Add(new,c);Add(ref,rr);
#          fi;
#        od;
#      od;
#      InfoChevie("# i=",i," found:",new,"\n");
#      Add(l,new);
#    od;
#    l:=List(Concatenation(l),function(v)local p;
#      p:=StandardParabolic(W,v);if p<>false then v:=v^p;fi;return v;end);
#    l:=CollectBy(l,SemisimpleRank);
#    l:=List(l,v->List(v,x->x.rootInclusion{x.generatingReflections}));
#    l:=Concatenation([[[]]],l);
#    Add(l,[W.rootInclusion{W.generatingReflections}]);
#    l:=List(l,v->List(v,x->List(x,y->stoi(Reflection(W,
#                                            W.rootRestriction[y])))));
#    l:=List(l,x->Set(List(x,Set)));
#    W.parabolicRepresentatives:=l;
#  fi;
        error("not implemented")
        return parabolic_reps(R,c[i])
      elseif all(x->all(y->y in 1:t[i].rank,x),r)
        return map(x->inclusion(W,t[i].indices[x]),r)
      else R=reflection_subgroup(W,inclusion(W,t[i].indices))
        return map(x->inclusion(R,x),r);
      end
    end...)),sols)...)
end

"""
`reflrep(W,w)`  Reflection representation

Let  `W` be a  finite reflection group  on the space  `V` and let  `w` be a
permutation  of the roots of `W`. The function `reflrep` returns the matrix
of  `w` acting on `V`. This is  the linear transformation of `V` which acts
trivially  on the orthogonal of  the coroots and has  same effect as `w` on
the simple roots. The function makes sense more generally for an element of
the normalizer of `W` in the whole permutation group of the roots.

```julia-repl
julia> W=reflection_subgroup(rootdatum("E7sc"),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia> reflrep(W,longest(W))
7×7 Matrix{Int64}:
  0   0   0   0   0  -1  2
  0  -1   0   0   0   0  2
  0   0   0   0  -1   0  3
  0   0   0  -1   0   0  4
  0   0  -1   0   0   0  3
 -1   0   0   0   0   0  2
  0   0   0   0   0   0  1
```
"""
function reflrep(W::PermRootGroup,w)
  W=parent(W)
  X=baseX(W)
  ir=independent_roots(W)
  if isempty(ir) return X end
  X=vcat(toM(roots(W,ir.^w)),X[length(ir)+1:end,:])
  improve_type(invbaseX(W)*X)
end

matY(W::PermRootGroup,w)=permutedims(reflrep(W,inv(w)))

"""
`is_parabolic(W)`

whether the reflection group `W` is a parabolic subgroup of `parent(W)`.
```julia-repl
julia> W=ComplexReflectionGroup(7)
G₇

julia> is_parabolic(reflection_subgroup(W,[1,2]))
false

julia> is_parabolic(reflection_subgroup(W,[1]))
true
```

"""
function is_parabolic(H)
  W=parent(H)
  setr=s->Set(reflection.(Ref(W),s))
  if iszero(ngens(H)) return true end
  v=toM(simpleroots(H))
  gens=filter(i->solutionmat(v,roots(W,i))!==nothing,eachindex(roots(W)))
  setr(gens)==setr(inclusion(H))
end

"""
`parabolic_closure(W,I)`

`I`  should be a  list of indices  of reflections of  `W`. Returns `J` such
that  `reflection_subgroup(W,J)` is the smallest  parabolic subgroup of `W`
containing `reflection_subgroup(W,I)`.

```julia-repl
julia> W=ComplexReflectionGroup(7)
G₇

julia> parabolic_closure(W,[1])
1-element Vector{Int64}:
 1

julia> parabolic_closure(W,[1,2])
3-element Vector{Int64}:
 1
 2
 3
```
"""
function parabolic_closure(W,I)
  if isempty(I) return I end
  v=toM(roots(W,I))
  gens=filter(i->solutionmat(v,roots(W,i))!==nothing,eachindex(roots(W)))
  inclusiongens(reflection_subgroup(W,gens),W)
end

#--------------- PRG: an implementation of PermRootGroups--------------------
@GapObj struct PRG{T,T1}<:PermRootGroup{T,T1}
  gens::Vector{Perm{T1}}
  matgens::Vector{Matrix{T}}
  roots::Vector{Vector{T}}
  coroots::Vector{Vector{T}}
end

function PRG(r::AbstractVector{<:AbstractVector},
             cr::AbstractVector{<:AbstractVector};NC=false)
# println("r=",r,"\ncr=",cr)
  if isempty(r) error("should call torus instead") end
  matgens=map(reflection,r,cr)
  T=eltype(matgens[1])  # promotion of r and cr types
  rr=map(x->convert.(T,x),r)
  cr=map(x->convert.(T,x),cr)

  # the following section is quite subtle: it has the (essential -- this is
  # what  allows  to  construct  reflexion  subgroups  in a consistent way)
  # property  that the order of the  constructed roots (thus the generating
  # permutations) depends only on the Cartan matrix of g, not on the actual
  # root values.

# println("# roots: ")
  refls=map(x->Int[],matgens)
  newroots=true
  while newroots
    newroots=false
    for (j,refl) in enumerate(refls)
      lr=length(rr)
      if length(refl)<lr
      for y in eachrow(toM(rr[length(refl)+1:end])*matgens[j])
        p=findfirst(==(y),rr) 
	if p===nothing || p>lr
          push!(rr,y)
#         println("j=$j rr[$(length(refl)+1)...] ",length(rr),":",y)
          newroots=true
          push!(refl,length(rr))
        else push!(refl,p)
	end
      end
      end
    end
#   println(" ",length(rr))
  end
  ncr=Vector{eltype(cr)}(undef,length(rr))
  ncr[eachindex(cr)].=cr
  W=PRG(Perm{Int16}.(refls),matgens,rr,ncr,Dict{Symbol,Any}())
  if !NC
    t=refltype(W)
    l=PermRoot.indices(t)
    if sort(l)!=eachindex(l)
      InfoChevie("# changing gens to <",join(l,","),"> for ",
                                             t,"<",ngens(W)," refs>\n")
      W=PRG(roots(W,l),coroots(W,l))
    end
  end
  W
end

PRG(a::Matrix,b::Matrix)=PRG(toL(a),toL(b))

PRG(i::Integer)=PRG(Perm{Int16}[],Matrix{Int}[],Vector{Int}[],Vector{Int}[],
    Dict{Symbol,Any}(:rank=>i))

radical(W::PermRootGroup)=PRG(rank(W)-semisimplerank(W))

@inline Gapjm.roots(W::PRG)=W.roots
@inline Gapjm.roots(W::PRG,i)=W.roots[i]
simpleroots(W::PRG)=roots(W,eachindex(gens(W)))
@inline coroots(W::PRG)=W.coroots
simplecoroots(W::PRG)=W.coroots[eachindex(gens(W))]
@inline inclusion(W::PRG,i=eachindex(W.roots))=i
@inline restriction(W::PRG,i=eachindex(W.roots))=i
@inline Base.parent(W::PRG)=W
@inline action(W::PRG,i,p)=i^p

function coroots(W::PRG,i::Integer)
  if isassigned(W.coroots,i) return W.coroots[i] end
  m=reflrep(W,reflection(W,i))
  j=findfirst(!iszero,roots(W,i))
  r=(one(m)-m)[:,j].//roots(W,i)[j]
  W.coroots[i]=improve_type(r)
end

coroots(W::PRG,i::AbstractVector{<:Integer})=isempty(i) ? empty(W.coroots) : coroots.(Ref(W),i)

function Base.:*(W::PRG,V::PRG)
  if rank(W)==0 return V
  elseif rank(V)==0 return W
  end
  if iszero(semisimplerank(V))
    r=map(x->vcat(x,fill(0,rank(V))),simpleroots(W))
    cr=map(x->vcat(x,fill(0,rank(V))),simplecoroots(W))
  elseif iszero(semisimplerank(W))
    r=map(x->vcat(fill(0,rank(V)),x),simpleroots(W))
    cr=map(x->vcat(fill(0,rank(V)),x),simplecoroots(W))
  else
    r=toL(cat(toM(simpleroots(W)),toM(simpleroots(V)),dims=(1,2)))
    cr=toL(cat(toM(simplecoroots(W)),toM(simplecoroots(V)),dims=(1,2)))
  end
  PRG(r,cr)
end
  
reflrep(W::PRG)=W.matgens
reflrep(W::PRG,i::Integer)=i<=ngens(W) ? W.matgens[i] : 
                                         reflrep(W,reflection(W,i))

#--------------- type of subgroups of PRG----------------------------------
@GapObj struct PRSG{T,T1}<:PermRootGroup{T,T1}
  gens::Vector{Perm{T1}}
  inclusion::Vector{Int}
  restriction::Vector{Int}
  parent::PRG{T,T1}
end

inclusion(W::PRSG)=W.inclusion
inclusion(W::PRSG,i)=W.inclusion[i]
restriction(W::PRSG)=W.restriction
restriction(W::PRSG,i)=W.restriction[i]
@inline Gapjm.roots(W::PRSG)=roots(parent(W),inclusion(W))
@inline Gapjm.roots(W::PRSG,i)=roots(parent(W),inclusion(W,i))
simpleroots(W::PRSG)=roots(parent(W),inclusiongens(W))
@inline coroots(W::PRSG)=coroots(parent(W),inclusion(W))
@inline coroots(W::PRSG,i)=coroots(parent(W),inclusion(W,i))
simplecoroots(W::PRSG)=coroots(parent(W),inclusiongens(W))
@inline Base.parent(W::PRSG)=W.parent
action(W::PRSG,i,p)=restriction(W,inclusion(W,i)^p)

function Base.:^(W::PRSG{T,T1},p::Perm{T1})where {T,T1}
  WW=parent(W)
  if !(p in WW) error("can only conjugate in parent") end
  reflection_subgroup(WW,inclusiongens(W).^p)
end

#function reflection_subgroupNC(W::PRG,I::AbstractVector)
#  I=Vector{Int}(I)
#  if I==eachindex(gens(W)) G=W
#    inclu=collect(eachindex(roots(W)))
#  else 
#    G=PRG(roots(W,I),coroots(W,I);NC=true)
#    inclu=Int.(indexin(G.roots,W.roots))
#  end
#  restr=zeros(Int,length(W.roots));restr[inclu]=1:length(inclu)
#  PRSG(reflections(W)[I],inclu,restr,W,Dict{Symbol,Any}())
#end
#
## contrary to Chevie, W is guaranteed to be a parent here
#function reflection_subgroup(W::PRG,I::AbstractVector)
#  if !haskey(W,:reflsubgroups)
#    W.reflsubgroups=Dict(
#      Int[]=>PRSG(empty(gens(W)),Int[],zeros(Int,length(W.roots)),W,
#                  Dict{Symbol,Any}(:rank=>rank(W),:refltype=>TypeIrred[])))
#  end
#  I=Vector{Int}(I)
#  if haskey(W.reflsubgroups,I) return W.reflsubgroups[I] end
#  H=reflection_subgroupNC(W,I)
#  t=refltype(H)
#  l=PermRoot.indices(t)
#  if sort(l)!=eachindex(gens(H))
#    InfoChevie("# changing inclusiongens to <",join(inclusion(H,l),
#      ","),"> for ",t,"<",length(inclusion(H))," refs>\n")
#    H=reflection_subgroupNC(W,inclusion(H,l))
#    for tt in t tt.indices=map(x->findfirst(==(x),l),tt.indices) end
#  end
#  H.refltype=t
#  W.reflsubgroups[I]=H
#  H
#end

function reflection_subgroup(W::PRG,I::AbstractVector;NC=false)
  if !haskey(W,:reflsubgroups)
    W.reflsubgroups=Dict(
      Int[]=>PRSG(empty(gens(W)),Int[],zeros(Int,length(W.roots)),W,
                  Dict{Symbol,Any}(:rank=>rank(W),:refltype=>TypeIrred[])))
  end
  I=Vector{Int}(I)
  if NC
    if I==eachindex(gens(W)) G=W
      inclu=collect(eachindex(roots(W)))
    else 
      G=PRG(roots(W,I),coroots(W,I);NC=true)
      inclu=Int.(indexin(G.roots,W.roots))
    end
    restr=zeros(Int,length(W.roots));restr[inclu]=1:length(inclu)
    return PRSG(reflections(W)[I],inclu,restr,W,Dict{Symbol,Any}())
  end
  if haskey(W.reflsubgroups,I) return W.reflsubgroups[I] end
  H=reflection_subgroup(W,I;NC=true)
  t=refltype(H)
  l=PermRoot.indices(t)
  if sort(l)!=eachindex(gens(H))
    InfoChevie("# changing inclusiongens to <",join(inclusion(H,l),
      ","),"> for ",t,"<",length(inclusion(H))," refs>\n")
    H=reflection_subgroup(W,inclusion(H,l);NC=true)
    for tt in t tt.indices=map(x->findfirst(==(x),l),tt.indices) end
  end
  H.refltype=t
  W.reflsubgroups[I]=H
  H
end

reflection_subgroup(W::PRSG,I::AbstractVector{Int};u...)=
   reflection_subgroup(parent(W),inclusion(W,I);u...)

function Base.show(io::IO, W::PRSG)
  I=inclusiongens(W)
  if !get(io,:limit,false) && !get(io,:TeX,false)
    print(io,"reflection_subgroup(",W.parent,",",I,")") 
    return
  end
  n=inclusion(W,PermRoot.indices(refltype(W)))
  if n!=eachindex(gens(W.parent))
    printTeX(io,"{",W.parent,"}_{"*joindigits(n;always=true)*"}=")
  end
  show(io,refltype(W))
  showtorus(io,W)
end

reflrep(W::PRSG)=map(i->reflrep(parent(W),i),inclusiongens(W))
reflrep(W::PRSG,i::Integer)=reflrep(parent(W),inclusion(W,i))

#-------------------------------------------------
"""
Catalan(n) `n`-th Catalan Number

```julia-repl
julia> catalan(8)
1430
```
"""
catalan(n::Int)=Int(prod(i->(n+i)//i,2:n))

# Catalan(W [,m] [,q]]) [q][Fuss-]Catalan numbers of W
"""
`Catalan(W)`

returns the Catalan Number of the irreducible complex reflection group `W`.
For well-generated groups, this number is equal to the number of simples in
the  dual Braid  monoid. For  other groups  it was  defined by  [Gordon and
Griffeth2012](biblio.htm#gg12).  For Weyl groups, it also counts the number
of antichains of roots.

```julia-repl
julia> catalan(coxgroup(:A,7))
1430
```

`Catalan(W,i)`

returns   the  `i`-th  Fuss-Catalan  Number   of  the  irreducible  complex
reflection  group `W`. For  well-generated groups, this  number is equal to
the  number of chains  `s₁,…,sᵢ` of simples  in the dual  monoid where `sⱼ`
divides  `sⱼ₊₁`. For these groups, it is also equal to `∏ⱼ(ih+dⱼ)/dⱼ` where
the  product runs over the reflection degrees  of `W`, and where `h` is the
Coxeter  number of `W`. For non-well generated groups, the definition is in
[Gordon and Griffeth2012](biblio.htm#gg12).

```julia-repl
julia> catalan(ComplexReflectionGroup(7),2)
16//1
```

`Catalan(W,q)`, resp. `Catalan(W,i,q)`

where  `q`  is  a  variable  (like  `Pol(:q)`  or  an  'Mvp')  returns  the
`q`-Catalan number (resp. the `i`-th `q`-Fuss Catalan number) of `W`. Again
the definitions in general are in [Gordon and
Griffeth2012](biblio.htm#gg12).

```julia-repl
julia> catalan(ComplexReflectionGroup(7),2,q)
Pol{Int64}: q⁷²+2q⁶⁰+3q⁴⁸+4q³⁶+3q²⁴+2q¹²+1
```
"""
function catalan(W,m=1,q=1)
  if length(refltype(W))>1 error(W," should be irreducible") end
  d=sort(degrees(W))
  d=filter(x->x!=1,d)
  h=div(sum(d)+sum(codegrees(W)),length(d))
  f(i)=sum(j->q^j,0:i-1)
  if length(d)==ngens(W) return Int(prod(x->f(m*h+x)//f(x),d)) end
  ci=charinfo(W)
  if haskey(ci,:opdam) opdam=ci[:opdam]^-1 else opdam=Perm() end
  ct=toL(CharTable(W).irr)
  complex=Perm(ct,conj(ct))
  fd=fakedegrees(W,Pol(:q))[ci[:extRefl][2]^(opdam^m*complex)]
  fd=vcat(map(i->fill(i+1,fd[i]),0:degree(fd))...)
  prod(map((e,d)->f(m*h+e)//f(d),fd,d))
end

"""
`reflection(s::Matrix [,r::AbstractVector])`

Here  `s` is  a square  matrix, and  if given  `r` is  a vector of the same
length  as `size(s)[1]`. The function determines if  `s` is the matrix of a
reflection  (resp. if `r` is  given if it is  the matrix of a reflection of
root  `r`; the point of  giving `r` is to  specify exactly the desired root
and  coroot, which  otherwise are  determined only  up to  a scalar and its
inverse).  The function  returns `nothing`  if `s`  if is  not a reflection
(resp. not a reflection with root `r`), and otherwise returns a named tuple
with four fields:

`.root`:   the root of the reflection `s` (equal to `r` if given)

`.coroot`:  the coroot of `s`

`.eigenvalue`:  the non-trivial eigenvalue of `s`

`.isOrthogonal`:   a  boolean  which is  `true` if  and  only if  `s` is
  orthogonal  with respect to  the usual scalar  product (then the root and
  eigenvalue are sufficient to determine `s`)

```julia-repl
julia> reflection([-1 0 0;1 1 0;0 0 1])
(root = [2, 0, 0], coroot = Rational{Int64}[1//1, -1//2, 0//1], eig = -1, isOrthogonal = false)

julia> reflection([-1 0 0;1 1 0;0 0 1],[1,0,0])
(root = [1, 0, 0], coroot = Rational{Int64}[2//1, -1//1, 0//1], eig = -1, isOrthogonal = false)
```
"""
function reflection(m::Matrix,r::AbstractVector)
  rr=one(m)-m
  rc=map(j->ratio(rr[j,:],r),axes(m,1))
  zeta=ratio(permutedims(m)*r,r)
  rzeta=Root1(zeta)
  if isnothing(zeta) || isnothing(rzeta) return nothing end
  orth=(rc*sum(conj(r).*r)==(1-zeta)*conj(r))
  (root=r,coroot=rc,eig=rzeta,isOrthogonal=orth)
end

function reflection(m::Matrix)
  rr=one(m)-m
  r=findfirst(i->!all(iszero,rr[i,:]),axes(rr,1))
  if !isnothing(r) reflection(m,rr[r,:]) end
end

"""
`invariant_form(W)`

This  function returns the matrix `F`  of an Hermitian form invariant under
the action of the reflection group `W`. That is, if `M` is the matrix of an
element of `W`, then `M*F*M'=F`.

```julia-repl
julia> W=ComplexReflectionGroup(4)
G₄

julia> invariant_form(W)
2×2 Matrix{Int64}:
 1  0
 0  2
```
"""
function invariant_form(W::PermRootGroup)
  I=independent_roots(W)
  C=cartan(W)[I,I]
# we use that C[i,j]/C[i,i]=F[j,i]/F[i,i]
  T=typeof(C[1,1]//1)
  F=zeros(T,size(C))
  for b in diagblocks(C)
    # first fill in the diagonal terms
    F[b[1],b[1]]=1
    next=[1]
    while !isempty(next)
      i=b[next[1]]
      next=next[2:end]
      for k in filter(k->F[b[k],b[k]]==0 && C[i,b[k]]!=0,eachindex(b))
	j=b[k]
        push!(next,k)
        F[j,j]=F[i,i]*C[i,j]*conj(C[j,j])//(conj(C[j,i])*C[i,i]);
      end
    end
    # then fill in the rest
    for i in b, j in b
      if i!=j F[j,i]=C[i,j]*F[i,i]//C[i,i] end
    end
  end
  d=rank(W)-semisimplerank(W)
  F=cat(F,one(zeros(T,d,d)),dims=(1,2))
  N=invbaseX(W)
  F=N*F*N'
  improve_type(F.//F[1,1])
end

"""
`generic_order(W,q)`

returns  the "compact" generic order of `W` as a polynomial in `q`. This is
`q^(Nₕ)Πᵢ(q^(dᵢ)-1)`  where `dᵢ`  are the  reflection degrees  and `Nₕ` the
number  of reflecting hyperplanes. For a Weyl group, it is the order of the
associated  semisimple  finite  reductive  group  over  the  field with `q`
elements.

```julia-repl
julia> Pol(:q)
Pol{Int64}: q

julia> PermRoot.generic_order(ComplexReflectionGroup(4),q)
Pol{Int64}: q¹⁴-q¹⁰-q⁸+q⁴
```
"""
generic_order(W,q)=q^sum(codegrees(W).+1)*prod(d->q^d-1,degrees(W))

"""
`invariants(W)`

returns  the fundamental invariants of `W` in its reflection representation
`V`.  That is, returns  a set of  algebraically independent elements of the
symmetric  algebra  of  the  dual  of  `V` which generate the `W`-invariant
polynomial  functions on `V`. Each such invariant function is returned as a
function:  if `e₁,…,eₙ` is a basis of `V` and `f` is the function, then the
value  of the polynomial  function on `a₁e₁+…+aₙeₙ`  is obtained by calling
`f(a₁,…,aₙ)`. This function depends on the classification, and is dependent
on the exact reflection representation of `W`. So for the moment it is only
implemented   when  the  reflection   representation  for  the  irreducible
components has the same Cartan matrix as the one provided by Chevie for the
corresponding  irreducible  group.  The  polynomials  are invariant for the
natural   action  of   the  group   elements  as   matrices;  that  is,  if
`m==reflrep(W,w)`  for some  `w` in  `W`, then  an invariant  `f` satisfies
`f(a₁,…,aₙ)=f(v₁,…,vₙ)`   where  `[v₁,…,vₙ]=[a₁,…,aₙ]×m`.  This  action  is
implemented on `Mvp`s by the function `^`.

```julia-repl
julia> W=coxgroup(:A,2)
A₂

julia> @Mvp x,y,z

julia> i=invariants(W);

julia> i[1](x,y)
Mvp{Int64}: -2x²+2xy-2y²

julia> i[2](x,y)
Mvp{Int64}: 6x²y-6xy²

julia> W=ComplexReflectionGroup(24)
G₂₄

julia> i=invariants(W)[1];

julia> p=i(x,y,z)
Mvp{Rational{Int64}}: (14//1)x⁴+(-12//1)x²y²+(-42//1)x²yz+(21//2)x²z²+(18//7)y⁴+(-6//1)y³z+(-9//2)y²z²+(-21//8)z⁴

julia> p^reflrep(W,1)-p
Mvp{Cyc{Rational{Int64}}}: 0
```
"""
function invariants(W)
  V=parent(W)
  i=map(refltype(W)) do t
    H=reflection_group(t)
    if cartan(V,inclusion(W,t.indices))!=cartan(H)
      error("non standard Cartan matrix: invariants not implemented")
    end
    ir=independent_roots(H)
    i=getchev(t,:Invariants)
    if i==false return false end
    map(f->function(arg...)
         return f(improve_type(inv(E(1).*toM(coroots(H)[ir])//1)*
    toM(coroots(V,inclusion(W,t.indices[ir]))))*collect(arg)...) end, i)
  end
  if false in i return false end
  i=vcat(i...)
  N=toM(W.roots[independent_roots(W)])
  if !isempty(N)
    N=GLinearAlgebra.nullspace(N)
    append!(i,map(v->function(arg...)return sum(v.*arg);end,N))
  end
  i
end

BadNumber(W)=prod(BadNumber.(refltype(W)))

function BadNumber(t::TypeIrred)
  r=rank(t)
  if iszero(r) return 1 end
  d=GLinearAlgebra.det(cartan(t))
  if d==0 error(t," should be well generated") end
  improve_type(prod(degrees(t))//(factorial(r)*d))
end

end
