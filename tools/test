









RouquierBlockData=function(W)
  local hplanes,bl0,sch,NRPARA,Generic1SchurElements

  NRPARA=5
 







  Generic1SchurElements=function(W)local c,o,v,H,vnames,vars

    c=Set(W.orbitRepresentative)

    o=List(W.EigenvaluesGeneratingReflections{c},x->1/x)

    vars="xyz"

    v=[]
v{c}=List([1..Length(o)],i->List([1..o[i]]-1,
		     j->Mvp(SPrint([vars[i]],j))*E(o[i])^j))

    H=ApplyFunc(Hecke,[W,v])

    vnames=Variables(H.parameter)

    return List(FactorizedSchurElements(H),function(s)local res,montovec,f

      montovec=function(mon)local res

	res=List(vnames,x->0)

	res{List(mon.elm[1].elm,x->Position(vnames,x))}=mon.elm[1].coeff

	return res

      end

      if IsInt(s.factor)   f=Mvp(s.factor)
else f=s.factor end

      res=rec(vars=List(vnames,Mvp),
	vcyc=List(s.vcyc,p->rec(pol=p.pol,mon=montovec(p.monomial),
	  coeff=p.monomial.coeff[1])),
        coeff=f.coeff[1],
	mon=montovec(f))


      SortBy(res.vcyc,x->[x.pol,x.mon,x.coeff])

      return res

    end)

  end

  sch=Generic1SchurElements(W)

  hplanes=Concatenation(List(sch,x->List(x.vcyc,y->y.mon)))

  hplanes=List(hplanes,v->v*Lcm(List(v,Denominator)))

  hplanes=Set(List(hplanes,v->v/Gcd(List(v,Numerator))))

  Sort(hplanes)
 
  hplanes=Concatenation([hplanes[1]*0],hplanes)
 
  InfoChevie("#I ",Length(hplanes)," hplanes\n")


  return List(hplanes, 
    function(h)local aA,res,para,findpara,c,m,p,hh
 

    hh=Filtered(hplanes,k->k!=0*k  &&  k!=h)

    m=NullspaceIntMat(TransposedMat([h]))

    para=[]

    while Length(para)<NRPARA  
      if Length(hh)==0  &&  h==[1,-1]   Add(para,[1,1])

      else p=List([1..Length(m)],i->Random([-2*Length(m)..2*Length(m)]))*m

	if  !  0 in hh*p   Add(para,p/Gcd(p)) end end
 end

    SortBy(para,x->x*x)
 


    aA=ApplyFunc(GcdPartitions,List(para,p->CollectBy([1..Length(sch)],
       i->2*sch[i].mon*p+Sum(sch[i].vcyc,x->x.mon*p*Degree(x.pol)))))



    para=para[1]
 

    c=List(sch,s->s.coeff*Product(s.vcyc,function(r)
      if para*r.mon==0   return Value(r.pol,r.coeff)
else return 1 end
end))



    res=List(Set(FactorsInt(Size(W))),function(p)local bl,vp,j,x,i,cut
 

      bl=GcdPartitions(PBlocks(W,p),aA)




      if h==[1,-1]   return bl end
 
      vp=List(c,x->PValuation(x,p))

      i=1

      while i<=Length(bl)   

	if Length(bl[i])==1   
	  if vp[bl[i][1]]!=0   
	     Error("Schur elt of v_",p,"==",vp[bl[i][1]]," alone in block")

	  else i=i+1 end

	else 

	  for j in bl[i]  
	    if vp[j]==0  &&  Length(bl[i])>1   
	      Add(bl,[j])
bl[i]=Difference(bl[i],[j]) end end


	  if Length(bl[i])>3   
	    if h!=h*0  


	      for j in Filtered(bl0,x->IsSubset(bl[i],x)  &&  x!=bl[i])  
		if vp{j}==List(sch{j},s->PValuation(s.coeff,p))  
		  bl[i]=Difference(bl[i],j)
Add(bl,j) end end
end

	    if Length(bl[i])>3   


cut=function(bl,para)local csch,lcm,lsch,p0,ct,ch,msch,l,Ah,getH

  InfoChevie("#I p==",p," h",Position(hplanes,h),":",FormatGAP(h),
     " cut",FormatGAP(bl))

    getH=function(para)local c,o,v

      c=Set(W.orbitRepresentative)

      o=List(W.EigenvaluesGeneratingReflections{c},x->1/x)

      o=List([1..Length(o)],i->Sum(o{[1..i-1]})+[1..o[i]])

      v=[]
v{c}=List(o,i->Zip(i,i-Minimum(i),
	function(x,y)return Mvp("x")^para[x]*E(Length(i))^y
end))

      return Hecke(W,v)
 
    end


  para=para*Lcm(List(Set(Concatenation(List(sch{bl},
           x->List(x.vcyc,y->y.mon))))*para,Denominator))

  Ah=getH(para)

  csch=List(sch{bl},s->s.coeff*CycPol(Mvp("x")^(para*s.mon))*
     Product(s.vcyc,x->CycPolOps.DescentOfScalars(x.pol,para*x.mon)))


  lcm=ApplyFunc(LcmCycPol,csch)

  lsch=List(csch,x->lcm/x)

  InfoChevie(" Schur:",Stime(),")

  lsch=List(lsch,x->Value(x,Mvp("x")))

  InfoChevie(" Value:",Stime(),"")

  ct=TransposedMat(CharTable(Ah).irreducibles{bl})

  SortParallel(List(ChevieClassInfo(W).classtext,x->-Length(x)),ct)

  ct=Filtered(ct,r->ForAll(r,x->IsCyc(x)  ||  ( !  ForAny(x.coeff,IsUnknown)  && 
      Length(Variables(x))<=1)))

  if Length(ct)!=NrConjugacyClasses(W)  
    Print("\n!! Unreliable computation: ",CharTable(Ah)," partially unknown\n") end

  p0=List([1..Length(bl)],x->[x])

  for ch in ct  
    InfoChevie("")

    msch=Zip(lsch,ch,function(x,y)return x*y
end)

    l=Filtered(Filtered(List(Combinations(p0),x->Set(Concatenation(x))),
       x->Length(x)>0),x->PValuation(Sum(msch{x}),p)>=0)

    if  !  [1..Length(bl)] in l   Error("theory") end

    l=Filtered(l,x->Number(l,y->IsSubset(x,y))==1)

    p0=LcmPartitions(l,p0)

    if Length(p0)==1   InfoChevie(Stime()," ok\n")
return [bl] end end


  InfoChevie(Stime(),"\n  ->",FormatGAP(List(p0,x->bl{x})),"\n")

  return List(p0,x->bl{x})

end

	      j=cut(bl[i],para)

	      bl=Concatenation(bl{[1..i-1]},j,bl{[i+1..Length(bl)]})

	      i=i+Length(j)

	    else i=i+1 end

	  else i=i+1 end end
 end

      bl=Filtered(bl,x->x!=[])
Sort(bl)
return bl

    end)


    res=ApplyFunc(LcmPartitions,res)

    if h==0*h   bl0=res end

    return [h,res]

  end)

end



RouquierBlocks=function(H)local W,d,p

  W=Group(H)

  d=RouquierBlockData(W)

  p=Concatenation(H.parameter{Set(W.orbitRepresentative)})

  d=Filtered(d,function(x)local h

    h=x[1]*Lcm(List(x[1],Denominator))

    h=Product(Zip(p,h,function(a,b)return a^b
end))

    return ScalMvp(h)!=false

    end)

  return ApplyFunc(LcmPartitions,List(d,x->x[2]))

end

