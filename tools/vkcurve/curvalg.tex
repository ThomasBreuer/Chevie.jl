%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{FollowMonodromy}
\index{FollowMonodromy}

'FollowMonodromy(<r>,<segno>,<print>)'

This function computes the monodromy braid  of the solution in $x$ of an
equation  $P(x,y)=0$  along  a  segment $[y_0,y_1]$.  It  is  called  by
'FundamentalGroup', once for each of the segments. The first argument is
a global record, similar to  the one produced by 'FundamentalGroup' (see
the  documentation of  this function)  but only  containing intermediate
information.  The second  argument is  the  position of  the segment  in
'r.segments'. The third argument is  a print function, determined by the
printlevel  set by  the user  (typically, by  calling 'FundamentalGroup'
with a second argument).

The function returns an element of the ambient braid group 'r.B'.

This function has no reason to be  called directly by the user, so we do
not illustrate its  behavior. Instead, we explain what  is displayed on
screen when the user sets the printlevel to $2$.

What is quoted below is an excerpt of what is displayed on screen
during the execution of
|    gap>  FundamentalGroup((x+3*y)*(x+y-1)*(x-y),2);

    <1/16>    1 time=          0   ?2?1?3
    <1/16>    2 time=      0.125   R2. ?3
    <1/16>    3 time=    0.28125   R2. ?2
    <1/16>    4 time=   0.453125   ?2R1?2
    <1/16>    5 time=   0.578125   R1. ?2
    ======================================
    =    Nontrivial braiding = 2         =
    ======================================
    <1/16>    6 time=   0.734375   R1. ?1
    <1/16>    7 time=    0.84375   . ?0. 
    <1/16>    8 time=   0.859375   ?1R0?1
    # The following braid was computed by FollowMonodromy in 8 steps.
    monodromy[1]:=B(2);
    # segment 1/16 Time=0.1sec|

'FollowMonodromy' computes  its results by subdividing  the segment into
smaller  subsegments  on which  the  approximations  are controlled.  It
starts at one  end and moves subsegment after subsegment.  A new line is
displayed at each step.

The  first column  indicates which  segment is  studied. In  the example
above, the function  is computing the monodromy along  the first segment
(out  of  $16$).  This  gives  a  rough  indication  of  the  time  left
before  completion of  the total  procedure.  The second  column is  the
number of  iterations so  far (number of  subsegments). In  our example,
'FollowMonodromy'  had to  cut the  segment into  $8$ subsegments.  Each
subsegment has its own length. The cumulative length at a given step, as
a  fraction of  the  total length  of the  segment,  is displayed  after
'time='.  This  gives  a  rough  indication  of  the  time  left  before
completion  of the  computation of  the monodromy  of this  segment. The
segment is completed when this fraction reaches $1$.

The last column has to do with the piecewise-linear approximation of the
geometric monodromy  braid. It is  subdivided into sub-columns  for each
string. In  the example above,  there are  three strings. At  each step,
some strings are fixed (they are  indicated by '. ' in the corresponding
column). A symbol like 'R5' or '?3' indicates that the string is moving.
The exact meaning of the symbol has to do with the complexity of certain
sub-computations.

As  some strings  are moving,  it  happens that  their real  projections
cross. When such a crossing occurs, it is detected and the corresponding
element of $B_n$ is displayed on screen ('Nontrivial braiding ='...) The
monodromy braid is the product of these elements of $B_n$, multiplied in
the order in which they occur.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{BnActsOnFn}
\index{BnActsOnFn}

'BnActsOnFn(<braid b>,<Free group F>)'

This function  implements the Hurwitz action  of the braid group  on $n$
strings  on  the  free  group  on $n$  generators,  where  the  standard
generator  $\sigma_i$ of  $B_n$  fixes  the generators  $f_1,\dots,f_n$,
except $f_i$ which is mapped to  $f_{i+1}$ and $f_{i+1}$ which is mapped
to $f_{i+1}^{-1}f_if_{i+1}$.

|    gap> B:=Braid(CoxeterGroupSymmetricGroup(3));
    function ( arg ) ... end
    gap> b:=B(1);
    1
    gap> BnActsOnFn(b,FreeGroup(3));
    GroupHomomorphismByImages( Group( f.1, f.2, f.3 ), Group( f.1, f.2, f.3 ), 
    [ f.1, f.2, f.3 ], [ f.2, f.2^-1*f.1*f.2, f.3 ] )
    gap> BnActsOnFn(b^2,FreeGroup(3));
    GroupHomomorphismByImages( Group( f.1, f.2, f.3 ), Group( f.1, f.2, f.3 ), 
    [ f.1, f.2, f.3 ], [ f.2^-1*f.1*f.2, f.2^-1*f.1^-1*f.2*f.1*f.2, f.3 ] )|

The second input is the free group on $n$ generators. The first input is
an  element  of  the  braid  group  on  $n$  strings,  in  its  \CHEVIE\
implementation.
